<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ja" xml:lang="ja"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.25">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>第4章 国連による紛争処理 – 平和への課題：補遺</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../content/05_ch05.html" rel="next">
<link href="../content/03_ch03.html" rel="prev">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-d2604bcb90b21ac6bc3164282300c13a.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "一致なし",
    "search-matching-documents-text": "一致した文書",
    "search-copy-link-title": "検索へのリンクをコピー",
    "search-hide-matches-text": "追加の検索結果を非表示",
    "search-more-match-text": "追加の検索結果",
    "search-more-matches-text": "追加の検索結果",
    "search-clear-button-title": "消去",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "取消",
    "search-submit-button-title": "検索",
    "search-label": "サーチ"
  }
}</script>
<style>
  :root {
    --sidebar-width: 280px;
    --margin-width: 150px;
    --gutter-width: 12px;
  }
</style>
<style>
  :root {
    --sidebar-width: 280px;
    --margin-width: 150px;
    --gutter-width: 12px;
  }
</style>
<link rel="preload" href="../fonts/BIZUDPMincho-Regular.woff2" as="font" type="font/woff2" crossorigin="">
<link rel="preload" href="../fonts/BIZUDPMincho-Bold.woff2" as="font" type="font/woff2" crossorigin="">
<link rel="preload" href="../fonts/BIZUDPGothic-Regular.woff2" as="font" type="font/woff2" crossorigin="">
<link rel="preload" href="../fonts/BIZUDPGothic-Bold.woff2" as="font" type="font/woff2" crossorigin="">


<link rel="stylesheet" href="../src/css/font-udpmincho.css">
<link rel="stylesheet" href="../src/css/base.css">
<link rel="stylesheet" href="../src/css/simple-theme.css">
<link rel="stylesheet" href="../src/css/right-panel.css">
</head>

<body class="nav-sidebar floating quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="サイドバーを切り替える" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../content/04_ch04.html"><span class="chapter-title">第4章 国連による紛争処理</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="サイドバーを切り替える" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="サーチ" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header sidebar-header-stacked">
      <a href="../index.html" class="sidebar-logo-link">
      </a>
    <div class="sidebar-title mb-0 py-0">
      <a href="../">平和への課題：補遺</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="サーチ"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../index.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">AJMUN 37th 平和への課題：補遺</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/00_front.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">フロント挨拶</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/01_ch01.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">第1章 プロジェクトの概要</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/02_ch02.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">第2章　集団安全保障体制の系譜</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/03_ch03.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">第3章　争点・論点解説</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/04_ch04.html" class="sidebar-item-text sidebar-link active"><span class="chapter-title">第4章 国連による紛争処理</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/05_ch05.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">第5章　国連の制度</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/06_ch06.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">第1節　国際法法原論</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Appendices</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="セクションを切り替え">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/90_afterword.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">編集後記</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/95_references.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">参考文献</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/96_index.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">索引</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">目次</h2>
   
  <ul>
  <li><a href="#はじめに" id="toc-はじめに" class="nav-link active" data-scroll-target="#はじめに">はじめに</a></li>
  <li><a href="#国連パレスチナ休戦監視機構1948年-国連パレスチナ休戦監視機構1948年" id="toc-国連パレスチナ休戦監視機構1948年-国連パレスチナ休戦監視機構1948年" class="nav-link" data-scroll-target="#国連パレスチナ休戦監視機構1948年-国連パレスチナ休戦監視機構1948年">国連（パレスチナ）休戦監視機構（1948年～） {#国連（パレスチナ）休戦監視機構（1948年～）}</a></li>
  <li><a href="#国連緊急軍" id="toc-国連緊急軍" class="nav-link" data-scroll-target="#国連緊急軍">国連緊急軍</a>
  <ul class="collapse">
  <li><a href="#第一次国連緊急軍unefⅰ-第一次国連緊急軍unefⅰ" id="toc-第一次国連緊急軍unefⅰ-第一次国連緊急軍unefⅰ" class="nav-link" data-scroll-target="#第一次国連緊急軍unefⅰ-第一次国連緊急軍unefⅰ">第一次国連緊急軍（UNEFⅠ） {#第一次国連緊急軍（unefⅰ）}</a></li>
  <li><a href="#第二次国連緊急軍unefⅱ" id="toc-第二次国連緊急軍unefⅱ" class="nav-link" data-scroll-target="#第二次国連緊急軍unefⅱ">第二次国連緊急軍（UNEFⅡ）</a></li>
  </ul></li>
  <li><a href="#コンゴ動乱1960年1964年-コンゴ動乱1960年1964年" id="toc-コンゴ動乱1960年1964年-コンゴ動乱1960年1964年" class="nav-link" data-scroll-target="#コンゴ動乱1960年1964年-コンゴ動乱1960年1964年">コンゴ動乱（1960年～1964年） {#コンゴ動乱（1960年～1964年）}</a></li>
  <li><a href="#キプロス1964年-キプロス1964年" id="toc-キプロス1964年-キプロス1964年" class="nav-link" data-scroll-target="#キプロス1964年-キプロス1964年">キプロス（1964年～） {#キプロス（1964年～）}</a></li>
  <li><a href="#アンゴラ1989年1999年-アンゴラ1989年1999年" id="toc-アンゴラ1989年1999年-アンゴラ1989年1999年" class="nav-link" data-scroll-target="#アンゴラ1989年1999年-アンゴラ1989年1999年">アンゴラ（1989年～1999年） {#アンゴラ（1989年～1999年）}</a></li>
  <li><a href="#ナミビア1989年1990年-ナミビア1989年1990年" id="toc-ナミビア1989年1990年-ナミビア1989年1990年" class="nav-link" data-scroll-target="#ナミビア1989年1990年-ナミビア1989年1990年">ナミビア（1989年～1990年） {#ナミビア（1989年～1990年）}</a></li>
  <li><a href="#湾岸戦争1990年1991年-湾岸戦争1990年1991年" id="toc-湾岸戦争1990年1991年-湾岸戦争1990年1991年" class="nav-link" data-scroll-target="#湾岸戦争1990年1991年-湾岸戦争1990年1991年">湾岸戦争（1990年～1991年） {#湾岸戦争（1990年～1991年）}</a></li>
  <li><a href="#イラク1991年2003年-イラク1991年2003年" id="toc-イラク1991年2003年-イラク1991年2003年" class="nav-link" data-scroll-target="#イラク1991年2003年-イラク1991年2003年">イラク（1991年～2003年） {#イラク（1991年～2003年）}</a></li>
  <li><a href="#西サハラ1991年-西サハラ1991年" id="toc-西サハラ1991年-西サハラ1991年" class="nav-link" data-scroll-target="#西サハラ1991年-西サハラ1991年">西サハラ（1991年～） {#西サハラ（1991年～）}</a></li>
  <li><a href="#エルサルバドル1991年1995年-エルサルバドル1991年1995年" id="toc-エルサルバドル1991年1995年-エルサルバドル1991年1995年" class="nav-link" data-scroll-target="#エルサルバドル1991年1995年-エルサルバドル1991年1995年">エルサルバドル（1991年～1995年） {#エルサルバドル（1991年～1995年）}</a></li>
  <li><a href="#旧ユーゴスラビアunprofor-旧ユーゴスラビアunprofor" id="toc-旧ユーゴスラビアunprofor-旧ユーゴスラビアunprofor" class="nav-link" data-scroll-target="#旧ユーゴスラビアunprofor-旧ユーゴスラビアunprofor">旧ユーゴスラビア（UNPROFOR） {#旧ユーゴスラビア（unprofor）}</a>
  <ul class="collapse">
  <li><a href="#クロアチア" id="toc-クロアチア" class="nav-link" data-scroll-target="#クロアチア">クロアチア</a></li>
  <li><a href="#ボスニア" id="toc-ボスニア" class="nav-link" data-scroll-target="#ボスニア">ボスニア</a></li>
  <li><a href="#マケドニア" id="toc-マケドニア" class="nav-link" data-scroll-target="#マケドニア">マケドニア</a></li>
  </ul></li>
  <li><a href="#カンボジア1992年1993年-カンボジア1992年1993年" id="toc-カンボジア1992年1993年-カンボジア1992年1993年" class="nav-link" data-scroll-target="#カンボジア1992年1993年-カンボジア1992年1993年">カンボジア（1992年～1993年） {#カンボジア（1992年～1993年）}</a></li>
  <li><a href="#ソマリア内戦1990年代初期-ソマリア内戦1990年代初期" id="toc-ソマリア内戦1990年代初期-ソマリア内戦1990年代初期" class="nav-link" data-scroll-target="#ソマリア内戦1990年代初期-ソマリア内戦1990年代初期">ソマリア内戦（1990年代初期） {#ソマリア内戦（1990年代初期）}</a></li>
  <li><a href="#モザンビーク1992年1994年-モザンビーク1992年1994年" id="toc-モザンビーク1992年1994年-モザンビーク1992年1994年" class="nav-link" data-scroll-target="#モザンビーク1992年1994年-モザンビーク1992年1994年">モザンビーク（1992年～1994年） {#モザンビーク（1992年～1994年）}</a></li>
  <li><a href="#リベリア1993年1997年-リベリア1993年1997年" id="toc-リベリア1993年1997年-リベリア1993年1997年" class="nav-link" data-scroll-target="#リベリア1993年1997年-リベリア1993年1997年">リベリア（1993年～1997年） {#リベリア（1993年～1997年）}</a></li>
  <li><a href="#ハイチ1993年-ハイチ1993年" id="toc-ハイチ1993年-ハイチ1993年" class="nav-link" data-scroll-target="#ハイチ1993年-ハイチ1993年">ハイチ（1993年～） {#ハイチ（1993年～）}</a></li>
  <li><a href="#ルワンダ内戦1994年-ルワンダ内戦1994年" id="toc-ルワンダ内戦1994年-ルワンダ内戦1994年" class="nav-link" data-scroll-target="#ルワンダ内戦1994年-ルワンダ内戦1994年">ルワンダ内戦（1994年） {#ルワンダ内戦（1994年）}</a></li>
  <li><a href="#エピローグ" id="toc-エピローグ" class="nav-link" data-scroll-target="#エピローグ">エピローグ</a>
  <ul class="collapse">
  <li><a href="#伝統的pko" id="toc-伝統的pko" class="nav-link" data-scroll-target="#伝統的pko">伝統的PKO</a></li>
  <li><a href="#防止予防型pko" id="toc-防止予防型pko" class="nav-link" data-scroll-target="#防止予防型pko">防止（予防）型PKO</a></li>
  <li><a href="#多機能型pko" id="toc-多機能型pko" class="nav-link" data-scroll-target="#多機能型pko">多機能型PKO</a></li>
  <li><a href="#複雑緊急事態型pko" id="toc-複雑緊急事態型pko" class="nav-link" data-scroll-target="#複雑緊急事態型pko">複雑・緊急事態型PKO</a></li>
  </ul></li>
  <li><a href="#参照" id="toc-参照" class="nav-link" data-scroll-target="#参照">参照</a></li>
  <li><a href="#参考文献" id="toc-参考文献" class="nav-link" data-scroll-target="#参考文献">参考文献</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">
<script>
  (function () {
    try {
      var storedTheme = localStorage.getItem('quarto-theme');
      if (!storedTheme || storedTheme === 'auto') return;
      document.documentElement.setAttribute('data-theme', storedTheme);
      var applyThemeToBody = function () {
        if (!document.body) {
          requestAnimationFrame(applyThemeToBody);
          return;
        }
        document.body.setAttribute('data-theme', storedTheme);
      };
      applyThemeToBody();
    } catch (err) {
      console.warn('Failed to apply stored theme early', err);
    }
  })();
</script>
<div class="header-ui">
  <div id="js-header" class="js-header">
    <div class="js-header__inner">
      <div class="js-header__left">
        <div class="js-header__logo">
          <span class="js-header__title"><span class="title-main">平和への課題：補遺</span><span class="title-sub">Background Guide</span></span>
        </div>
      </div>
      <div class="js-header__right">
        <div class="js-header__controls">
          <!-- 設定メニューボタン -->
          <button class="js-settings-toggle-btn" id="settings-toggle-btn" aria-label="設定メニューを開く">
            <span class="settings-toggle-icon" aria-hidden="true"></span>
            <span class="settings-toggle-text">表示設定</span>
          </button>
        </div>
      </div>
    </div>
  </div>
  
  <!-- 格納型設定メニュー -->
  <div class="settings-menu" id="settings-menu">
    <div class="settings-menu__inner">
      <div class="settings-menu__header">
        <h3 class="anchored">表示設定</h3>
        <button class="settings-menu__close" id="settings-menu-close">×</button>
      </div>
      <div class="settings-menu__content">
        <!-- 文字サイズ -->
        <div class="settings-item">
          <label for="font-size-select">文字サイズ：</label>
          <select class="js-font-size-select" id="font-size-select" aria-label="文字サイズ">
            <option value="3XS">3XS</option>
            <option value="2XS">2XS</option>
            <option value="XS">XS</option>
            <option value="S">S</option>
            <option value="M" selected="">M</option>
            <option value="L">L</option>
            <option value="XL">XL</option>
          </select>
        </div>
        
        <!-- テーマ切替 -->
        <div class="settings-item">
          <label for="theme-select">テーマ：</label>
          <select class="js-theme-select" id="theme-select" aria-label="テーマ">
            <option value="light">ライト</option>
            <option value="dark">ダーク</option>
            <option value="auto">自動</option>
          </select>
        </div>
        
        <!-- コメント機能 -->
        <div class="settings-divider"></div>
        <div class="settings-section-title">コメント機能</div>
        <div class="settings-item">
          <button class="js-comments-export-page" id="comments-export-page">コメント出力(このページ)</button>
        </div>
        <div class="settings-item">
          <button class="js-comments-export-all" id="comments-export-all">全コメント出力</button>
        </div>
        <div class="settings-item">
          <label for="comments-import" class="js-comments-import-label">コメント読込：</label>
          <input type="file" id="comments-import" class="js-comments-import" accept="application/json" style="display:none;">
          <button class="js-comments-import-button" id="comments-import-button">ファイル選択</button>
        </div>
        
        <!-- プレビューのトースト表示数 -->
        <div class="settings-item">
          <label for="gdoc-toast-max">プレビューのトースト数：</label>
          <input type="range" id="gdoc-toast-max" min="0" max="9" value="3" aria-label="プレビューのトースト数">
          <span id="gdoc-toast-max-value">3</span>
        </div>

        <!-- 各種設定リセット -->
        <div class="settings-divider"></div>
        <div class="settings-section-title">リセット</div>
        <div class="settings-item settings-item--reset-buttons">
          <button type="button" id="reset-ui-settings">UI系をリセット</button>
          <button type="button" id="reset-memo-settings">メモ系をリセット</button>
          <button type="button" id="reset-preview-settings">プレビューをリセット</button>
          <button type="button" id="reset-all-settings">すべてをリセット</button>
        </div>
      </div>
    </div>
  </div>
  <div class="settings-menu-overlay" id="settings-menu-overlay"></div>
</div>

<div class="toc-overlay">
  <div class="toc-overlay__backdrop"></div>
  <div class="toc-sheet">
    <div class="toc-sheet__header">
      <h3 class="anchored">ナビゲーション</h3>
      <button class="toc-sheet__close">×</button>
    </div>
    <div class="toc-sheet__content">
      <!-- 左パネル相当の内容はJavaScriptで生成 -->
    </div>
  </div>
</div>

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-title">第4章 国連による紛争処理</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="はじめに" class="level2">
<h2 class="anchored" data-anchor-id="はじめに">はじめに</h2>
<p>この章では、具体的なPKO事例に関して解説を加える。「常設即応PKO部隊の設立の是非」に関して思考するうえで、過去のPKO事例を是非とも参考にしていただきたい。</p>
</section>
<section id="国連パレスチナ休戦監視機構1948年-国連パレスチナ休戦監視機構1948年" class="level2">
<h2 class="anchored" data-anchor-id="国連パレスチナ休戦監視機構1948年-国連パレスチナ休戦監視機構1948年">国連（パレスチナ）休戦監視機構（1948年～） {#国連（パレスチナ）休戦監視機構（1948年～）}</h2>
<p>国連（パレスチナ）休戦監視機構（UNTSO）は、第一次中東戦争の停戦および休戦協定の履行を監視することを主たる目的に、1948年に設立された国連最初のPKOである。</p>
<p>1948年にイスラエル共和国が成立したのに伴い、これを拒否するアラブ諸国とイスラエルとの間にパレスチナにおける紛争が発生した。安保理は、この事態収拾を目指し、4月17日、パレスチナにおける休戦のための条件を提示し、関係当事者に対し、それを遵守するように要請した（<a href="https://digitallibrary.un.org/record/111966">安保理決議46号</a>）。また、4月23日には、その履行の監視を助ける目的で、パレスチナ休戦委員会を設置した（<a href="https://digitallibrary.un.org/record/111967">安保理決議48号</a>）。その後、パレスチナ休戦委員会は、休戦監視を効果的に行うためには、軍事スタッフの参加が必要であるとの見解を示した。</p>
<p>安保理はこれを受け、5月29日、<a href="https://digitallibrary.un.org/record/111999">安保理決議50号</a>を採択し、すべての当事者に対し、4週間にわたり、軍隊のすべての行動を停止するように要請し、また、<a href="https://digitallibrary.un.org/record/210013">総会決議186号</a>によって任命された国連調停官ベルナドッテ伯に対し、休戦を監視するように指示し、加えて、そのために必要な十分な数の軍事監視要員を提供することを決定した。監視団の第一団は、6月11日から14日にかけて現地に入り、すぐにパレスチナおよび周辺のアラブ諸国地域に展開し、休戦監視のための暫定本部がハイファに置かれた。</p>
<p>設定された4週間の休戦が解けると、再び、大規模な戦闘が起こったため、安保理は、すべての当事者に対し、戦闘行為の即時停止を命じ、無期限の休戦を呼び掛けた（<a href="https://digitallibrary.un.org/record/470028">安保理決議54号</a>）。その後、ベルナドッテ暗殺後に任命されたバンチ調停官代行の尽力もあって、1949年には、イスラエルとアラブ4か国（エジプト・ヨルダン・レバノン・シリア）の間で、4つの全面休戦協定が結ばれた。この結果、調停官代行の任務は終了し、新たに4つの混合休戦委員会が設置された。またUNTSOの指揮権も、同機構の司令官に移された（<a href="https://digitallibrary.un.org/record/515721">安保理決議73号</a>）。これに伴い、UNTSOの任務は、停戦の維持および監視ならびに当事国による全面休戦協定の適用や遵守を支援することとされた。</p>
<p>その後、繰り返し休戦協定が破られ、イスラエルとアラブ各国間の戦闘が激化したのを受け、そのつど、新たな任務を与えられた他の国連平和維持軍が、それぞれの地域に展開されてきた。すなわち、第一次国連緊急軍（UNEFⅠ）、第二次国連緊急軍（UNEFⅡ）、国連兵力引き離し監視軍（UNDOF）、および国連レバノン暫定軍（UNIFIL）である。したがって、UNTSOは、これまでにこれらの活動と連携を保ちながら、全面休戦協定の履行監視を行ってきた。</p>
<p>UNTSOは、PKOの新設に際し、高度に訓練され、経験を積んだ監視要員を早急に確保し、派遣する必要があることから、その供給源としての役割も果たしてきている。これまでに、コンゴ国連軍（ONUC）、国連イエメン監視団（UNYOM）、国連アフガニスタン＝パキスタン軍事監視団（UNGOMAP）、国連イラク＝クウェート監視団（UNIKOM）、国連保護軍（UNPROFOR）、および国連モザンビーク活動（ONUMOZ）などに対して、軍事監視要員を提供してきている。なお、UNTSOには、任期に関する規定は存在しないため、通常のPKOで見られるような任期延長の決議は必要とされない。</p>
</section>
<section id="国連緊急軍" class="level2">
<h2 class="anchored" data-anchor-id="国連緊急軍">国連緊急軍</h2>
<p>国連緊急軍（UNEF）は、1956年に起きた第二次中東戦争に対応して、<a href="https://digitallibrary.un.org/record/208415">総会決議998号</a>および<a href="https://digitallibrary.un.org/record/208417">総会決議1000号</a>に基づき派遣された国連の平和維持活動である。この活動は、のちに第四次中東戦争の際に派遣されたPKOが第二次国連緊急軍（UNEFⅡ）と名づけられたことから、第一次国連緊急軍（UNEFⅠ）と呼ばれている。</p>
<section id="第一次国連緊急軍unefⅰ-第一次国連緊急軍unefⅰ" class="level3">
<h3 class="anchored" data-anchor-id="第一次国連緊急軍unefⅰ-第一次国連緊急軍unefⅰ">第一次国連緊急軍（UNEFⅠ） {#第一次国連緊急軍（unefⅰ）}</h3>
<p>1956年、ナセルエジプト大統領が、アメリカ政府によるアスワンダム建設資金援助の撤回を受け、スエズ運河会社の国有化を決定したことにより、エジプト・イスラエル間の関係が悪化した。イスラエルは、休戦ラインを越え、エジプト領内への侵攻を開始した。国有化の決定により多大な影響を被っていたイギリス・フランス両国も紛争に介入し、スエズ運河沿いの数都市に空爆を実施し、現地に軍隊を展開した。</p>
<p>安全保障理事会は、アメリカの要請によって開催されたが、イギリス・フランス両国の拒否権により、何ら事態の進展を図ることができなかった。このため、1950年11月3日付<a href="https://digitallibrary.un.org/record/666446">総会決議377（Ⅴ）</a>、いわゆる「平和のための結集<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>」決議の手続きに基づき、この問題は、総会へと移された。11月1日、第一回緊急特別総会が開催された。2日、総会は、即時停戦及び全軍隊の休戦ライン後方への撤退、並びに運河の再開を求める<a href="https://digitallibrary.un.org/record/617455">総会決議997号</a>を採択した。同時に、ハマーショルド国連事務総長に対し、国連がとるべき措置についての検討が指示された。危機打開のために国連警察軍設置の必要を説くカナダ外相は事務総長と協議を重ね、総会に対し、国連緊急軍の設置に関する決議案を提出した。4日、<a href="https://digitallibrary.un.org/record/208415">総会決議998号</a>を採択し、事務総長に対し、設置計画を48時間以内に提示するよう要請した。総会は、この勧告内容を支持し、5日、<a href="https://digitallibrary.un.org/record/208417">総会決議1000号</a>を採択し、UNEF司令部を設置した。さらに総会は、7日、UNEFの組織および任務に関する原則を承認した。</p>
<p>事務総長は、部隊参加国との協議を進めるとともに、UNEFの駐留は受入国の同意に基礎を置くという立場から、エジプト政府との交渉を開始した。12日には、エジプト政府の同意を得て、カイロに暫定本部が設置された。15日、現地にUNEFの第一陣が展開された。部隊参加国の選定にあたり、紛争に特別の利害を有する国や五大国の参加は見送られた。また、1957年2月8日、国連とエジプトとの間で、UNEFの地位に関する協定が結ばれ、UNEFの根拠、国連旗の使用、移動の自由、特権・免除、民事管轄権と刑事管轄権など駐留に際しての諸原則が規定された。</p>
<p>UNEFの任務は、敵対行為の停止が順守されているかどうか監視すること、イギリス軍・フランス軍およびイスラエル軍のエジプト領内からの撤退を監視するとともに、被占領地域のエジプトへの平和的移管を支援すること、外国軍の撤退後、エジプト・イスラエル間の休戦境界線および国際国境線沿いの一定地域に展開することで緩衝地帯の役割を果たすこと、とされた。なお、任務の遂行にあたっては、自衛の場合を除き、武力行使の権限は認められないとされた。</p>
<p>イスラエル軍が撤退を完了した1957年3月以降、UNEFは、休戦境界線及び国際国境線沿いに部隊を展開し、監視活動に従事することで、同地域の安定に貢献してきた。ところが、1967年4月7日、イスラエル軍とシリア軍との間で軍事衝突が起き、それ以降、中東地域全体で緊張が高まっていた。このような情勢の中、エジプト政府は、5月16日、UNEFに対し、エジプトからの撤収を要求した。ウ・タント事務総長は、関係国と協議し、事態の収拾に努めたが、関係国からの協力はついに得られなかった。そのため、18日、司令官に対し撤収を指示した。UNEFは、19日より撤収を開始し、6月17日にその活動を終了した。</p>
<p>UNEFⅠは伝統的なPKOである。そのため、自衛以外の武力行使は認められなかった。同意に基づき部隊を展開し、同意が得られなくなると部隊を撤収することになった。</p>
</section>
<section id="第二次国連緊急軍unefⅱ" class="level3">
<h3 class="anchored" data-anchor-id="第二次国連緊急軍unefⅱ">第二次国連緊急軍（UNEFⅡ）</h3>
<p>第二次国連緊急軍（UNEFⅡ）は、1973年に起きたエジプト・イスラエル間の武力紛争（第四次中東戦争）に対応して、<a href="https://digitallibrary.un.org/record/93468">安保理決議340号</a>および<a href="https://digitallibrary.un.org/record/93469?ln=en">安保理決議341</a>に基づき派遣された国連の平和維持活動である。その主たる任務は、即時かつ全面的停戦の遵守と1973年10月22日16時50分の選挙地点までの後退を要求した<a href="https://digitallibrary.un.org/record/93468">安保理決議340</a>の履行を監視することにあった。また、赤十字国際委員会（ICRC）との協力という形で、人道的側面の活動に従事するという任務も与えられた。</p>
<p>1973年10月6日のエジプト軍の進軍により始まったこの戦争は、10月21日、イスラエル軍がエジプト軍を分断したことにより、紛争が本格化した。これを受けて、安保理は、<a href="https://digitallibrary.un.org/record/93466">安保理決議338号</a>および<a href="https://digitallibrary.un.org/record/93467">安保理決議339号</a>を採択し、当事者間に停戦を呼びかけたが、東西陣営の対立も絡んで事態はなかなか進展しなかった。このような状況の中で、非同盟諸国を中心にして、安保理は、10月25日、国連緊急軍の設置を決定し、事務総長に対し24時間以内に報告書を提出するように要請した。事務総長は、報告書の提出に先立って、緊急措置として、<a href="#キプロス（1964年～）">国連キプロス平和維持軍（UNFICYP）</a>で任務遂行中の部隊をエジプトに派遣すること、および、<a href="#国連（パレスチナ）休戦監視機構（1948年～）">国連休戦監視団（UNTSO）</a>参謀長のシラスボーを国連緊急軍の臨時司令官とし、カイロのUNTSO連絡事務所を本部とすることを提案し、安保理に了承された。</p>
<p>事務総長は、報告書の中で、活動の原則と指針を明らかにし、国連緊急軍の任務遂行のために必要な要員・期間・経費を示した。安保理は、これを了承し、UNEFⅡの設置が決まった。</p>
<p>UNEFⅡは、当初、暫定的な緊急措置により、シラスボー司令官の率いるUNTSOの要員に、UNFICYPの数部隊が加わる形で構成された。予定されていた正式な組織構成は、東西陣営の対立により難航したが、衡平な地理的代表の原則を考慮し、1974年2月20日までには必要な規模は達成された。なお、UNEFⅡの地位に関しては、特別な協定は結ばれず、国連の特権免除条約と共に、UNEFⅠの地位協定を適用することで、当事者間に合意ができた。</p>
<p>UNEFⅡは、停戦履行の監視と人道的問題（文壇地域への非軍事的物資の輸送など）への協力を優先的課題として取り組むことから開始した。その後、緩衝地帯を徐々に広げながら、もう一つの主たる任務である1973年10月22日時点の占拠地点までの後退の実現に向けて、兵力ひいはがし地帯の設定とその地帯の両側での兵力・軍備制限地域の設定にも関わっていった。この設定にともない、引き離し地域の管理、制限地域での監視活動も、その任務として加えられた。また、加えて、捕虜の交換の支援など、人道的役割も果たした。</p>
<p>UNEFⅡの任期は、8回延長され、活動は通算5年9か月にわたった。しかし、1979年3月に締結されたエジプト・イスラエル間の平和条約の発効により、安保理は、当事国が望んでいるにもかかわらず、東西陣営の対立により、UNEFⅡの職務権限の延長を決定することができなかった。したがって、UNEFⅡは1979年7月24日の任期切れに伴い、その任務を終了した。</p>
<p>UNEFⅠが総会決議で設立されたのに対して、UNEFⅡは安保理によって設立されたものであり、より強力な政治的正当性を持つものであった。しかし、最終段階では、政治的な限界からソ連の拒否権行使により解散を余儀なくされた。</p>
<p>UNEFⅡは、停戦監視や兵力引き離しの監督、緩衝地帯の管理といった与えられた任務を約6年間にわたって遂行し、歴史的な和平合意への道を切り開いたとの見方ができる。</p>
</section>
</section>
<section id="コンゴ動乱1960年1964年-コンゴ動乱1960年1964年" class="level2">
<h2 class="anchored" data-anchor-id="コンゴ動乱1960年1964年-コンゴ動乱1960年1964年">コンゴ動乱（1960年～1964年） {#コンゴ動乱（1960年～1964年）}</h2>
<p>1960年7月、独立直後の旧ベルギー領コンゴにおいて、白人商工に対するコンゴ人兵士の反乱が発生したため、ベルギー軍が在留自国民の保護を目的として軍事介入を開始した。これに乗じ、南部のカタンガ州のチョンベ首相は、今後在住のベルギー人などの外国人の支援を受けてカタンガ州の独立を宣言した。</p>
<p>コンゴ政府からの事務総長あての軍事的援助の要請に応じて、安保理は、7月14日、ベルギー軍撤退を要求するとともに、事務総長に対して、コンゴ政府と協議の上で、国連の技術援助を受ける同政府の努力によって今後国家保安隊が十分に任務を遂行できるようになったとの見解を同政府が示すまでの期間、必要な軍事援助を提供する権限を付与することを決議した（<a href="https://digitallibrary.un.org/record/112108?ln=en">安保理決議143号</a>）。</p>
<p>ハマーショルド国連事務総長は、同意原則、中立性の原則、内政不干渉原則、自衛の原則など『研究摘要』の諸原則を適用して、ベルギー軍撤退の促進及び法と秩序の維持の支援を職務権限とするコンゴ国連軍（ONUC）の設立計画を作成し、安保理は、カタンガ州からのベルギー軍の撤退を求め、ONUCの同州への進駐の重要性を認め、加盟国に対し、決議の履行について援助を求める決議（<a href="https://digitallibrary.un.org/record/112110?ln=en">安保理決議146号</a>）を採択した。ONUCは、8月12日に平和裏に同州に進駐して、9月9日までにベルギー軍撤退を実現し、また、法と秩序の維持についても当初はある程度の成果をあげていた。</p>
<p>しかし、同年9月以降、親西欧派のカサブブ大統領と急進派のルムンバ首相の解任合戦とモブツ参謀長のクーデターによる「憲政の危機」、ルムンバ元首相の逮捕・殺害、東部でのルムンバ派の反乱、カタンガ州北部での戦闘激化と、重大な事件が相次いて発生し、事態は急激に悪化した。このため、安保理は、1961年2月21日、国際の平和と安全に対する脅威を認定し、ONUCに対して、最後の手段としての武力の行使も含めて、内戦の発生を防止するためにあらゆる適切な措置をとるよう促し、国連の指揮に服さないすべての外国軍事要員、準軍事要員、政治顧問、傭兵の撤退を求める決議（<a href="https://digitallibrary.un.org/record/280617?ln=en">安保理決議161号</a>）を採択した。その後、「憲政の危機」については、国連調停員会が努力を重ねた結果、1961年6月2日にONUCの警護のもとで議会が再開され、アドーラ新中央政府首相が任命されたことで、一応の収拾をみた。</p>
<p>新たに樹立された中央政府の要請に基づいて、ONUCは、8月末から9月中旬にかけて、カタンガ州で傭兵排除のために武力を行使したが失敗に終わり、9月17日、ハマーショルド事務総長は停戦交渉に向かう途上、飛行機事故により殉職した。同年11月24日、安保理は、外部勢力の支援を受けるカタンガ州分離運動とONUC要員に対する武力攻撃を強く非難し、事務総長に対して、国連の指揮に服さないすべての外国軍事要員、準軍事要員、政治顧問、傭兵らの逮捕、拘留、追放のために、必要な場合には武力の行使を含む措置をとることを許可する決議（<a href="https://digitallibrary.un.org/record/112133?ln=en">安保理決議169号</a>）を採択し、同年12月、ONUCはカタンガ憲兵隊の拠点を制圧した。チョンベ・カタンガ州首相は、中央政府の権限行使などを認めるキトナ協定を締結し、翌1962年8月には、ウ・タント事務総長の提案した国家和解計画を、中央政府、カタンガ州政府の両首相が受諾した。しかし、カタンガ側は計画の履行を引き延ばし、ONUCを再び攻撃したため、同年12月末からよく1963年1月にかけて、ONUCは三たび、傭兵排除のために武力を行使し、カタンガの分離運動は終結した。ONUCは、コンゴ政府の要請に基づいて、翌1964年6月30日まで、規模を縮小しながら活動を続けた。</p>
<p>ソ連・フランスなどは、ONUCに安保理の授権を超えた違法な武力行使があったとして、分担金の支払いを拒み、不足分については、加盟国からの自発的拠出金や公債発行によって補った。</p>
</section>
<section id="キプロス1964年-キプロス1964年" class="level2">
<h2 class="anchored" data-anchor-id="キプロス1964年-キプロス1964年">キプロス（1964年～） {#キプロス（1964年～）}</h2>
<p>1960年8月16日にイギリスから独立したキプロス共和国は、混在するギリシア系住民とトルコ系住民の利害の均衡を図るため、議会の代表や公務員・軍人などを一定の比率で両系に割り当て、重要問題に関しては少数派尾トルコ系から選出される副大統領が拒否権を持つという独特の憲法を備えていた。さらに、キプロス・ギリシア・トルコ・イギリスの四者が締結した「保障条約」が、この憲法の基本規定およびキプロスの主権と領土保全を保障するものとされた。</p>
<p>ところが、憲法規定の適用は、独立直後から困難に瀕し、ギリシア系住民とトルコ系住民との反目が昂じた結果、1963年12月21日に武力衝突が生じた。</p>
<p>平和の回復を目指す関係当事者の試みがすべて失敗した後、安全保障理事会は、<a href="https://digitallibrary.un.org/record/112185">安保理決議186号</a>を採択し、国連キプロス平和維持軍（UNFICYP）の設置を勧告した。UNFICYPの職務権限は、戦闘の再発防止に最善を尽くすこと、そして、必要に応じ、法と秩序の維持および回復ならびに平常な事態への復帰に寄与すること、とされた。</p>
<p>以来、UNFICYPは現地介在を続けたが、それでも、1974年7月には、中立路線をとろうとする大統領に対する親ギリシア派のクーデターをきっかけに、トルコ軍がキプロスに介入する事態となり、その収拾をはかるギリシア・トルコ・イギリスの三保障国交渉も決裂して、大規模な軍事衝突が再燃した。安保理は、<a href="https://digitallibrary.un.org/record/93472">安保理決議355号</a>により、事務総長に適当な行動をとることを要請し、1974年8月16日に事実上の停戦が発効したのに伴い、UNFICYPは、戦闘の結果、キプロス島を二分した二つの住民集団の支配地域の間に設けられた停戦ラインおよび緩衝地帯の軍事的現状維持を監視するために、再配備された。さらに、UNFICYPは、戦闘を逃れて異動した大量の避難民や極度の窮乏状態に置かれている住民に対する緊急人道救助に取り組む国連難民高等弁務官事務所（UNHCR）の活動の支援を中心に、人道的活動にも携わることになった。</p>
<p>安保理は、通常6か月ごとに駐留を延長してきている。また、駐留のための経費は兵力提供国の負担と、国連に対する自発的拠出金とでまかなうものとされたことから、累積赤字が2億ドル近くなるほど、UNFICYPの財政的基盤は脆弱であった。</p>
<p>こうしたUNFICYPの基本構造および活動形態は見直しも必要になっている。1992年5月31日付事務総長報告書は、UNFICYPの各国部隊の削減または撤退の検討を示唆しており、兵力提供国の一部は既に自国部隊の削減に着手した。</p>
<p>事務総長は安保理に対して、UNFICYPの駐留は依然として不可欠であるとの見解を示しているが、キプロス紛争に対する国連の関与の形態としては、事務総長の周旋活動に重点を移し、紛争の政治的決着を模索する傾向がみられる。</p>
</section>
<section id="アンゴラ1989年1999年-アンゴラ1989年1999年" class="level2">
<h2 class="anchored" data-anchor-id="アンゴラ1989年1999年-アンゴラ1989年1999年">アンゴラ（1989年～1999年） {#アンゴラ（1989年～1999年）}</h2>
<p>ポルトガル領アンゴラは、1975年11月15日に独立を予定してたが、同年半ばより民族解放団体三派間の対立抗争が激化して内戦状態に陥り、主にソ連・東欧諸国から支援を受けていたアンゴラ解放人民運動（MPLA）政権と、アメリカ、イギリス、中国、朝鮮民主主義人民共和国、ルーマニア、ザイール等から支援を受けていたアンゴラ解放民族戦線（FNLA）および南アフリカから支援を受けていたアンゴラ完全独立民族同盟（UNITA）の連合政権とが別々に独立を宣言するに至った。</p>
<p>南アは、FNLA・UNITA連合政権を支援して、同国占領下のナミビアを経由して軍事介入し、一方、これに対抗するため、MPLAはキューバ軍の支援を要請して、内戦は国際紛争に発展した。翌1976年2月、南ア軍は撤退し、内戦に勝利を収めたMPLA政権は領内に実効的支配を確立した。同政権は、国際社会のほとんどの諸国からアンゴラを代表する正統政府として承認され、キューバ軍は同政権の要請に従って駐留を続けた。ところが、南アは、1978年頃より、アンゴラに基地を置くナミビアの民族解放団体、南西アフリカ人民機構（SWAPO）のゲリラ追討とUNITAへの支援を目的として、再びアンゴラ領内に侵攻し始めた。</p>
<p>1981年に発足したアメリカのレーガン政権は、UNITAを「自由の戦士」と呼んで軍事援助を与えた。さらに、南アとの友好関係を重視する「建設的関与」政策を掲げて、アンゴラからキューバ軍が撤退しない限り、南アはナミビアの独立を認めなくてよい、とのリンケージを主張したため、南アはナミビアに居座りを続けたばかりか、アンゴラ領南部の奥深くまで侵攻、占領し、キューバ軍の撤退を迫った。一方、アンゴラ政府は、キューバ軍の撤退より先にナミビアを独立させるべきと主張し、米ソの代理戦争化した紛争は、膠着状態に陥った。</p>
<p>しかし、東西冷戦が解消に向かい始めたのに伴い、1988年12月13日、米国の仲介によってキューバ・アンゴラ・南ア参加国間で<a href="https://digitallibrary.un.org/record/71636?ln=en">安保理決議435号</a>に従ったナミビアの独立手続きの開始日を1989年4月1日とするブラザビル議定書が締結され、さらに、同12月22日、国連本部で、ナミビア独立手続きの開始と領土保全・政治的独立の尊重、内政不干渉に関する参加国協定およびキューバ軍の段階的な完全撤退に関するキューバ・アンゴラ二国間協定が締結された。二国間協定によれば、キューバ軍は1991年7月1日までに撤退を完了することになっていた。これらの協定の締結に先立つ同12月20日、安全保障理事会は、キューバ軍撤退協定の遵守を検証するために、31か月の期間で国連アンゴラ検証団（UNAVEM）を設立した（<a href="https://digitallibrary.un.org/record/52988?ln=en">安保理決議626号</a>）。UNAVEMの憲章の下に、1989年1月10日から始まったキューバ軍の撤退は順調に実施され、予定より早く1991年5月25日に完了した。</p>
<p>一方、アンゴラ政府とUNITAは、ポルトガルを仲介者、米ソをオブザーバーとして和平交渉を進めていたが、同年5月1日、アンゴラ和平協定を締結した。同協定は、停戦監視については、アンゴラ政府とUNITAの代表を構成員、ポルトガル・米国・ソ連の代表をオブザーバーとする合同検証委員会を設立すること、各紛争当事者から提供された8名ないし12名の要員から構成され、合同監視委員会に従属する監視団を通じて、停戦を監視すること、当該監視団がその責任を遂行しているかどうかを国連の要因が検証することを規定していた。5月20日、デクエヤル事務総長は、安保理に対し、UNAVEMの職務権限を、①停戦監視に関する当事者の合意の憲章、②停戦期間中のアンゴラ警察の監視に関する当事者の合意の検証に拡大すること、新たな職務権限の期間は、停戦発効の日から大統領選挙・議会選挙の完了の翌日までとすることを勧告した。5月30日、安保理はこの勧告を承認し、UNAVEMの呼称を第二次国連アンゴラ検証団（UNAVEMⅡ）と改めた（<a href="https://digitallibrary.un.org/record/196834?ln=en">安保理決議696号</a>）。</p>
<p>さらに、ガリ事務総長は、UNAVEMⅡの職務権限を選挙プロセスの検証に拡大し、UNAVEMⅡに選挙部門を設けることを勧告し、3月24日、安保理はこの勧告を承認した（<a href="https://digitallibrary.un.org/record/196972?ln=en">安保理決議747号</a>）。和平協定に従ったUNITAの武装解除はほとんど進んでいなかったが、UNAVEMⅡの選挙監視要員の検証のもとに、アンゴラの議会選挙と大統領選挙が実施され、10月17日、選挙結果が発表された。議会選挙では政府側が勝利を収め、大統領選挙については、過半数を獲得した候補がいなかったため、ドス・サントス大統領とUNITAのザビンビ議長との間で、第2回投票が実施されることになった。アンゴラ担当事務総長特別代表は、選挙プロセスは概して自由かつ公正なものであったと宣言した。ところが、UNITA側は、選挙に不正があったと主張して、政府側に対して武力攻撃を開始し、内戦が再燃するに至った。事務総長・事務総長特別代表・UNAVEMⅡは、当事者間の仲介を試みたが、戦闘は激化の一途をたどり、事態は和平協定締結以前よりもはるかに悪化した。停戦合意の崩壊に伴い、1993年1月29日、安全保障理事会は、UNAVEMⅡの規模を大幅に縮小し、首都ルアンダに撤収させることを決議した（<a href="https://digitallibrary.un.org/record/197138?ln=en">安保理決議804号</a>）。UNAVEMⅡは本来の職務権限を行使できないため、主に当事者間の周旋・仲介の役割を果たした。同年9月15日、安保理は、憲章第7章のもとで、平和と安全に対する脅威を認定し、停戦に応じないUNITAに対して、武器・石油禁輸措置をとることを決定した（<a href="https://digitallibrary.un.org/record/197326?ln=en">安保理決議864号</a>）。</p>
<p>1993年11月15日、アンゴラ政府とUNITAは、事務総長特別代表の支援のもとに、ザンビアのルサカで交渉を開始した。両当事者は、12月11日に軍事的問題に関して、1994年1月31日に警察に関して、また、5月5日に選挙プロセスの官僚に関して、それぞれ合意に達した。最大の対立点であった国民的和解についても、国連・米国・ソ連・ポルトガルによる一括提案を、5月に政府が、9月にUNITAが受諾した。10月27日、安保理は、停戦に備えて、UNAVEMⅡを元の規模に戻すことを許可した（<a href="https://digitallibrary.un.org/record/198060?ln=en">安保理決議966号</a>）。1994年11月20日、新たな包括和平協定、ルサカ議定書が締結され、11月22日に停戦が発効した。1995年2月1日、ガリ事務総長は、安保理に対して、アンゴラ和平協定、ルサカ議定書および関連の安保理諸決議を基礎として、アンゴラにおける平和を回復し、国民和解を達成することに関して、当事者を援助するために、第三次アンゴラ検証団（UNAVEMⅢ）を設立することを勧告し、2月8日、安保理はこの勧告を承認した（<a href="https://digitallibrary.un.org/record/198181?ln=en">安保理決議976号</a>）。しかし、その後も、ルサカ議定書の履行は大幅に遅延したため、1996年12月2日、事務総長は、UNAVEMⅢを段階的に撤退させることを安保理に勧告し、安保理もこれを承認した（<a href="https://digitallibrary.un.org/record/229411?ln=en">安保理決議1087号</a>）。</p>
<p>その後のUNAVEMⅢの活動に関しては、今会議が1995年時点であることから割愛する。</p>
</section>
<section id="ナミビア1989年1990年-ナミビア1989年1990年" class="level2">
<h2 class="anchored" data-anchor-id="ナミビア1989年1990年-ナミビア1989年1990年">ナミビア（1989年～1990年） {#ナミビア（1989年～1990年）}</h2>
<p>ナミビアは、第一次世界大戦後は南アメリカを受任国とする国際連盟の委任統治領となった。第二次世界大戦後、国際連盟が解散すると、他の委任統治領は独立するかまたは国連の信託統治地域となったが、南アの身は国連との信託統治協定の締結を拒み、一方的にこの地域の併合を宣言した。</p>
<p>このため、1949年、国連総会は国際司法裁判所（ICJ）に勧告的意見を求めた。1950年、ICJは、委任状は依然として有効で、南アは南西アフリカの国際的地位を一方的に変更する権限を持たない、南アは連盟規約第22条と委任状に規定された国際的義務および住民の制限を送付する義務を負い、委任統治に関する監督機能は国連が遂行する、との意見を示した。以後、国連は、監督権限を行使するための努力を積み重ねたが、南アは一貫してこれを拒絶し、アパルトヘイト政策を推進し、現地住民に対する弾圧を強化したため、1966年、国連総会は、委任統治を終了させ、南西アフリカを国連の直接の責任のもとに置くことを決議し、1967年、国連南西アフリカ理事会を設置した。しかし、なおも南アは居座りを続けたため、1970年、安保理は、南アがとったすべての行動は違法かつ無効と宣言し、ICJの勧告的意見を求めた。ICJは、1971年、委任状は条約の性質を持つので、南アの重大な義務違反は国連総会に対して委任状を終了させる権利を与える、南アはナミビアからただちに撤退する義務を負う、国連加盟国はナミビアにおける南アの存在の違法性を確認する義務を負う、との意見を示した。</p>
<p>これに対し、南アは、ナミビアを傀儡政権のもとで独立させよと企てたため、安保理は、ナミビアの独立を国連の監督と管理のもとに実施される自由かつ公平な選挙を通じてのみ達成されるべきことを宣言した（<a href="https://digitallibrary.un.org/record/93716">安保理決議385号</a>）。1978年4月には、関係諸国と協議を重ねた米・英・仏・西独・カナダの西側安保理理事国が、国連事務総長特別代表のもとで進められる独立手続きを詳細に定めた「ナミビアの事態の解決のための提案（S/12636）」を安保理に提出し、これを受けて、安保理は、7月27日、事務総長に対し、国連の管理と監視の下での自由かつ公正な選挙によるナミビアの早期独立を確保するために事務総長特別代表を任命し、提案の実施のための勧告を含む報告書を提出するよう要請した（<a href="https://digitallibrary.un.org/record/93782">安保理決議431号</a>）。</p>
<p>上述の通り、国連は長年ナミビアの独立を支持しており、1978年には、UNTAGを設立し（<a href="https://digitallibrary.un.org/record/93786">安保理決議435号</a>）、停戦・南ア軍の撤退・南アがナミビアに設立した非正規軍の動員解除の監視などを担当する軍事部門と選挙の管理・監視や難民帰還の支援などを担当する文民部門を構成した。</p>
<p>しかし、米ソの代理戦争の舞台となったこともあり、決議の履行は大幅に遅れた。東西冷戦が解消に向かい始めたのに伴い、UNTAG設立の決議から10年遅れで進展が見られるようになった。1988年12月13日、米国の仲介によって、キューバ＝アンゴラ＝南ア三か国間で、安保理決議435号に従ったナミビア独立手続きの開始日を1989年4月1日とするブラザビル議定書が締結され、さらに、1988年12月22日、国連本部で、ナミビア独立手続きの開始と領土保全・政治的独立の尊重、内政不干渉に関する三か間協定（S/20325）およびキューバ軍の段階的な完全撤退に関するキューバ＝アンゴラ二か国間協定（S/20345、S/20346）が締結された。安保理は、1989年1月16日、決議435号の履行を4月1日に開始すると決定し（<a href="https://digitallibrary.un.org/record/54308?ln=en&amp;v=pdf">安保理決議629号</a>）、続いて、2月16日、決議435号を当初予定された形で実施することを決定した（<a href="https://digitallibrary.un.org/record/56654?ln=en&amp;v=pdf">安保理決議632号</a>）。これらの決議に従い、同年4月1日、UNTAGのもとで選挙プロセスが開始された。</p>
<p>アーティサーリ事務総長特別代表は、選挙プロセスはすべての段階で自由かつ公正なものであったと認定した。その後、ナミビアは独立を達成し、UNTAGは活動を終了した。</p>
<p>UNTAGは、選挙の実施や独立プロセスの管理といった、後述する「多機能型PKO」の先駆けとみなされる。冷戦終結期には、大国の協力の下で実施されたこともあり、しばしばPKOの成功例と考えられる。</p>
</section>
<section id="湾岸戦争1990年1991年-湾岸戦争1990年1991年" class="level2">
<h2 class="anchored" data-anchor-id="湾岸戦争1990年1991年-湾岸戦争1990年1991年">湾岸戦争（1990年～1991年） {#湾岸戦争（1990年～1991年）}</h2>
<p>湾岸戦争において、イラク軍のクウェート占領に終止符を打ったいわゆる多国籍軍は、国連加盟国の兵員が共通の目的の下に協調行動をとったものだが、一連の国連平和維持活動とは性格を異にするものである。</p>
<p>1990年、クウェート国境に結集していたイラク軍がクウェート領に侵攻を開始し、ほぼ全土を制圧した。国連本部では、クウェートと米国の要請により緊急安全保障理事会が開催され、<a href="https://digitallibrary.un.org/record/94220?ln=en">安保理決議660号</a>が採択された。この決議では、国際の平和と安全の破壊が存在することを前文で認定した上で、イラクに対してクウェートからの無条件・即時撤退を要求していた。これは事態の悪化を防止するため、国連憲章第7章の枠内でとられる暫定措置である。</p>
<p>イラクがこれを無視したため、国連安保理は、さらに憲章7章に基づき、イラクに厳しい経済制裁を課す<a href="https://digitallibrary.un.org/record/94221?ln=en">安保理決議661号</a>を採択した。</p>
<p>経済制裁は総じて実効的に履行されたが、一部の制裁決議からの逸脱を阻止して実効性を高めるため、当該地域に兵力を展開している加盟諸国に対して海域において必要な措置をとることを容認する<a href="https://digitallibrary.un.org/record/95664?ln=en">安保理決議665号</a>や、空域での必要な措置を容認する<a href="https://digitallibrary.un.org/record/97522?ln=en">安保理決議670号</a>も採択され、必要な措置とは、実力行使も示唆することが了解された。</p>
<p>それでもなおイラクは、クウェートの併合、西側外国人の軟禁などの国際法違反を重ね、ついに安保理は、のちに多国籍軍の行動の前提となる<a href="https://digitallibrary.un.org/record/110709?ln=en">安保理決議687号</a>を採択した。これはイラクによるクウェート撤退の期限を定め、それまでに撤退が実現されなければ、加盟諸国に対して、国際の平和と安全を回復するために、「必要なあらゆる手段」をとる権限を認めるものであった。</p>
<p>事態は解消せず、米軍を主力とする多国籍軍は、イラクおよびクウェート占領地内の戦術拠点に対する大規模な空爆を開始し、地上戦を経て戦闘がおさまった。</p>
<p>この湾岸戦争の正式な休戦の枠組みは、安保理決議687号が提示した。そこには、イラク＝クウェート間の国境線の画定、国連監視団の派遣、大量破壊兵器の破棄、賠償責任等が規定され、イラクの決議受諾によって休戦が発効することとされた。</p>
<p>湾岸戦争では、国連が自ら軍隊を指揮するのではなく、加盟国（実質的には米国主導の有志連合）に軍事行動の「許可」と「正当性」を与えたものである。国連はあくまで法的な根拠を提供したのみで、作戦の指揮権は多国籍軍にあった。</p>
</section>
<section id="イラク1991年2003年-イラク1991年2003年" class="level2">
<h2 class="anchored" data-anchor-id="イラク1991年2003年-イラク1991年2003年">イラク（1991年～2003年） {#イラク（1991年～2003年）}</h2>
<p>先述したように、米軍を中心とするいわゆる多国籍軍の空爆により開始された湾岸戦争は、地上戦の末にイラク軍がクウェートから撤退し、戦闘終結をみた。</p>
<p>国連安保理は、<a href="https://digitallibrary.un.org/record/108110?ln=en">安保理決議686号</a>によりイラクに暫定的な停戦条件を課し、さらに<a href="https://digitallibrary.un.org/record/110709?ln=en">安保理決議687号</a>を採択して正式な停戦条件を提示した。イラクがこれを受け入れたことによって湾岸戦争の停戦は正式に成立した。</p>
<p>決議687号の第5項は、イラク＝クウェート国境に非武装地帯（DMZ）を設けて国連監視団を派遣することを規定し、事務総長に対して、イラク＝クウェート両国と協議の上、監視団の展開計画を安保理に提出するよう要請していた。4月5日事務総長が安保理に提出した報告書は、監視団の職務内容を①ホール＝アブダッラー水路および1963年のイラク＝クウェート間の合意された議事録に定められた国境線からイラク側に10キロ、クウェート側に5キロの幅で設定される非武装地帯の監視、②非武装地帯における現地介在と監視による国境侵犯の抑制、③国境を越えてなされる敵対行為の監視、とし、そのために必要な監視員を300人と見積もっていた。軍事監視員は非武装だが、活動地域は当時多国籍軍の支配下にあり、その撤退に伴う過渡期の状況に照らして一時的に歩兵部隊、工兵隊、および航空機を含む後方支援部隊による支援の必要性が指摘された。</p>
<p>イラクは4月8日、クウェートは4月9日に監視団派遣計画を受諾し、これに協力する旨を事務総長に通告した。安保理は4月9日に<a href="https://digitallibrary.un.org/record/110791?ln=en">安保理決議689号</a>により事務総長に報告書を承認し、6か月の任期で国連イラク＝クウェート軍事監視団（UNIKOM）を設置した。決議の前文には、これが国連憲章第7章に基づくものであることが示されている。</p>
<p>監視員は、当初33か国が299人を提供したが、このうち18か国は多国籍軍に参加または協力していたこと、そして、安保理の五常任理事国がすべて兵員を提供したことがUNIKOMの大きな特徴である。支援部隊、別の平和維持軍から一時的に転用された歩兵部隊を合わせた総員は約1400人であった。</p>
<p>UNIKOMはまず、兵力の撤退を監視し、それが完了した5月9日からは全長200キロにおよぶ非武装地帯および40キロのホール＝アブダッラー水路の監視を行った。現地は概して、平穏で非武装地帯も尊重されたので、随行の歩兵部隊はいったん本務地に復帰した。</p>
<p>ところが、1992年末から、イラク軍による小規模な境界および非武装地帯の侵犯が相次いだため、事務総長は、こうした安全保障理事会決議の違反を抑止できるように、UNIKOMに武器を携行する歩兵部隊を投入し、3500人程度まで増員することを提案した。安保理はこれを承認し、<a href="https://digitallibrary.un.org/record/243005?ln=en">安保理決議806号</a>によりUNIKOMの職務権限は拡大した。</p>
<p>最終的には、UNIKOMの監視活動は2003年のイラク戦争の勃発を防ぐことができず、その存在意義には懐疑的な評価を下さざるを得ない。</p>
</section>
<section id="西サハラ1991年-西サハラ1991年" class="level2">
<h2 class="anchored" data-anchor-id="西サハラ1991年-西サハラ1991年">西サハラ（1991年～） {#西サハラ（1991年～）}</h2>
<p>西サハラでは、スペイン領サハラの時代からその領有権を主張する近隣国のモロッコ・モーリタニアと佐原住民の間に衝突が頻発した。西サハラの法的地位については国連総会が国際司法裁判所に勧告的意見を求め、裁判所によって西サハラ住民の民族自決権が認められている。しかし、モロッコは勧告的意見に反発し、領有権をスペインに認めさせるために大行進を行った。1976ンrンにスペインは、植民地支配の締結後、モロッコとモーリタニアに旅游権を承認し西サハラは分割され、勧告的意見は無視されることになる。一方、1973年に独立を目指す住民が結成した民族解放組織ポリサリオ戦線はサハラ・アラブ民主共和アラブ民主共和国樹立を宣言し、アルジェリアの支援を得てゲリラ戦を開始、戦闘は激化した。その後1979年に、モーリタニアは領有権放棄を表明し、同時にモロッコは西サハラ全域の領有を宣言して今日に至る。</p>
<p>国連は1963年に西サハラを非自治地域として認定して以来、植民地独立付与宣言の履行のため、植民地独立付与宣言履行特別委員会等の活動を通して、西サハラ住民の自決を達成するため、一貫して住民投票の実施を求めてきた。デクエヤル事務総長も、1985年よりOAU（アフリカ統一機構）と共同で周旋活動をすすめ、「独立か、モロッコへの帰属か」を問う西サハラにおける住民投票実施のための事務総長／OAU議長共同提案は、モロッコとポリサリオ戦線によって原則的に受諾されるに至った。</p>
<p>西サハラにおける住民投票のための任務は、事務総長／OAU議長共同提案に基づいたもので、事務総長は具体的な実施計画と予定表を二度にわたり詳細な報告書にまとめた。この提案は、安保理において全会一致で承認され、ポリサリオ戦線とモロッコ政府軍の間に停戦が合意されたため、MINURSO（国連西サハラ住民投票監視団）が設立された（<a href="https://digitallibrary.un.org/record/112199?ln=en">安保理決議690号</a>）。</p>
<p>MINURSOの任務は、停戦の監視・西サハラの帰属を決定するための公正な住民投票を実施し、その結果を認証することなど多岐にわたった。</p>
<p>しかし、完全な停戦には至らず、MINURSOの初期の活動は軍事要員による停戦の監視に限られた。住民投票の有権者確定作業で対立し、MINURSOの活動はしばしば中断を余儀なくされる状況（<a href="https://digitallibrary.un.org/record/214147?ln=en">安保理決議1056号</a>）であった。MINURSOの活動の期限延長を続けているが、任務を全うできるか、情勢はなお流動的である。</p>
</section>
<section id="エルサルバドル1991年1995年-エルサルバドル1991年1995年" class="level2">
<h2 class="anchored" data-anchor-id="エルサルバドル1991年1995年-エルサルバドル1991年1995年">エルサルバドル（1991年～1995年） {#エルサルバドル（1991年～1995年）}</h2>
<p>エルサルバドルでは1979年に軍部左派がクーデターを起こし、軍民評議会政権を八足させた。ファラブンド・マルチ民族解放戦線（FMLN）などの左翼ゲリラは、反政府運動を激化させ、国内は内戦状態に至った。内戦の解決は、同様の紛争を抱える中米諸国とともに進められた。紛争を抱える中米5か国はグアテマラ合意を発表した。この合意を支援するために、1989年より国連中米監視団（ONUCA）が派遣された。1990年にはニカラグアで選挙が実施され、同国の情勢が安定するに及んで、安保理はONUCAを発展解消させ、エルサルバドルを対象に絞った国連エルサルバドル監視団（ONUSAL）を発足させた。</p>
<p>ONUSALは当初、人権部門が活動を開始する。エルサルバドル政府とFMLNの紛争両当事者が締結した一連の協定の目的を達成するため、1991年安保理はONUSALを創設する<a href="https://digitallibrary.un.org/record/113530?ln=en">安保理決議693号</a>を採択した。ONUSALはエルサルバドルの人権擁護官や人権NGOとの協力とその強化をはかった。</p>
<p>1992年には、安保理は次の目標を武力紛争の収拾とし、ONUSALの職務権限を拡大させ、停戦監視および治安維持を任務とした（<a href="https://digitallibrary.un.org/record/134962?ln=en">安保理決議729号</a>）。</p>
<p>1992年に紛争が終結すると、エルサルバドル政府は、ONUSALの職務権限を再度拡大し、1994年に予定される選挙の監視を行うことを要請し、安保理がそれに応えた（<a href="https://digitallibrary.un.org/record/167009?ln=en">安保理決議832号</a>）。選挙後も新政権が平和合意文書を完全に履行するためにはONUSALの任期を延長する必要があった（<a href="https://digitallibrary.un.org/record/164311?ln=en">安保理決議961号</a>）。その後、ONUSALの憲章と周旋の任務を引き継ぐために、事務総長の要請によって国連エルサルバドル使節団（MINUSAL）が任命された。</p>
<p>ONUSALは、人権監視から始まり、和平プロセスの進展に合わせて職務権限を柔軟に拡大させた包括的なPKOの成功例と言えるだろう。</p>
</section>
<section id="旧ユーゴスラビアunprofor-旧ユーゴスラビアunprofor" class="level2">
<h2 class="anchored" data-anchor-id="旧ユーゴスラビアunprofor-旧ユーゴスラビアunprofor">旧ユーゴスラビア（UNPROFOR） {#旧ユーゴスラビア（unprofor）}</h2>
<p>ユーゴスラビア社会主義連邦共和国（旧ユーゴスラビア）は、6共和国から構成される連邦であったが、スロベニア共和国、クロアチア共和国の分離・独立宣言ののち、1991年に連邦の維持を求めるセルビア人勢力がクロアチアにおいて攻撃を行ったことから内戦が始まった。国連保護軍（UNPROFOR）は、この状況の収拾を目的としてクロアチア共和国に配置されたが、その後、ボスニア・ヘルツェゴビナ共和国においても、連邦からの独立を求める動きによって紛争が悪化したことを受けて、同地域にも関与した。さらに、予防的展開として旧ユーゴスラビア・マケドニア共和国にも派遣された。UNPROFORは、一時は45000人の規模に達し、PKOとして過去最大の展開となった。<br>
1995年3月、UNPROFORが再編成され、ボスニア・ヘルツェゴビナに展開し、クロアチアおよびマケドニアには別組織のPKOが設置された。1995年末にUNPROFORは任務を終了し、その後はNATO主導の和平履行部隊（IFOR）が任務を引き継いだ。</p>
<section id="クロアチア" class="level3">
<h3 class="anchored" data-anchor-id="クロアチア">クロアチア</h3>
<p>1991年6月、クロアチア共和国がユーゴスラビアからの独立を宣言したころから、独立に反対する国内のセルビア人勢力は、ユーゴスラビア連邦軍の支援を受け、敵対行為を行った。紛争の悪化を防ぐ目的で、安保理が<a href="https://digitallibrary.un.org/record/126827?ln=en">安保理決議713号</a>において、旧ユーゴスラビア全域への武器禁輸を決定した。さらに、事務総長は停戦合意とPKOの配置を実現するために、当事者に対して積極的な働きかけを行った。主要な当事者の合意を得て、翌年、UNPROFORの設置が決定された（<a href="https://digitallibrary.un.org/record/137965?ln=en">安保理決議743号</a>）。UNPROFORは、国連安全地区（UNPA）に設置され、セルビア人の武装解除および同地区のセルビア人居住者の保護を行った。</p>
<p>その後、UNPROFORの職務権限は徐々に拡大されていった。1992年にはUNPA周辺のセルビア人居住地区（ピンク・ゾーン）を監視する権限が与えられ（<a href="https://digitallibrary.un.org/record/145155?ln=en">安保理決議762号</a>）、UNPAへの市民の立ち入りの管理や国境における税関、入国管理の職務を行い（<a href="https://digitallibrary.un.org/record/147636?ln=en">安保理決議769号</a>）、さらにプレブラカ半島の武装解除を監視する職務が与えられた（<a href="https://digitallibrary.un.org/record/151309?ln=en">安保理決議779号</a>）。</p>
<p>このような国連の努力にもかかわらず、1993年、クロアチア軍がUNPAおよびピンク・ゾーンに侵入し、攻撃を行い、セルビア人勢力との紛争が再燃した。当事者は停戦合意の締結とその違反を繰り返したため、最終的な解決に達することはできなかった。事務総長は国連の関与の重要性を認識し、UNPROFORの期限は延長されていった。</p>
<p>1995年1月、クロアチア大統領は、UNPROFORが状況の改善に必要な役割を果たしていないことを理由として、食権限の延長に同意しない旨を通告した。その後、UNPROFORの再編戦によって、UNPROFORの任務終了後に国連信頼回復活動（UNCRO）の設置が決定され（<a href="https://digitallibrary.un.org/record/174991?ln=en">安保理決議981号</a>）、停戦合意の遵守や交渉による解決を助長する機能などが許可された。UNCROは1996年1月に任務を終了したが、UNCROを引き継いで東スラボニア、バラニャ、西スレム地方には国連東スラボニア、バラニャおよび西スレム暫定統治機構（UNTAES）が設立され、またプレブラカ半島には武装解除の監視のために国連プレブラカ監視団（UNMOP）が設置された。</p>
</section>
<section id="ボスニア" class="level3">
<h3 class="anchored" data-anchor-id="ボスニア">ボスニア</h3>
<p>ボスニアにおけるUNPROFORの展開は、1992年5月に発生したムスリム人勢力およびクロアチア人勢力対ボスニア・セルビア人勢力の紛争がきっかけとなった。紛争の悪化を受けて、国連憲章第7章に基づき、サラエボ周辺および空港に安全地区の設置が要求された（<a href="https://digitallibrary.un.org/record/142881?ln=en">安保理決議757号</a>）。6月には、同空港の治安および機能確保の目的で、安保理はUNPROFORのボスニア・ヘルツェゴヴィナへの配備を許可した（<a href="https://digitallibrary.un.org/record/145109?ln=en">安保理決議761号</a>）。しかし、UNPROFORの活動が妨害されたことから、国連憲章第7章のもと、人道救助物資の提供と空港の安全確保のために、加盟国に対して必要な措置をとる権限が与えられた（<a href="https://digitallibrary.un.org/record/148183?ln=en">安保理決議770号</a>）。10月には、UNPROFORおよび国連関係の航空機を除き、ボスニア・ヘルツェゴヴィナ上空での軍用機の飛行を全面的に禁止した（<a href="https://digitallibrary.un.org/record/151454?ln=en">安保理決議781号</a>）。飛行禁止区域が設定されていたものの決議が順守されなかったため、安保理決議816号において、決議の履行のためにすべての必要な手段をとることを加盟国に許可した。この決議に基づいて飛行禁止を確保するため、1994年2月にNATOは飛行禁止に違反したボスニア・セルビア人勢力の航空機を撃墜した。</p>
<p>さらに、ボスニア・セルビア人勢力の攻撃によって市民に被害が及んだことから、安保理はスレブレニツァ周辺を安全地区と認定し、同地区での敵対行為を禁止し軍の即時撤退を求めた（<a href="https://digitallibrary.un.org/record/164939?ln=en">安保理決議819号</a>）。その後、ゴラジュデ等の地域も安全地区とされ（<a href="https://digitallibrary.un.org/record/166133?ln=en">安保理決議824号</a>）、さらに安保理はUNPROFORの職務権限を拡大し、憲章第7章のもと、同地区の保護および国連の活動促進のため、武力行使を含む必要な措置をとることを認めた（<a href="https://digitallibrary.un.org/record/166973?ln=en">安保理決議836号</a>）。</p>
<p>1994年3月以降、ボスニア・セルビア人勢力はゴラジュデをはじめとする安全地区に攻撃を行った。停戦合意が約束されたのにもかかわらず攻撃は継続された。NATOはセルビア人勢力の敵対行為に対し応酬した。また、クロアチア共和国が自国の軍隊をボスニア・ヘルツェゴビナ領域内に展開していたことが明らかとなり、クロアチア共和国内でも<a href="https://digitallibrary.un.org/record/166973?ln=en">安保理決議836号</a>に基づいて空爆が行われた。経済制裁の強化、新たな停戦合意の締結、領土の分割の提案など様々な措置がとられたが、当事者は11月のデイトン協定まで最終的な合意には至らなかった。</p>
<p>アメリカ主導のデイトン協定によって、ボスニア・ヘルツェゴビナは、ボスニア連邦とセルビア系住民のスルプスカ共和国より構成される国家となることが決定した。</p>
<p>1995年12月、安保理は加盟国に対してIFORの設置の権限を付与し、UNPROFORからIFORへの職務権限の移管が行われた。IFORは当事者の合意に基づいて強制措置をとることを認められていた。さらに、文民部門を担当する国連ボスニア・ヘルツェゴビナ・ミッション（UNMIBH）の設置が決定された。UNMIBHは、国際警察タスクフォースと国連民政部門から構成され、デイトン協定の履行を促進することを目的としていた。1996年12月12日、安保理は加盟国に対し、IFORに代わる安定化部隊（SFOR）の設置の権限を付与し、また、UNMIBHの期限を延長した。</p>
</section>
<section id="マケドニア" class="level3">
<h3 class="anchored" data-anchor-id="マケドニア">マケドニア</h3>
<p>マケドニア共和国へのUNPROFORの展開は、マケドニア大統領の要請に基づいて行われた。1992年11月、旧ユーゴスラビアの他地域での紛争の影響を懸念し、マケドニア大統領は国連に対して監視団の設置を要請した。これを受けて、安保理は<a href="https://digitallibrary.un.org/record/155227?ln=en">安保理決議795号</a>を採択し、UNPROFORの配置を決定した。これは国連で初めての予防展開のPKOであり、紛争が発生する前にPKO部隊を配置するという画期的な試みであった。</p>
<p>マケドニアにおけるUNPROFORの任務は、アルバニアとマケドニア、ユーゴスラビア連邦共和国（セルビアおよびモンテネグロ）とマケドニアの国境監視、国連の現地関与による国家の治安の強化、マケドニア領土の監視とその報告が任務であった。</p>
<p>UNPROFORの再編成を受けて、1995年3月31日、<a href="https://digitallibrary.un.org/record/174992?ln=en">安保理決議983号</a>において、マケドニアで活動していた部隊を独立した国連予防展開軍（UNPREDEP）へと改変し、UNPROFORの終了後の任務を引き継いだ。</p>
</section>
</section>
<section id="カンボジア1992年1993年-カンボジア1992年1993年" class="level2">
<h2 class="anchored" data-anchor-id="カンボジア1992年1993年-カンボジア1992年1993年">カンボジア（1992年～1993年） {#カンボジア（1992年～1993年）}</h2>
<p>ポル・ポト政権による大虐殺と、その後の20年以上にわたる内戦で荒廃したカンボジアの和平プロセスを支援したのが、カンボジアに展開したPKOであるUNTACである。</p>
<p>1970年以来長い戦乱の歴史をたどってきたカンボジアは、1991年10月23日の「カンボジア紛争の包括的政治解決に関する協定（パリ協定）」署名によって、和平への道が開かれることになった。国連カンボジア暫定統治機構（UNTAC）は、このパリ協定の履行を確保し、カンボジアにおける自由かつ公正な選挙を実施し、新しいカンボジア政府が樹立されるまでの間、暫定的にカンボジアを統治するために、パリ協定によって提案されたものである。</p>
<p>パリ協定の署名に先立ち、事務総長は、カンボジア紛争当事者4派による停戦を確保するために、小規模の国連カンボジア先遣隊（UNAMIC）を派遣することを提案した。UNAMICは、<a href="https://digitallibrary.un.org/record/129520?ln=en">安保理決議717号</a>により設置された。地雷探知や後方支援の活動から始まり、のちに地雷除去活動にも従事した。</p>
<p>1992年、事務総長はUNTAC実施計画を安保理に提出した。安保理はこの計画に基づき、<a href="https://digitallibrary.un.org/record/138379?ln=en">安保理決議745号</a>によってUNTACを設置し、1993年5月までに選挙を実施することを決定した。UNTACは、カンボジアの暫定統治以外にも武装解除、選挙の実施、人権監視、難民帰還、復興など極めて広範な職務権限を担った。</p>
<p>パリ協定の規定に則り、停戦の第二段階である武装解除、動員解除を開始した。しかし、ポル・ポト派はベトナム軍の完全撤退を要求し、武装・動員解除を一貫して拒否した。安保理の度重なる要求にも関わらず、ポル・ポト派はこれに従わなかったため、残る3派の武装解除も凍結されることとなった。さらに安保理は<a href="https://digitallibrary.un.org/record/154414?ln=en">安保理決議792号</a>によって、ポル・ポト派に対する経済制裁措置を検討する姿勢を打ち出した。それでもなお、ポル・ポト派による攻撃が続いたため、1993年5月には、これに対処するために、回収された武器の一部が返却される事態にまで至った。</p>
<p>このような混乱した状況にもかかわらず、有権者登録、難民帰還などは比較的順調に実施され、ポル・ポト派支配地域を除いた地域で460万人以上の有権者登録が行われた。UNTACは選挙の日程を変更することなく、有権者の約90％が投票した。これに伴い、<a href="https://digitallibrary.un.org/record/167977?ln=en">安保理決議840号</a>では、「選挙は自由かつ公正」であったことを宣言した。</p>
<p>その後、カンボジア暫定政府が正式に発足し、UNTACは使命を達成したことを確認し、すべての部隊が撤退することが決定した。</p>
<p>UNTACは、軍事部門ならず、人権監視、さらには、選挙実施および暫定統治といった実質的な国づくりにも関与する多機能型の平和維持活動であった。</p>
</section>
<section id="ソマリア内戦1990年代初期-ソマリア内戦1990年代初期" class="level2">
<h2 class="anchored" data-anchor-id="ソマリア内戦1990年代初期-ソマリア内戦1990年代初期">ソマリア内戦（1990年代初期） {#ソマリア内戦（1990年代初期）}</h2>
<p>アフリカ大陸の北東端に位置するソマリアは、イギリスとイタリアの植民地支配から1960年に独立した。ソマリアは、ソマリア人の単一民族国家ながら、20ほどの氏族・小氏族に分かれている。1969年にクーデターによりシアド・バーレが政権を握って9年程の後、氏族間の抗争が頻発するようになった。</p>
<p>20年近く続いたバーレ政権は1990年12月に崩壊し、翌1991年1月には統一ソマリア会議（USC）が暫定新政権を握った。当初、マフディー・モハメド大統領が一方的に暫定政府樹立に取りかかったが、まもなくモハメド大統領派とアイディード将軍派が衝突し、USCの新政権は分裂状態となった。USCの内部抗争は武力衝突にまで発展し、首都モガディシュにおいて事実上中央政府が存在しなくなり、内政は混迷を極めた。その結果、ソマリア全土で氏族や小氏族が武装して抗争や略奪を繰り返した。大規模な干ばつが重なり飢饉が拡大し、難民や避難民の流出を招いた。</p>
<p>安保理は、新政府の内部抗争に対応して、1992年1月にまずソマリアに対し武器禁輸措置を決定した（<a href="https://digitallibrary.un.org/record/135713?ln=en">安保理決議733号</a>）。事務総長による休戦交渉の末、1992年3月3日、主要な対立派閥であるモハメド派とアイディード派の間に束の間であれ停戦合意が成立した。その後、安保理は停戦合意の履行確保および首都モガディシュとその近郊における避難民への人道物資提供の支援のため、第一次国連ソマリア活動（UNOSOM１）を設立した（<a href="https://digitallibrary.un.org/record/141599?ln=en">安保理決議751号</a>）。UNOSOMⅠは度重なる部隊の拡大にも関わらず、救援物資の多くが武装集団に略奪されるなどその活動は著しく妨害された。事務総長はソマリアでの救援s物資の輸送を確保するには国連憲章第7章に基づく措置が必要である旨の勧告を安保理に行った。</p>
<p>これを受けた安保理は、人道的救援活動のための安全な環境を確保する目的で武力の行使を含む行動を容認する決議を採択した（<a href="https://digitallibrary.un.org/record/154648?ln=en">安保理決議794号</a>）。この決議に基づき、米軍主導の多国籍軍である統一タスクフォース（UNITAF）がソマリアに展開した。UNITAFによる人道的救援のための「希望回復作戦」により、深刻な飢饉に見舞われた中南部において治安の回復、食糧配給の促進が行われた。しかし、武装解除まで任務に含むべきものとする事務総長と人道目的に限定すべきとする米国との間でUNITAFの任務の解釈が一致せず、武装諸集団の武装解除に関しては不完全となった。</p>
<p>事務総長は、UNOSOMⅠの任務を拡大し、武装解除のための強制行動の権限を含むUNOSOMⅡを国連憲章第7章のもとで設置し、UNITAFからUNOSOMⅡへ移行させることを勧告し、安保理はこれを承認した。UNOSOMⅡは平和強制部隊の性格をもつものであった。</p>
<p>UNOSOMⅡの設置と並行して、国連の主導のもと、ソマリア問題の政治的解決のための和平への取り組みも進行した。</p>
<p>UNOSOMⅡの任務は、停戦協定の実施やソマリア国民和解議会第一回会合のアディスアベバ協定の実施を含む広範囲のものとなった。任務には、停戦監視、敵対行為の防止、強制力を伴う武装解除、避難民・難民の帰還の促進、地雷撤去の促進が含まれた。加えて、UNOSOMⅡは、政府・行政の再構築、警察の訓練・組織、司法や刑事システムの改革の促進をも担っている。ソマリアの国家としての機能を全土にわたって再構築するという、従来のPKOにはない任務をUNOSOMⅡは負った。</p>
<p>1993年10月3日、アメリカ特殊部隊がモガディシュ南部におけるアイディード派の逮捕と武装解除のための作戦に失敗し、18人のアメリが軍人が死亡して以降、ついに、アメリカは撤退の方向に方針転換し、他国もこれに続いた。UNOSOMⅡは活動の見直しの必要を踏まえて、平和強制活動の中止、従来の人道的援助の刑好みにUNOSOMⅡの活動を縮小すること、および1995年3月の撤退が確認されたのである。</p>
<p>UNOSOMは、人道面での支援や地区・地方の行sりと警察の再構築など一定の成果を残したものの、暫定国民評議会火災への予定表を達成することなく、ソマリアから完全に撤収した。</p>
<p>UNOSOMは伝統的なPKOから始まったものの、特定の勢力を敵とみなして戦闘を行った結果、モガディシュでアメリカ兵に多数の死者を出すことになった。ソマリアの混乱を収拾できなかっただけではなく、国際社会にソマリアの悪夢という深いトラウマを植え付けた。</p>
</section>
<section id="モザンビーク1992年1994年-モザンビーク1992年1994年" class="level2">
<h2 class="anchored" data-anchor-id="モザンビーク1992年1994年-モザンビーク1992年1994年">モザンビーク（1992年～1994年） {#モザンビーク（1992年～1994年）}</h2>
<p>南部アフリカに位置するモザンビークは、ポルトガルから独立して以来、一党独裁体制がとられてきた。モザンビーク解放戦線（FRELIMO）とモザンビーク民族抵抗運動（RENAMO）との間で16年におよぶ破壊的な内戦が継続した。</p>
<p>サモラ・マシェル大統領率いる政府であるモザンビーク解放戦線（FRELIMO）は、新ソ連の社会主義化を進めた。旧南ローデシア白人政権は、社会主義運動の波及を恐れ、アフォソン・ドラカマ議長率いる反政府組織のモザンビーク民族抵抗運動（RENAMO）の結成を支援した。旧南ローデシアが黒人政権のジンバブエとして独立した後は、南アフリカ共和国が引き続きRENAMOを支援した。</p>
<p>1980年代初めからモザンビーク国内でRENAMOによるゲリラ活動が開始された。FRELIMOは、ジンバブエやタンザニアの軍事援助を得てRENAMOに対抗し、全土は内戦状態となった。</p>
<p>イタリア等の仲介により、1992年、ローマにおいて包括和平協定が紛争当事者の政府FRELIMOとRENAMOの間で調印され、内戦は終結を見た。両者はモザンビークの和平たっせのための原則と方法について合意し、国連に和平協定履行への協力・監視を要請することで一致した。和平協定の内容は、双方の軍隊が武装解除に応じ、兵力集結後、一部を新設の統合軍に再編成すること、一年後に大統領選挙と議会選挙を実施することを骨子とした。事務総長は、和平協定履行のため国連モザンビーク活動（ONUMOZ）の設置を提案し、<a href="https://digitallibrary.un.org/record/155929?ln=en">安保理決議797号</a>によって設置が決定された。</p>
<p>ONUMOZは、モザンビーク初の複数政党制の選挙実施に向けて、停戦監視、武装解除、選挙監視、人道的援助など、和平プロセスに伴う複数の機能を担う平和維持活動として活動した。具体的な任務は、政治行政、軍事、選挙、人道的援助の四部門に、のちに増設された警察部門を加えた計五部門によって担われた。</p>
<p>国連側の人員派遣の遅れや武装解除計画の遅延などにより、選挙日程も延期された。事務総長は、アンゴラの経験を踏まえて、紛争の再発を最大限に防ぐため、十分に武装解除を行ってから選挙を行うことを目指した。政府とRENAMOの対立がありつつも、選挙は実施され、FRELIMOが過半数を超える与党、RENAMOが最大与党となった。安保理は選挙に基づく新政府の樹立を歓迎し、ONUMOZの活動終了を宣言し、ONUMOZのすべての部隊が撤収した。</p>
<p>ONUMOZは、カンボジアやエルサルバドルと並び、包括的な和平合意の履行を支援した「多機能型のPKO」の代表例とされる。</p>
</section>
<section id="リベリア1993年1997年-リベリア1993年1997年" class="level2">
<h2 class="anchored" data-anchor-id="リベリア1993年1997年-リベリア1993年1997年">リベリア（1993年～1997年） {#リベリア（1993年～1997年）}</h2>
<p>アメリカの解放奴隷がこの地に入植、その後、リベリア共和国の独立を宣言した。リベリアでは、少数の入植者の子孫が大多数の先住民を支配する体制が続いた。先住民クラン族によってこの体制は打倒されたが、ドウ政権はクラン族のみを重用し、他の国民には苛烈な弾圧を加えた。ドウ政権打倒を目指してリベリア国民愛国戦線（NPFL）がコートジボワールから侵攻し、同国の反政府運動や部族対立は内戦へと発展した。1990年には、NPFLと独立リベリア国民愛国戦線（INPFL）が首都以外を制圧、人口の過半数が家を失い、数十万人が近隣諸国に脱出する事態となった。</p>
<p>1990年、西アフリカ諸国経済共同体（ECOWAS）の要請に基づき、平和維持軍として、ECOWAS監視団（ECOMOG）の設立を決議し、ECOMOGは、停戦合意が確立しないまま、展開を開始した。また、国民統一暫定政府（IGNU）を樹立した。しかし、NPFLはこれらに同意を与えなかった。ECOMOGとNPFL間に戦闘が発生し、ECOMOGも巻き込んだ激しい内戦状態が続いたが、ECOWAS五か国委員会の仲介によって、ヤムスクロⅣ和平協定が締結された。しかし、NPFLは再び協力を拒否し、NPFLと民主リベリア統一解放運動（ULIMO）との間で戦闘が激化した。1992年、安保理は、ECOWASを支持し、ヤムスクロⅣ協定がリベリア紛争解決の最善の枠組みであるとする議長声明を採択した。</p>
<p>安保理は、すべての当事者に停戦を要請し、リベリアに対する武器禁輸措置を決定し、事務総長に対し、特別代表の派遣を要請した（<a href="https://digitallibrary.un.org/record/153983?ln=en">安保理決議788号</a>）。1993年、国連・アフリカ統一機構（OAU）・ECOWASの支援のもとに、IGNU・NPFL・ULIMO間にコトヌー和平協定が締結された。この協定の実施の監視については、ECOMOGが主要な責任を負い、国連監視団がその監視活動を監視・検証するものとされた。安保理は、国連リベリア監視団（UNOMIL）先遣隊の派遣を承認（<a href="https://digitallibrary.un.org/record/170851?ln=en">安保理決議856号</a>）し、続いて、UNOMILの設立を承認した。UNOMILの職務権限は、停戦違反の調査・報告、和平協定のその他の規定の遵守の監視、選挙プロセスの監視・検証、人道援助活動の調整の援助、動員解除の計画立案、重大な国際人道法違反の報告、地雷除去の支援、ECOMOGとの調整であるとされた（<a href="https://digitallibrary.un.org/record/173063?ln=en">安保理決議866号</a>）。</p>
<p>しかし、和平協定の実施は大幅に遅れ、停戦は頻繁に破られ、当事者は内部分裂を繰り返し、UNOMILは職務権限の延長を余儀なくされた。その後、多数の協定によって、当事者は停戦と1年以内の総選挙に合意した。</p>
<p>その後、大統領・議会選挙が1997年に実施され、テイラー候補が大統領に当選して、新政府が樹立された。議会は、NPFLが第一党となった。民主的に選出された新政府が成立したため、UNOMILは活動を終了した。</p>
<p>UNOMILの活動終了後、1997年にアナン事務総長は、国連リベリア平和建設事務所をリベリアに設置した。国連の平和建設活動を強化、調整し、国民和解と人権尊重の促進を助け、再建・復興のための国際支援を動員することを目的として、現在も活動を続ける。</p>
<p>UNOMILは1997年に選挙を実施し、民主的な政府の樹立という一定の成果を上げたといえる。しかし、武力行使の権限が限定的であるといったようなマンデート上の理由で内戦の再発を防ぐことには寄与できなかった。</p>
</section>
<section id="ハイチ1993年-ハイチ1993年" class="level2">
<h2 class="anchored" data-anchor-id="ハイチ1993年-ハイチ1993年">ハイチ（1993年～） {#ハイチ（1993年～）}</h2>
<p>1990年、ハイチで初の民主的な選挙が実施され、「変革と民主主義国民戦線（FNCD）」のアリスティド候補が大統領に選出された。この選挙の過程は、総会が設置した国連ハイチ選挙検証監視団（ONUVEH）が中心となって、国際的に監視され、選挙が公正に実施されたことが確認された。</p>
<p>1991年、アリスティド大統領が就任したが、セドラ将軍率いる軍部クーデターにより政権の座を追われることになった。</p>
<p>米州機構（OAS）をはじめ、国際社会は、このクーデターを強く非難し、合法政権の復帰を求めた。この政変に伴い、ハイチ国内には政治的・経済的・社会的混乱が生じた。革命軍事政権による圧政のため人権が無視され、国際的にも孤立し、経済状況が深刻化するにつれ、母国を捨てる難民が急増した事態は、国際社会にとっての重大な関心事となっていった。1993年、安保理は、この事態を平和に対する脅威と認定し、ハイチに対し石油と武器の禁輸を課す経済制裁を発動した（<a href="https://digitallibrary.un.org/record/168120?ln=en">安保理決議841号</a>）。</p>
<p>1993年、OASや国連の努力の甲斐あって、ハイチの政治的危機を解決するための枠組みを提供するガバナーズ島合意が、両陣営の間で成立した。この合意には、ハイチ危機解決のための国際協力の一つとして、「国連の現地関与によるハイチ軍の近代化と新警察隊の設立のための援助」を規定していた。</p>
<p>安保理は、国連の現地関与に関し、「事務総長の韓国に基づき、早急に、必要な措置をとる用意がある」ことを明らかにした。これを受けて、アリスティド大統領は、配置が受け入れる国連の援助の職内容の範囲について提案した。その後、事務総長は、関係国との協議ののち、安保理に対し、国連ハイチ使節団（UNMIH）抗争を勧告した。</p>
<p>事態の推移を見守っていた安保理は、ハイチ首相が適正に選出されたことを受け、経済制裁を停止した。また、安保理は決議862号を採択し、国連ハイチ使節団の展開のために必要なものを詳細に調査し、その受け入れを準備する目的で、先遣隊（UNMIHAT）の派遣を承認した。</p>
<p>その後、安保理は、UNMIHATからの報告に基づき、UNMIHの設立と即時展開を許可した（<a href="https://digitallibrary.un.org/record/173065?ln=en">安保理決議867号</a>）。UNMIHATは軍事部門・警察部門から構成され、ハイチ警察への指導や訓練の提供、人権政治協定の精神や文言の尊重を検証するために現存する保安隊の職務状況を監視すること、災害救援、捜索と救助、国境や沿岸の監視などの非戦闘能力に関する訓練を提供することが職務権限であった。</p>
<p>しかし、ハイチへ展開する軍事部門の舞台を輸送する米軍艦隊が接岸を妨害される事件が発生した。国連はこのようなハイチ国内の情勢悪化を受け、UNMIHの即時展開を諦め、また要員の安全の確保という点に鑑み、UNMIHATも引き上げた。</p>
<p>その後、安保理は経済制裁の停止を解除し、経済制裁の実効性を高めるために、加盟国に対し会場での臨検を認める決議を採択した（<a href="https://digitallibrary.un.org/record/174421?ln=en">安保理決議873号</a>・<a href="https://digitallibrary.un.org/record/174419?ln=en">安保理決議875号</a>）。</p>
<p>このような国際社会の圧力は強まったにもかかわらず、強硬姿勢を崩さず、アリスティド大統領の帰国も実現しなかった。</p>
<p>安保理は経済制裁を強化し、衣料品や人道物資を除くすべての物品を禁輸対象とした（<a href="https://digitallibrary.un.org/record/186367?ln=en">安保理決議917号</a>）。さらに、安保理は、加盟国に対し、多国籍軍の編成および必要なあらゆる措置をとる権限を与えるとともに、UNMIHの現地展開の準備のため、UNMIH先遣隊を設立した（<a href="https://digitallibrary.un.org/record/191651?ln=en">安保理決議940号</a>）。一時は軍事的衝突も懸念されたが、アメリカ元大統領カーターの仲介により、政治的和解が成立した。その後、ハイチ政府の同意を得て、治安の維持および平和的な民政移管の環境づくりを目的とし、ハイチ領内に多国籍軍が暫定的に展開された。その後、大きな衝突もなく、事態は解決の方向に向かった。これを受け、<a href="https://digitallibrary.un.org/record/161992?ln=en">安保理決議944号</a>に基づき制裁は解除された。</p>
<p>1995年1月、安保理は、UNMIHの展開にとって適切な、安全でかつ安定した環境が今やハイチに存在していると認定し、多国籍軍からUNMIHへの権限の完全な移譲を決定した。</p>
<p>1995年6月、安保理は、ハイチに民主主義を根付かせ、ハイチの司法制度を再生するにあたっては、有効な国民警察隊の存在が重用であり、そのためには適切な国際支援を継続する必要があるとの認識から、国連ハイチ支援団（UNSMIH）の設立を決定した。その後、UNSMIHは任期の延長がなされつつも、1997年にその任務を終了した。</p>
</section>
<section id="ルワンダ内戦1994年-ルワンダ内戦1994年" class="level2">
<h2 class="anchored" data-anchor-id="ルワンダ内戦1994年-ルワンダ内戦1994年">ルワンダ内戦（1994年） {#ルワンダ内戦（1994年）}</h2>
<p>ルワンダ政府とルワンダ愛国戦線（RPF）は、OAUとタンザニアの支援のもとに、1992年アルーシャで停戦協定を締結し、1993年には和平協定を締結した。両当事者の軍の統合に関する議定書は、国連の責任と指揮のもとにおかれ、和平協定の実施を援助する中立国際軍の設立を規定していた。安保理は和平協定の実施を支援するために、国連ルワンダ支援団（UNAMIR）を設立した。その職務権限は、キガリ市の安全への寄与、停戦協定遵守の監視、選挙へ至るまでの暫定政府の職務権限の最終段階における安全状況の監視、地雷除去の援助、軍の統合に関する議定書違反の申し立ての調査、難民の帰還と避難民の再定住の監視、人道援助活動の調整の援助、憲兵隊と警察の活動の調査であった。総選挙と新政権樹立の後に終了が予定されていた（<a href="https://digitallibrary.un.org/record/197341?ln=en">安保理決議872号</a>）。</p>
<p>しかし、1994年4月6日、ルワンダのハビャリマナ、ブルンジのヌタリャミラ両大統領が搭乗機の墜落事故で死亡したのをきっかけに内戦が再発し、ルワンダ政府軍・フツ族民兵によるツチ族に対する大量虐殺が遂行され、UNAMIRも攻撃を受ける事態となった。これに対応して、安保理はUNAMIRの職務権限と規模を数次にわたり変更した。まず、4月21日に、職務権限を①当事者間の仲介、②人道援助活動再開の援助、③事態の進展の監視に変更し、規模を縮小した（<a href="https://digitallibrary.un.org/record/197526?ln=en">安保理決議912号</a>）。次に、大量虐殺の侵攻に伴い、5月17日に、平和と安全に対する脅威の存在を認定し、ルワンダに対し武器禁輸措置を決定するとともに、職務権限を①危機に瀕している避難民、難民および市民の安全と保護への寄与、②救援物資の提供と人道救援活動への安全と支援の提供に拡大し、規模を拡大した（<a href="https://digitallibrary.un.org/record/197563?ln=en">安保理決議918号</a>）。</p>
<p>しかし、軍事要員が十分に集まらなかったため、安保理はフランスの申し出に応じ、UNAMIRが必要な規模に達するまで人道目的を達成するために必要なあらゆる手段を用いる権限を付与された多国籍軍を設立することに合意（<a href="https://digitallibrary.un.org/record/197582?ln=en">安保理決議929号</a>）し、フランス中心の多国籍軍がルワンダ南東部に人道的安全地帯を設定した。</p>
<p>この間にRPFが勝利を収め、7月18日に停戦を宣言し、フツ族穏健派を含めた新政府が樹立される一方、旧政権の軍・政府関係者やフツ族民兵とともに、約200万人のフツ族難民がザイールなど近隣諸国に流出する事態となった。その後、UNAMIRは難民の自発的機関を促す努力を続け、11月30日、その職務権限は①ルワンダ国際刑事法廷要因と国連人権担当官の安全への寄与、②新国家警察の設立と訓練の援助に拡大された（<a href="https://digitallibrary.un.org/record/198050?ln=en">安保理決議965号</a>）が、難民キャンプを支配する旧政府勢力の脅迫や新政府による報復の恐れから、ほとんど期間は進まず、また、旧政府勢力による越境テロ活動が増加した。</p>
<p>1995年に安保理とガリ事務総長は、ザイールのルワンダ難民キャンプへの武器の売却・供給を監視する国連監視団の設立を検討したが、ザイール政府の反対で実現しなかった。業を煮やした新政府はUNAMIR受け入れの同意を撤回したため、1995年12月12日、安保理は、その職務権限を最終期限として1996年3月8日まで延長することを決定した。また、職務権限を①難民の自発的かつ安全な帰還を達成するのを援助するために周旋を行うこと、②そのような帰還の促進についてルワンダ政府を援助すること、③難民の帰還のための後方支援について国際機関を援助すること、④ルワンダ国際刑事法廷に保護を与えることに変更し、規模を1200人に縮小した（<a href="https://digitallibrary.un.org/record/201012?ln=en">安保理決議1029号</a>）。活動終了後、撤収は1996年4月19日に完了した。</p>
</section>
<section id="エピローグ" class="level2">
<h2 class="anchored" data-anchor-id="エピローグ">エピローグ</h2>
<p>ここでは、PKOについて、PKOがどのような目的で、具体的にどのようなことを行うのかに着目して機能（任務内容）による分類を示す。<br>
もちろんPKOの類型に関しては他の切り口も存在するため、あくまで1つの参考として読んでいただきたい。</p>
<section id="伝統的pko" class="level3">
<h3 class="anchored" data-anchor-id="伝統的pko">伝統的PKO</h3>
<p>冷戦期に確立された、最も古典的なPKOの形態を指す。</p>
<p>主な目的・任務は①国家間の紛争における停戦監視、②当事者（主に各国の正規軍）の兵力引き離し、③非武装地帯や緩衝地帯のパトロールである。</p>
<p>特徴として、PKO三原則を厳格に遵守すること・紛争の根本原因には介入せず、あくまで「平和を維持」することが目的であること・構成員は主に各国の軍人で、軽武装が基本であることが挙げられる。</p>
<p>代表的なPKO事例は、<a href="#第一次国連緊急軍（unefⅰ）">第一次国連緊急軍（UNEFⅠ）</a>・<a href="#キプロス（1964年～）">国連キプロス平和維持隊（UNFICYP）</a>である。</p>
</section>
<section id="防止予防型pko" class="level3">
<h3 class="anchored" data-anchor-id="防止予防型pko">防止（予防）型PKO</h3>
<p>紛争が本格化する前に展開し、未然に防ぐことを目的としたPKOを指す。冷戦後に登場した新しい概念である。</p>
<p>主な目的・任務は、①紛争の火種がある地域に展開し、監視・報告を行うことで、紛争の発生や拡大を抑止する、②当事者間の信頼醸成を支援することである。</p>
<p>特徴として、武力紛争が発生する前の段階で展開する点、軍事部門だけではなく、政治・民生部門の役割も重要となることが挙げられる。</p>
<p>代表的なPKO事例は、<a href="#旧ユーゴスラビア（unprofor）">国連予防展開軍（UNPREDEP）</a>である。</p>
</section>
<section id="多機能型pko" class="level3">
<h3 class="anchored" data-anchor-id="多機能型pko">多機能型PKO</h3>
<p>停戦監視だけではなく、紛争後の国の安定化と再建を包括的に支援するPKOを指す。</p>
<p>主な目的・任務は、停戦監視に加えて、①武装解除・動員解除・社会復帰、②選挙の監視・実施支援、③人権状況の監視、④警察官の育成・指導、⑤難民の帰還支援・行政機構の再建支援、である。</p>
<p>特徴として、内戦終結後の「平和の構築」に重点を置くこと・軍人だけでなく文民（警察官・選挙監視員・人権専門家など）が多数参加することが挙げられる。</p>
<p>代表的なPKO事例は、<a href="#カンボジア（1992年～1993年）">国連カンボジア暫定統治機構（UNTAC）</a>、<a href="#モザンビーク（1992年～1994年）">国連モザンビーク活動（ONUMOZ）</a>である。</p>
</section>
<section id="複雑緊急事態型pko" class="level3">
<h3 class="anchored" data-anchor-id="複雑緊急事態型pko">複雑・緊急事態型PKO</h3>
<p>国家機能が崩壊し、人道危機が深刻化する無政府状態の内戦に対応するPKOを指す。</p>
<p>主な目的・任務は、①人道支援物資の安全な輸送・配給の確保、②民間人・避難民の保護、③場合により、平和を強制するための武力行使（平和執行）も含むことである。</p>
<p>特徴として、明確な停戦合意や統治機構が存在しない中で活動する・PKO三原則を維持することが極めて困難・活小津が武装勢力の攻撃対象となり、PKO要員にも多くの犠牲が出ることが挙げられる。</p>
<p>代表的なPKO事例は、<a href="#ソマリア内戦（1990年代初期）">第二次国連ソマリア活動（UNOSOMⅡ）</a>・<a href="#旧ユーゴスラビア（unprofor）">国連保護軍（UNPROFOR）</a>である。</p>
</section>
</section>
<section id="参照" class="level2">
<h2 class="anchored" data-anchor-id="参照">参照</h2>
<table class="caption-top table">
<thead>
<tr class="header">
<th>機能別分類</th>
<th>事例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>伝統的PKO</td>
<td><a href="#第一次国連緊急軍（unefⅰ）">第一次国連緊急軍（UNEFⅠ）</a> <a href="#第一次国連緊急軍（unefⅰ）">第二次国連緊急軍（UNEFⅡ）</a> <a href="#イラク（1991年～2003年）">国連イラク＝クウェート軍事監視団（UNIKOM）</a> <a href="#エルサルバドル（1991年～1995年）">国連中米監視団（ONUCA）</a> <a href="#コンゴ動乱（1960年～1964年）">コンゴ国連軍（ONUC）</a></td>
</tr>
<tr class="even">
<td>防止（予防）型PKO</td>
<td><a href="#マケドニア">国連マケドニア予防展開軍（UNPREDEP）</a></td>
</tr>
<tr class="odd">
<td>多機能型PKO</td>
<td><a href="#アンゴラ（1989年～1999年）">国連アンゴラ検証団（UNAVEM）</a> <a href="#ナミビア（1989年～1990年）">国連ナミビア独立支援グループ（UNTAG）</a> <a href="#西サハラ（1991年～）">国連西サハラ住民投票監視団（MINURSO）</a> <a href="#エルサルバドル（1991年～1995年）">国連エルサルバドル監視団（ONUSAL）</a> <a href="#カンボジア（1992年～1993年）">国連カンボジア暫定統治機構（UNTAC）</a> <a href="#モザンビーク（1992年～1994年）">国連モザンビーク活動（ONUMOZ）</a> <a href="#リベリア（1993年～1997年）">国連リベリア監視団（UNOMIL）</a> <a href="#ハイチ（1993年～）">国連ハイチ使節団（UNMIH）</a></td>
</tr>
<tr class="even">
<td>複雑・緊急事態型PKO</td>
<td><a href="#旧ユーゴスラビア（unprofor）">国連保護軍（UNPROFOR）</a> <a href="#ソマリア内戦（1990年代初期）">国連ソマリア活動（UNOSOM）</a> <a href="#ルワンダ内戦（1994年）">国連ルワンダ支援団（UNAMIR）</a></td>
</tr>
</tbody>
</table>
<p>※<a href="#湾岸戦争（1990年～1991年）">湾岸多国籍軍</a>に関しては、国連PKOではなく、安保理決議による授権によって、特定の軍事行動を承認された、アメリカを中心とする有志国連軍であるため、分類を行っていない。</p>
</section>
<section id="参考文献" class="level2">
<h2 class="anchored" data-anchor-id="参考文献">参考文献</h2>
<ul>
<li>『国連による平和と安全の維持』<br>
</li>
<li>『国連による平和と安全の維持』<br>
</li>
<li>『国連の平和外交　PEACEMONGER』<br>
</li>
<li>『委託調査のやつ』</li>
</ul>


</section>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr>
<ol>
<li id="fn1"><p>安保理が拒否権等によって機能不全になった時に、代わりに総会が平和のために行動できるルール。<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "コピーしました");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "コピーしました");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../content/03_ch03.html" class="pagination-link" aria-label="第3章　争点・論点解説">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-title">第3章　争点・論点解説</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../content/05_ch05.html" class="pagination-link" aria-label="第5章　国連の制度">
        <span class="nav-page-text"><span class="chapter-title">第5章　国連の制度</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<script>
// Inlined UI script for offline file:// compatibility
// Source: src/js/ui-clean.js (inlined)
(function() {
  'use strict';

const STORAGE_KEYS = {
  tocLocation: 'quarto-toc-location',
  theme: 'quarto-theme',
  fontSize: 'quarto-font-size',
  markers: 'quarto-markers',
  comments: 'quarto-comments',
  scrollPosition: 'quarto-scroll-position',
  rightTab: 'quarto-right-tab',
  readingState: 'quarto-reading-state'
};

  const NAV_DATA_STATE = {
    promise: null,
    data: null,
    rootPrefix: null
  };

  function getRootPrefix() {
    if (NAV_DATA_STATE.rootPrefix != null) return NAV_DATA_STATE.rootPrefix;
    const meta = document.querySelector('meta[name="quarto:offset"]');
    let prefix = meta ? (meta.getAttribute('content') || '') : '';
    if (prefix && !prefix.endsWith('/')) prefix += '/';
    NAV_DATA_STATE.rootPrefix = prefix;
    return prefix;
  }

  function normalizePath(path) {
    const cleaned = (path || '').replace(/\\/g, '/');
    const decoded = decodeURIComponent(cleaned);
    return decoded.replace(/^\/+/, '');
  }

  // =============================
  // 設定リセット系ユーティリティ
  // =============================
  function resetUiSettings() {
    try {
      // 現行UIの表示系
      localStorage.removeItem(STORAGE_KEYS.theme);
      localStorage.removeItem(STORAGE_KEYS.fontSize);
      localStorage.removeItem(STORAGE_KEYS.rightTab);
      localStorage.removeItem('footnotes-sort');
      localStorage.removeItem('comments-sort');

      // 旧UI由来（残っている可能性があるもの）
      localStorage.removeItem('txtSize');
      localStorage.removeItem('theme');
      localStorage.removeItem('tocLocation');
      localStorage.removeItem('scrollPos');
    } catch (e) {
      console.warn('resetUiSettings failed', e);
    }
  }

  function resetMemoSettings() {
    try {
      // マーカー／コメント関連
      localStorage.removeItem(STORAGE_KEYS.markers);
      localStorage.removeItem(STORAGE_KEYS.comments);
    } catch (e) {
      console.warn('resetMemoSettings failed', e);
    }
  }

  function resetPreviewSettings() {
    try {
      // Docs/BG プレビュー関連
      localStorage.removeItem('gdocPreviewMaxToasts');
      localStorage.removeItem('gdocPreviewState_v2');
    } catch (e) {
      console.warn('resetPreviewSettings failed', e);
    }
  }

  function resetAllSettingsHard() {
    try {
      // localStorage 全消去（他サイトのデータは同一オリジン内なので注意が必要だが、
      // このBGビューア専用オリジン前提で、完全リセットとして実装）
      localStorage.clear();
    } catch (e) {
      console.warn('resetAllSettingsHard failed', e);
    }
    try {
      // 読書状態・スクロール状態など sessionStorage 由来のものもクリア
      sessionStorage.clear();
    } catch (e) {
      console.warn('sessionStorage clear failed', e);
    }
  }

  function computeCurrentOutputPath() {
    const currentUrl = new URL(window.location.href);
    let rel = decodeURIComponent(currentUrl.pathname);
    try {
      const rootUrl = new URL(getRootPrefix() || './', window.location.href);
      if (rel.startsWith(rootUrl.pathname)) {
        rel = rel.slice(rootUrl.pathname.length);
      }
    } catch (e) {
      console.warn('computeCurrentOutputPath root resolution failed:', e);
    }
    const outIdx = rel.indexOf('/out/');
    if (outIdx >= 0) rel = rel.slice(outIdx + 5);
    rel = rel.replace(/^\//, '');
    if (!rel) rel = 'index.html';
    if (rel.endsWith('/')) rel += 'index.html';
    return rel;
  }

  function isSamePage(pathA, pathB) {
    return normalizePath(pathA) === normalizePath(pathB);
  }

  function buildHref(pagePath, anchor) {
    const current = computeCurrentOutputPath();
    if (isSamePage(pagePath, current)) {
      return anchor ? `#${anchor}` : '#';
    }
    const prefix = getRootPrefix();
    const base = `${prefix || ''}${pagePath}`;
    return anchor ? `${base}#${anchor}` : base;
  }

  function updateIndexLinksForContext() {
    const currentPath = computeCurrentOutputPath();
    const inContentDir = typeof currentPath === 'string' && currentPath.startsWith('content/');
    const links = document.querySelectorAll('a[data-aj-index-root-href]');
    if (!links.length) return;
    links.forEach(link => {
      const rootHref = link.getAttribute('data-aj-index-root-href');
      const localHref = link.getAttribute('data-aj-index-local-href');
      const target = inContentDir && localHref ? localHref : rootHref;
      if (target) {
        link.setAttribute('href', target);
      }
    });
  }

  function reinforceAnchors(scope) {
    if (!scope || typeof scope.querySelectorAll !== 'function') return;
    const anchors = scope.querySelectorAll('a[href]');
    anchors.forEach(anchor => {
      if (anchor.dataset.ajLinkReinforced === 'true') return;
      anchor.dataset.ajLinkReinforced = 'true';
      const href = anchor.getAttribute('href') || '';
      if (/^https?:\/\//i.test(href)) {
        if (!anchor.getAttribute('target')) {
          anchor.setAttribute('target', '_blank');
        }
        const rel = anchor.getAttribute('rel') || '';
        if (!/noopener/i.test(rel)) {
          anchor.setAttribute('rel', (rel + ' noopener noreferrer').trim());
        }
      }
    });
  }

  function setInlineFootnoteMode(active) {
    const next = !!active;
    if (INLINE_FOOTNOTE_MODE === next) return;
    INLINE_FOOTNOTE_MODE = next;
    if (!INLINE_FOOTNOTE_MODE) {
      hideCommentPopover();
    }
  }

  function ensureCommentMarkerInteractions() {
    const markers = document.querySelectorAll('.text-marker[data-comment-id]');
    markers.forEach(marker => {
      if (marker.dataset.commentMarkerBound === 'true') return;
      marker.dataset.commentMarkerBound = 'true';
      marker.addEventListener('click', handleCommentMarkerClick);
      marker.addEventListener('pointerenter', handleCommentMarkerPointerEnter);
      marker.addEventListener('pointerleave', handleCommentMarkerPointerLeave);
    });
  }

  function handleCommentMarkerClick(event) {
    if (!INLINE_FOOTNOTE_MODE) return;
    event.preventDefault();
    event.stopPropagation();
    const marker = event.currentTarget;
    if (commentPopoverEl && commentPopoverMarker === marker && commentPopoverPersistent) {
      hideCommentPopover();
    } else {
      showCommentPopover(marker, { persistent: true });
    }
  }

  function handleCommentMarkerPointerEnter(event) {
    if (!INLINE_FOOTNOTE_MODE) return;
    if (event.pointerType && event.pointerType !== 'mouse') return;
    const marker = event.currentTarget;
    showCommentPopover(marker, { persistent: false });
    clearCommentPopoverHideTimer();
  }

  function handleCommentMarkerPointerLeave() {
    if (!INLINE_FOOTNOTE_MODE) return;
    scheduleCommentPopoverHide(200);
  }

  function showCommentPopover(marker, opts) {
    if (!marker) return;
    const rec = getCommentRecordById(marker.getAttribute('data-comment-id'));
    if (!rec) return;
    const persistent = !!(opts && opts.persistent);
    clearCommentPopoverHideTimer();
    commentPopoverPersistent = persistent;
    commentPopoverMarker = marker;
    if (commentPopoverEl) {
      commentPopoverEl.remove();
      commentPopoverEl = null;
    }
    commentPopoverEl = document.createElement('div');
    commentPopoverEl.className = 'comment-inline-popover';
    const snippetRaw = (rec.text || '').trim();
    const snippetHtml = snippetRaw ? `対象: ${escapeHtml(snippetRaw.slice(0, 160))}` : '';
    const bodyHtml = escapeHtml(rec.body || '').replace(/\n/g, '<br>');
    commentPopoverEl.innerHTML = `
      ${snippetHtml ? `<div class="comment-inline-popover__snippet">${snippetHtml}</div>` : ''}
      <div class="comment-inline-popover__body">${bodyHtml || '<em>コメント内容がありません。</em>'}</div>
    `;
    commentPopoverEl.addEventListener('pointerenter', clearCommentPopoverHideTimer);
    commentPopoverEl.addEventListener('pointerleave', () => scheduleCommentPopoverHide(200));
    document.body.appendChild(commentPopoverEl);
    positionCommentPopover(marker);
  }

  function hideCommentPopover() {
    clearCommentPopoverHideTimer();
    if (commentPopoverEl) {
      commentPopoverEl.remove();
      commentPopoverEl = null;
    }
    commentPopoverMarker = null;
    commentPopoverPersistent = false;
  }

  function scheduleCommentPopoverHide(delay) {
    if (commentPopoverPersistent || !commentPopoverEl) return;
    clearCommentPopoverHideTimer();
    commentPopoverHideTimer = window.setTimeout(() => {
      hideCommentPopover();
    }, delay || 0);
  }

  function clearCommentPopoverHideTimer() {
    if (commentPopoverHideTimer) {
      clearTimeout(commentPopoverHideTimer);
      commentPopoverHideTimer = null;
    }
  }

  function positionCommentPopover(marker) {
    if (!commentPopoverEl || !marker) return;
    const rect = marker.getBoundingClientRect();
    const popRect = commentPopoverEl.getBoundingClientRect();
    const scrollX = window.scrollX || document.documentElement.scrollLeft || 0;
    const scrollY = window.scrollY || document.documentElement.scrollTop || 0;
    const viewportWidth = document.documentElement.clientWidth || window.innerWidth || popRect.width;
    const viewportHeight = document.documentElement.clientHeight || window.innerHeight || popRect.height;
    let top = scrollY + rect.bottom + 10;
    let left = scrollX + rect.left + (rect.width / 2) - (popRect.width / 2);
    const minLeft = scrollX + 8;
    const maxLeft = scrollX + viewportWidth - popRect.width - 8;
    if (left < minLeft) left = minLeft;
    if (left > maxLeft) left = maxLeft;
    const maxTop = scrollY + viewportHeight - popRect.height - 8;
    if (top > maxTop) {
      top = scrollY + rect.top - popRect.height - 10;
    }
    if (top < scrollY + 8) {
      top = scrollY + 8;
    }
    commentPopoverEl.style.top = `${top}px`;
    commentPopoverEl.style.left = `${left}px`;
  }

  function updateCommentPopoverPosition() {
    if (!INLINE_FOOTNOTE_MODE || !commentPopoverEl || !commentPopoverMarker) return;
    positionCommentPopover(commentPopoverMarker);
  }

  function getCommentRecordById(id) {
    if (!id) return null;
    const list = COMMENTS_DB[pageKey()] || [];
    return list.find(rec => rec && rec.id === id) || null;
  }

  document.addEventListener('click', (event) => {
    if (!INLINE_FOOTNOTE_MODE) return;
    const marker = event.target.closest && event.target.closest('.text-marker[data-comment-id]');
    if (marker) return;
    if (commentPopoverEl && !event.target.closest('.comment-inline-popover')) {
      hideCommentPopover();
    }
  });

  window.addEventListener('scroll', () => updateCommentPopoverPosition(), { passive: true });
  window.addEventListener('resize', () => updateCommentPopoverPosition());

  function cloneTreeWithDepth(nodes, maxLevel) {
    if (!Array.isArray(nodes) || !nodes.length) return [];
    const walk = (list) => {
      const acc = [];
      list.forEach(node => {
        if (!node || typeof node !== 'object') return;
        if (typeof node.level !== 'number' || node.level > maxLevel) return;
        const copy = {
          title: node.title,
          level: node.level,
          anchor: node.anchor,
          children: []
        };
        if (Array.isArray(node.children) && node.children.length) {
          copy.children = walk(node.children);
        }
        acc.push(copy);
      });
      return acc;
    };
    return walk(nodes);
  }

  function resolveNavData(data) {
    if (data && typeof data === 'object' && Array.isArray(data.pages)) {
      NAV_DATA_STATE.data = data;
      return data;
    }
    throw new Error('Invalid navigation data payload');
  }

  function loadNavDataViaScript(prefix) {
    if (typeof document === 'undefined') {
      return Promise.reject(new Error('DOM unavailable for script loading'));
    }
    return new Promise((resolve, reject) => {
      const existing = document.querySelector('script[data-nav-data="true"]');
      if (existing && typeof window.__NAV_DATA__ === 'object' && window.__NAV_DATA__) {
        try {
          resolve(resolveNavData(window.__NAV_DATA__));
        } catch (err) {
          reject(err);
        }
        return;
      }
      const script = document.createElement('script');
      script.type = 'text/javascript';
      script.dataset.navData = 'true';
      script.src = `${prefix}assets/nav-data.js`;
      script.onload = () => {
        try {
          resolve(resolveNavData(window.__NAV_DATA__));
        } catch (err) {
          reject(err);
        }
      };
      script.onerror = () => reject(new Error('Failed to load nav-data.js'));
      document.head.appendChild(script);
    });
  }

  function loadNavData() {
    if (NAV_DATA_STATE.data) return Promise.resolve(NAV_DATA_STATE.data);
    if (typeof window.__NAV_DATA__ === 'object' && window.__NAV_DATA__) {
      try {
        return Promise.resolve(resolveNavData(window.__NAV_DATA__));
      } catch (err) {
        return Promise.reject(err);
      }
    }
    if (NAV_DATA_STATE.promise) return NAV_DATA_STATE.promise;
    const prefix = getRootPrefix() || '';
    if (location.protocol === 'file:') {
      NAV_DATA_STATE.promise = loadNavDataViaScript(prefix)
        .catch(err => {
          console.warn('Failed to load nav data via script:', err);
          NAV_DATA_STATE.data = null;
          return null;
        });
      return NAV_DATA_STATE.promise;
    }

    const url = new URL(`${prefix}assets/nav-data.json`, window.location.href);
    NAV_DATA_STATE.promise = fetch(url.href)
      .then(res => {
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        return res.json();
      })
      .then(json => resolveNavData(json))
      .catch(err => {
        console.warn('Failed to fetch nav data, retrying with script fallback:', err);
        return loadNavDataViaScript(prefix)
          .catch(scriptErr => {
            console.warn('Script fallback failed for nav data:', scriptErr);
            NAV_DATA_STATE.data = null;
            return null;
          });
      });
    return NAV_DATA_STATE.promise;
  }

  function canonicalPageKey(pathname) {
    try {
      let path = (pathname || '').split(/[?#]/)[0];
      path = path.replace(/\\/g, '/').replace(/\/+/g, '/');
      const segments = path.split('/').filter(Boolean);
      if (!segments.length) return 'index.html';
      const last = segments[segments.length - 1];
      if (!last || last.toLowerCase() === 'index.html') {
        const prev = segments.length > 1 ? segments[segments.length - 2] : '';
        return prev ? `${prev}/index.html` : 'index.html';
      }
      return last;
    } catch {
      return pathname || 'index.html';
    }
  }

  function pageKey() {
    return canonicalPageKey(window.location.pathname || '');
  }

  function canonicalizeCommentsDB(db) {
    const merged = {};
    const seenMap = {};
    if (!db || typeof db !== 'object') {
      return {};
    }
    Object.keys(db).forEach(oldKey => {
      const canonical = canonicalPageKey(oldKey);
      if (!merged[canonical]) {
        merged[canonical] = [];
        seenMap[canonical] = new Set();
      }
      const list = db[oldKey] || [];
      list.forEach(rec => {
        if (!rec || !rec.id || seenMap[canonical].has(rec.id)) return;
        merged[canonical].push(rec);
        seenMap[canonical].add(rec.id);
      });
    });
    return merged;
  }

  // コメントDB（ページキー毎に配列）
  let COMMENTS_DB = {};
  try {
    COMMENTS_DB = JSON.parse(localStorage.getItem(STORAGE_KEYS.comments) || '{}') || {};
  } catch {
    COMMENTS_DB = {};
  }
  COMMENTS_DB = canonicalizeCommentsDB(COMMENTS_DB);
  try { localStorage.setItem(STORAGE_KEYS.comments, JSON.stringify(COMMENTS_DB)); } catch {}
  function saveComments() {
    try { localStorage.setItem(STORAGE_KEYS.comments, JSON.stringify(COMMENTS_DB)); }
    catch (e) { console.warn('Save comments failed', e); }
  }

let INLINE_FOOTNOTE_MODE = false;
let commentPopoverEl = null;
let commentPopoverMarker = null;
let commentPopoverPersistent = false;
let commentPopoverHideTimer = null;
let cleanupCommentMarkersDom = () => {};
let refreshCommentMarkersFromDB = () => {};
let readingStateSaveTimer = null;

  function resolveAssetPath(relPath) {
    try {
      // Prefer Quarto's offset meta when available so paths work on index.html and content pages
      const offsetMeta = document.querySelector('meta[name="quarto:offset"]');
      if (offsetMeta) {
        let offset = offsetMeta.getAttribute('content') || '';
        if (offset && !offset.endsWith('/')) offset += '/';
        return offset + relPath;
      }

      // Fallback: derive base from simple-theme.css location if present
      const themeLink = document.querySelector('link[rel="stylesheet"][href*="src/css/simple-theme.css"]');
      if (themeLink) {
        const href = themeLink.getAttribute('href') || '';
        const parts = href.split('/');
        const srcIndex = parts.indexOf('src');
        if (srcIndex >= 0) {
          const prefix = parts.slice(0, srcIndex).join('/');
          const base = prefix ? prefix.replace(/\/*$/, '/') : '';
          return base + relPath;
        }
      }
    } catch (e) {
      console.warn('resolveAssetPath failed', e);
    }
    return relPath;
  }

  let readingMeterState = null;
  let scrollExtensionEl = null;
  let pendingScrollExtensionRaf = 0;
  const SCROLL_EXTENSION_BUFFER = 80;
  const FOOTNOTE_INLINE_BREAKPOINT = 1024;
  let currentFootnoteLayout = null;

  function formatReadingNumber(value) {
    if (!Number.isFinite(value)) return '0';
    try {
      return value.toLocaleString('ja-JP');
    } catch (error) {
      console.warn('Failed to format number:', error);
      return String(Math.trunc(value));
    }
  }

  function extractReadableText(root) {
    if (!root) return '';
    const clone = root.cloneNode(true);
    const selectorsToRemove = [
      '.header-ui',
      '.settings-menu',
      '.settings-menu-overlay',
      '.scroll-settings-header',
      '#scroll-settings-header',
      '.toc-overlay',
      '.global-search-overlay',
      '.marker-toolbar'
    ];
    selectorsToRemove.forEach((selector) => {
      clone.querySelectorAll(selector).forEach((node) => node.remove());
    });
    return (clone.textContent || '').replace(/\s+/g, '');
  }

  function ensureScrollExtensionElement() {
    if (scrollExtensionEl && document.body.contains(scrollExtensionEl)) {
      return scrollExtensionEl;
    }
    if (!document.body) return null;
    scrollExtensionEl = document.createElement('div');
    scrollExtensionEl.id = 'scroll-extension-anchor';
    scrollExtensionEl.setAttribute('aria-hidden', 'true');
    scrollExtensionEl.style.cssText = 'width:1px;height:0;margin:0;padding:0;';
    document.body.appendChild(scrollExtensionEl);
    return scrollExtensionEl;
  }

  function updateScrollExtensionNow() {
    const placeholder = ensureScrollExtensionElement();
    if (!placeholder) return;
    placeholder.style.height = '0px';
    const docElement = document.documentElement || document.body;
    const baseHeight = Math.max(
      document.body ? document.body.scrollHeight : 0,
      docElement ? docElement.scrollHeight : 0
    );
    let maxBottom = baseHeight;
    let hasTarget = false;
    const targets = [
      document.getElementById('quarto-document-content'),
      document.getElementById('quarto-sidebar'),
      document.getElementById('quarto-margin-sidebar')
    ];
    targets.forEach(el => {
      if (!el) return;
      const rect = el.getBoundingClientRect();
      if (!rect || !Number.isFinite(rect.bottom)) return;
      const bottom = rect.bottom + window.scrollY;
      if (!Number.isFinite(bottom)) return;
      maxBottom = Math.max(maxBottom, bottom);
      hasTarget = true;
    });
    if (!hasTarget) {
      placeholder.style.height = '0px';
      return;
    }
    const needed = Math.max(0, Math.ceil(maxBottom - baseHeight + SCROLL_EXTENSION_BUFFER));
    placeholder.style.height = needed > 0 ? `${needed}px` : '0px';
  }

  function scheduleScrollExtensionUpdate() {
    if (typeof requestAnimationFrame !== 'function') {
      return updateScrollExtensionNow();
    }
    if (pendingScrollExtensionRaf) {
      cancelAnimationFrame(pendingScrollExtensionRaf);
    }
    pendingScrollExtensionRaf = requestAnimationFrame(() => {
      pendingScrollExtensionRaf = 0;
      updateScrollExtensionNow();
    });
  }

  function initializeReadingMeter(displayEl) {
    if (!displayEl) return;

    const readingRoot = document.querySelector('#quarto-document-content');
    if (!readingRoot) {
      displayEl.textContent = '[0/0]';
      displayEl.setAttribute('aria-label', '読書メーター: 0 / 0');
      return;
    }

    const totalText = extractReadableText(readingRoot);
    const totalChars = totalText.length;
    const formattedTotal = formatReadingNumber(totalChars);

    displayEl.textContent = `[0/${formattedTotal}]`;
    displayEl.setAttribute('data-total-chars', `${totalChars}`);
    displayEl.setAttribute('data-current-chars', '0');
    displayEl.setAttribute('aria-live', 'polite');
    displayEl.setAttribute('aria-label', `読書メーター: 0 / ${formattedTotal}`);

    const state = {
      displayEl,
      readingRoot,
      measureElement: readingRoot,
      totalChars,
      formattedTotal,
      lastCurrent: -1,
      lastOutput: '',
      updateScheduled: false,
      cleanup: null
    };

    const computeRatio = () => {
      if (!state.measureElement) return 0;
      const rect = state.measureElement.getBoundingClientRect();
      const contentTop = window.scrollY + rect.top;
      const contentBottom = contentTop + rect.height;
      if (!Number.isFinite(contentTop) || !Number.isFinite(contentBottom) || contentBottom <= contentTop) {
        return 0;
      }

      const scrollTop = window.scrollY;
      const scrollBottom = scrollTop + window.innerHeight;
      const scrollRange = contentBottom - contentTop - window.innerHeight;
      let ratio;

      if (scrollRange <= 0) {
        if (scrollBottom >= contentBottom) {
          ratio = 1;
        } else if (scrollTop <= contentTop) {
          ratio = 0;
        } else {
          ratio = (scrollTop - contentTop) / Math.max(1, contentBottom - contentTop);
        }
      } else {
        ratio = (scrollTop - contentTop) / scrollRange;
      }

      if (!Number.isFinite(ratio)) {
        return 0;
      }
      return Math.min(1, Math.max(0, ratio));
    };

    const applyUpdate = () => {
      state.updateScheduled = false;
      if (state.totalChars <= 0) {
        const output = '[0/0]';
        if (output !== state.lastOutput) {
          state.lastOutput = output;
          state.displayEl.textContent = output;
          state.displayEl.setAttribute('data-current-chars', '0');
          state.displayEl.setAttribute('aria-label', '読書メーター: 0 / 0');
        }
        return;
      }

      const ratio = computeRatio();
      const currentChars = Math.max(0, Math.min(state.totalChars, Math.round(state.totalChars * ratio)));
      if (currentChars === state.lastCurrent && state.lastOutput) {
        return;
      }

      state.lastCurrent = currentChars;
      const formattedCurrent = formatReadingNumber(currentChars);
      const output = `[${formattedCurrent}/${state.formattedTotal}]`;
      if (output !== state.lastOutput) {
        state.lastOutput = output;
        state.displayEl.textContent = output;
        state.displayEl.setAttribute('data-current-chars', `${currentChars}`);
        state.displayEl.setAttribute('aria-label', `読書メーター: ${formattedCurrent} / ${state.formattedTotal}`);
      }
    };

    const scheduleUpdate = () => {
      if (state.updateScheduled) return;
      state.updateScheduled = true;
      requestAnimationFrame(applyUpdate);
    };

    const onScroll = () => scheduleUpdate();
    const onResize = () => scheduleUpdate();

    if (readingMeterState && typeof readingMeterState.cleanup === 'function') {
      readingMeterState.cleanup();
    }

    window.addEventListener('scroll', onScroll, { passive: true });
    window.addEventListener('resize', onResize);

    state.cleanup = () => {
      window.removeEventListener('scroll', onScroll);
      window.removeEventListener('resize', onResize);
    };

    readingMeterState = state;
    scheduleUpdate();
  }

  function getSavedRightTab() {
    try {
      const saved = localStorage.getItem(STORAGE_KEYS.rightTab);
      if (saved && ['footnotes', 'comments', 'both'].includes(saved)) {
        return saved;
      }
    } catch (e) {
      console.warn('Failed to read right tab state', e);
    }
    return 'both';
  }
  function saveRightTab(tab) {
    if (!['footnotes', 'comments', 'both'].includes(tab)) return;
    try { localStorage.setItem(STORAGE_KEYS.rightTab, tab); }
    catch (e) { console.warn('Failed to save right tab state', e); }
  }

  function setupTopChapterNavigation() {
    if (document.querySelector('nav.page-navigation-top')) return;
    const header = document.querySelector('header.quarto-title-block');
    const bottomNav = document.querySelector('nav.page-navigation');
    if (!header || !bottomNav) return;
    const topNav = bottomNav.cloneNode(true);
    topNav.classList.add('page-navigation-top');
    header.parentNode.insertBefore(topNav, header);
  }

  function getActiveChapterSection() {
    return document.querySelector('section.chapter-page.active') || null;
  }
  function getCurrentChapterSlug() {
    const active = getActiveChapterSection();
    if (!active) return null;
    const id = active.getAttribute('id') || '';
    return id.startsWith('page-') ? id.slice(5) : (id || null);
  }

  function getSectionSlugFromElement(el) {
    if (!el || !(el instanceof HTMLElement)) return null;
    const sec = el.closest('section.chapter-page');
    if (!sec || !sec.id) return null;
    const id = sec.id;
    return id.startsWith('page-') ? id.slice(5) : id;
  }

  function findCommentAnchorElement(rec) {
    if (!rec || !Array.isArray(rec.ranges)) return null;
    for (const range of rec.ranges) {
      const node = getNodeByPathSafe(range?.s);
      if (!node) continue;
      let el = node.nodeType === Node.ELEMENT_NODE ? node : node.parentElement;
      while (el && !(el instanceof HTMLElement)) el = el.parentElement;
      if (el) return el;
    }
    return null;
  }

  function detectCommentSlug(rec) {
    const el = findCommentAnchorElement(rec);
    return el ? getSectionSlugFromElement(el) : null;
  }

  function isCommentInSection(rec, section) {
    if (!section) return true;
    const el = findCommentAnchorElement(rec);
    return !!(el && section.contains(el));
  }

  function getActiveComments() {
    const list = (COMMENTS_DB[pageKey()] || []);
    // 章タブやセクションに関わらず、このページ上のコメントをすべて返す
    return list.filter(rec => !!rec);
  }

  function gatherActiveCommentsWithElements() {
    return getActiveComments()
      .map(rec => {
        const el = findCommentAnchorElement(rec);
        return el ? { rec, el } : null;
      })
      .filter(Boolean);
  }

  function gatherActiveFootnotes() {
    const active = getActiveChapterSection();
    const refSelector = 'a[role="doc-noteref"], a.footnote-ref';
    const refMap = new Map();
    const scope = active || document;
    Array.from(scope.querySelectorAll(refSelector)).forEach(ref => {
      if (active && !active.contains(ref)) return;
      const href = ref.getAttribute('href') || ref.getAttribute('data-footnote-href');
      if (!href || !href.startsWith('#')) return;
      const id = href.slice(1);
      const top = ref.getBoundingClientRect().top + window.scrollY;
      const label = (() => {
        const sup = ref.querySelector('sup');
        const raw = (sup ? sup.textContent : ref.textContent) || '';
        return raw.replace(/\s+/g, ' ').trim();
      })();
      const existing = refMap.get(id);
      if (!existing || top < existing.pos) {
        refMap.set(id, { id, ref, pos: top, number: label });
      }
    });
    const items = [];
    refMap.forEach(entry => {
      let def = document.getElementById(entry.id);
      if (!def) return;
      if (!(def instanceof HTMLElement)) def = def.parentElement;
      if (!def) return;
      let li = def;
      if (li.tagName && li.tagName.toLowerCase() !== 'li') {
        const nearestLi = li.closest('li');
        if (nearestLi) li = nearestLi;
      }
      if (!(li instanceof HTMLElement)) return;
      if (active) {
        const parentSection = li.closest('section.chapter-page');
        if (parentSection && parentSection !== active) return;
      }
      const fallbackLabel = entry.number || entry.id.replace(/[^0-9]+/g, '').trim();
      items.push({ id: entry.id, li, ref: entry.ref, pos: entry.pos, number: fallbackLabel });
    });
    return items;
  }

  async function initUI() {
    let navData = null;
    try {
      navData = await loadNavData();
    } catch (e) {
      console.warn('Nav data load failed:', e);
    }

    const safeInvoke = async (label, action) => {
      try {
        const result = action();
        if (result && typeof result.then === 'function') {
          await result;
        }
      } catch (err) {
        console.error(`UI init step failed (${label}):`, err);
      }
    };

    const steps = [
      ['header-controls', () => setupHeaderControls()],
      ['left-sidebar-tabs', () => setupLeftPanelTabs(navData)],
      ['site-title-enhancements', () => applySiteTitleEnhancements(navData)],
      ['mobile-nav-drawer', () => setupMobileNavDrawer(navData)],
      ['left-sidebar-stability', () => setupLeftSidebarStability()],
      ['right-sidebar', () => setupRightSidebar()],
      ['top-nav', () => setupTopChapterNavigation()],
      ['markers', () => setupMarkerFunctionality()],
      ['mobile-footnotes', () => setupMobileFootnoteToggle()],
      ['disable-default-search', () => disableDefaultQuartoSearch()],
      ['sidebar-search', () => setupSidebarSearch()],
      ['global-search', () => setupGlobalSearch()],
      ['shortcuts', () => setupKeyboardShortcuts()],
      ['scroll-position', () => setupScrollPosition()],
      ['body-links', () => reinforceAnchors(document.getElementById('quarto-document-content'))],
      ['index-links', () => updateIndexLinksForContext()],
      ['custom-toc', () => setTimeout(() => CustomTOC.initializeCustomTOC(navData), 100)],
    ];

    for (const [label, action] of steps) {
      await safeInvoke(label, action);
    }

    console.log('UI initialized');
    window.addEventListener('resize', () => scheduleScrollExtensionUpdate(), { passive: true });
    window.addEventListener('orientationchange', () => scheduleScrollExtensionUpdate());
    window.addEventListener('load', () => scheduleScrollExtensionUpdate(), { once: true });
    scheduleScrollExtensionUpdate();
    setTimeout(() => {
      refreshRightPanels();
      restoreReadingState();
    }, 120);
  }
  const queueInit = () => window.setTimeout(initUI, 0);
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', queueInit, { once: true });
  } else {
    queueInit();
  }

  function setupHeaderControls() {
    const settingsToggleBtn = document.getElementById('settings-toggle-btn');
    const settingsMenu = document.getElementById('settings-menu');
    const settingsMenuClose = document.getElementById('settings-menu-close');
    const settingsMenuOverlay = document.getElementById('settings-menu-overlay');
    const themeSelect = document.getElementById('theme-select');
    const fontSizeSelect = document.getElementById('font-size-select');
    const commentsExportPage = document.getElementById('comments-export-page');
    const commentsExportAll = document.getElementById('comments-export-all');
    const commentsImport = document.getElementById('comments-import');
    const commentsImportButton = document.getElementById('comments-import-button');
    const toastMaxRange = document.getElementById('gdoc-toast-max');
    const toastMaxValue = document.getElementById('gdoc-toast-max-value');
    const resetUiBtn = document.getElementById('reset-ui-settings');
    const resetMemoBtn = document.getElementById('reset-memo-settings');
    const resetPreviewBtn = document.getElementById('reset-preview-settings');
    const resetAllBtn = document.getElementById('reset-all-settings');

    // ハンバーガーメニューは廃止

    // 一般の画像についても data-asset 属性があれば resolveAssetPath で解決する
    try {
      const assetImgs = document.querySelectorAll('img[data-asset]');
      assetImgs.forEach(img => {
        const rel = img.getAttribute('data-asset');
        if (!rel) return;
        const resolved = resolveAssetPath(rel);
        if (resolved && img.src !== resolved) {
          img.src = resolved;
        }
      });
    } catch (e) {
      console.warn('resolveAssetPath for img[data-asset] failed', e);
    }

    if (settingsToggleBtn && settingsMenu && settingsMenuOverlay) {
      const openSettingsMenu = () => {
        settingsMenu.classList.add('open');
        settingsMenuOverlay.classList.add('open');
      };

      const closeSettingsMenu = () => {
        settingsMenu.classList.remove('open');
        settingsMenuOverlay.classList.remove('open');
      };

      settingsToggleBtn.addEventListener('click', openSettingsMenu);
      settingsMenuClose.addEventListener('click', closeSettingsMenu);
      settingsMenuOverlay.addEventListener('click', closeSettingsMenu);

      // ESCキーでメニューを閉じる
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && settingsMenu.classList.contains('open')) {
          closeSettingsMenu();
        }
      });
    }

    // テーマ切替機能
    if (themeSelect) {
      const mq = window.matchMedia('(prefers-color-scheme: dark)');
      function applyTheme(mode) {
        const target = mode === 'auto' ? (mq.matches ? 'dark' : 'light') : mode;
        document.body.setAttribute('data-theme', target);
        document.documentElement.setAttribute('data-theme', target);
      }
      const saved = localStorage.getItem(STORAGE_KEYS.theme) || 'auto';
      themeSelect.value = saved;
      applyTheme(saved);
      mq.addEventListener('change', () => { if ((localStorage.getItem(STORAGE_KEYS.theme) || 'auto') === 'auto') applyTheme('auto'); });
      themeSelect.addEventListener('change', (e) => {
        const theme = e.target.value;
        localStorage.setItem(STORAGE_KEYS.theme, theme);
        applyTheme(theme);
      });
    }

    // 文字サイズ変更機能
    if (fontSizeSelect) {
      const currentSize = localStorage.getItem(STORAGE_KEYS.fontSize) || 'M';
      fontSizeSelect.value = currentSize;
      document.body.setAttribute('data-font-size', currentSize);
      fontSizeSelect.addEventListener('change', (e) => {
        const size = e.target.value;
        document.body.setAttribute('data-font-size', size);
        localStorage.setItem(STORAGE_KEYS.fontSize, size);
      });
    }

    // コメント出力機能
    if (commentsExportPage) {
      commentsExportPage.addEventListener('click', () => exportComments(true));
    }
    if (commentsExportAll) {
      commentsExportAll.addEventListener('click', () => exportComments(false));
    }

    // コメントインポート機能
    if (commentsImport && commentsImportButton) {
      commentsImport.addEventListener('change', (e) => importCommentsFromFile(e.target.files[0]));
      commentsImportButton.addEventListener('click', () => commentsImport.click());
    }

    // リセットボタン群
    if (resetUiBtn) {
      resetUiBtn.addEventListener('click', () => {
        const ok = window.confirm('UI系の設定（テーマ・文字サイズ・右パネルタブ・ソート設定など）をリセットしますか？');
        if (!ok) return;
        resetUiSettings();
        // 即時反映のため、ページを再読み込み
        window.location.reload();
      });
    }

    if (resetMemoBtn) {
      resetMemoBtn.addEventListener('click', () => {
        const ok = window.confirm('メモ系（マーカー・コメント）の保存データをすべてリセットしますか？\\n※元に戻すことはできません。');
        if (!ok) return;
        resetMemoSettings();
        window.location.reload();
      });
    }

    if (resetPreviewBtn) {
      resetPreviewBtn.addEventListener('click', () => {
        const ok = window.confirm('プレビュー関連の設定（Docs/BGプレビューの状態・トースト表示数）をリセットしますか？');
        if (!ok) return;
        resetPreviewSettings();
        window.location.reload();
      });
    }

    if (resetAllBtn) {
      resetAllBtn.addEventListener('click', () => {
        const ok = window.confirm('すべての設定と保存データを完全にリセットします。\\nlocalStorage / sessionStorage を初期化しますが、本当に実行しますか？');
        if (!ok) return;
        resetAllSettingsHard();
        window.location.reload();
      });
    }

    // プレビューのトースト表示数スライダー
    if (toastMaxRange && toastMaxValue) {
      let stored = 3;
      try {
        const raw = localStorage.getItem('gdocPreviewMaxToasts');
        if (raw != null) {
          const n = parseInt(raw, 10);
          if (!isNaN(n)) stored = Math.min(9, Math.max(0, n));
        }
      } catch (e) {
        // ignore
      }
      toastMaxRange.value = String(stored);
      toastMaxValue.textContent = String(stored);

      toastMaxRange.addEventListener('input', () => {
        toastMaxValue.textContent = String(toastMaxRange.value);
      });
      toastMaxRange.addEventListener('change', () => {
        const n = parseInt(toastMaxRange.value, 10) || 0;
        try {
          localStorage.setItem('gdocPreviewMaxToasts', String(Math.min(9, Math.max(0, n))));
        } catch (e) {}
        if (window.__gdocPreviewAPI__ && typeof window.__gdocPreviewAPI__.refreshToasts === 'function') {
          window.__gdocPreviewAPI__.refreshToasts();
        }
      });
    }

    ensureHeaderListButtons();
    document.addEventListener('quarto-hrChanged', ensureHeaderListButtons);
    window.addEventListener('resize', ensureHeaderListButtons);
  }

  function ensureHeaderListButtons() {
    try {
      const searchButtons = document.querySelectorAll('.quarto-search-button');
      if (!searchButtons.length) return;
      searchButtons.forEach(searchButton => {
        const parent = searchButton.parentElement;
        if (!parent) return;
        if (parent.querySelector('.quarto-list-button')) return;
        const listBtn = document.createElement('button');
        listBtn.type = 'button';
        listBtn.className = 'btn quarto-list-button';
        listBtn.setAttribute('aria-label', 'プレビュー・コメント・マーカー一覧を開く');
        const icon = document.createElement('img');
        icon.alt = '';
        icon.decoding = 'async';
        icon.loading = 'lazy';
        icon.setAttribute('aria-hidden', 'true');
        icon.src = resolveAssetPath('assets/list.png');
        listBtn.appendChild(icon);
        listBtn.addEventListener('click', (event) => {
          event.preventDefault();
          openGlobalListOverlay();
        });
        parent.insertBefore(listBtn, searchButton);
      });
    } catch (e) {
      console.warn('inject list button failed', e);
    }
  }

  function renderNavDrawerContent(container, navData) {
    if (!container) return;
    container.innerHTML = '';
    const switcher = document.createElement('div');
    switcher.className = 'toc-switcher nav-drawer-switcher';
    switcher.innerHTML = `
      <div class="toc-tabs">
        <button type="button" class="toc-tab active" data-tab="site">各章</button>
        <button type="button" class="toc-tab" data-tab="page">章内</button>
        <button type="button" class="toc-tab" data-tab="all">全体</button>
      </div>
      <div class="toc-panel toc-site-content"></div>
      <div class="toc-panel toc-page-content hidden"></div>
      <div class="toc-panel toc-all-content hidden"></div>
    `;
    container.appendChild(switcher);
    const sitePanel = switcher.querySelector('.toc-site-content');
    const pagePanel = switcher.querySelector('.toc-page-content');
    const allPanel = switcher.querySelector('.toc-all-content');
    if (sitePanel) CustomTOC.renderChapterTab(sitePanel, navData);
    if (pagePanel) CustomTOC.renderPageTab(pagePanel, navData, 4);
    if (allPanel) CustomTOC.renderAllTab(allPanel, navData);
    const tabButtons = switcher.querySelectorAll('.toc-tab');
    tabButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        const target = btn.dataset.tab;
        tabButtons.forEach(other => other.classList.remove('active'));
        btn.classList.add('active');
        switcher.querySelectorAll('.toc-panel').forEach(panel => {
          panel.classList.add('hidden');
        });
        const panel = switcher.querySelector(`.toc-${target}-content`);
        if (panel) panel.classList.remove('hidden');
      });
    });
  }

  function setupMobileNavDrawer(navData) {
    const overlay = document.querySelector('.toc-overlay');
    if (!overlay) return;
    const closeBtn = overlay.querySelector('.toc-sheet__close');
    const backdrop = overlay.querySelector('.toc-overlay__backdrop');
    const content = overlay.querySelector('.toc-sheet__content');
    const toggleButtons = document.querySelectorAll('.quarto-btn-toggle, [data-bs-target=".quarto-sidebar-collapse-item"]');
    const buttons = Array.from(new Set(Array.from(toggleButtons)));
    if (!buttons.length) return;

    const closeDrawer = () => {
      document.body.classList.remove('toc-open');
    };

    const openDrawer = () => {
      renderNavDrawerContent(content, navData);
      document.body.classList.add('toc-open');
    };

    const toggleDrawer = () => {
      if (document.body.classList.contains('toc-open')) {
        closeDrawer();
      } else {
        openDrawer();
      }
    };

    const interceptToggle = (event) => {
      if (window.innerWidth > 1024) {
        closeDrawer();
        return;
      }
      event.preventDefault();
      event.stopPropagation();
      if (typeof event.stopImmediatePropagation === 'function') {
        event.stopImmediatePropagation();
      }
      toggleDrawer();
    };

    buttons.forEach(btn => {
      btn.addEventListener('click', interceptToggle, true);
    });

    if (closeBtn) closeBtn.addEventListener('click', closeDrawer);
    if (backdrop) backdrop.addEventListener('click', closeDrawer);
    overlay.addEventListener('click', (event) => {
      if (event.target.classList.contains('toc-overlay')) {
        closeDrawer();
      }
    });
    if (content) {
      content.addEventListener('click', (event) => {
        const anchor = event.target.closest('a');
        if (anchor) closeDrawer();
      });
    }
    document.addEventListener('keydown', (event) => {
      if (event.key === 'Escape' && document.body.classList.contains('toc-open')) {
        closeDrawer();
      }
    });
    window.addEventListener('resize', () => {
      if (window.innerWidth > 1024) closeDrawer();
    });
  }

  function setupLeftPanelTabs(navData) {
    const sidebar = document.getElementById('quarto-sidebar');
    if (!sidebar) return;
    const menuContainer = sidebar.querySelector('.sidebar-menu-container');
    if (!menuContainer) return;

    const tabWrapper = document.createElement('div');
    tabWrapper.className = 'toc-switcher';
    tabWrapper.innerHTML = `
      <div class="toc-tabs">
        <button type="button" class="toc-tab active" data-tab="site">各章</button>
        <button type="button" class="toc-tab" data-tab="page">章内</button>
        <button type="button" class="toc-tab" data-tab="all">全体</button>
      </div>
      <div class="toc-panel toc-site-content"></div>
      <div class="toc-panel toc-page-content hidden"></div>
      <div class="toc-panel toc-all-content hidden"></div>
    `;

    const parent = menuContainer.parentNode;
    parent.replaceChild(tabWrapper, menuContainer);

    const sitePanel = tabWrapper.querySelector('.toc-site-content');
    const pagePanel = tabWrapper.querySelector('.toc-page-content');
    const allPanel = tabWrapper.querySelector('.toc-all-content');

    sitePanel.innerHTML = '';
    pagePanel.innerHTML = '';
    allPanel.innerHTML = '';

    menuContainer.innerHTML = '';
    sitePanel.appendChild(menuContainer);

    const allContainer = document.createElement('div');
    allContainer.className = 'toc-all-container';
    allPanel.appendChild(allContainer);

    if (!navData || !Array.isArray(navData.pages) || !navData.pages.length) {
      menuContainer.innerHTML = '<p class="toc-empty">目次データを読み込めませんでした。</p>';
      allContainer.innerHTML = '<p class="toc-empty">目次データを読み込めませんでした。</p>';
      pagePanel.innerHTML = '<p class="toc-empty">目次データを読み込めませんでした。</p>';
    } else {
      CustomTOC.renderChapterTab(menuContainer, navData);
      CustomTOC.renderAllTab(allContainer, navData);
      CustomTOC.renderPageTab(pagePanel, navData, 4);
    }

    const tabButtons = tabWrapper.querySelectorAll('.toc-tab');
    const panels = { site: sitePanel, page: pagePanel, all: allPanel };
    tabButtons.forEach(button => {
      button.addEventListener('click', () => {
        const target = button.dataset.tab;
        tabButtons.forEach(btn => btn.classList.remove('active'));
        button.classList.add('active');
        Object.values(panels).forEach(p => p.classList.add('hidden'));
        if (panels[target]) {
          panels[target].classList.remove('hidden');
          if (target === 'page' && navData) {
            CustomTOC.renderPageTab(pagePanel, navData, 4);
          }
        }
      });
    });
    scheduleScrollExtensionUpdate();
  }

  function setupLeftSidebarStability() {
    const sidebar = document.getElementById('quarto-sidebar');
    const toggles = document.querySelectorAll('[data-bs-target=".quarto-sidebar-collapse-item"]');
    if (!sidebar || !toggles.length) return;
    let pendingState = null;
    let pendingExpiry = 0;
    let restoreHandle = null;

    const applyPendingState = () => {
      if (!pendingState) return;
      scrollToReadingState(pendingState);
      if (Date.now() > pendingExpiry) {
        pendingState = null;
      }
    };

    const scheduleRestore = () => {
      if (!pendingState) return;
      if (restoreHandle) {
        cancelAnimationFrame(restoreHandle);
        restoreHandle = null;
      }
      restoreHandle = requestAnimationFrame(() => {
        restoreHandle = requestAnimationFrame(() => {
          applyPendingState();
        });
      });
    };

    const captureStateBeforeToggle = () => {
      const snapshot = captureReadingState({ captureNodeRef: true });
      if (!snapshot) return;
      pendingState = snapshot;
      pendingExpiry = Date.now() + 1200;
      scheduleRestore();
    };

    toggles.forEach(btn => {
      btn.addEventListener('click', captureStateBeforeToggle, true);
      btn.addEventListener('keydown', (event) => {
        if (event.key === 'Enter' || event.key === ' ') {
          captureStateBeforeToggle();
        }
      }, true);
    });

    sidebar.addEventListener('transitionstart', () => {
      if (!pendingState) {
        captureStateBeforeToggle();
      }
    });

    sidebar.addEventListener('animationstart', () => {
      if (!pendingState) {
        captureStateBeforeToggle();
      }
    });

    sidebar.addEventListener('transitionend', (event) => {
      if (!pendingState) return;
      if (event && event.propertyName && !/width|flex|margin|padding/i.test(event.propertyName)) return;
      scheduleRestore();
    });

    const sidebarMutationObserver = new MutationObserver(() => {
      if (pendingState) scheduleRestore();
    });
    sidebarMutationObserver.observe(sidebar, { attributes: true, attributeFilter: ['class', 'style'] });

    window.addEventListener('resize', () => {
      if (pendingState) {
        scheduleRestore();
      }
    });
  }

  function applySiteTitleEnhancements(navData) {
    enhanceSidebarSiteTitle();
    updateMainHeaderTitle(navData);
  }

  function enhanceSidebarSiteTitle() {
    try {
      const link = document.querySelector('#quarto-sidebar .sidebar-title a');
      if (!link || link.dataset.siteTitleEnhanced === 'true') return;
      const mainText = (link.textContent || '').trim() || '平和への課題：補遺';
      const safeMain = escapeHtml(mainText);
      const subtitle = 'Background Guide';
      link.innerHTML = `<span class="site-title-main">${safeMain}</span><span class="site-title-sub">${subtitle}</span>`;
      link.dataset.siteTitleEnhanced = 'true';
    } catch (e) {
      console.warn('enhanceSidebarSiteTitle failed', e);
    }
  }

  function updateMainHeaderTitle(navData) {
    const header = document.querySelector('header.quarto-title-block');
    if (!header) return;
    const titleEl = header.querySelector('.quarto-title .title');
    if (!titleEl) return;
    const existingSpan = titleEl.querySelector('.chapter-title') || titleEl.firstElementChild;
    const current = computeCurrentOutputPath();
    let pageTitle = '';
    try {
      if (navData && Array.isArray(navData.pages)) {
        const entry = navData.pages.find(page => {
          if (!page) return false;
          const paths = [page.output, page.url, page.source];
          return paths.some(p => isSamePage(p, current));
        });
        if (entry && entry.title) {
          pageTitle = entry.title;
        }
      }
    } catch (e) {
      console.warn('updateMainHeaderTitle nav data lookup failed', e);
    }
    if (!pageTitle && existingSpan) {
      pageTitle = (existingSpan.textContent || '').trim();
    }
    if (!pageTitle) {
      const contentHeading = document.querySelector('main h1, main h2');
      if (contentHeading) {
        pageTitle = (contentHeading.textContent || '').trim();
      }
    }
    if (!pageTitle) {
      header.style.display = 'none';
      return;
    }
    header.style.display = 'none';
  }

  function setupRightSidebar() {
    ensureRightTabs();
    refreshRightPanels();
    const onResize = debounce(() => {
      ensureRightTabs();
      refreshRightPanels();
    }, 200);
    window.addEventListener('resize', onResize);
    window.addEventListener('orientationchange', onResize);
    window.addEventListener('hashchange', () => { setTimeout(refreshRightPanels, 60); });
  }

  function refreshRightPanels() {
    applyFootnoteLayout();
    renderCommentsPanel();
    if (SIDENOTES_ON) {
      renderSidenotes(currentRightTab());
    }
    enumerateReadingNodes();
    scheduleReadingStateSave();
    scheduleScrollExtensionUpdate();
  }

  function ensureRightTabs() {
    const marginSidebar = document.getElementById('quarto-margin-sidebar');
    if (!marginSidebar) return;
    let wrapper = marginSidebar.querySelector('.right-switcher');
    if (!wrapper) {
      wrapper = document.createElement('div');
      wrapper.className = 'right-switcher';
      wrapper.innerHTML = `
        <div class="toc-tabs">
          <button type="button" class="toc-tab" data-tab="footnotes">脚注</button>
          <button type="button" class="toc-tab" data-tab="comments">ｺﾒﾝﾄ</button>
          <button type="button" class="toc-tab" data-tab="both">両方</button>
        </div>
        <div class="toc-panel right-footnotes"></div>
        <div class="toc-panel right-comments" style="display:none"></div>
        <div class="toc-panel right-both" style="display:none"></div>
      `;
      marginSidebar.innerHTML = '';
      marginSidebar.appendChild(wrapper);

      const tabs = wrapper.querySelectorAll('.toc-tab');
      tabs.forEach(btn => {
        btn.addEventListener('click', () => {
          activateRightTab(btn.dataset.tab || 'footnotes');
        });
      });
      const savedTab = getSavedRightTab();
      activateRightTab(savedTab, { skipSave: true });
      // 傍注表示は常に ON とする
      setSidenotesMode(true);
    } else {
      activateRightTab(getSavedRightTab(), { skipSave: true });
      // 既存 DOM 再利用時も傍注モードを維持
      if (!SIDENOTES_ON) setSidenotesMode(true);
    }
  }

  let SIDENOTES_ON = false;
  let SIDENOTES_ITEMS = [];

  function activateRightTab(tab, opts = {}) {
    const marginSidebar = document.getElementById('quarto-margin-sidebar');
    if (!marginSidebar) return;
    const wrapper = marginSidebar.querySelector('.right-switcher');
    if (!wrapper) return;
    const tabs = Array.from(wrapper.querySelectorAll('.toc-tab'));
    const normalized = ['footnotes', 'comments', 'both'].includes(tab) ? tab : 'both';
    tabs.forEach(btn => btn.classList.toggle('active', btn.dataset.tab === normalized));
    const footPanel = wrapper.querySelector('.right-footnotes');
    const commPanel = wrapper.querySelector('.right-comments');
    const bothPanel = wrapper.querySelector('.right-both');
    if (SIDENOTES_ON) {
      if (footPanel) footPanel.style.display = 'none';
      if (commPanel) commPanel.style.display = 'none';
      if (bothPanel) bothPanel.style.display = 'none';
      renderSidenotes(normalized);
    } else {
      if (footPanel) footPanel.style.display = normalized === 'footnotes' ? '' : 'none';
      if (commPanel) commPanel.style.display = normalized === 'comments' ? '' : 'none';
      if (bothPanel) bothPanel.style.display = normalized === 'both' ? '' : 'none';
    }
    if (!opts.skipSave) saveRightTab(normalized);
  }

  function currentRightTab() {
    const active = document.querySelector('#quarto-margin-sidebar .toc-tab.active');
    if (active) return active.getAttribute('data-tab') || 'footnotes';
    return getSavedRightTab();
  }

  function setSidenotesMode(on) {
    const ms = document.getElementById('quarto-margin-sidebar');
    if (!ms) return;
    const foot = ms.querySelector('.right-footnotes');
    const comm = ms.querySelector('.right-comments');
    const both = ms.querySelector('.right-both');
    SIDENOTES_ON = !!on;
    if (SIDENOTES_ON) {
      ms.classList.add('sidenotes-on');
      if (foot) foot.style.display = 'none';
      if (comm) comm.style.display = 'none';
      if (both) both.style.display = 'none';
      renderSidenotes(currentRightTab());
      window.addEventListener('scroll', updateSidenotesPositions, { passive: true });
      window.addEventListener('resize', updateSidenotesPositions);
    } else {
      ms.classList.remove('sidenotes-on');
      clearSidenotes();
      window.removeEventListener('scroll', updateSidenotesPositions);
      window.removeEventListener('resize', updateSidenotesPositions);
      activateRightTab(currentRightTab(), { skipSave: true });
    }
  }

  function clearSidenotes() {
    const ms = document.getElementById('quarto-margin-sidebar');
    ms.querySelectorAll('.margin-note').forEach(n => n.remove());
    SIDENOTES_ITEMS = [];
  }

  function renderSidenotes(mode) {
    clearSidenotes();
    const ms = document.getElementById('quarto-margin-sidebar');
    if (!ms) return;
    const makeNote = (opts) => {
      const note = document.createElement('div');
      note.className = 'margin-note' + (opts.kind==='comment' ? ' comment' : '');
      note.innerHTML = `
        <div class=\"meta\"><span>${opts.time||''}</span>${opts.moveHtml||''}${opts.showMenu ? '<button class="menu" title="メニュー" style="margin-left:auto;background:none;border:none;cursor:pointer;font-size:16px;line-height:1;">⋯</button>' : ''}</div>
        ${opts.targetHtml||''}
        <div class=\"body\">${opts.bodyHtml||''}</div>
      `;
      ms.appendChild(note);
      return note;
    };

    const footnotes = gatherActiveFootnotes();
    const comments = gatherActiveCommentsWithElements();

    const entries = [];
    if (mode !== 'comments') {
      footnotes.forEach(fn => {
        if (!fn.ref) return;
        entries.push({ kind: 'foot', el: fn.ref, def: fn.li, label: fn.number });
      });
    }
    if (mode !== 'footnotes') {
      comments.forEach(item => {
        if (!item.el) return;
        entries.push({ kind: 'comment', el: item.el, rec: item.rec });
      });
    }

    SIDENOTES_ITEMS = entries.map(entry => {
      if (entry.kind === 'comment') {
        const rec = entry.rec;
        const note = makeNote({
          kind: 'comment',
          time: fmtMMDDHHmm(rec.t),
          moveHtml: `<a href="#" class="mv">移動</a>`,
          targetHtml: `<div class="target">${escapeHtml((rec.text||'').slice(0,80))}</div>`,
          bodyHtml: escapeHtml(rec.body||''),
          showMenu: true
        });
        note.querySelector('.mv')?.addEventListener('click', (e)=>{ e.preventDefault(); scrollToComment(rec); });
        note.querySelector('.menu')?.addEventListener('click', (e)=>{ e.stopPropagation(); openCommentMenu(note, rec, { x: e.clientX, y: e.clientY }); });
        return { kind: 'comment', el: entry.el, node: note };
      } else {
        // 脚注の傍注では、元の脚注HTMLを元にクローンを作り、
        // 先頭に [番号] スパンを 1 個だけ挿入して同一行に表示する
        let bodyHtml = '';
        if (entry.def) {
          const clone = entry.def.cloneNode(true);
          clone.querySelectorAll('.footnote-back, .footnote-backref, [role="doc-backlink"]').forEach(a => a.remove());
          const hasNum = clone.querySelector('.footnote-num');
          if (!hasNum) {
            const numSpan = document.createElement('span');
            numSpan.className = 'footnote-num';
            const labelText = (entry.label && String(entry.label).trim().length)
              ? String(entry.label).trim()
              : '';
            numSpan.textContent = labelText ? (labelText + '. ') : '';
            clone.insertBefore(numSpan, clone.firstChild);
          }
          bodyHtml = clone.innerHTML;
        }
        const note = makeNote({
          kind: 'foot',
          bodyHtml: bodyHtml,
          moveHtml: '',
          showMenu: false
        });
        note.querySelector('.menu')?.remove();
        return { kind: 'foot', el: entry.el, node: note };
      }
    });

    updateSidenotesPositions();
    reinforceAnchors(ms);
  }

  function rightSidebarBaseOffset() {
    const ms = document.getElementById('quarto-margin-sidebar');
    if (!ms) return 0;
    const switcher = ms.querySelector('.right-switcher');
    return switcher ? switcher.offsetHeight + 12 : 0;
  }

  function updateSidenotesPositions() {
    if (!SIDENOTES_ON) return;
    const ms = document.getElementById('quarto-margin-sidebar');
    if (!ms) return;
    const msRect = ms.getBoundingClientRect();
    const viewH = window.innerHeight || document.documentElement.clientHeight || 0;
    const msHeight = ms.clientHeight || (viewH || 0);
    if (!msHeight) return;
    const buffer = viewH || msHeight; // 1画面分のバッファ
    const baseOffset = rightSidebarBaseOffset();

    // アンカー位置に応じて傍注の理想位置を決める
    const entries = SIDENOTES_ITEMS
      .filter(item => item.el && item.node && item.el.getClientRects().length)
      .map(item => {
        const rect = item.el.getBoundingClientRect();
        const node = item.node;
        const nodeHeight = node.offsetHeight || 0;
        // アンカーの上端を右パネル座標系に合わせる
        const anchorTopInSidebar = rect.top - msRect.top;
        // 傍注はタブ行の直下から並ぶので baseOffset を足す
        const desiredTop = anchorTopInSidebar + baseOffset;
        return { item, desiredTop, nodeHeight };
      })
      .sort((a, b) => a.desiredTop - b.desiredTop);

    // ノート同士が重ならないように、手前のノートの下に最小限だけずらして配置する。
    // アンカーが画面外に出ていっても entries からは除外しないことで、
    // 上のノートが非表示になった瞬間に下のノートが大きくジャンプすることを防ぐ。
    const gap = 4;
    let cursor = -Infinity;
    entries.forEach(({ item, desiredTop, nodeHeight }) => {
      const node = item.node;
      if (!node) return;
      const height = nodeHeight || node.offsetHeight || 0;
      // 直前のノートの直下までは押し下げるが、それ以上はアンカーに追随
      const top = Math.max(desiredTop, cursor);
      const bottom = top + height;
      // 1画面分のバッファを考慮し、完全に表示範囲から外れたときだけ非表示にする
      const visible = bottom > (baseOffset - buffer) && top < (msHeight + buffer);
      if (!visible) {
        node.style.display = 'none';
        return;
      }
      node.style.display = 'block';
      node.style.top = top + 'px';
      cursor = top + height + gap;
    });
  }

  function applyFootnoteLayout() {
    const inlineQuery = window.matchMedia(`(max-width: ${FOOTNOTE_INLINE_BREAKPOINT}px)`);
    const shouldInline = inlineQuery.matches || window.innerWidth <= FOOTNOTE_INLINE_BREAKPOINT;
    const nextMode = shouldInline ? 'inline' : 'sidebar';
    if (currentFootnoteLayout !== nextMode) {
      currentFootnoteLayout = nextMode;
      document.body && document.body.classList.toggle('footnotes-inline-mode', shouldInline);
      document.body && document.body.classList.toggle('footnotes-sidebar-mode', !shouldInline);
    }
    const rendered = shouldInline ? !!renderInlineFootnotes() : !!renderSidebarFootnotes();
    try {
      if (document.body) {
        document.body.classList.toggle('js-footnotes-enhanced', rendered);
      }
    } catch (e) {
      console.warn('applyFootnoteLayout: failed to mark enhanced footnotes state', e);
    }
  }

  function renderSidebarFootnotes() {
    setInlineFootnoteMode(false);
    document.querySelectorAll('.footnote-inline').forEach(n => n.remove());
    let marginSidebar = document.getElementById('quarto-margin-sidebar');
    if (!marginSidebar) return false;

    if (marginSidebar.style.display === 'none') {
      const prev = marginSidebar.dataset.prevDisplay || '';
      marginSidebar.style.display = prev;
      delete marginSidebar.dataset.prevDisplay;
    }

    if (!marginSidebar.querySelector('.right-switcher')) {
      ensureRightTabs();
      marginSidebar = document.getElementById('quarto-margin-sidebar');
    }

    let footHost = marginSidebar.querySelector('.right-footnotes');
    if (!footHost) {
      footHost = document.createElement('div');
      footHost.className = 'toc-panel right-footnotes';
      marginSidebar.appendChild(footHost);
    }

    let bothHost = marginSidebar.querySelector('.right-both');
    if (!bothHost) {
      bothHost = document.createElement('div');
      bothHost.className = 'toc-panel right-both';
      bothHost.style.display = 'none';
      marginSidebar.appendChild(bothHost);
    }

    footHost.innerHTML = '';
    if (bothHost) bothHost.innerHTML = '';

    const headerRow = document.createElement('div');
    headerRow.style.cssText = 'display:flex;align-items:center;justify-content:space-between;margin-bottom:6px;';
    const header = document.createElement('h2');
    header.className = 'footnotes-title';
    header.textContent = '脚注';
    const sort = document.createElement('select');
    sort.innerHTML = '<option value="pos">本文位置順</option><option value="num">番号順</option>';
    sort.value = localStorage.getItem('footnotes-sort') || 'pos';
    sort.addEventListener('change', () => { localStorage.setItem('footnotes-sort', sort.value); renderSidebarFootnotes(); });
    headerRow.appendChild(header); headerRow.appendChild(sort);
    footHost.appendChild(headerRow);

    const footnotes = gatherActiveFootnotes();
    if (!footnotes.length) {
      footHost.insertAdjacentHTML('beforeend','<p class="footnotes-empty">このページには脚注がありません。</p>');
      if (bothHost) bothHost.insertAdjacentHTML('beforeend','<p class="footnotes-empty">このページには脚注/コメントがありません。</p>');
      return false;
    }

    const items = footnotes.slice();
    const mode = sort.value;
    const getSortableNumber = (item) => {
      const primary = Number(item.number);
      if (!Number.isNaN(primary)) return primary;
      const fallbackFromId = Number(String(item.id || '').replace(/[^0-9]+/g, ''));
      if (!Number.isNaN(fallbackFromId)) return fallbackFromId;
      return Number.POSITIVE_INFINITY;
    };
    if (mode === 'pos') {
      items.sort((a,b)=>a.pos-b.pos);
    } else {
      items.sort((a,b)=> {
        const numA = getSortableNumber(a);
        const numB = getSortableNumber(b);
        if (numA !== numB) return numA - numB;
        const labelA = (a.number || '').toString();
        const labelB = (b.number || '').toString();
        const cmpLabel = labelA.localeCompare(labelB, undefined, { numeric: true, sensitivity: 'base' });
        if (cmpLabel !== 0) return cmpLabel;
        return (a.id || '').localeCompare(b.id || '');
      });
    }

    const wrapper = document.createElement('div');
    wrapper.className = 'margin-footnotes';
    const ol = document.createElement('ol');
    items.forEach((it, idx) => {
      const clone = it.li.cloneNode(true);
      const displayLabel = (it.number && String(it.number).trim().length) ? String(it.number).trim() : String(idx + 1);
      if (!clone.querySelector('.footnote-num')) {
        const num = document.createElement('span');
        num.className = 'footnote-num';
        num.textContent = displayLabel + '. ';
        clone.insertBefore(num, clone.firstChild);
      }
      it.number = displayLabel;
      it.displayIndex = displayLabel;
      it.clone = clone;
      ol.appendChild(clone);
    });
    wrapper.appendChild(ol);
    footHost.appendChild(wrapper);
    reinforceAnchors(footHost);

    // 両方タブ: コメントと脚注を本文位置で混在
    if (bothHost) {
      renderBothPanel(bothHost, items);
      reinforceAnchors(bothHost);
    }

    setupScrollSyncForFootnotes(footHost, items);
    refreshCommentMarkersFromDB({ preserveExisting: true });
    scheduleScrollExtensionUpdate();
    return true;
  }

  function renderBothPanel(host, footItems) {
    const commentAnchors = gatherActiveCommentsWithElements();
    const commItems = commentAnchors.map(({ rec, el }) => {
      const rect = el ? el.getBoundingClientRect() : null;
      const top = rect ? (rect.top + window.scrollY) : Infinity;
      return { type: 'comment', top, rec };
    });
    const footMixed = (footItems || []).map((f) => ({
      type: 'foot',
      top: f.pos,
      id: f.id,
      displayIndex: f.displayIndex,
      number: f.number,
      clone: f.li.cloneNode(true)
    }));
    const merged = commItems.concat(footMixed).sort((a, b) => a.top - b.top);

    host.innerHTML = '';
    const header = document.createElement('h2');
    header.className = 'footnotes-title';
    header.textContent = '両方';
    host.appendChild(header);

    const list = document.createElement('div');
    list.className = 'both-mixed-list';
    list.style.cssText = 'display:flex; flex-direction:column; gap:8px;';

    merged.forEach(item => {
      if (item.type === 'comment') {
        const rec = item.rec;
        const card = document.createElement('div');
        card.className = 'comment-card';
        card.style.cssText = 'padding:10px;background:#fff;border-radius:6px;border-left:3px solid #ff9800;box-shadow:0 1px 3px rgba(0,0,0,0.08);';
        const meta = document.createElement('div');
        meta.className = 'comment-meta';
        meta.style.cssText = 'font-size:12px;color:#6c757d;margin-bottom:6px;display:flex;gap:8px;align-items:center;';
        const t = document.createElement('span');
        t.textContent = fmtMMDDHHmm(rec.t);
        const move = document.createElement('a');
        move.href = '#';
        move.textContent = '移動';
        move.addEventListener('click', (e) => { e.preventDefault(); scrollToComment(rec); });
        meta.appendChild(t);
        meta.appendChild(move);
        const target = document.createElement('div');
        target.className = 'comment-snippet';
        target.style.cssText = 'font-size:13px;color:#495057;background:#fff3e0;padding:6px 8px;border-radius:4px;margin-bottom:6px;';
        target.textContent = rec.text || '';
        const body = document.createElement('div');
        body.className = 'comment-body';
        body.style.cssText = 'white-space:pre-wrap; line-height:1.5;';
        body.textContent = rec.body || '';
        card.appendChild(meta);
        card.appendChild(target);
        card.appendChild(body);
        list.appendChild(card);
      } else {
        const wrapper = document.createElement('div');
        wrapper.className = 'both-footnote-card';
        wrapper.style.cssText = 'padding:10px;background:#fff;border-radius:6px;border-left:3px solid #6c757d;box-shadow:0 1px 3px rgba(0,0,0,0.06);';
        const clone = item.clone;
        if (!clone.querySelector('.footnote-num')) {
          const num = document.createElement('span');
          num.className = 'footnote-num';
          const label = (item.displayIndex && String(item.displayIndex).trim().length)
            ? String(item.displayIndex).trim()
            : (item.number && String(item.number).trim().length)
              ? String(item.number).trim()
              : String(footMixed.indexOf(item) + 1);
          num.textContent = label + '. ';
          clone.insertBefore(num, clone.firstChild);
        }
        wrapper.appendChild(clone);
        list.appendChild(wrapper);
      }
    });
    host.appendChild(list);
    reinforceAnchors(list);
    setupScrollSyncForBoth(host, merged);
  }

  // 本文側のスクロール位置と右パネル内部スクロールの同期ユーティリティ
  function computeScrollRatioFromPositions(positions) {
    if (!Array.isArray(positions) || !positions.length) return null;
    let minPos = Infinity;
    let maxPos = -Infinity;
    positions.forEach(p => {
      if (typeof p !== 'number' || !isFinite(p)) return;
      if (p < minPos) minPos = p;
      if (p > maxPos) maxPos = p;
    });
    if (!isFinite(minPos) || !isFinite(maxPos)) return null;

    const scrollY = window.scrollY || window.pageYOffset || document.documentElement.scrollTop || 0;
    const viewH = window.innerHeight || document.documentElement.clientHeight || 0;
    const center = scrollY + viewH / 2;

    if (maxPos === minPos) {
      return center <= minPos ? 0 : 1;
    }
    let ratio = (center - minPos) / (maxPos - minPos);
    if (ratio < 0) ratio = 0;
    else if (ratio > 1) ratio = 1;
    return ratio;
  }

  function scrollRightSidebarToRatio(ratio, host) {
    if (ratio == null) return;
    const container = document.getElementById('quarto-margin-sidebar') || host;
    if (!container) return;
    const maxScroll = container.scrollHeight - container.clientHeight;
    if (!(maxScroll > 0)) return;
    const clamped = Math.max(0, Math.min(1, ratio));
    container.scrollTop = maxScroll * clamped;
  }

  function setupScrollSyncForFootnotes(host, items) {
    const mode = localStorage.getItem('footnotes-sort') || 'pos';
    if (mode !== 'pos') return;
    if (!Array.isArray(items) || !items.length) return;
    const positions = items
      .map(it => (typeof it.pos === 'number' ? it.pos : null))
      .filter(p => typeof p === 'number' && isFinite(p));
    if (!positions.length) return;

    const onScroll = () => {
      const ratio = computeScrollRatioFromPositions(positions);
      scrollRightSidebarToRatio(ratio, host);
    };
    window.addEventListener('scroll', onScroll, { passive: true });
  }

  function setupScrollSyncForBoth(host, items) {
    const onScroll = () => {
      if (!Array.isArray(items) || !items.length) return;
      const positions = items
        .map(it => (typeof it.top === 'number' ? it.top : null))
        .filter(p => typeof p === 'number' && isFinite(p));
      const ratio = computeScrollRatioFromPositions(positions);
      scrollRightSidebarToRatio(ratio, host);
    };
    window.addEventListener('scroll', onScroll, { passive: true });
  }

  function renderCommentsPanel() {
    const marginSidebar = document.getElementById('quarto-margin-sidebar');
    if (!marginSidebar) return;
    const commHost = marginSidebar.querySelector('.right-comments');
    if (!commHost) return;
    const list = getActiveComments();
    commHost.innerHTML = '';

    const header = document.createElement('div');
    header.style.cssText = 'display:flex;align-items:center;justify-content:space-between;margin-bottom:6px;';
    const title = document.createElement('h2');
    title.className = 'footnotes-title';
    title.textContent = 'コメント';
    const sort = document.createElement('select');
    sort.innerHTML = '<option value="new">新しい順</option><option value="pos">本文位置順</option><option value="old">古い順</option>';
    sort.value = localStorage.getItem('comments-sort') || 'new';
    sort.addEventListener('change', () => { localStorage.setItem('comments-sort', sort.value); renderCommentsPanel(); });
    header.appendChild(title); header.appendChild(sort);
    commHost.appendChild(header);

    if (!list.length) { commHost.insertAdjacentHTML('beforeend','<p class="footnotes-empty">コメントはありません。</p>'); return; }

    const computePos = (rec) => {
      const el = findCommentAnchorElement(rec);
      const top = el ? (el.getBoundingClientRect().top + window.scrollY) : Infinity;
      return top;
    };

    let arr = list.slice();
    const mode = sort.value;
    if (mode === 'new') arr.sort((a,b)=>b.t-a.t);
    else if (mode === 'old') arr.sort((a,b)=>a.t-b.t);
    else if (mode === 'pos') arr.sort((a,b)=>computePos(a)-computePos(b));

    const ul = document.createElement('ul');
    ul.className = 'comment-list';
    ul.style.listStyle = 'none'; ul.style.padding = '0'; ul.style.margin = '0';

    arr.forEach(rec => {
      const li = document.createElement('li');
      li.dataset.id = rec.id;
      li.className = 'comment-item';
      li.style.cssText = 'margin:12px 0; padding:10px; background:#fff; border-radius:6px; border-left:3px solid #6c757d; box-shadow:0 1px 3px rgba(0,0,0,0.08); position:relative;';
      const meta = document.createElement('div');
      meta.className = 'comment-meta';
      meta.style.cssText = 'font-size:12px; color:#6c757d; margin-bottom:6px; display:flex; gap:8px; align-items:center;';
      const time = fmtMMDDHHmm(rec.t);
      const move = document.createElement('a');
      move.href = '#'; move.textContent = '移動';
      move.addEventListener('click', (e) => { e.preventDefault(); scrollToComment(rec); });
      const menuBtn = document.createElement('button');
      menuBtn.textContent = '⋯';
      menuBtn.setAttribute('aria-label','メニュー');
      menuBtn.style.cssText = 'margin-left:auto;background:none;border:none;cursor:pointer;font-size:18px;line-height:1;';
      menuBtn.addEventListener('click', (e) => { e.stopPropagation(); openCommentMenu(li, rec, {x:e.clientX,y:e.clientY}); });
      meta.innerHTML = `<span>${time}</span>`;
      meta.appendChild(move);
      meta.appendChild(menuBtn);

      const target = document.createElement('div');
      target.className = 'comment-snippet';
      target.style.cssText = 'font-size:13px; color:#495057; background:#f8f9fa; padding:6px 8px; border-radius:4px; margin-bottom:6px;';
      target.textContent = rec.text || '';
      const body = document.createElement('div');
      body.className = 'comment-body';
      body.style.cssText = 'white-space:pre-wrap; line-height:1.5;';
      body.textContent = rec.body || '';
      li.appendChild(meta); li.appendChild(target); li.appendChild(body);
      ul.appendChild(li);
    });

    commHost.appendChild(ul);
    setupScrollSyncForComments(commHost, arr);
  }

  let commentMenuCleanup = null;

  function openCommentMenu(li, rec, pt) {
    closeAnyInlineMenu();
    const menu = document.createElement('div');
    menu.className = 'comment-menu-popup';
    menu.style.cssText = 'position:fixed; background:#fff; border:1px solid #e1e5eb; box-shadow:0 4px 12px rgba(0,0,0,0.12); border-radius:6px; z-index:10001; padding:6px;';
    menu.innerHTML = '<button type="button" data-act="edit" style="display:block;width:100%;text-align:left;padding:6px 10px;background:none;border:none;cursor:pointer;">編集</button>\n<button type="button" data-act="del" style="display:block;width:100%;text-align:left;padding:6px 10px;background:none;border:none;cursor:pointer;">削除</button>';
    document.body.appendChild(menu);
    const x = pt?.x || (li.getBoundingClientRect().right - 10);
    const y = pt?.y || (li.getBoundingClientRect().top + 20);
    menu.style.left = x + 'px';
    menu.style.top = y + 'px';
    const onDoc = (e)=>{ if (!menu.contains(e.target)) { closeAnyInlineMenu(); } };
    const onViewportChange = () => closeAnyInlineMenu();
    document.addEventListener('mousedown', onDoc, true);
    window.addEventListener('scroll', onViewportChange, true);
    window.addEventListener('resize', onViewportChange);
    commentMenuCleanup = () => {
      document.removeEventListener('mousedown', onDoc, true);
      window.removeEventListener('scroll', onViewportChange, true);
      window.removeEventListener('resize', onViewportChange);
      commentMenuCleanup = null;
    };
    menu.addEventListener('click', (e) => {
      const act = e.target?.getAttribute('data-act');
      if (act === 'edit') editComment(rec);
      if (act === 'del') deleteComment(rec);
      closeAnyInlineMenu();
    });
  }

  function closeAnyInlineMenu(){
    document.querySelectorAll('.comment-menu-popup').forEach(n=>n.remove());
    if (typeof commentMenuCleanup === 'function') {
      commentMenuCleanup();
    }
  }

  function editComment(rec) {
    const overlay = document.createElement('div');
    overlay.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.4);z-index:10000;display:flex;align-items:center;justify-content:center;';
    const dialog = document.createElement('div');
    dialog.style.cssText = 'background:#fff;color:#222;max-width:600px;width:92%;padding:16px;border-radius:8px;box-shadow:0 10px 30px rgba(0,0,0,0.25);';
    dialog.innerHTML = `
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
        <h3 style="margin:0;font-size:16px;">コメント編集</h3>
        <button type=\"button\" aria-label=\"閉じる\" style=\"background:none;border:none;font-size:18px;cursor:pointer;\">×</button>
      </div>
      <div style="font-size:13px;color:#555;background:#f8f9fa;border:1px solid #e9ecef;padding:8px;border-radius:4px;margin-bottom:8px;">対象: ${(rec.text||'').slice(0,140)}</div>
      <textarea id="comment-edit-area" rows="6" style="width:100%;font-size:14px;padding:8px;border-radius:6px;border:1px solid #ced4da;resize:vertical;">${(rec.body||'')}</textarea>
      <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:10px;">
        <button type="button" id="comment-edit-cancel" style="padding:6px 12px;border:1px solid #dee2e6;border-radius:4px;background:#f8f9fa;cursor:pointer;">キャンセル</button>
        <button type="button" id="comment-edit-save" style="padding:6px 12px;border:1px solid #0d6efd;border-radius:4px;background:#0d6efd;color:#fff;cursor:pointer;">保存</button>
      </div>
    `;
    overlay.appendChild(dialog);
    document.body.appendChild(overlay);
    const close = ()=>{
      overlay.remove();
      document.removeEventListener('keydown', onKey);
    };
    const onKey = (evt) => {
      if (evt.key === 'Escape') {
        evt.preventDefault();
        close();
      }
    };
    dialog.querySelector('[aria-label="閉じる"]').addEventListener('click', close);
    dialog.querySelector('#comment-edit-cancel').addEventListener('click', close);
    overlay.addEventListener('click', (evt) => {
      if (evt.target === overlay) {
        close();
      }
    });
    document.addEventListener('keydown', onKey);
    const editTextarea = dialog.querySelector('#comment-edit-area');
    const editSaveBtn = dialog.querySelector('#comment-edit-save');
    editSaveBtn.addEventListener('click', () => {
      if (editSaveBtn.disabled) return;
      const v = (editTextarea.value||'').trim();
      if (!v) { editTextarea.focus(); return; }
      editSaveBtn.disabled = true;
      const originalLabel = editSaveBtn.textContent;
      editSaveBtn.textContent = '保存中…';
      let success = false;
      try {
        const key = pageKey();
        const arr = COMMENTS_DB[key]||[];
        const idx = arr.findIndex(x=>x.id===rec.id);
        if (idx>=0) {
          arr[idx].body = v;
          arr[idx].t = Date.now();
          COMMENTS_DB[key]=arr;
          saveComments();
          refreshRightPanels();
          refreshCommentMarkersFromDB();
        }
        success = true;
      } catch (error) {
        console.warn('Failed to update comment', error);
      }
      if (success) {
        Promise.resolve().then(() => {
          closeAnyInlineMenu();
          close();
        });
      } else {
        editSaveBtn.disabled = false;
        editSaveBtn.textContent = originalLabel;
      }
    });
  }

  function deleteComment(rec) {
    closeAnyInlineMenu();
    if (!confirm('このコメントを削除しますか？')) return;
    const key = pageKey();
    const arr = COMMENTS_DB[key]||[];
    COMMENTS_DB[key] = arr.filter(x=>x.id!==rec.id);
    saveComments();
    // マーカーも削除
    document.querySelectorAll(`.text-marker[data-comment-id="${rec.id}"]`).forEach(el => {
      const p = el.parentNode; while (el.firstChild) p.insertBefore(el.firstChild, el); p.removeChild(el);
    });
    refreshCommentMarkersFromDB();
    refreshRightPanels();
  }

  function setupScrollSyncForComments(host, items) {
    const mode = localStorage.getItem('comments-sort') || 'new';
    if (mode !== 'pos') return;
    if (!Array.isArray(items) || !items.length) return;
    const positions = items
      .map(rec => {
        const el = findCommentAnchorElement(rec);
        if (!el) return null;
        const rect = el.getBoundingClientRect();
        return rect ? (rect.top + window.scrollY) : null;
      })
      .filter(p => typeof p === 'number' && isFinite(p));
    if (!positions.length) return;

    const onScroll = () => {
      const ratio = computeScrollRatioFromPositions(positions);
      scrollRightSidebarToRatio(ratio, host);
    };
    window.addEventListener('scroll', onScroll, { passive: true });
  }

  function scrollToComment(rec) {
    try {
      const first = (rec.ranges && rec.ranges[0]);
      if (!first) return;
      const node = getNodeByPathSafe(first.s);
      if (!node) return;
      let el = node.nodeType === Node.ELEMENT_NODE ? node : node.parentElement;
      while (el && el !== document.body && !(el instanceof HTMLElement)) el = el.parentElement;
      if (!el) return;
      el.scrollIntoView({ behavior: 'smooth', block: 'center' });
      const prev = el.style.boxShadow;
      el.style.transition = 'box-shadow 0.3s ease';
      el.style.boxShadow = '0 0 0 3px rgba(26,115,232,0.5)';
      setTimeout(() => { el.style.boxShadow = prev || ''; }, 1600);
    } catch (e) { console.warn('scrollToComment failed', e); }
  }

  function getNodeByPathSafe(path) {
    try { let n=document.body; for (const idx of path||[]) { if (!n || !n.childNodes[idx]) return null; n = n.childNodes[idx]; } return n; } catch { return null; }
  }

  function renderInlineFootnotes() {
    setInlineFootnoteMode(true);
    const marginSidebar = document.getElementById('quarto-margin-sidebar');
    if (marginSidebar && marginSidebar.style.display !== 'none') {
      marginSidebar.dataset.prevDisplay = marginSidebar.style.display || '';
      marginSidebar.style.display = 'none';
    }
    document.querySelectorAll('.footnote-inline').forEach(n => n.remove());
    const active = getActiveChapterSection();
    const scope = active || document;
    const refSelector = 'a[role="doc-noteref"], a.footnote-ref';
    const refs = Array.from(scope.querySelectorAll(refSelector)).filter(ref => !active || active.contains(ref));
    if (!refs.length) return false;
    const hostTailMap = new Map();
    let inserted = false;
    refs.forEach(ref => {
      const href = ref.getAttribute('href') || ref.getAttribute('data-footnote-href');
      if (!href || !href.startsWith('#')) return;
      const id = href.slice(1);
      const target = document.getElementById(id);
      if (!target) return;
      if (active) {
        const section = target.closest('section.chapter-page');
        if (section && section !== active) return;
      }
      const numberText = (ref.textContent || '').replace(/[^0-9]/g, '') || '';
      const host = findHostParagraph(ref);
      if (!host) return;
      const clone = target.cloneNode(true);
      clone.querySelectorAll('.footnote-back, .footnote-backref, [role="doc-backlink"]').forEach(a => a.remove());
      const container = document.createElement('div');
      container.className = 'footnote-inline';
      const numSpan = document.createElement('span');
      numSpan.className = 'footnote-num';
      numSpan.textContent = (numberText ? numberText : '') + '. ';
      container.appendChild(numSpan);
      while (clone.firstChild) container.appendChild(clone.firstChild);
      const tail = hostTailMap.get(host);
      if (tail && tail.parentNode) {
        tail.insertAdjacentElement('afterend', container);
      } else {
        host.insertAdjacentElement('afterend', container);
      }
      hostTailMap.set(host, container);
      reinforceAnchors(container);
      inserted = true;
    });
    ensureCommentMarkerInteractions();
    scheduleScrollExtensionUpdate();
    return inserted;
  }

  function findHostParagraph(el) {
    let p = el;
    while (p && p !== document.body) {
      if (p.tagName === 'P' || p.tagName === 'LI') return p;
      p = p.parentElement;
    }
    return null;
  }

  function debounce(fn, ms) {
    let t;
    return (...args) => { clearTimeout(t); t = setTimeout(() => fn.apply(this, args), ms); };
  }

function setupMarkerFunctionality() {
    let markersDB = JSON.parse(localStorage.getItem(STORAGE_KEYS.markers) || '{}');
    let pendingSerializedRange = null;

    const handleSelectionEvent = (e) => {
      if (closestInteractive(e.target)) return;
      const sel = window.getSelection();
      if (!sel || sel.rangeCount === 0) {
        hideMarkerToolbar();
        pendingSerializedRange = null;
        return;
}

  function getHeadingElements() {
    const scope = document.getElementById('quarto-document-content');
    if (!scope) return [];
    return scope.querySelectorAll('h1, h2, h3, h4, h5, h6');
  }

  function enumerateReadingNodes() {}

  function findReadableElement(node) {
    const scope = document.getElementById('quarto-document-content');
    if (!scope) return null;
    let current = node;
    while (current && current !== document.body) {
      if (current.tagName) {
        const tag = current.tagName.toLowerCase();
        if (['p','li','blockquote','pre','table','figure','dd','dt'].includes(tag)) {
          return current;
        }
      }
      current = current.parentElement;
    }
    return null;
  }

  function captureReadingState(options) {
    const opts = options || {};
    const headings = getHeadingElements();
    const docEl = document.documentElement;
    const body = document.body;
    const scrollTop = (docEl && docEl.scrollTop) || (body && body.scrollTop) || 0;
    const viewportHeight = window.innerHeight || docEl.clientHeight || 0;
    const viewportWidth = window.innerWidth || docEl.clientWidth || body.clientWidth || 0;
    const focusLine = scrollTop + viewportHeight * 0.35;
    let current = null;
    for (let i = 0; i < headings.length; i += 1) {
      const el = headings[i];
      const top = el.offsetTop;
      if (top <= focusLine) {
        current = el;
      } else {
        break;
      }
    }
    if (!current && headings.length) {
      current = headings[0];
    }
    const pageHeight = Math.max(1, (docEl && docEl.scrollHeight) || (body && body.scrollHeight) || 1) - viewportHeight;
    const pageRatio = pageHeight > 0 ? scrollTop / pageHeight : 0;
    const state = { pageRatio };
    const centerX = viewportWidth / 2;
    let focusNode = null;
    try {
      focusNode = document.elementFromPoint(centerX, viewportHeight * 0.4);
    } catch (e) {
      focusNode = null;
    }
    if (current) {
      const currentId = current.getAttribute('id') || current.getAttribute('data-anchor-id') || '';
      const next = current.nextElementSibling ? current.nextElementSibling.closest('h1, h2, h3, h4, h5, h6') : null;
      let nextTop = null;
      if (next) {
        nextTop = next.offsetTop;
      } else {
        nextTop = (docEl && docEl.scrollHeight) || (body && body.scrollHeight) || (current.offsetTop + viewportHeight);
      }
      const currentTop = current.offsetTop;
      const sectionHeight = Math.max(1, nextTop - currentTop);
      const rel = (focusLine - currentTop) / sectionHeight;
      if (currentId) {
        state.sectionId = currentId;
        state.sectionOffset = Math.min(0.995, Math.max(0, rel));
      }
    }
    const focusElement = findReadableElement(focusNode);
    if (focusElement) {
      const rect = focusElement.getBoundingClientRect();
      const elementHeight = Math.max(1, rect.height || focusElement.offsetHeight || 1);
      const elementTop = focusElement.offsetTop;
      const relInElement = Math.min(0.995, Math.max(0, (focusLine - elementTop) / elementHeight));
      state.focusElementOffset = relInElement;
      const id = focusElement.getAttribute('id') || focusElement.getAttribute('data-anchor-id') || '';
      if (id) state.focusElementId = id;
      if (opts.captureNodeRef) {
        state.__focusNode = focusElement;
      }
    }
    return state;
  }

  function scrollToReadingState(state) {
    if (!state) return false;
    const docEl = document.documentElement;
    const body = document.body;
    const viewportHeight = window.innerHeight || docEl.clientHeight || 0;
    const focusRatio = typeof state.focusElementOffset === 'number' ? state.focusElementOffset : null;
    const resolveFocusTarget = () => {
      if (state.__focusNode && state.__focusNode instanceof HTMLElement && document.body.contains(state.__focusNode)) {
        return state.__focusNode;
      }
      if (state.focusElementId) {
        return document.getElementById(state.focusElementId) || document.querySelector(`[data-anchor-id="${state.focusElementId}"]`);
      }
      return null;
    };
    const focusTarget = resolveFocusTarget();
    if (focusTarget) {
      const ratio = focusRatio != null ? focusRatio : 0.35;
      const targetTop = focusTarget.offsetTop + ratio * Math.max(1, focusTarget.offsetHeight || 1);
      const desired = targetTop - viewportHeight * 0.35;
      window.scrollTo({ top: Math.max(0, desired), behavior: 'auto' });
      return true;
    }
    if (state.sectionId) {
      const selector = `#${escapeCssId(state.sectionId)}`;
      let target = document.querySelector(selector);
      if (!target) {
        target = document.querySelector(`[data-anchor-id="${state.sectionId}"]`);
      }
      if (target) {
        const headings = Array.from(getHeadingElements());
        const idx = headings.indexOf(target);
        let nextTop = null;
        if (idx >= 0 && idx + 1 < headings.length) {
          nextTop = headings[idx + 1].offsetTop;
        } else {
          nextTop = (docEl && docEl.scrollHeight) || (body && body.scrollHeight) || (target.offsetTop + viewportHeight);
        }
        const currentTop = target.offsetTop;
        const sectionHeight = Math.max(1, nextTop - currentTop);
        const rel = typeof state.sectionOffset === 'number' ? state.sectionOffset : 0;
        const dest = currentTop + rel * sectionHeight;
        window.scrollTo({ top: Math.max(0, dest), behavior: 'auto' });
        return true;
      }
    }
    if (typeof state.pageRatio === 'number') {
      const docHeight = Math.max(1, ((docEl && docEl.scrollHeight) || (body && body.scrollHeight) || 1) - viewportHeight);
      const targetY = state.pageRatio * docHeight;
      window.scrollTo({ top: Math.max(0, targetY), behavior: 'auto' });
      return true;
    }
    return false;
  }

  function escapeCssId(id) {
    if (window.CSS && typeof window.CSS.escape === 'function') {
      return window.CSS.escape(id);
    }
    return id.replace(/[^a-zA-Z0-9_\-]/g, '\\$&');
  }

  function restoreReadingState() {
    let raw = null;
    try {
      raw = sessionStorage.getItem(STORAGE_KEYS.readingState);
    } catch (e) {
      raw = null;
    }
    if (!raw) return;
    let state = null;
    try {
      state = JSON.parse(raw);
    } catch (e) {
      state = null;
    }
    scrollToReadingState(state);
  }

  function persistReadingState() {
    let state = null;
    try {
      state = captureReadingState();
    } catch (e) {
      state = null;
    }
    if (!state) return;
    try {
      sessionStorage.setItem(STORAGE_KEYS.readingState, JSON.stringify(state));
    } catch (e) {
      // ignore
    }
  }

  function scheduleReadingStateSave() {
    if (readingStateSaveTimer) return;
    readingStateSaveTimer = window.setTimeout(() => {
      readingStateSaveTimer = null;
      persistReadingState();
    }, 500);
  }
      const text = sel.toString().trim();
      if (text) {
        const rect = getSelectionRect(sel);
        const fallbackPoint = { x: e.clientX, y: e.clientY };
        try {
          pendingSerializedRange = serializeRange(sel.getRangeAt(0));
        } catch {
          pendingSerializedRange = null;
        }
        showMarkerToolbar(rect, fallbackPoint);
      } else {
        hideMarkerToolbar();
        pendingSerializedRange = null;
      }
    };

    // テキスト選択でツールバーを表示（UI要素上は無効）
    document.addEventListener('mouseup', handleSelectionEvent);
    document.addEventListener('touchend', handleSelectionEvent);

    function closestInteractive(el){
      return el.closest('.marker-toolbar, .js-header, .global-search-dialog, #quarto-sidebar');
    }

    function getSelectionRect(selection) {
      if (!selection || selection.rangeCount === 0) return null;
      try {
        const range = selection.getRangeAt(0).cloneRange();
        const rect = range.getBoundingClientRect();
        if (rect && (rect.width || rect.height)) return rect;
        const rects = range.getClientRects();
        for (const r of rects) {
          if (r.width || r.height) return r;
        }
      } catch (err) {
        console.warn('getSelectionRect failed', err);
      }
      const focusContainer = selection.focusNode instanceof Element ? selection.focusNode : selection.focusNode?.parentElement;
      return focusContainer ? focusContainer.getBoundingClientRect() : null;
    }

    function showMarkerToolbar(rect, fallbackPoint) {
      let toolbar = document.querySelector('.marker-toolbar');
      if (!toolbar) {
        toolbar = createMarkerToolbar();
        document.body.appendChild(toolbar);
      }
      toolbar.classList.add('show');
      toolbar.style.display = 'flex';
      toolbar.style.flexDirection = 'column';
      toolbar.style.gap = '6px';
      toolbar.style.position = 'absolute';
      toolbar.style.removeProperty('right');
      toolbar.style.removeProperty('bottom');
      positionMarkerToolbar(toolbar, rect, fallbackPoint);
    }

    function positionMarkerToolbar(toolbar, rect, fallbackPoint) {
      requestAnimationFrame(() => {
        if (!toolbar.classList.contains('show')) return;
        let targetRect = rect;
        if (!targetRect || (!(targetRect.width || targetRect.height))) {
          if (fallbackPoint && typeof fallbackPoint.x === 'number' && typeof fallbackPoint.y === 'number') {
            targetRect = {
              top: fallbackPoint.y,
              bottom: fallbackPoint.y,
              left: fallbackPoint.x,
              right: fallbackPoint.x,
              width: 0,
              height: 0
            };
          } else {
            const vw = window.innerWidth || document.documentElement.clientWidth || 0;
            const vh = window.innerHeight || document.documentElement.clientHeight || 0;
            targetRect = {
              top: vh / 2,
              bottom: vh / 2,
              left: vw / 2,
              right: vw / 2,
              width: 0,
              height: 0
            };
          }
        }
        const scrollX = window.scrollX ?? window.pageXOffset ?? document.documentElement.scrollLeft ?? 0;
        const scrollY = window.scrollY ?? window.pageYOffset ?? document.documentElement.scrollTop ?? 0;
        const toolbarWidth = toolbar.offsetWidth;
        const toolbarHeight = toolbar.offsetHeight;
        const margin = 12;
        const viewportWidth = document.documentElement.clientWidth || window.innerWidth || toolbarWidth;
        const rectWidth = targetRect.width ?? (targetRect.right - targetRect.left) ?? 0;
        const rectCenterX = targetRect.left + rectWidth / 2;
        let left = scrollX + rectCenterX - toolbarWidth / 2;
        left = Math.max(scrollX + 8, Math.min(left, scrollX + viewportWidth - toolbarWidth - 8));
        const rectBottom = targetRect.bottom ?? (targetRect.top + targetRect.height) ?? targetRect.top;
        let top = scrollY + targetRect.top - toolbarHeight - margin;
        if (top < scrollY + 8) {
          top = scrollY + rectBottom + margin;
        }
        const viewportHeight = document.documentElement.clientHeight || window.innerHeight || toolbarHeight;
        const maxTop = scrollY + viewportHeight - toolbarHeight - 8;
        top = Math.min(top, maxTop);
        toolbar.style.left = `${Math.round(left)}px`;
        toolbar.style.top = `${Math.round(top)}px`;
      });
    }

    function createMarkerToolbar() {
      const toolbar = document.createElement('div');
      toolbar.className = 'marker-toolbar';
      toolbar.innerHTML = `
        <div class="marker-controls" role="toolbar" aria-label="ハイライト色選択">
          <div class="marker-colors">
            <button type="button" class="marker-color-btn" data-color="yellow" title="黄"></button>
            <button type="button" class="marker-color-btn" data-color="green" title="緑"></button>
            <button type="button" class="marker-color-btn" data-color="blue" title="青"></button>
            <button type="button" class="marker-color-btn" data-color="pink" title="ピンク"></button>
          </div>
          <button type="button" class="marker-comment-btn" title="選択範囲にコメント" aria-label="選択範囲にコメント">コメント</button>
        </div>
      `;
      toolbar.querySelectorAll('.marker-color-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          applyMarker(btn.dataset.color);
          hideMarkerToolbar();
        });
      });
      const commentBtn = toolbar.querySelector('.marker-comment-btn');
      if (commentBtn) {
        commentBtn.addEventListener('click', () => {
          openCommentDialog();
        });
      }
      return toolbar;
    }

    function openCommentDialog() {
      const selection = window.getSelection();
      let baseRange = null;
      if (selection && selection.rangeCount > 0 && selection.toString().trim()) {
        baseRange = selection.getRangeAt(0);
      } else if (pendingSerializedRange) {
        baseRange = deserializeRange(pendingSerializedRange);
      }
      if (!baseRange || baseRange.collapsed) return;

      const overlay = document.createElement('div');
      overlay.className = 'comment-dialog-overlay';
      const dialog = document.createElement('div');
      dialog.className = 'comment-dialog';
      dialog.innerHTML = `
        <div class="comment-dialog__header">
          <h3 class="comment-dialog__title">コメントを追加</h3>
          <button type="button" aria-label="閉じる" class="comment-dialog__close">×</button>
        </div>
        <div class="comment-dialog__snippet" id="comment-snippet"></div>
        <textarea id="comment-textarea" rows="6" class="comment-dialog__textarea" placeholder="ここにコメントを入力（長文可）"></textarea>
        <div class="comment-dialog__actions">
          <button type="button" id="comment-cancel" class="comment-dialog__btn comment-dialog__btn--muted">キャンセル</button>
          <button type="button" id="comment-save" class="comment-dialog__btn comment-dialog__btn--primary">保存</button>
        </div>
      `;
      overlay.appendChild(dialog);
      document.body.appendChild(overlay);

      const close = () => overlay.remove();
      dialog.querySelector('button[aria-label="閉じる"]').addEventListener('click', close);
      dialog.querySelector('#comment-cancel').addEventListener('click', close);

      // 選択スニペット表示
      const snippet = baseRange.cloneContents().textContent || window.getSelection().toString();
      dialog.querySelector('#comment-snippet').textContent = `対象: ${snippet?.slice(0,140) || ''}`;

      const saveBtn = dialog.querySelector('#comment-save');
      const commentTextarea = dialog.querySelector('#comment-textarea');
      const originalLabel = saveBtn.textContent;
      saveBtn.addEventListener('click', () => {
        if (saveBtn.disabled) return;
        const body = (commentTextarea.value || '').trim();
        if (!body) { commentTextarea.focus(); return; }
        const segs = getTextSegments(baseRange);
        if (!segs.length) { close(); return; }
        saveBtn.disabled = true;
        saveBtn.textContent = '保存中…';
        let saved = false;
        try {
          const serializedRanges = segs.map(seg => ({ s: getPath(seg.node), so: seg.start, e: getPath(seg.node), eo: seg.end }));
          const rec = { id: `comment-${Date.now()}-${Math.floor(Math.random()*1000)}`, ranges: serializedRanges, text: snippet, body, t: Date.now(), slug: getCurrentChapterSlug() || null };
          const key = pageKey();
          if (!COMMENTS_DB[key]) COMMENTS_DB[key] = [];
          COMMENTS_DB[key].push(rec);
          saveComments();
          saved = true;
          segs.forEach(seg => {
            const span = document.createElement('span');
            span.className = 'text-marker marker-orange';
            span.setAttribute('data-comment-id', rec.id);
            applyColorStyles(span, 'orange');
            wrapBySplitText(seg.node, seg.start, seg.end, span);
          });
          ensureCommentMarkerInteractions();
          try {
            refreshRightPanels();
          } catch (panelError) {
            console.warn('Refresh right panels failed after comment', panelError);
          }
          hideMarkerToolbar();
          const selection = window.getSelection();
          if (selection && typeof selection.removeAllRanges === 'function') {
            selection.removeAllRanges();
          }
          pendingSerializedRange = null;
        } catch (error) {
          console.warn('Failed to save comment', error);
          saveBtn.disabled = false;
          saveBtn.textContent = originalLabel;
          return;
        }
        close();
      });
    }

    function applyMarker(color) {
      const selection = window.getSelection();
      let baseRange = null;
      if (selection && selection.rangeCount > 0 && selection.toString().trim()) {
        baseRange = selection.getRangeAt(0);
      } else if (pendingSerializedRange) {
        baseRange = deserializeRange(pendingSerializedRange);
      }
      if (!baseRange || baseRange.collapsed) return;

      const markerId = `marker-${Date.now()}-${Math.floor(Math.random()*1000)}`;
      const segments = getTextSegments(baseRange);
      if (!segments.length) return;

      const serializedRanges = [];
      segments.forEach(seg => {
        // 分割済みサブレンジをスタイル付与
        const span = document.createElement('span');
        span.className = `text-marker marker-${color}`;
        span.setAttribute('data-marker-id', markerId);
        applyColorStyles(span, color);
        span.addEventListener('dblclick', () => removeMarkerGroup(markerId));
        span.addEventListener('contextmenu', (e) => { e.preventDefault(); cycleMarkerColorGroup(markerId); });

        // 信頼性の高いsplitTextベースのラップ（file://でも安定）
        const serialized = { s: getPath(seg.node), so: seg.start, e: getPath(seg.node), eo: seg.end };
        wrapBySplitText(seg.node, seg.start, seg.end, span);
        serializedRanges.push(serialized);
      });

      selection.removeAllRanges();

      const page = window.location.pathname;
      if (!markersDB[page]) markersDB[page] = [];
      markersDB[page].push({ id: markerId, color, ranges: serializedRanges, t: Date.now() });
      saveMarkers();
      pendingSerializedRange = null;
    }

    // 選択範囲に交差するテキストノードをサブレンジに分割
    function getTextSegments(range) {
      const segments = [];

      // ルートがテキストノードの場合を考慮
      if (range.commonAncestorContainer && range.commonAncestorContainer.nodeType === Node.TEXT_NODE) {
        const node = range.commonAncestorContainer;
        const start = (node === range.startContainer) ? range.startOffset : 0;
        const end = (node === range.endContainer) ? range.endOffset : (node.nodeValue || '').length;
        if (start !== end) segments.push({ node, start, end });
        return segments;
      }

      const walker = document.createTreeWalker(
        range.commonAncestorContainer,
        NodeFilter.SHOW_TEXT,
        {
          acceptNode: (node) => {
            try {
              return range.intersectsNode(node) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;
            } catch (e) {
              // フォールバック: compareBoundaryPoints
              if (!node.nodeValue) return NodeFilter.FILTER_REJECT;
              const r = document.createRange();
              r.selectNodeContents(node);
              const endVsStart = range.compareBoundaryPoints(Range.END_TO_START, r);
              if (endVsStart <= 0) return NodeFilter.FILTER_REJECT;
              const startVsEnd = range.compareBoundaryPoints(Range.START_TO_END, r);
              if (startVsEnd >= 0) return NodeFilter.FILTER_REJECT;
              return NodeFilter.FILTER_ACCEPT;
            }
          }
        }
      );

      let node;
      while ((node = walker.nextNode())) {
        let start = 0;
        let end = node.nodeValue.length;
        if (node === range.startContainer && range.startContainer.nodeType === Node.TEXT_NODE) start = range.startOffset;
        if (node === range.endContainer && range.endContainer.nodeType === Node.TEXT_NODE) end = range.endOffset;
        if (start !== end) segments.push({ node, start, end });
      }
      return segments;
    }

    function hideMarkerToolbar() {
      const toolbar = document.querySelector('.marker-toolbar');
      if (toolbar) {
        toolbar.classList.remove('show');
        toolbar.style.display = 'none';
      }
    }

    function removeMarkerGroup(markerId) {
      document.querySelectorAll(`.text-marker[data-marker-id="${markerId}"]`).forEach(el => {
        const parent = el.parentNode;
        while (el.firstChild) parent.insertBefore(el.firstChild, el);
        parent.removeChild(el);
      });
      const page = window.location.pathname;
      if (markersDB[page]) {
        markersDB[page] = markersDB[page].filter(m => m.id !== markerId);
        if (!markersDB[page].length) delete markersDB[page];
        saveMarkers();
      }
    }

    function clearAllMarkers() {
      document.querySelectorAll('.text-marker').forEach(n => {
        const parent = n.parentNode;
        while (n.firstChild) parent.insertBefore(n.firstChild, n);
        parent.removeChild(n);
      });
      delete markersDB[window.location.pathname];
      saveMarkers();
    }

    function cycleMarkerColorGroup(markerId) {
      const order = ['yellow','green','blue','pink'];
      const els = Array.from(document.querySelectorAll(`.text-marker[data-marker-id="${markerId}"]`));
      if (!els.length) return;
      const el = els[0];
      const current = order.find(c => el.classList.contains(`marker-${c}`)) || 'yellow';
      const next = order[(order.indexOf(current)+1)%order.length];
      els.forEach(e => { order.forEach(c => e.classList.remove(`marker-${c}`)); e.classList.add(`marker-${next}`); applyColorStyles(e, next); });
      const page = window.location.pathname;
      const rec = (markersDB[page]||[]).find(m => m.id === markerId);
      if (rec) { rec.color = next; saveMarkers(); }
    }

    function saveMarkers(){ localStorage.setItem(STORAGE_KEYS.markers, JSON.stringify(markersDB)); }

    function restoreMarkers() {
      const page = window.location.pathname;
      const list = (markersDB[page] || []);
      list.forEach(m => {
        // 互換性: 古い形式 {range} を {ranges:[range]} に変換
        const ranges = m.ranges || (m.range ? [m.range] : []);
        ranges.forEach(rSerialized => {
        const tn = getNodeByPath(rSerialized.s);
        if (!tn || tn.nodeType !== Node.TEXT_NODE) return;
        const span = document.createElement('span');
        span.className = `text-marker marker-${m.color}`;
        span.setAttribute('data-marker-id', m.id);
        applyColorStyles(span, m.color);
        span.addEventListener('dblclick', () => removeMarkerGroup(m.id));
        span.addEventListener('contextmenu', (e) => { e.preventDefault(); cycleMarkerColorGroup(m.id); });
        wrapBySplitText(tn, rSerialized.so, rSerialized.eo, span);
        });
      });
    }

    function restoreCommentMarkers() {
      try {
        const list = (COMMENTS_DB[pageKey()] || []);
        list.forEach(rec => {
          (rec.ranges || []).forEach(r => {
            if (!r || typeof r.so !== 'number' || typeof r.eo !== 'number' || r.so === r.eo) return;
            const tn = getNodeByPath(r.s);
            if (!tn || tn.nodeType !== Node.TEXT_NODE) return;
            const span = document.createElement('span');
            span.className = 'text-marker marker-orange';
            span.setAttribute('data-comment-id', rec.id);
            applyColorStyles(span, 'orange');
            wrapBySplitText(tn, r.so, r.eo, span);
          });
        });
      } catch (e) {
        console.warn('restoreCommentMarkers failed', e);
      }
    }

    cleanupCommentMarkersDom = function() {
      document.querySelectorAll('.text-marker[data-comment-id]').forEach(span => {
        const parent = span.parentNode;
        if (!parent) return;
        while (span.firstChild) parent.insertBefore(span.firstChild, span);
        parent.removeChild(span);
      });
    };

    refreshCommentMarkersFromDB = function(options) {
      const preserveExisting = !!(options && options.preserveExisting);
      const existingCount = document.querySelectorAll('.text-marker[data-comment-id]').length;
      if (preserveExisting && existingCount > 0) {
        ensureCommentMarkerInteractions();
        return;
      }
      cleanupCommentMarkersDom();
      restoreCommentMarkers();
      ensureCommentMarkerInteractions();
    };

    // 既存マーカー / コメントマーカー再描画
    restoreMarkers();
    refreshCommentMarkersFromDB();

    // 範囲のシリアライズ/デシリアライズ
    function serializeRange(range) {
      return {
        s: getPath(range.startContainer), so: range.startOffset,
        e: getPath(range.endContainer), eo: range.endOffset
      };
    }
    function deserializeRange(obj) {
      try {
        const sc = getNodeByPath(obj.s);
        const ec = getNodeByPath(obj.e);
        if (!sc || !ec) return null;
        const r = document.createRange();
        r.setStart(sc, Math.min(obj.so, nodeMaxOffset(sc)));
        r.setEnd(ec, Math.min(obj.eo, nodeMaxOffset(ec)));
        return r;
      } catch { return null; }
    }
    function nodeIndex(node){ let i=0; while(node && node.previousSibling){ node = node.previousSibling; i++; } return i; }
    function getPath(node){ const p=[]; let n=node; while(n && n !== document.body){ p.push(nodeIndex(n)); n = n.parentNode; } return p.reverse(); }
    function getNodeByPath(path){ let n=document.body; for(const idx of path){ if(!n || !n.childNodes[idx]) return null; n = n.childNodes[idx]; } return n; }
    function nodeMaxOffset(n){ return n.nodeType===Node.TEXT_NODE ? (n.nodeValue||'').length : (n.childNodes?n.childNodes.length:0); }

    function wrapBySplitText(textNode, start, end, wrapper) {
      try {
        let mid = textNode;
        if (start > 0) mid = textNode.splitText(start);
        let tail = mid;
        const len = end - start;
        if (len < mid.nodeValue.length) tail = mid.splitText(len);
        const parent = mid.parentNode;
        parent.insertBefore(wrapper, mid);
        wrapper.appendChild(mid);
      } catch (e) {
        console.warn('wrapBySplitText failed', e);
      }
    }

    function applyColorStyles(el, color) {
      // インラインスタイルで確実に可視化（CSSが読み込めないfile://時の保険）
      const map = {
        yellow: 'rgba(255, 235, 59, 0.6)',
        green:  'rgba(129, 199, 132, 0.5)',
        blue:   'rgba(100, 181, 246, 0.5)',
        pink:   'rgba(244, 143, 177, 0.5)',
        orange: 'rgba(255, 152, 0, 0.45)'
      };
      el.style.backgroundColor = map[color] || 'rgba(255, 235, 59, 0.6)';
      el.style.boxShadow = 'inset 0 -0.15em 0 rgba(0,0,0,0.08)';
    }
  }

  function setupMobileFootnoteToggle() {
    document.querySelectorAll('.footnote-ref').forEach(footnote => {
      footnote.addEventListener('click', (e) => {
        e.preventDefault();
        const footnoteId = footnote.getAttribute('href');
        const footnoteDef = document.querySelector(footnoteId);
        if (footnoteDef) footnoteDef.classList.toggle('expanded');
      });
    });
  }

  function disableDefaultQuartoSearch() {
    try {
      const defaultBtn = document.getElementById('quarto-search');
      if (defaultBtn) defaultBtn.remove();
      const defaultPanel = document.getElementById('quarto-search-results');
      if (defaultPanel) defaultPanel.remove();
      const defaultOptions = document.getElementById('quarto-search-options');
      if (defaultOptions) defaultOptions.remove();
      if (window.Quarto && typeof window.Quarto.doc === 'object') {
        window.Quarto.doc.disableSearch = true;
      }
    } catch (e) {
      console.warn('Failed to disable default Quarto search', e);
    }
  }

  function setupSidebarSearch() {
    const sidebarSearch = document.querySelector('#quarto-sidebar .sidebar-search');
    if (!sidebarSearch) return;

    sidebarSearch.innerHTML = '';
    sidebarSearch.style.display = '';

    const utilityBar = document.createElement('div');
    utilityBar.className = 'sidebar-search-utility';

    const searchButton = document.createElement('button');
    searchButton.type = 'button';
    searchButton.className = 'sidebar-search-button';
    searchButton.setAttribute('aria-label', '検索を開く (Cmd+K)');
    searchButton.title = '検索 (Cmd+K)';

    const searchIcon = document.createElement('img');
    searchIcon.className = 'sidebar-search-button-icon';
    searchIcon.alt = '';
    searchIcon.decoding = 'async';
    searchIcon.loading = 'lazy';
    searchIcon.setAttribute('aria-hidden', 'true');
    searchIcon.src = resolveAssetPath('assets/search.png');

    searchButton.appendChild(searchIcon);
    searchButton.addEventListener('click', () => {
      const handle = openSearchOverlay('');
      if (handle && handle.input) {
        const inputEl = handle.input;
        const end = inputEl.value.length;
        inputEl.focus();
        inputEl.setSelectionRange(end, end);
      }
    });

    utilityBar.appendChild(searchButton);

    // プレビュー・コメント・マーカー一覧を開くボタン（検索アイコンのすぐ右）
    const listButton = document.createElement('button');
    listButton.type = 'button';
    listButton.className = 'sidebar-search-button sidebar-list-button';
    listButton.setAttribute('aria-label', 'プレビュー・コメント一覧を開く');
    listButton.title = 'プレビュー・コメント・マーカー一覧';
    listButton.style.marginLeft = '6px';

    const listIcon = document.createElement('img');
    listIcon.className = 'sidebar-search-button-icon';
    listIcon.alt = '';
    listIcon.decoding = 'async';
    listIcon.loading = 'lazy';
    listIcon.setAttribute('aria-hidden', 'true');
    listIcon.src = resolveAssetPath('assets/list.png');
    listButton.appendChild(listIcon);

    listButton.addEventListener('click', () => {
      openGlobalListOverlay();
    });

    utilityBar.appendChild(listButton);

    const meterWrapper = document.createElement('div');
    meterWrapper.className = 'sidebar-reading-meter';
    meterWrapper.setAttribute('role', 'status');
    meterWrapper.setAttribute('aria-label', '読書メーター');
    meterWrapper.title = '読書メーター';

    const meterValue = document.createElement('span');
    meterValue.className = 'sidebar-reading-meter-value';
    meterValue.textContent = '[0/0]';

    meterWrapper.appendChild(meterValue);
    utilityBar.appendChild(meterWrapper);

    sidebarSearch.appendChild(utilityBar);

    SEARCH_RESULTS_VIEW.sidebarContainer = null;
    SEARCH_RESULTS_VIEW.sidebarSummary = null;
    SEARCH_RESULTS_VIEW.sidebarList = null;
    SEARCH_RESULTS_VIEW.sidebarQuery = null;
    SEARCH_RESULTS_VIEW.sidebarClearBtn = null;

    initializeReadingMeter(meterValue);
    restoreSearchSession();
  }

  const SEARCH_SESSION_KEY = 'quarto-search-session';

  function saveSearchSession(session) {
    try {
      sessionStorage.setItem(SEARCH_SESSION_KEY, JSON.stringify(session));
    } catch (error) {
      console.warn('Search session save failed', error);
    }
  }

  function loadSearchSession() {
    try {
      const raw = sessionStorage.getItem(SEARCH_SESSION_KEY);
      if (!raw) return null;
      return JSON.parse(raw);
    } catch (error) {
      console.warn('Search session load failed', error);
      return null;
    }
  }

  function restoreSearchSession() {
    const session = loadSearchSession();
    if (!session || !Array.isArray(session.results) || !session.results.length) {
      clearSidebarSearchResults();
      return;
    }

    SEARCH_RESULTS_VIEW.sidebarData = session;
    renderSidebarSearchResults(session);

    const currentUrl = new URL(window.location.href, window.location.origin);
    if (session.active) {
      const target = new URL(session.active.url, window.location.href);
      if (target.origin === currentUrl.origin && target.pathname === currentUrl.pathname) {
        requestAnimationFrame(() => {
          clearSearchHighlights();
          scrollToMatchOnPage(session.query, session.active.matchIndex || 0);
        });
      }
    }
  }

  function clearSidebarSearchResults() {
    if (SEARCH_RESULTS_VIEW.sidebarContainer) {
      SEARCH_RESULTS_VIEW.sidebarContainer.classList.add('hidden');
      const empty = SEARCH_RESULTS_VIEW.sidebarContainer.querySelector('.sidebar-search-empty');
      if (empty) empty.classList.remove('hidden');
    }
    if (SEARCH_RESULTS_VIEW.sidebarSummary) {
      SEARCH_RESULTS_VIEW.sidebarSummary.innerHTML = '';
    }
    if (SEARCH_RESULTS_VIEW.sidebarList) {
      SEARCH_RESULTS_VIEW.sidebarList.innerHTML = '';
    }
    if (SEARCH_RESULTS_VIEW.sidebarQuery) {
      SEARCH_RESULTS_VIEW.sidebarQuery.textContent = '';
    }
    SEARCH_RESULTS_VIEW.sidebarData = null;
    clearSearchHighlights();
    try {
      sessionStorage.removeItem(SEARCH_SESSION_KEY);
    } catch (error) {
      console.warn('Failed to clear search session', error);
    }
  }

  function renderSidebarSearchResults(session) {
    const container = SEARCH_RESULTS_VIEW.sidebarContainer;
    if (!container) return;

    SEARCH_RESULTS_VIEW.sidebarData = session;

    const empty = container.querySelector('.sidebar-search-empty');
    const summary = SEARCH_RESULTS_VIEW.sidebarSummary;
    const list = SEARCH_RESULTS_VIEW.sidebarList;
    const queryLabel = SEARCH_RESULTS_VIEW.sidebarQuery;

    if (!session || !Array.isArray(session.results) || !session.results.length) {
      clearSidebarSearchResults();
      return;
    }

    container.classList.remove('hidden');
    if (empty) empty.classList.add('hidden');
    if (queryLabel) {
      queryLabel.textContent = `「${session.query}」`;
    }
    if (summary) {
      const hiddenCount = session.results.reduce((sum, item) => sum + (item.remainingMatches || 0), 0);
      const totalMatches = session.results.length + hiddenCount;
      summary.innerHTML = `<p><strong>${totalMatches}</strong>件の結果（「${escapeHtml(session.query)}」）</p>`;
    }
    if (list) {
      list.innerHTML = '';
      session.results.forEach((result, index) => {
        const itemBtn = document.createElement('button');
        itemBtn.type = 'button';
        itemBtn.className = 'sidebar-search-item';
        if (session.active &&
            session.active.url === result.url &&
            session.active.matchIndex === result.matchIndex) {
          itemBtn.classList.add('active');
        }

        itemBtn.innerHTML = `
          <span class="sidebar-search-item-title">${escapeHtml(result.title || result.url)}</span>
          <span class="sidebar-search-item-order">${result.matchIndex + 1}/${result.totalMatches || result.matchCount || 1}</span>
          <span class="sidebar-search-item-count">${result.totalMatches || result.matchCount || 1}件</span>
          <div class="sidebar-search-item-context">${result.context}</div>
        `;

        itemBtn.addEventListener('click', () => {
          handleSidebarResultSelection(result, index);
        });
        list.appendChild(itemBtn);
      });
    }
  }

  function handleSidebarResultSelection(result, index) {
    if (!SEARCH_RESULTS_VIEW.sidebarData) return;
    const session = SEARCH_RESULTS_VIEW.sidebarData;
    session.active = {
      url: result.url,
      matchIndex: result.matchIndex,
      index
    };
    session.timestamp = Date.now();
    saveSearchSession(session);
    renderSidebarSearchResults(session);
    navigateToSearchResult(result, session.query);
  }

  function handleOverlayResultSelection(result) {
    if (!result) return;
    const activePayload = convertResultToSession(result);
    const session = {
      query: SEARCH_RESULTS_VIEW.query,
      results: convertOverlayResultsForSession(SEARCH_RESULTS_VIEW.results),
      active: {
        url: activePayload.url,
        matchIndex: activePayload.matchIndex || 0
      },
      timestamp: Date.now()
    };
    SEARCH_RESULTS_VIEW.sidebarData = session;
    saveSearchSession(session);
    renderSidebarSearchResults(session);
    if (typeof SEARCH_RESULTS_VIEW.closeOverlay === 'function') {
      SEARCH_RESULTS_VIEW.closeOverlay();
    }
    navigateToSearchResult(activePayload, session.query);
  }

  function resolveResultUrl(url) {
    try {
      const resolved = new URL(url, window.location.href);
      return resolved.href;
    } catch {
      return url;
    }
  }

  function convertOverlayResultsForSession(results) {
    return results.map(convertResultToSession);
  }

  function convertResultToSession(result) {
    const page = result.page || {};
    return {
      url: resolveResultUrl(page.url || result.url || window.location.href),
      title: page.title || result.title || (page.url || 'ページ'),
      chapter: page.chapter || result.chapter || '',
      context: result.context || '',
      matchCount: result.matchCount || 1,
      totalMatches: result.totalMatches || result.matchCount || 1,
      remainingMatches: result.remainingMatches || 0,
      matchIndex: result.matchIndex || 0
    };
  }

  function navigateToSearchResult(result, query) {
    if (!result) return;
    const targetUrl = new URL(result.url, window.location.href);
    const currentUrl = new URL(window.location.href);
    const sameDocument = targetUrl.origin === currentUrl.origin && targetUrl.pathname === currentUrl.pathname;

    if (sameDocument) {
      if (targetUrl.hash && targetUrl.hash !== window.location.hash) {
        window.location.hash = targetUrl.hash;
      }
      requestAnimationFrame(() => {
        if (!scrollToMatchOnPage(query, result.matchIndex || 0) && targetUrl.hash) {
          const targetEl = document.querySelector(targetUrl.hash);
          if (targetEl && typeof targetEl.scrollIntoView === 'function') {
            targetEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
          }
        }
      });
    } else {
      window.location.href = targetUrl.href;
    }
  }

  let activeSearchHighlights = [];

  function clearSearchHighlights() {
    if (!activeSearchHighlights.length) return;
    activeSearchHighlights.forEach(span => {
      try {
        if (!span || !span.parentNode) return;
        const parent = span.parentNode;
        while (span.firstChild) {
          parent.insertBefore(span.firstChild, span);
        }
        parent.removeChild(span);
      } catch (error) {
        console.warn('Failed clearing highlight', error);
      }
    });
    activeSearchHighlights = [];
  }

  function highlightRange(range) {
    if (!range) return;
    const mark = document.createElement('mark');
    mark.className = 'search-hit-highlight';
    try {
      range.surroundContents(mark);
      activeSearchHighlights.push(mark);
      mark.scrollIntoView({ behavior: 'smooth', block: 'center' });
      setTimeout(() => {
        mark.classList.add('search-hit-fade');
      }, 100);
    } catch (error) {
      console.warn('Failed to highlight range', error);
    }
  }

  function scrollToMatchOnPage(query, matchIndex) {
    if (!query) return false;
    clearSearchHighlights();
    const walker = document.createTreeWalker(document.body, NodeFilter.SHOW_TEXT, null);
    const target = query.toLowerCase();
    let occurrence = -1;
    let node = walker.nextNode();
    while (node) {
      if (!(node.parentElement && node.parentElement.closest('.global-search-overlay'))) {
        const text = node.textContent || '';
        const lower = text.toLowerCase();
        let pos = 0;
        while (true) {
          const found = lower.indexOf(target, pos);
          if (found === -1) break;
          occurrence += 1;
          if (occurrence === matchIndex) {
            const range = document.createRange();
            range.setStart(node, found);
            range.setEnd(node, found + query.length);
            highlightRange(range);
            return true;
          }
          pos = found + query.length;
        }
      }
      node = walker.nextNode();
    }
    return false;
  }
  function setupGlobalSearch() {
    const openBtn = document.getElementById('search-open-btn');
    if (openBtn) openBtn.addEventListener('click', (e) => { e.preventDefault(); openSearchOverlay(); });

    window.quartoOpenSearch = (initialQuery = '') => {
      if (typeof initialQuery !== 'string') initialQuery = '';
      openSearchOverlay(initialQuery);
    };

    document.addEventListener('keydown', (e) => {
      if ((e.ctrlKey || e.metaKey) && (e.key === 'k' || e.key === 'K')) {
        e.preventDefault();
        openSearchOverlay();
      }
    }, true);
  }

  const SEARCH_STATE = {
    pages: [],
    index: {},
    loading: false,
    loaded: false,
    localSections: []
  };

  const SEARCH_RESULTS_VIEW = {
    results: [],
    query: '',
    rendered: 0,
    chunkSize: 20,
    totalCount: 0,
    summaryEl: null,
    listEl: null,
    loadMoreWrapper: null,
    loadMoreBtn: null,
    lastChapter: '',
    lastPage: '',
    closeOverlay: null,
    overlayKeyHandler: null,
    overlayClickHandler: null,
    sidebarContainer: null,
    sidebarSummary: null,
    sidebarList: null,
    sidebarQuery: null,
    sidebarClearBtn: null,
    sidebarData: null
  };

  const MAX_SNIPPETS_PER_PAGE = 20;
  const MAX_MATCHES_SCAN = 400;

  function collectBookPages() {
    if (SEARCH_STATE.pages.length) return SEARCH_STATE.pages;
    // file:// では他ページfetchがブロックされるため現在ページのみ
    if (location.protocol === 'file:') {
      const sections = Array.from(document.querySelectorAll('section.chapter-page'));
      const baseUrl = window.location.href.split('#')[0];
      if (!sections.length) {
        SEARCH_STATE.localSections = [];
        SEARCH_STATE.pages = [baseUrl];
        return SEARCH_STATE.pages;
      }
      SEARCH_STATE.localSections = sections.map(section => {
        const id = section.id || '';
        const url = id ? `${baseUrl}#${id}` : baseUrl;
        return { id, url, element: section };
      });
      SEARCH_STATE.pages = SEARCH_STATE.localSections.map(entry => entry.url);
      return SEARCH_STATE.pages;
    }
    const sidebar = document.querySelector('#quarto-sidebar .sidebar-menu-container');
    const hrefs = new Set();
    if (sidebar) {
      sidebar.querySelectorAll('a[href]')?.forEach(a => {
        const href = a.getAttribute('href');
        if (!href) return;
        if (href.startsWith('http')) return;
        if (href.startsWith('#')) return;
        hrefs.add(new URL(href, window.location.href).href);
      });
    }
    // Also add current page
    hrefs.add(window.location.href);
    SEARCH_STATE.pages = Array.from(hrefs);
    SEARCH_STATE.localSections = [];
    return SEARCH_STATE.pages;
  }

  function normalizeWhitespace(text) {
    return (text || '').replace(/\s+/g, ' ').trim();
  }

  function deriveSectionTitle(section, fallback) {
    if (!section) return fallback || 'このページ';
    const selectors = ['h1 .chapter-title', 'h1', '.chapter-title', 'header .title', 'h2', 'h3'];
    for (const sel of selectors) {
      const el = section.querySelector(sel);
      if (el) {
        const txt = normalizeWhitespace(el.textContent);
        if (txt) return txt;
      }
    }
    const heading = Array.from(section.querySelectorAll('h1, h2, h3, h4, h5')).find(h => normalizeWhitespace(h.textContent));
    if (heading) return normalizeWhitespace(heading.textContent);
    const id = section.id || '';
    if (id) return normalizeWhitespace(id.replace(/^page-/, '').replace(/[-_]+/g, ' ')) || (fallback || 'このページ');
    return fallback || 'このページ';
  }

  function extractSectionText(section) {
    if (!section) return '';
    const clone = section.cloneNode(true);
    const removable = [
      'script',
      'style',
      'nav',
      '.single-pager',
      '.margin-note',
      '.right-footnotes',
      '.right-comments',
      '.right-both',
      '.comment-menu-popup',
      '.global-search-overlay',
      '.global-search-dialog',
      '.marker-toolbar'
    ];
    removable.forEach(sel => clone.querySelectorAll(sel).forEach(el => el.remove()));
    return normalizeWhitespace(clone.textContent || '');
  }

  async function buildSearchIndex() {
    if (SEARCH_STATE.loaded || SEARCH_STATE.loading) return;
    SEARCH_STATE.loading = true;
    SEARCH_STATE.index = {};
    const pages = collectBookPages();

    if (location.protocol === 'file:') {
      const baseUrl = window.location.href.split('#')[0];
      if (!SEARCH_STATE.localSections || !SEARCH_STATE.localSections.length) {
        collectBookPages();
      }
      const docTitle = normalizeWhitespace(document.querySelector('header .title')?.textContent || document.title || '');
      const sections = (SEARCH_STATE.localSections && SEARCH_STATE.localSections.length)
        ? SEARCH_STATE.localSections
        : [];
      const seen = new Set();
      if (sections.length) {
        sections.forEach(entry => {
          const section = entry.element;
          const url = entry.url || (entry.id ? `${baseUrl}#${entry.id}` : baseUrl);
          const title = deriveSectionTitle(section, docTitle || baseUrl);
          const text = extractSectionText(section);
          SEARCH_STATE.index[url] = { url, title, text, slug: entry.id };
          seen.add(url);
        });
        const hasIndex = sections.some(entry => (entry.id || '').toLowerCase() === 'page-index');
        if (!hasIndex) {
          const main = document.querySelector('main#quarto-document-content') || document.querySelector('main') || document.body;
          if (main) {
            const text = extractSectionText(main);
            const url = baseUrl;
            if (!seen.has(url)) {
              const title = deriveSectionTitle(main, docTitle || baseUrl);
              SEARCH_STATE.index[url] = { url, title, text };
            }
          }
        }
      } else {
        const main = document.querySelector('main#quarto-document-content') || document.querySelector('main') || document.body;
        const text = extractSectionText(main);
        SEARCH_STATE.index[baseUrl] = { url: baseUrl, title: docTitle || baseUrl, text };
      }
      SEARCH_STATE.loaded = true;
      SEARCH_STATE.loading = false;
      return;
    }

    const fetchPage = async (url) => {
      try {
        const res = await fetch(url);
        const html = await res.text();
        const doc = new DOMParser().parseFromString(html, 'text/html');
        const title = (doc.querySelector('header .title')?.textContent || doc.querySelector('title')?.textContent || '').trim();
        const main = doc.querySelector('main') || doc.querySelector('#quarto-document-content') || doc.body;
        const text = (main.textContent || '').replace(/\s+/g, ' ').trim();
        return { url, title, text };
      } catch (e) {
        console.warn('Search: failed to fetch', url, e);
        return { url, title: url, text: '' };
      }
    };

    const results = await Promise.all(pages.map(fetchPage));
    results.forEach(r => { SEARCH_STATE.index[r.url] = r; });
    SEARCH_STATE.loaded = true;
    SEARCH_STATE.loading = false;
  }

  function openSearchOverlay(initialQuery = '') {
    const startQuery = (typeof initialQuery === 'string') ? initialQuery.trim() : '';
    let overlay = document.querySelector('.global-search-overlay');
    if (overlay) overlay.remove();

    overlay = document.createElement('div');
    overlay.className = 'global-search-overlay';
    overlay.innerHTML = `
      <div class="global-search-dialog" role="dialog" aria-modal="true" aria-label="全ページ検索">
        <div class="global-search-header">
          <h3>検索</h3>
          <button class="global-search-close" aria-label="閉じる">×</button>
        </div>
        <div class="global-search-input-wrapper">
          <input id="global-search-input" type="text" placeholder="キーワードを入力 (Ctrl/Cmd + K)" autocomplete="off" />
          <button id="global-search-btn">検索</button>
        </div>
        <div class="global-search-results">
          <div class="search-help">検索語を入力してください。</div>
        </div>
      </div>
    `;
    document.body.appendChild(overlay);
    overlay.style.display = 'block';
    document.body.classList.add('search-overlay-active');

    const close = () => {
      if (overlay && overlay.parentNode) {
        overlay.parentNode.removeChild(overlay);
      }
      document.body.classList.remove('search-overlay-active');
      if (SEARCH_RESULTS_VIEW.overlayKeyHandler) {
        document.removeEventListener('keydown', SEARCH_RESULTS_VIEW.overlayKeyHandler, true);
        SEARCH_RESULTS_VIEW.overlayKeyHandler = null;
      }
      if (SEARCH_RESULTS_VIEW.overlayClickHandler) {
        document.removeEventListener('click', SEARCH_RESULTS_VIEW.overlayClickHandler, true);
        SEARCH_RESULTS_VIEW.overlayClickHandler = null;
      }
      resetSearchResultsView();
      SEARCH_RESULTS_VIEW.closeOverlay = null;
    };
    overlay.addEventListener('click', (e) => { if (e.target === overlay) close(); });
    overlay.querySelector('.global-search-close')?.addEventListener('click', close);

    const input = overlay.querySelector('#global-search-input');
    const btn = overlay.querySelector('#global-search-btn');
    const syncSidebarInput = () => {};
    input.value = startQuery;
    input.focus();

    const ensureIndex = async () => {
      if (!SEARCH_STATE.loaded) {
        const results = overlay.querySelector('.global-search-results');
        results.innerHTML = '<div class="search-loading">索引を作成中...</div>';
        await buildSearchIndex();
      }
    };

    const doSearch = async () => {
      const q = (input.value || '').trim();
      syncSidebarInput(q);
      const resultsEl = overlay.querySelector('.global-search-results');
      if (!q) {
        resultsEl.innerHTML = '<div class="search-help">検索語を入力してください。</div>';
        resetSearchResultsView();
        return;
      }
      await ensureIndex();
      const results = [];
      for (const url of Object.keys(SEARCH_STATE.index)) {
        const item = SEARCH_STATE.index[url];
        if (!item || !item.text) continue;
        const page = {
          url,
          title: item.title || url,
          chapter: item.title || ''
        };
        const matches = findMatches(item.text, q, MAX_SNIPPETS_PER_PAGE);
        matches.forEach(match => {
          results.push({
            page,
            context: match.context,
            matchCount: match.totalMatches,
            totalMatches: match.totalMatches,
            matchIndex: match.matchIndex,
            remainingMatches: match.remainingMatches
          });
        });
      }
      renderResults(resultsEl, results, q);
    };

    const debouncedSearch = debounce(doSearch, 200);

    const dialog = overlay.querySelector('.global-search-dialog');
    const keyHandler = (event) => {
      if (event.key === 'Escape') {
        event.preventDefault();
        close();
      }
    };
    const clickHandler = (event) => {
      if (dialog && !dialog.contains(event.target)) {
        close();
      }
    };
    document.addEventListener('keydown', keyHandler, true);
    document.addEventListener('click', clickHandler, true);
    SEARCH_RESULTS_VIEW.overlayKeyHandler = keyHandler;
    SEARCH_RESULTS_VIEW.overlayClickHandler = clickHandler;
    SEARCH_RESULTS_VIEW.closeOverlay = close;

    input.addEventListener('input', () => { debouncedSearch(); });
    input.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') { e.preventDefault(); doSearch(); }
      if (e.key === 'Escape') { e.preventDefault(); close(); }
    });
    btn.addEventListener('click', () => { doSearch(); });

    if (startQuery.length) {
      doSearch();
      const end = input.value.length;
      input.setSelectionRange(end, end);
    }

    return { overlay, input, close };
  }

  function findMatches(text, query, limit) {
    if (!text || !query) return [];
    const sanitized = text.replace(/\s+/g, ' ');
    const hay = sanitized.toLowerCase();
    const needle = query.toLowerCase();
    const indices = [];
    let pos = 0;
    let safety = 0;
    while (pos < hay.length) {
      const idx = hay.indexOf(needle, pos);
      if (idx === -1) break;
      indices.push(idx);
      pos = idx + needle.length;
      safety += 1;
      if (safety >= MAX_MATCHES_SCAN) break;
    }
    const total = indices.length;
    if (!total) return [];
    const clamp = Math.min(total, limit || MAX_SNIPPETS_PER_PAGE);
    const results = [];
    for (let i = 0; i < clamp; i += 1) {
      const start = Math.max(0, indices[i] - 80);
      const end = Math.min(sanitized.length, indices[i] + query.length + 80);
      let snippet = sanitized.slice(start, end);
      snippet = highlight(snippet, query);
      if (start > 0) snippet = '…' + snippet;
      if (end < sanitized.length) snippet = snippet + '…';
      const remainingMatches = (total > clamp && i === clamp - 1) ? total - clamp : 0;
      if (remainingMatches > 0) {
        snippet += `<span class="search-result-more">他${remainingMatches}件の一致</span>`;
      }
      results.push({
        context: snippet,
        matchIndex: i,
        totalMatches: total,
        remainingMatches
      });
    }
    return results;
  }

  function escapeHtml(s) {
    return (s || '').replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[c]));
  }

  function highlight(text, query) {
    const escQ = query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    return text.replace(new RegExp(escQ, 'gi'), m => `<mark>${escapeHtml(m)}</mark>`);
  }

  function fmtMMDDHHmm(t){
    const d = new Date(t); const pad = (n)=>String(n).padStart(2,'0');
    return `${pad(d.getMonth()+1)}/${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}`;
  }

  // --- グローバル一覧モーダル（プレビュー / コメント / マーカー） ---
  function openGlobalListOverlay() {
    try {
      const existing = document.querySelector('.global-list-overlay');
      if (existing) existing.remove();

      const overlay = document.createElement('div');
      overlay.className = 'global-list-overlay';
      overlay.style.position = 'fixed';
      overlay.style.inset = '0';
      overlay.style.background = 'rgba(0,0,0,0.45)';
      overlay.style.zIndex = '1700';
      overlay.style.display = 'flex';
      overlay.style.alignItems = 'center';
      overlay.style.justifyContent = 'center';

      const dialog = document.createElement('div');
      dialog.className = 'global-list-dialog';
      dialog.style.background = '#fff';
      dialog.style.borderRadius = '10px';
      dialog.style.boxShadow = '0 10px 30px rgba(0,0,0,0.3)';
      dialog.style.maxWidth = '720px';
      dialog.style.width = '96vw';
      dialog.style.maxHeight = '80vh';
      dialog.style.display = 'flex';
      dialog.style.flexDirection = 'column';
      dialog.style.overflow = 'hidden';

      const header = document.createElement('div');
      header.style.display = 'flex';
      header.style.alignItems = 'center';
      header.style.justifyContent = 'space-between';
      header.style.padding = '10px 14px';
      header.style.borderBottom = '1px solid #e1e5e9';
      const title = document.createElement('h3');
      title.textContent = 'プレビュー / コメント / マーカー一覧';
      title.style.margin = '0';
      title.style.fontSize = '15px';
      title.style.fontWeight = '600';
      const closeBtn = document.createElement('button');
      closeBtn.type = 'button';
      closeBtn.textContent = '×';
      closeBtn.setAttribute('aria-label', '閉じる');
      closeBtn.style.border = 'none';
      closeBtn.style.background = 'none';
      closeBtn.style.cursor = 'pointer';
      closeBtn.style.fontSize = '18px';
      closeBtn.style.lineHeight = '1';
      closeBtn.style.marginLeft = '12px';
      header.appendChild(title);
      header.appendChild(closeBtn);

      const tabs = document.createElement('div');
      tabs.style.display = 'flex';
      tabs.style.borderBottom = '1px solid #e1e5e9';

      const tabNames = [
        { id: 'previews-docs', label: 'Docsプレビュー' },
        { id: 'previews-bg', label: 'BGプレビュー' },
        { id: 'comments', label: 'コメント' },
        { id: 'markers', label: 'マーカー' }
      ];
      const panels = {};

      tabNames.forEach((t, idx) => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.textContent = t.label;
        btn.dataset.tab = t.id;
        btn.style.flex = '1';
        btn.style.padding = '8px 10px';
        btn.style.border = 'none';
        btn.style.borderBottom = idx === 0 ? '2px solid #1a73e8' : '2px solid transparent';
        btn.style.background = idx === 0 ? '#ffffff' : '#f8f9fa';
        btn.style.cursor = 'pointer';
        btn.style.fontSize = '13px';
        btn.style.fontWeight = idx === 0 ? '600' : '500';
        btn.addEventListener('click', () => {
          const current = dialog.querySelectorAll('.global-list-tab');
          for (let i = 0; i < current.length; i++) {
            const b = current[i];
            const active = b === btn;
            b.style.borderBottom = active ? '2px solid #1a73e8' : '2px solid transparent';
            b.style.background = active ? '#ffffff' : '#f8f9fa';
            b.style.fontWeight = active ? '600' : '500';
          }
          Object.keys(panels).forEach(id => {
            panels[id].style.display = id === t.id ? 'block' : 'none';
          });
          if (t.id === 'previews-docs') renderGlobalPreviewList(panels['previews-docs'], 'gdoc');
          if (t.id === 'previews-bg') renderGlobalPreviewList(panels['previews-bg'], 'bg');
          if (t.id === 'comments') renderGlobalCommentList(panels.comments);
          if (t.id === 'markers') renderGlobalMarkerList(panels.markers);
        });
        btn.className = 'global-list-tab';
        tabs.appendChild(btn);
      });

      const body = document.createElement('div');
      body.style.flex = '1';
      body.style.overflowY = 'auto';
      body.style.padding = '10px 14px 12px';
      body.style.fontSize = '13px';

      tabNames.forEach((t, idx) => {
        const panel = document.createElement('div');
        panel.className = 'global-list-panel global-list-' + t.id;
        panel.style.display = idx === 0 ? 'block' : 'none';
        body.appendChild(panel);
        panels[t.id] = panel;
      });

      dialog.appendChild(header);
      dialog.appendChild(tabs);
      dialog.appendChild(body);
      overlay.appendChild(dialog);
      document.body.appendChild(overlay);

      const close = () => {
        if (overlay && overlay.parentNode) overlay.parentNode.removeChild(overlay);
      };
      closeBtn.addEventListener('click', close);
      overlay.addEventListener('click', (e) => {
        if (e.target === overlay) close();
      });

      // 初期タブ: Docsプレビュー
      renderGlobalPreviewList(panels['previews-docs'], 'gdoc');
    } catch (e) {
      console.warn('openGlobalListOverlay failed', e);
    }
  }

  function loadPreviewItemsForGlobalList() {
    var items = [];
    try {
      if (window.__gdocPreviewAPI__ && typeof window.__gdocPreviewAPI__.getItems === 'function') {
        items = window.__gdocPreviewAPI__.getItems() || [];
      } else {
        var raw = window.localStorage.getItem('gdocPreviewState_v2');
        if (raw) {
          var parsed = JSON.parse(raw);
          if (parsed && Array.isArray(parsed.items)) items = parsed.items;
        }
      }
    } catch (e) {
      console.warn('loadPreviewItemsForGlobalList failed', e);
      items = [];
    }
    return items;
  }

  function renderGlobalPreviewList(panel, kind) {
    if (!panel) return;
    panel.innerHTML = '';
    var allItems = loadPreviewItemsForGlobalList();
    var items = kind ? allItems.filter(function (item) {
      return item.kind === kind;
    }) : allItems;
    
    if (!items || !items.length) {
      var empty = document.createElement('p');
      var msg = kind === 'gdoc' ? '現在Docsプレビュー中の文書はありません。' :
                kind === 'bg' ? '現在BGプレビュー中の文書はありません。' :
                '現在プレビュー中の文書はありません。';
      empty.textContent = msg;
      empty.style.cssText = 'margin:4px 0;color:#6c757d;';
      panel.appendChild(empty);
      return;
    }

    var list = document.createElement('ul');
    list.style.listStyle = 'none';
    list.style.padding = '0';
    list.style.margin = '0';

    items.forEach(function (item) {
      var li = document.createElement('li');
      li.style.cssText = 'margin:6px 0;padding:6px 8px;border-radius:6px;border:1px solid #e1e5e9;display:flex;flex-direction:column;gap:4px;';

      var titleRow = document.createElement('div');
      titleRow.style.cssText = 'display:flex;align-items:center;gap:8px;';
      var titleSpan = document.createElement('span');
      titleSpan.style.flex = '1';
      titleSpan.style.fontWeight = '500';
      titleSpan.textContent = item.title || item.href || item.id || '(無題)';
      var stateSpan = document.createElement('span');
      stateSpan.style.fontSize = '11px';
      stateSpan.style.color = '#6c757d';
      stateSpan.textContent = item.state === 'active' ? '表示中' : '格納中';
      titleRow.appendChild(titleSpan);
      titleRow.appendChild(stateSpan);

      var actions = document.createElement('div');
      actions.style.cssText = 'display:flex;gap:4px;flex-wrap:wrap;';

      // 「表示」ボタン（目アイコン）
      var btnShow = document.createElement('button');
      btnShow.type = 'button';
      btnShow.className = 'gdoc-toast-btn';
      btnShow.setAttribute('aria-label', 'プレビュー表示');
      btnShow.title = 'プレビュー表示';
      btnShow.innerHTML = '<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M12 5C7 5 3.1 8 1.5 12 3.1 16 7 19 12 19s8.9-3 10.5-7C20.9 8 17 5 12 5zm0 10a3 3 0 110-6 3 3 0 010 6z"></path></svg>';
      btnShow.addEventListener('click', function () {
        if (window.__gdocPreviewAPI__ && typeof window.__gdocPreviewAPI__.activate === 'function') {
          window.__gdocPreviewAPI__.activate(item.key);
        }
      });

      // 「本文へ」ボタン（ジャンプアイコン）
      var btnJump = document.createElement('button');
      btnJump.type = 'button';
      btnJump.className = 'gdoc-toast-btn';
      btnJump.setAttribute('aria-label', '本文へ移動');
      btnJump.title = '本文へ移動';
      btnJump.innerHTML = '<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M12 2c-.55 0-1 .45-1 1v12.59l-4.3-4.3a1 1 0 10-1.4 1.42l6 6a1 1 0 001.4 0l6-6a1 1 0 10-1.4-1.42L13 15.59V3c0-.55-.45-1-1-1z"></path></svg>';
      btnJump.addEventListener('click', function () {
        if (window.__gdocPreviewAPI__ && typeof window.__gdocPreviewAPI__.jumpToSource === 'function') {
          window.__gdocPreviewAPI__.jumpToSource(item.key);
        }
      });

      // 「他タブで開く」ボタン（外部リンクアイコン）
      var btnTab = document.createElement('button');
      btnTab.type = 'button';
      btnTab.className = 'gdoc-toast-btn';
      btnTab.setAttribute('aria-label', '別タブで開く');
      btnTab.title = '別タブで開く';
      btnTab.innerHTML = '<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M14 3h7v7h-2V6.41l-9.29 9.3-1.42-1.42 9.3-9.29H14V3z"></path><path d="M5 5h5V3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2v-5h-2v5H5V5z"></path></svg>';
      btnTab.addEventListener('click', function () {
        var url = item.href || item.previewUrl;
        if (url) window.open(url, '_blank', 'noopener');
      });

      // 「閉じる」ボタン（×アイコン）
      var btnClose = document.createElement('button');
      btnClose.type = 'button';
      btnClose.className = 'gdoc-toast-btn';
      btnClose.setAttribute('aria-label', '閉じる');
      btnClose.title = '閉じる';
      btnClose.innerHTML = '<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M5.293 6.707l5.293 5.293-5.293 5.293c-.39.39-.39 1.024 0 1.414s1.024.39 1.414 0l5.293-5.293 5.293 5.293c.39.39 1.024.39 1.414 0s.39-1.024 0-1.414L13.414 12l5.293-5.293c.39-.39.39-1.024 0-1.414s-1.024-.39-1.414 0L12 10.586 6.707 5.293c-.39-.39-1.024-.39-1.414 0s-.39 1.024 0 1.414z"></path></svg>';
      btnClose.addEventListener('click', function () {
        if (window.__gdocPreviewAPI__ && typeof window.__gdocPreviewAPI__.close === 'function') {
          window.__gdocPreviewAPI__.close(item.key);
          renderGlobalPreviewList(panel);
        }
      });

      actions.appendChild(btnShow);
      actions.appendChild(btnJump);
      actions.appendChild(btnTab);
      actions.appendChild(btnClose);

      li.appendChild(titleRow);
      li.appendChild(actions);
      list.appendChild(li);
    });

    panel.appendChild(list);
  }

  var GLOBAL_LIST_SCOPE = {
    comments: 'page',
    markers: 'page'
  };

  function renderGlobalCommentList(panel) {
    if (!panel) return;
    panel.innerHTML = '';
    var scope = GLOBAL_LIST_SCOPE.comments || 'page';

    // スコープ切り替えトグル（このページ / 全ページ）
    var ctrl = document.createElement('div');
    ctrl.style.cssText = 'display:flex;align-items:center;justify-content:flex-end;margin-bottom:6px;gap:6px;font-size:11px;color:#6c757d;';
    var label = document.createElement('label');
    label.style.display = 'inline-flex';
    label.style.alignItems = 'center';
    label.style.gap = '4px';
    var checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.checked = scope === 'all';
    checkbox.addEventListener('change', function () {
      GLOBAL_LIST_SCOPE.comments = checkbox.checked ? 'all' : 'page';
      renderGlobalCommentList(panel);
    });
    label.appendChild(checkbox);
    label.appendChild(document.createTextNode('全ページ'));
    ctrl.appendChild(label);
    panel.appendChild(ctrl);

    var key = typeof pageKey === 'function' ? pageKey() : window.location.pathname;
    var list = [];
    if (scope === 'page') {
      // コメントパネルと同じロジックで、このページ上のコメントを取得
      if (typeof getActiveComments === 'function') {
        list = getActiveComments().slice();
      } else if (typeof COMMENTS_DB === 'object' && COMMENTS_DB && COMMENTS_DB[key]) {
        list = COMMENTS_DB[key].slice();
      } else {
        list = [];
      }
    } else {
      if (typeof COMMENTS_DB === 'object' && COMMENTS_DB) {
        Object.keys(COMMENTS_DB).forEach(function (k) {
          (COMMENTS_DB[k] || []).forEach(function (rec) {
            list.push({ __pageKey: k, rec: rec });
          });
        });
      }
    }
    if (!list.length) {
      var empty = document.createElement('p');
      empty.textContent = scope === 'page' ? 'このページにはコメントがありません。' : '全ページにコメントがありません。';
      empty.style.cssText = 'margin:4px 0;color:#6c757d;';
      panel.appendChild(empty);
      return;
    }

    // 並び替え（新しい順）
    list.sort(function (a, b) {
      var ra = scope === 'page' ? a : a.rec;
      var rb = scope === 'page' ? b : b.rec;
      return (rb.t || 0) - (ra.t || 0);
    });

    var ul = document.createElement('ul');
    ul.style.listStyle = 'none';
    ul.style.padding = '0';
    ul.style.margin = '0';

    list.forEach(function (entry) {
      var rec = scope === 'page' ? entry : entry.rec;
      var pageKeyForRec = scope === 'page' ? key : entry.__pageKey;

      var li = document.createElement('li');
      li.style.cssText = 'margin:6px 0;padding:6px 8px;border-radius:6px;border:1px solid #e1e5e9;';

      var meta = document.createElement('div');
      meta.style.cssText = 'font-size:11px;color:#6c757d;display:flex;gap:8px;align-items:center;margin-bottom:4px;';
      var time = document.createElement('span');
      time.textContent = fmtMMDDHHmm(rec.t || Date.now());
      meta.appendChild(time);
      if (scope === 'all' && pageKeyForRec !== key) {
        var pageLabel = document.createElement('span');
        pageLabel.textContent = pageKeyForRec;
        pageLabel.style.maxWidth = '220px';
        pageLabel.style.overflow = 'hidden';
        pageLabel.style.textOverflow = 'ellipsis';
        meta.appendChild(pageLabel);
      }
      var move = document.createElement('button');
      move.type = 'button';
      move.textContent = '移動';
      move.style.cssText = 'padding:2px 6px;font-size:11px;border-radius:4px;border:1px solid #6c757d;background:#fff;cursor:pointer;';
      move.addEventListener('click', function () {
        if (scope === 'page' || pageKeyForRec === key) {
          scrollToComment(rec);
        } else {
          // 別ページのコメントの場合はそのページを開く
          try {
            window.location.href = pageKeyForRec;
          } catch (e) {
            window.location.assign(pageKeyForRec);
          }
        }
      });
      meta.appendChild(move);

      var target = document.createElement('div');
      target.style.cssText = 'font-size:13px;color:#495057;background:#f8f9fa;padding:4px 6px;border-radius:4px;margin-bottom:4px;';
      target.textContent = rec.text || '';
      var body = document.createElement('div');
      body.style.cssText = 'white-space:pre-wrap;line-height:1.5;';
      body.textContent = rec.body || '';

      li.appendChild(meta);
      li.appendChild(target);
      li.appendChild(body);
      ul.appendChild(li);
    });

    panel.appendChild(ul);
  }

  function renderGlobalMarkerList(panel) {
    if (!panel) return;
    panel.innerHTML = '';
    var scope = GLOBAL_LIST_SCOPE.markers || 'page';

    var ctrl = document.createElement('div');
    ctrl.style.cssText = 'display:flex;align-items:center;justify-content:flex-end;margin-bottom:6px;gap:6px;font-size:11px;color:#6c757d;';
    var label = document.createElement('label');
    label.style.display = 'inline-flex';
    label.style.alignItems = 'center';
    label.style.gap = '4px';
    var checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.checked = scope === 'all';
    checkbox.addEventListener('change', function () {
      GLOBAL_LIST_SCOPE.markers = checkbox.checked ? 'all' : 'page';
      renderGlobalMarkerList(panel);
    });
    label.appendChild(checkbox);
    label.appendChild(document.createTextNode('全ページ'));
    ctrl.appendChild(label);
    panel.appendChild(ctrl);

    var markersDB;
    try {
      markersDB = JSON.parse(window.localStorage.getItem(STORAGE_KEYS.markers) || '{}') || {};
    } catch (e) {
      markersDB = {};
    }
    var page = window.location.pathname;
    var list = [];
    if (scope === 'page') {
      list = markersDB[page] || [];
    } else {
      Object.keys(markersDB).forEach(function (k) {
        (markersDB[k] || []).forEach(function (m) {
          list.push({ __pageKey: k, marker: m });
        });
      });
    }
    if (!list.length) {
      var empty = document.createElement('p');
      empty.textContent = scope === 'page' ? 'このページにはマーカーがありません。' : '全ページにマーカーがありません。';
      empty.style.cssText = 'margin:4px 0;color:#6c757d;';
      panel.appendChild(empty);
      return;
    }

    var ul = document.createElement('ul');
    ul.style.listStyle = 'none';
    ul.style.padding = '0';
    ul.style.margin = '0';

    list.forEach(function (entry) {
      var m = scope === 'page' ? entry : entry.marker;
      var pageKeyForMarker = scope === 'page' ? page : entry.__pageKey;

      var li = document.createElement('li');
      li.style.cssText = 'margin:6px 0;padding:6px 8px;border-radius:6px;border:1px solid #e1e5e9;display:flex;flex-direction:column;gap:4px;';

      var row = document.createElement('div');
      row.style.cssText = 'display:flex;align-items:center;gap:8px;';
      var label = document.createElement('span');
      label.style.flex = '1';
      label.textContent = (function () {
        var span = document.querySelector('.text-marker[data-marker-id="' + m.id + '"]');
        if (span && span.textContent) return span.textContent.slice(0, 80);
        return '(マーカー)';
      })();
      if (scope === 'all' && pageKeyForMarker !== page) {
        label.textContent = '[' + pageKeyForMarker + '] ' + label.textContent;
      }
      var colorSwatch = document.createElement('span');
      colorSwatch.style.display = 'inline-block';
      colorSwatch.style.width = '10px';
      colorSwatch.style.height = '10px';
      colorSwatch.style.borderRadius = '2px';
      var colorMap = { yellow:'#fff59d', green:'#c8e6c9', blue:'#bbdefb', pink:'#f8bbd0', orange:'#ffcc80' };
      colorSwatch.style.backgroundColor = colorMap[m.color] || '#fff59d';
      row.appendChild(label);
      row.appendChild(colorSwatch);

      var actions = document.createElement('div');
      actions.style.cssText = 'display:flex;gap:6px;flex-wrap:wrap;';
      var btnMove = document.createElement('button');
      btnMove.type = 'button';
      btnMove.textContent = '移動';
      btnMove.style.cssText = 'padding:3px 8px;font-size:11px;border-radius:4px;border:1px solid #6c757d;background:#fff;cursor:pointer;';
      btnMove.addEventListener('click', function () {
        try {
          if (scope === 'page' || pageKeyForMarker === page) {
            var span = document.querySelector('.text-marker[data-marker-id="' + m.id + '"]');
            if (span && typeof span.scrollIntoView === 'function') {
              var el = span;
              while (el && el !== document.body && !(el instanceof HTMLElement)) {
                el = el.parentElement;
              }
              if (!el) el = span;
              el.scrollIntoView({ behavior: 'smooth', block: 'center' });
              try {
                var prevBox = el.style.boxShadow;
                el.style.transition = 'box-shadow 0.3s ease';
                el.style.boxShadow = '0 0 0 3px rgba(26,115,232,0.5)';
                setTimeout(function () {
                  el.style.boxShadow = prevBox || '';
                }, 1600);
              } catch (e2) {}
            }
          } else {
            window.location.href = pageKeyForMarker;
          }
        } catch (e) {}
      });
      var btnDelete = document.createElement('button');
      btnDelete.type = 'button';
      btnDelete.textContent = '削除';
      btnDelete.style.cssText = 'padding:3px 8px;font-size:11px;border-radius:4px;border:1px solid #dc3545;background:#fff;color:#dc3545;cursor:pointer;';
      btnDelete.addEventListener('click', function () {
        try {
          // remove spans
          document.querySelectorAll('.text-marker[data-marker-id="' + m.id + '"]').forEach(function (el) {
            var parent = el.parentNode;
            while (el.firstChild) parent.insertBefore(el.firstChild, el);
            parent.removeChild(el);
          });
          // update storage
          var db = markersDB[page] || [];
          markersDB[page] = db.filter(function (x) { return x.id !== m.id; });
          if (!markersDB[page].length) delete markersDB[page];
          window.localStorage.setItem(STORAGE_KEYS.markers, JSON.stringify(markersDB));
          renderGlobalMarkerList(panel);
        } catch (e) {
          console.warn('failed to delete marker group', e);
        }
      });

      actions.appendChild(btnMove);
      actions.appendChild(btnDelete);

      li.appendChild(row);
      li.appendChild(actions);
      ul.appendChild(li);
    });

    panel.appendChild(ul);
  }

  function renderResults(container, results, query) {
    if (!container) return;

    if (!results.length) {
      container.innerHTML = `<div class="search-no-results"><p>一致が見つかりませんでした。</p><ul><li>語句を短くする</li><li>別のキーワードを試す</li></ul></div>`;
      resetSearchResultsView();
      return;
    }

    resetSearchResultsView();
    clearSearchHighlights();
    SEARCH_RESULTS_VIEW.results = results;
    SEARCH_RESULTS_VIEW.query = query;
    SEARCH_RESULTS_VIEW.totalCount = results.length + results.reduce((sum, r) => sum + (r.remainingMatches || 0), 0);

    container.innerHTML = '';

    const summary = document.createElement('div');
    summary.className = 'search-results-summary';
    container.appendChild(summary);
    SEARCH_RESULTS_VIEW.summaryEl = summary;

    const listWrap = document.createElement('div');
    listWrap.className = 'search-results-items';
    container.appendChild(listWrap);
    SEARCH_RESULTS_VIEW.listEl = listWrap;

    const loadMoreWrapper = document.createElement('div');
    loadMoreWrapper.className = 'search-load-more-wrapper';
    const loadMoreBtn = document.createElement('button');
    loadMoreBtn.type = 'button';
    loadMoreBtn.className = 'search-load-more-btn';
    loadMoreBtn.textContent = 'さらに表示';
    loadMoreWrapper.appendChild(loadMoreBtn);
    container.appendChild(loadMoreWrapper);
    SEARCH_RESULTS_VIEW.loadMoreWrapper = loadMoreWrapper;
    SEARCH_RESULTS_VIEW.loadMoreBtn = loadMoreBtn;
    loadMoreBtn.addEventListener('click', () => renderOverlayResultsChunk());

    renderOverlayResultsChunk(true);
  }

  function renderOverlayResultsChunk(reset = false) {
    const state = SEARCH_RESULTS_VIEW;
    if (!state.listEl) return;

    if (reset) {
      state.listEl.innerHTML = '';
      state.rendered = 0;
      state.lastChapter = '';
      state.lastPage = '';
    }

    const total = state.results.length;
    if (state.rendered >= total) {
      updateOverlayResultsSummary();
      if (state.loadMoreWrapper) state.loadMoreWrapper.style.display = 'none';
      return;
    }

    const limit = Math.min(total, state.rendered + state.chunkSize);
    for (let i = state.rendered; i < limit; i += 1) {
      const result = state.results[i];
      const chapter = result.page?.chapter || '';
      const pageUrl = result.page?.url || '';

      if (chapter && (chapter !== state.lastChapter || pageUrl !== state.lastPage)) {
        const section = document.createElement('section');
        section.className = 'search-chapter-section';
        const heading = document.createElement('h4');
        heading.className = 'search-chapter-title';
        heading.textContent = chapter;
        section.appendChild(heading);
        state.listEl.appendChild(section);
        state.lastChapter = chapter;
        state.lastPage = pageUrl;
      }

      const item = document.createElement('div');
      item.className = 'search-result-item';

      const titleRow = document.createElement('div');
      titleRow.className = 'search-result-title';

      const link = document.createElement('a');
      link.className = 'search-result-link';
      link.href = result.page?.url || '#';
      link.textContent = result.page?.title || result.page?.url || 'ページ';
      link.addEventListener('click', (event) => {
        event.preventDefault();
        handleOverlayResultSelection(result);
      });

      const order = document.createElement('span');
      order.className = 'search-snippet-order';
      order.textContent = `${(result.matchIndex || 0) + 1}/${result.totalMatches || result.matchCount || 1}`;

      const badge = document.createElement('span');
      badge.className = 'search-match-count';
      badge.textContent = `${result.totalMatches || result.matchCount || 1}件`;

      titleRow.appendChild(link);
      titleRow.appendChild(order);
      titleRow.appendChild(badge);
      item.appendChild(titleRow);

      const ctx = document.createElement('div');
      ctx.className = 'search-result-context';
      ctx.innerHTML = result.context;
      item.appendChild(ctx);

      state.listEl.appendChild(item);
    }

    state.rendered = limit;
    updateOverlayResultsSummary();

    if (state.loadMoreWrapper) {
      state.loadMoreWrapper.style.display = state.rendered >= total ? 'none' : '';
    }
  }

  function updateOverlayResultsSummary() {
    const state = SEARCH_RESULTS_VIEW;
    if (!state.summaryEl) return;
    const hiddenCount = state.results.reduce((sum, item) => sum + (item.remainingMatches || 0), 0);
    const totalMatches = state.results.length + hiddenCount;
    const shownMatches = Math.min(state.rendered, state.results.length);
    const escapedQuery = escapeHtml(state.query);
    state.summaryEl.innerHTML = `
      <p><strong>${totalMatches}</strong>件の結果（「${escapedQuery}」）</p>
      <p class="search-results-muted">${shownMatches}件を表示中${hiddenCount > 0 ? `（他${hiddenCount}件）` : ''}</p>
    `;
  }

  function resetSearchResultsView() {
    SEARCH_RESULTS_VIEW.results = [];
    SEARCH_RESULTS_VIEW.query = '';
    SEARCH_RESULTS_VIEW.rendered = 0;
    SEARCH_RESULTS_VIEW.totalCount = 0;
    SEARCH_RESULTS_VIEW.summaryEl = null;
    SEARCH_RESULTS_VIEW.listEl = null;
    SEARCH_RESULTS_VIEW.loadMoreWrapper = null;
    SEARCH_RESULTS_VIEW.loadMoreBtn = null;
    SEARCH_RESULTS_VIEW.lastChapter = '';
    SEARCH_RESULTS_VIEW.lastPage = '';
  }

  function setupKeyboardShortcuts() {
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        const dialogs = document.querySelectorAll('.global-search-dialog');
        dialogs.forEach(dialog => dialog.remove());
      }
    });
  }

  function setupScrollPosition() {
    const scrollY = sessionStorage.getItem(STORAGE_KEYS.scrollPosition);
    if (scrollY) window.scrollTo(0, parseInt(scrollY));
  window.addEventListener('beforeunload', () => {
    sessionStorage.setItem(STORAGE_KEYS.scrollPosition, window.scrollY);
    persistReadingState();
  });
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'hidden') {
        persistReadingState();
      }
    });
    window.addEventListener('scroll', scheduleReadingStateSave, { passive: true });
    window.addEventListener('resize', scheduleReadingStateSave);
  }

  function expandAllInMenu(root) {
    try {
      root.querySelectorAll('.collapse').forEach(el => {
        el.classList.add('show');
        el.style.height = 'auto';
      });
      root.querySelectorAll('[data-bs-toggle="collapse"]').forEach(tg => {
        tg.setAttribute('aria-expanded', 'true');
      });
      root.querySelectorAll('[data-bs-toggle="collapse"]').forEach(tg => {
        tg.removeAttribute('data-bs-toggle');
        tg.removeAttribute('data-bs-target');
      });
    } catch (e) {
      console.warn('Failed to expand all menu levels:', e);
    }
  }

  // Quarto左サイドバー（各章/全体）: 指定階層まで展開、それ以降を折りたたみ
  function setSidebarDepth(root, maxDepth) {
    try {
      const togglers = root.querySelectorAll('[data-bs-toggle="collapse"][data-bs-target]');
      const getDepthForTarget = (target) => {
        let d = 1; let n = target;
        while (n && n !== root) { if (n.tagName === 'UL') d++; n = n.parentElement; }
        return d;
      };
      togglers.forEach(tg => {
        const sel = tg.getAttribute('data-bs-target');
        if (!sel || sel[0] !== '#') return;
        const target = root.querySelector(sel);
        if (!target) return;
        const depth = getDepthForTarget(target);
        const open = (maxDepth === Infinity) || (depth <= maxDepth);
        target.classList.toggle('show', !!open);
        target.style.height = open ? 'auto' : '';
        tg.setAttribute('aria-expanded', open ? 'true' : 'false');
      });
    } catch (e) {
      console.warn('setSidebarDepth error:', e);
    }
  }

  // ページ内目次: ツリー化 + 展開/格納トグルを付与（デフォルト階層まで展開）
  // 階層判定は必ずMarkdownの#数（= 見出しタグH1..H6のレベル）に従う
  function enhancePageToc(panel, defaultDepth) {
    const nav = panel.querySelector('nav#TOC');
    if (!nav) return;
    const getHeadingLevelFromLink = (a) => {
      try {
        if (!a) return null;
        const href = a.getAttribute('href') || '';
        if (!href.startsWith('#')) return null;
        const id = href.slice(1);
        const h = document.getElementById(id);
        if (!h) return null;
        const tag = (h.tagName || '').toUpperCase();
        if (/^H[1-6]$/.test(tag)) return parseInt(tag.slice(1), 10);
        return null;
      } catch { return null; }
    };

    nav.querySelectorAll('li').forEach(li => {
      const childUl = li.querySelector(':scope > ul');
      const link = li.querySelector(':scope > a');
      const level = getHeadingLevelFromLink(link);

      if (childUl) {
        li.classList.add('has-children');
        const toggle = document.createElement('span');
        toggle.className = 'toc-toggle';
        toggle.textContent = '▾';
        if (link && link.parentNode === li) {
          const row = document.createElement('div');
          row.className = 'li-row';
          li.insertBefore(row, link);
          row.appendChild(toggle);
          row.appendChild(link);
        } else {
          li.insertBefore(toggle, li.firstChild);
        }
        toggle.addEventListener('click', () => {
          li.classList.toggle('collapsed');
          toggle.textContent = li.classList.contains('collapsed') ? '▸' : '▾';
        });
      }

      // 初期展開状態は # のレベルで判定
      if (level != null) {
        const open = (defaultDepth === Infinity) || (level <= defaultDepth);
        if (open) {
          li.classList.remove('collapsed');
          const t = li.querySelector(':scope > .toc-toggle');
          if (t) t.textContent = '▾';
        } else {
          li.classList.add('collapsed');
          const t = li.querySelector(':scope > .toc-toggle');
          if (t) t.textContent = '▸';
        }
      }
    });
  }

  // 独自TOCシステム
  const CustomTOC = {
    // 現在のページの見出しを取得
    getPageHeadings: function() {
      const headmap = new Map();
      let maxDepth = 0;
      
      // メインコンテンツから見出しを取得
      const allHeadings = document.querySelectorAll('main h1, main h2, main h3, main h4, main h5, main h6');
      
      allHeadings.forEach(heading => {
        const text = heading.textContent || heading.innerText || '';
        if (!text.trim()) return;
        
        const level = parseInt(heading.tagName.slice(1), 10);
        const id = heading.id || this.generateIdFromText(text);
        
        headmap.set(id, {
          id: id,
          text: text,
          level: level,
          element: heading,
          children: []
        });
        maxDepth = Math.max(maxDepth, level);
      });
      
      return { headings: headmap, maxDepth: maxDepth };
    },
    
    // テキストからIDを生成（Quarto互換）
    generateIdFromText: function(text) {
      return text
        .replace(/\s+/g, ' ')
        .trim()
        .toLowerCase()
        .replace(/[^\w\s-]/g, '')
        .replace(/\s+/g, '-');
    },
    
    // ページ外TOC：すべてのページ情報（静的データ）
    getAllPagesTOC: function() {
      // ページ構成を静的に定義する
      return [
        {
          title: "AJMUN 37th 平和への課題：補遺",
          url: "../index.html",
          type: "cover"
        },
        {
          title: "フロント挨拶",
          url: "../content/00_front.html",
          type: "front"
        },
        {
          title: "第1章 プロジェクトの概要",
          url: "../content/01_ch01.html",
          type: "chapter",
          sections: [
            "1.1 はじめに",
            "1.2 プロジェクトの目的",
            "1.2.1 課題認識",
            "1.2.2 解決方針",
            "1.3 技術選定",
            "1.3.1 Quarto + Pandoc",
            "1.3.2 UDP明朝フォント",
            "1.4 プロジェクト構成",
            "1.4.1 ディレクトリ構造",
            "1.4.2 ファイル配置戦略",
            "1.5 開発アプローチ",
            "1.5.1 プログレッシブエンハンスメント",
            "1.5.2 アクセシビリティ優先"
          ]
        },
        {
          title: "第2章 技術的課題と解決策",
          url: "../content/02_ch02.html",
          type: "chapter",
          sections: [
            "2.1 日本語組版の課題",
            "2.1.1 文字エンコーディング",
            "2.1.2 フォントの扱い",
            "2.2 レスポンシブデザイン",
            "2.2.1 標長画面の制約",
            "2.2.2 モバイルへの対応",
            "2.3 パフォーマンスの最適化",
            "2.3.1 読み込み時間の短縮",
            "2.3.2 スムーズな操作感"
          ]
        },
        {
          title: "第3章 実装方針",
          url: "../content/03_ch03.html",
          type: "chapter",
          sections: [
            "3.1 開発アプローチ",
            "3.1.1 プロジェクト構造",
            "3.1.2 ビルドシステム",
            "3.2 技術選択",
            "3.3 品質保証"
          ]
        },
        {
          title: "コラム1：Webフォントの歴史",
          url: "../content/20_col01.html",
          type: "column",
          sections: [
            "デジタルタイポグラフィの発展",
            "画像フォントの時代",
            "Webフォントの登場",
            "日本語対応の課題",
            "サブセット化の重要性"
          ]
        },
        {
          title: "コラム2：アクセシビリティの重要性",
          url: "../content/21_col02.html",
          type: "column",
          sections: [
            "リテラシーの多様性",
            "視覚的配慮",
            "聴覚的配慮",
            "身体的配慮",
            "技術的な実装"
          ]
        },
        {
          title: "第4章 UI/UX設計",
          url: "../content/04_ch04.html",
          type: "chapter",
          sections: [
            "4.1 基本原則",
            "4.2 コンポーネント設計",
            "4.3 アクセシビリティ"
          ]
        },
        {
          title: "第5章 パフォーマンス最適化",
          url: "../content/05_ch05.html",
          type: "chapter",
          sections: [
            "5.1 読み込み速度",
            "5.2 レンダリングの効率化",
            "5.3 キャッシュ戦略"
          ]
        },
        {
          title: "第6章 国連の制度",
          url: "./06_ch06.html",
          type: "chapter",
          sections: [
            "はじめに",
            "第1節 国連という組織",
            "第1項 概要・組織構造",
            "第2項 安全保障理事会",
            "第3項 国連の紛争対処",
            "第4項 安保理決議に基づく義務",
            "コラム 安保理決議の拘束力",
            "第2節 国連財政",
            "第2項 PKO予算",
            "第3節 国連による経済制裁",
            "第1項 国際連合憲章における経済制裁措置",
            "第2項 冷戦下の経済制裁",
            "第3項 冷戦後の経済制裁",
            "第3項 経済制裁に伴う問題とその後",
            "第4項 国連憲章第50条の注解",
            "第4節 国連平和維持活動(PKO)",
            "参考文献"
          ]
        },
        {
          title: "第7章 まとめと展望",
          url: "../content/07_ch07.html",
          type: "chapter",
          sections: [
            "7.1 プロジェクトの成果",
            "7.2 技術的貢献",
            "7.3 今後の発展",
            "まとめ"
          ]
        },
        {
          title: "コラム3：今後の技術動向",
          url: "../content/22_col03.html",
          type: "column",
          sections: [
            "新しい技術の登場",
            "Variable Fonts",
            "Container Queries",
            "Web Components",
            "発展の可能性",
            "PWA化",
            "オフライン対応",
            "マルチデバイス同期"
          ]
        },
        {
          title: "編集後記",
          url: "../content/90_afterword.html",
          type: "appendix",
          sections: [
            "執筆の経緯",
            "技術的な挑戦",
            "フォント埋込",
            "レスポンシブ設計",
            "脚注処理",
            "読者の皆様へ",
            "今後の展望",
            "結びに"
          ]
        },
        {
          title: "参考文献",
          url: "../content/95_references.html",
          type: "appendix"
        },
        {
          title: "索引",
          url: "../content/96_index.html",
          type: "appendix",
          sections: [
            "あ", "う", "か", "こ", "し", "た", "は", "ろ"
          ]
        }
      ];
    },
    
    // ページ内TOCを生成（章内タブ用）
    generatePageTOC: function(maxDepth) {
      const { headings } = this.getPageHeadings();
      
      if (headings.size === 0) {
        return '<p class="toc-empty">このページには見出しがありません。</p>';
      }
      
      const items = [];
      headings.forEach((heading, id) => {
        const level = Math.min(Math.max(heading.level, 1), 6);
        if (level > maxDepth) return;
        const levelClass = `page-toc-level-${level}`;
        const liClasses = ['page-toc-item', levelClass].join(' ');
        items.push(`<li class="${liClasses}"><a class="page-toc-link" href="#${id}">${heading.text}</a></li>`);
      });

      if (!items.length) {
        return '<p class="toc-empty">このページには見出しがありません。</p>';
      }

      return `<ul class="page-toc-list">${items.join('')}</ul>`;
    },
    
    // 全体TOCを生成（全体タブ用）
    generateAllPagesTOC: function() {
      const pages = this.getAllPagesTOC();
      const currentPath = (window.location.pathname || '').split('/').pop() || 'index.html';
      
      let html = '<ul class="all-toc-list">';
      
      pages.forEach(page => {
        const normalizedPage = (page.url || '').replace(/^\.\//, '').split('/').pop() || '';
        const isActive = normalizedPage === currentPath;
        const itemClasses = ['all-toc-item', `all-toc-item--${page.type || 'other'}`];
        if (isActive) itemClasses.push('active');
        
        html += `<li class="${itemClasses.join(' ')}">`;
        html += `<a href="${page.url}" class="all-toc-link">${page.title}</a>`;
        
        if (Array.isArray(page.sections) && page.sections.length) {
          html += '<ul class="all-toc-sublist">';
          page.sections.forEach(sectionName => {
            const sectionId = this.generateIdFromText(sectionName);
            const link = `${page.url}#${sectionId}`;
            html += `<li class="all-toc-subitem"><a href="${link}" class="all-toc-sublink">${sectionName}</a></li>`;
          });
          html += '</ul>';
        }
        
        html += '</li>';
      });
      
      html += '</ul>';
      return html;
    },
    
    // TOC構造をHTMLに変換
    renderTOCStructure: function(structure, maxDepth = Infinity, options = {}) {
      const {
        listClass = 'custom-toc-list',
        childListClass = 'custom-toc-child-list',
        itemClass = (item, active) => `custom-toc-item level-${item.level} ${active}`,
        linkClass = (item, active) => `custom-toc-link ${active}`
      } = options;

      const normalizeClass = (value) => (value || '').trim().replace(/\s+/g, ' ');

      const renderItems = (items, currentDepth = 1) => {
        let resultHtml = '';

        items.forEach(item => {
          if (Array.isArray(item)) {
            if (currentDepth <= maxDepth) {
              resultHtml += `<ul class="${normalizeClass(childListClass)}">`;
              item.forEach(childItem => {
                resultHtml += renderItems([childItem], currentDepth + 1);
              });
              resultHtml += '</ul>';
            }
          } else if (item && item.id) {
            const isActive = document.getElementById(item.id)?.classList.contains('active');
            const activeClass = isActive ? 'active' : '';
            const liClass = typeof itemClass === 'function' ? itemClass(item, activeClass) : itemClass;
            const linkClassName = typeof linkClass === 'function' ? linkClass(item, activeClass) : linkClass;

            resultHtml += `<li class="${normalizeClass(liClass)}">`;
            resultHtml += `<a href="#${item.id}" class="${normalizeClass(linkClassName)}">${item.text}</a>`;

            if (item.children && item.children.length > 0 && currentDepth < maxDepth) {
              resultHtml += `<ul class="${normalizeClass(childListClass)}">`;
              item.children.forEach(child => {
                resultHtml += renderItems([child], currentDepth + 1);
              });
              resultHtml += '</ul>';
            }

            resultHtml += '</li>';
          }
        });

        return resultHtml;
      };

      let html = `<ul class="${normalizeClass(listClass)}">`;
      structure.forEach(item => {
        html += renderItems([item], 1);
      });
      html += '</ul>';
      return html;
    },
    
    // TOCを初期化
    initializeCustomTOC: function() {
      // 章内タブ用TOC
      const pageTOCPanel = document.querySelector('.toc-page-content');
      if (pageTOCPanel) {
        const pageTOC = this.generatePageTOC(Infinity);
        pageTOCPanel.innerHTML = pageTOC;
      }
      
      // 全体タブ用TOC
      const allTOCPanel = document.querySelector('.toc-all-content');
      if (allTOCPanel) {
        const allTOC = this.generateAllPagesTOC();
        allTOCPanel.innerHTML = allTOC;
        
        // 階層折りたたみ機能
        this.setupTOCToggling(allTOCPanel);
      }
    },
    
    // TOCの階層展開/折りたたみ機能
    setupTOCToggling: function(container) {
      const toggleButtons = container.querySelectorAll('.custom-toc-item > .custom-toc-link');
      
      toggleButtons.forEach(link => {
        const listItem = link.closest('.custom-toc-item');
        const childList = listItem.querySelector('.custom-toc-child-list');
        
        if (childList) {
          // 開閉ボタンを追加
          const toggleBtn = document.createElement('span');
          toggleBtn.className = 'custom-toc-toggle';
          toggleBtn.textContent = '▾';
          
          link.parentNode.insertBefore(toggleBtn, link);
          link.style.paddingLeft = '20px';
          
          // 第4階層以下はデフォルトで折りたたむ
          const level = parseInt(listItem.className.match(/level-(\d+)/)?.[1] || 1, 10);
          const collapsed = level >= 4;
          
          if (collapsed) {
            childList.style.display = 'none';
            toggleBtn.textContent = '▸';
          }
          
          toggleBtn.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            
            const isCollapsed = childList.style.display === 'none';
            childList.style.display = isCollapsed ? '' : 'none';
            toggleBtn.textContent = isCollapsed ? '▾' : '▸';
          });
          
          // 親リンクのクリック動作
          link.addEventListener('click', (e) => {
            e.stopPropagation();
          });
        }
      });
    }
  };

  CustomTOC.getNavData = function(navData) {
    return navData || NAV_DATA_STATE.data;
  };

  CustomTOC.normalizeText = function(text) {
    return (text || '').replace(/\s+/g, ' ').trim();
  };

  CustomTOC.getCurrentPage = function(navData) {
    const data = this.getNavData(navData);
    if (!data || !Array.isArray(data.pages)) return null;
    const current = computeCurrentOutputPath();
    return data.pages.find(page => isSamePage(page.output, current)) || null;
  };

  CustomTOC.createTree = function(nodes, pageOutput, options = {}) {
    const { variant } = options;
    const ul = document.createElement('ul');
    ul.className = 'toc-tree';
    if (variant) ul.classList.add(variant);

    nodes.forEach((node, index) => {
      if (!node) return;
      const depth = Math.min(node.level || 1, 6);
      const li = document.createElement('li');
      li.className = `toc-item toc-level-${depth}`;
      if (index === nodes.length - 1) li.classList.add('is-last');

      const row = document.createElement('div');
      row.className = 'toc-row';

      const link = document.createElement('a');
      link.className = `toc-link toc-level-${depth}`;
      link.href = buildHref(pageOutput, node.anchor || null);
      link.textContent = node.title || '';
      row.appendChild(link);
      li.appendChild(row);

      const hasChildren = Array.isArray(node.children) && node.children.length > 0;
      if (hasChildren) {
        const childList = this.createTree(node.children, pageOutput, options);
        li.appendChild(childList);
        li.classList.add('has-children');
      }

      ul.appendChild(li);
    });

    return ul;
  };

  CustomTOC.cloneNodeWithLevelOffset = function(node, offset) {
    if (!node) return null;
    const level = Math.max(1, (node.level || 1) + offset);
    const clone = {
      title: node.title,
      level,
      anchor: node.anchor,
      children: []
    };
    if (Array.isArray(node.children) && node.children.length) {
      clone.children = node.children
        .map(child => this.cloneNodeWithLevelOffset(child, offset))
        .filter(Boolean);
    }
    return clone;
  };

  CustomTOC.rebasePageHeadings = function(nodes) {
    if (!Array.isArray(nodes) || !nodes.length) return [];

    const rebased = [];
    let consumedLevel1 = false;

    nodes.forEach(node => {
      if (!node) return;
      const level = node.level || 1;
      if (level <= 1) {
        consumedLevel1 = true;
        if (Array.isArray(node.children) && node.children.length) {
          node.children.forEach(child => {
            const adjusted = this.cloneNodeWithLevelOffset(child, -1);
            if (adjusted) rebased.push(adjusted);
          });
        }
      } else {
        const adjusted = this.cloneNodeWithLevelOffset(node, -1);
        if (adjusted) rebased.push(adjusted);
      }
    });

    if (!rebased.length && !consumedLevel1) {
      return nodes
        .map(node => this.cloneNodeWithLevelOffset(node, -1))
        .filter(Boolean);
    }

    return rebased;
  };

  CustomTOC.renderChapterTab = function(container, navData) {
    if (!container) return;
    const data = this.getNavData(navData);
    container.innerHTML = '';

    if (!data || !Array.isArray(data.pages) || !data.pages.length) {
      container.innerHTML = '<p class="toc-empty">目次データを読み込めませんでした。</p>';
      return;
    }

    const list = document.createElement('ul');
    list.className = 'toc-chapter-list toc-tree';
    const current = computeCurrentOutputPath();

    data.pages.forEach(page => {
      if (!page) return;
      const li = document.createElement('li');
      li.className = 'toc-chapter-item';
      if (isSamePage(page.output, current)) li.classList.add('active');

      const headingTree = cloneTreeWithDepth(page.headings || [], 1);
      const nodes = headingTree.length ? headingTree : [{
        title: page.title,
        level: 1,
        anchor: page.headings && page.headings.length ? page.headings[0].anchor : null,
        children: []
      }];

      const primary = nodes[0];
      const link = document.createElement('a');
      link.className = 'toc-link toc-chapter-link';
      link.href = buildHref(page.output, primary.anchor || null);
      link.textContent = primary.title || page.title;
      li.appendChild(link);

      if (nodes.length > 1) {
        const childList = document.createElement('ul');
        childList.className = 'toc-tree toc-chapter-sublist';
        nodes.slice(1).forEach(node => {
          const subLi = document.createElement('li');
          subLi.className = 'toc-item toc-level-1';
          const subLink = document.createElement('a');
          subLink.className = 'toc-link';
          subLink.href = buildHref(page.output, node.anchor || null);
          subLink.textContent = node.title || '';
          subLi.appendChild(subLink);
          childList.appendChild(subLi);
        });
        li.appendChild(childList);
      }

      list.appendChild(li);
    });

    container.appendChild(list);
  };

  CustomTOC.renderAllTab = function(container, navData) {
    if (!container) return;
    const data = this.getNavData(navData);
    container.innerHTML = '';
    container.classList.add('toc-all-container-ready');

    if (!data || !Array.isArray(data.pages) || !data.pages.length) {
      container.innerHTML = '<p class="toc-empty">目次データを読み込めませんでした。</p>';
      return;
    }

    const list = document.createElement('ul');
    list.className = 'toc-all-list toc-tree toc-tree-root toc-tree-all-root';
    const current = computeCurrentOutputPath();

    data.pages.forEach(page => {
      if (!page) return;
      const li = document.createElement('li');
      li.className = 'toc-all-item';
      if (isSamePage(page.output, current)) li.classList.add('active');

      const headingTree = cloneTreeWithDepth(page.headings || [], 3);
      let sectionNodes = headingTree;
      let chapterAnchor = page.headings && page.headings.length ? page.headings[0].anchor : null;
      if (
        headingTree.length === 1 &&
        this.normalizeText(headingTree[0].title) === this.normalizeText(page.title)
      ) {
        chapterAnchor = headingTree[0].anchor || chapterAnchor;
        sectionNodes = headingTree[0].children || [];
      }

      const link = document.createElement('a');
      link.className = 'toc-link toc-all-link';
      link.href = buildHref(page.output, chapterAnchor || null);
      link.textContent = page.title;
      li.appendChild(link);

      if (sectionNodes.length) {
        const childTree = this.createTree(sectionNodes, page.output, { variant: 'toc-tree-all' });
        li.appendChild(childTree);
      }

      list.appendChild(li);
    });

    container.appendChild(list);
  };

  CustomTOC.renderPageTab = function(container, navData, maxDepth = 4) {
    if (!container) return;
    const page = this.getCurrentPage(navData);
    container.innerHTML = '';
    container.classList.add('toc-page-container');

    if (!page) {
      container.innerHTML = '<p class="toc-empty">このページには見出しがありません。</p>';
      return;
    }

    const headingTree = cloneTreeWithDepth(page.headings || [], maxDepth);
    const rebasedTree = this.rebasePageHeadings(headingTree)
      .filter(node => (node.level || 1) >= 1);

    if (!rebasedTree.length) {
      container.innerHTML = '<p class="toc-empty">このページには見出しがありません。</p>';
      return;
    }

    const tree = this.createTree(rebasedTree, page.output, { variant: 'toc-tree-page' });
    tree.classList.add('toc-tree-root', 'toc-tree-page-root');
    container.appendChild(tree);
  };

  CustomTOC.initializeCustomTOC = function(navData) {
    const data = this.getNavData(navData);
    if (!data) return;

    const pagePanel = document.querySelector('.toc-page-content');
    if (pagePanel) {
      this.renderPageTab(pagePanel, data, 4);
    }

    const allPanel = document.querySelector('.toc-all-content .toc-all-container') || document.querySelector('.toc-all-content');
    if (allPanel) {
      this.renderAllTab(allPanel, data);
    }

    const sitePanel = document.querySelector('.toc-site-content .sidebar-menu-container');
    if (sitePanel) {
      this.renderChapterTab(sitePanel, data);
    }
  };

  CustomTOC.generatePageTOC = function(maxDepth = 4) {
    const temp = document.createElement('div');
    this.renderPageTab(temp, this.getNavData(), maxDepth);
    return temp.innerHTML || '<p class="toc-empty">このページには見出しがありません。</p>';
  };

  CustomTOC.generateAllPagesTOC = function() {
    const temp = document.createElement('div');
    this.renderAllTab(temp, this.getNavData());
    return temp.innerHTML || '<p class="toc-empty">目次データを読み込めませんでした。</p>';
  };

  // コメントエクスポート/インポート
  function exportComments(pageOnly) {
    try {
      const data = pageOnly ? { [pageKey()]: COMMENTS_DB[pageKey()]||[] } : COMMENTS_DB;
      const blob = new Blob([JSON.stringify({ version:'1.0', exportedAt: new Date().toISOString(), data }, null, 2)], { type:'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      const base = pageOnly ? (pageKey().split('/').pop()||'page') : 'all';
      a.download = `comments_${base}_${new Date().toISOString().slice(0,10)}.json`;
      document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
    } catch (e) { alert('コメント出力に失敗しました'); }
  }
  function importCommentsFromFile(file) {
    if (!file) return;
    const reader = new FileReader();
    reader.onload = () => {
      try {
        const json = JSON.parse(reader.result);
        const incoming = json.data || {};
        // マージ
        Object.keys(incoming).forEach(k => {
          if (!Array.isArray(incoming[k])) return;
          if (!COMMENTS_DB[k]) COMMENTS_DB[k] = [];
          const existingIds = new Set(COMMENTS_DB[k].map(r=>r.id));
          incoming[k].forEach(rec => { if (!existingIds.has(rec.id)) COMMENTS_DB[k].push(rec); });
        });
        saveComments();
        refreshRightPanels();
        alert('コメントをインポートしました');
      } catch (e) {
        alert('コメント読込に失敗しました');
      }
    };
    reader.readAsText(file, 'utf-8');
  }

})();
</script>
<style>
  .gdoc-popover {
    position: absolute;
    z-index: 1100;
    max-width: 320px;
    background: var(--gdoc-popover-bg, #fff);
    color: inherit;
    border-radius: 6px;
    box-shadow: 0 4px 16px rgba(0,0,0,0.18);
    border: 1px solid rgba(0,0,0,0.07);
    font-size: 14px;
  }
  .gdoc-popover[hidden] {
    display: none !important;
  }
  .gdoc-popover-inner {
    padding: 8px 10px;
  }
  .gdoc-popover-header {
    margin-bottom: 6px;
    font-weight: 600;
    line-height: 1.3;
    max-height: 3.2em;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .gdoc-popover-title {
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
  }
  .gdoc-popover-actions {
    display: flex;
    gap: 6px;
    justify-content: flex-end;
  }
  .gdoc-popover-actions .gdoc-btn {
    border: none;
    background: transparent;
    padding: 4px 6px;
    border-radius: 4px;
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: 13px;
    color: inherit;
  }
  .gdoc-popover-actions .gdoc-btn:hover {
    background: rgba(0,0,0,0.06);
  }
  .gdoc-popover-actions .gdoc-btn svg {
    width: 16px;
    height: 16px;
  }

.gdoc-modal {
    position: static;
    z-index: auto;
  }
  .gdoc-modal[hidden] {
    display: none !important;
  }
  .gdoc-modal-dialog {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: min(900px, 90vw);
    height: min(600px, 80vh);
    min-width: 320px;
    min-height: 220px;
    max-width: 95vw;
    max-height: 95vh;
    background: #fff;
    border-radius: 8px;
    overflow: hidden;
    box-shadow: 0 10px 30px rgba(0,0,0,0.35);
    display: flex;
    flex-direction: column;
    z-index: 1500;
  }
  .gdoc-modal-header {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 6px 10px;
    border-bottom: 1px solid rgba(0,0,0,0.08);
    background: #f5f5f5;
    cursor: move;
    user-select: none;
  }
  .gdoc-modal-title {
    font-size: 14px;
    font-weight: 600;
    margin-right: 8px;
    max-width: 60vw;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .gdoc-modal-header-actions {
    display: inline-flex;
    align-items: center;
    gap: 4px;
  }
  .gdoc-modal-header-actions .gdoc-modal-btn {
    border: none;
    background: transparent;
    padding: 4px 6px;
    border-radius: 4px;
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: 13px;
    color: inherit;
  }
  .gdoc-modal-header-actions .gdoc-modal-btn:hover {
    background: rgba(0,0,0,0.06);
  }
  .gdoc-modal-header-actions .gdoc-modal-btn svg {
    width: 15px;
    height: 15px;
  }
  .gdoc-modal-body {
    flex: 1 1 auto;
    position: relative;
    overflow: auto;
  }
  .gdoc-modal-iframe {
    border: none;
    width: 100%;
    height: 100%;
    transform-origin: 0 0;
  }
  .bg-preview-body {
    display: none;
    padding: 20px 40px;
    max-width: 900px;
    margin: 0 auto;
    font-size: inherit; /* 設定された文字サイズを継承 */
    line-height: 1.8;
    overflow-y: auto;
    height: 100%;
  }
  
  /* 文字サイズクラスに対応 */
  .font-size-small .bg-preview-body { font-size: 14px; }
  .font-size-medium .bg-preview-body { font-size: 16px; }
  .font-size-large .bg-preview-body { font-size: 18px; }
  .font-size-xlarge .bg-preview-body { font-size: 20px; }
  .bg-preview-body.active {
    display: block;
  }
  .bg-preview-body .inline-footnote {
    color: #1a73e8;
    font-size: 0.9em;
    margin-left: 2px;
  }
  .bg-preview-body .text-marker {
    background: rgba(255, 235, 59, 0.3);
    padding: 0 2px;
  }

  body[data-theme="dark"] .gdoc-popover {
    --gdoc-popover-bg: #111827;
    background: #111827;
    color: #e2e8f0;
    border-color: rgba(138, 180, 248, 0.25);
    box-shadow: 0 18px 36px rgba(0, 0, 0, 0.55);
  }

  body[data-theme="dark"] .gdoc-popover-actions .gdoc-btn:hover {
    background: rgba(255, 255, 255, 0.08);
  }

  body[data-theme="dark"] .gdoc-modal-dialog {
    background: #0b101a;
    color: #e1e5ed;
    border: 1px solid rgba(138, 180, 248, 0.35);
    box-shadow: 0 24px 48px rgba(0, 0, 0, 0.7);
  }

  body[data-theme="dark"] .gdoc-modal-header {
    background: rgba(255, 255, 255, 0.05);
    border-bottom-color: rgba(255, 255, 255, 0.12);
    color: inherit;
  }

  body[data-theme="dark"] .gdoc-modal-header-actions .gdoc-modal-btn:hover {
    background: rgba(255, 255, 255, 0.08);
  }

  body[data-theme="dark"] .bg-preview-body {
    color: #e5e9f0;
    background: transparent;
  }

  body[data-theme="dark"] .bg-preview-body a {
    color: #8ab4f8;
  }

  /* プレビュー内のポップオーバーを最前面に */
  .bg-preview-body .gdoc-popover,
  .bg-preview-body #bg-preview-popover {
    z-index: 10001 !important;
  }
  .bg-preview-body h1,
  .bg-preview-body h2,
  .bg-preview-body h3,
  .bg-preview-body h4 {
    margin-top: 1.5em;
    margin-bottom: 0.5em;
  }
  .bg-preview-body p {
    margin-bottom: 1em;
  }
  .bg-preview-body a {
    color: #1a73e8;
    text-decoration: none;
  }
  .bg-preview-body a:hover {
    text-decoration: underline;
  }
  /* モバイルモードでは画面全体を覆うモーダルとして動作 */
  .gdoc-modal.gdoc-modal-mobile {
    position: fixed;
    inset: 0;
    z-index: 1500;
    background: rgba(0,0,0,0.35);
  }
  .gdoc-modal.gdoc-modal-mobile .gdoc-modal-dialog {
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 96vw;
    height: 90vh;
    min-width: 0;
    min-height: 0;
    max-width: none;
    max-height: none;
    border-radius: 8px;
  }
  
  /* モバイル版でのウィンドウサイズ変更対応 */
  @media (max-width: 768px) {
    .gdoc-modal-dialog {
      position: fixed !important;
      top: 50% !important;
      left: 50% !important;
      transform: translate(-50%, -50%) !important;
      width: 95vw !important;
      height: 95vh !important;
    }
  }
  .gdoc-resize-handle {
    position: absolute;
    width: 12px;
    height: 12px;
    z-index: 1600;
    background: transparent;
    /* 視認性が必要なら、以下のコメントアウトを外す
    background: rgba(0,0,0,0.15);
    border-radius: 50%;
    */
  }
  .gdoc-resize-handle-nw {
    top: -4px;
    left: -4px;
    cursor: nwse-resize;
  }
  .gdoc-resize-handle-ne {
    top: -4px;
    right: -4px;
    cursor: nesw-resize;
  }
  .gdoc-resize-handle-sw {
    bottom: -4px;
    left: -4px;
    cursor: nesw-resize;
  }
  .gdoc-resize-handle-se {
    bottom: -4px;
    right: -4px;
    cursor: nwse-resize;
  }

  /* 右下に積まれる格納トースト */
  .gdoc-toast-container {
    position: fixed;
    right: 16px;
    bottom: 16px;
    z-index: 1400;
    display: flex;
    flex-direction: column;
    gap: 8px;
    max-width: 480px;
    pointer-events: none;
  }
  .gdoc-toast-container-inner {
    pointer-events: auto;
    display: flex;
    flex-direction: column;
    gap: 8px;
  }
.gdoc-toast {
    width: 480px;
    max-width: 100vw;
    background: #f5f5f5;
    color: #222;
    border-radius: 8px;
    box-shadow: 0 4px 16px rgba(0,0,0,0.18);
    display: flex;
    align-items: center;
    padding: 6px 10px;
    box-sizing: border-box;
  }
  .gdoc-toast-main {
    flex: 1 1 auto;
    min-width: 0;
    display: flex;
    align-items: center;
    gap: 8px;
    cursor: pointer;
  }
  .gdoc-toast-title {
    flex: 1 1 auto;
    min-width: 0;
    font-size: 13px;
    font-weight: 500;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .gdoc-toast-actions {
    flex: 0 0 auto;
    display: inline-flex;
    align-items: center;
    gap: 4px;
  }
  .gdoc-toast-btn {
    border: none;
    background: transparent;
    padding: 2px 4px;
    border-radius: 4px;
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    color: inherit;
  }
  .gdoc-toast-btn:hover {
    background: rgba(255,255,255,0.12);
  }
  .gdoc-toast-btn svg {
    width: 14px;
    height: 14px;
  }

  /* トーストのダークテーマ */
  body[data-theme="dark"] .gdoc-toast {
    background: #303134;
    color: #e0e0e0;
    box-shadow: 0 4px 16px rgba(0,0,0,0.6);
  }

  body[data-theme="dark"] .gdoc-toast-btn:hover {
    background: rgba(255,255,255,0.08);
  }

  /* 他文書一覧モーダル */
  .gdoc-list-modal {
    position: fixed;
    inset: 0;
    z-index: 1550;
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(0,0,0,0.4);
  }
  .gdoc-list-modal[hidden] {
    display: none !important;
  }
  .gdoc-list-modal-dialog {
    width: min(640px, 96vw);
    max-height: 80vh;
    background: #fff;
    border-radius: 8px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.35);
    display: flex;
    flex-direction: column;
    overflow: hidden;
  }
  .gdoc-list-modal-header {
    padding: 8px 12px;
    border-bottom: 1px solid rgba(0,0,0,0.08);
    display: flex;
    align-items: center;
    justify-content: space-between;
  }
  .gdoc-list-modal-title {
    font-size: 14px;
    font-weight: 600;
  }
  .gdoc-list-modal-close {
    border: none;
    background: transparent;
    cursor: pointer;
    font-size: 18px;
    line-height: 1;
  }
  .gdoc-list-modal-body {
    padding: 8px 12px;
    overflow: auto;
  }
  .gdoc-list {
    list-style: none;
    margin: 0;
    padding: 0;
    display: flex;
    flex-direction: column;
    gap: 6px;
  }
  .gdoc-list-item {
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 4px 6px;
    border-radius: 4px;
  }
  .gdoc-list-item:hover {
    background: rgba(0,0,0,0.03);
  }
  .gdoc-list-item-title {
    flex: 1 1 auto;
    min-width: 0;
    font-size: 13px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .gdoc-list-item-actions {
    flex: 0 0 auto;
    display: inline-flex;
    align-items: center;
    gap: 4px;
  }
  .gdoc-list-item-btn {
    border: none;
    background: transparent;
    cursor: pointer;
    padding: 2px 4px;
    border-radius: 4px;
    font-size: 12px;
  }
  .gdoc-list-item-btn:hover {
    background: rgba(0,0,0,0.06);
  }
</style>

<div id="gdoc-preview-popover" class="gdoc-popover" hidden="">
  <div class="gdoc-popover-inner">
    <div class="gdoc-popover-header">
      <span class="gdoc-popover-title"></span>
    </div>
    <div class="gdoc-popover-actions" role="group" aria-label="Googleドキュメント操作">
      <button type="button" class="gdoc-btn gdoc-btn-preview" data-action="preview" title="プレビュー表示" aria-label="プレビュー表示">
        <!-- 目アイコン -->
        <svg viewbox="0 0 24 24" aria-hidden="true"><path d="M12 5C7 5 3.1 8 1.5 12 3.1 16 7 19 12 19s8.9-3 10.5-7C20.9 8 17 5 12 5zm0 10a3 3 0 110-6 3 3 0 010 6z"></path></svg>
      </button>
      <button type="button" class="gdoc-btn gdoc-btn-open" data-action="open" title="別タブで開く" aria-label="別タブで開く">
        <!-- 外部リンクアイコン -->
        <svg viewbox="0 0 24 24" aria-hidden="true"><path d="M14 3h7v7h-2V6.41l-9.29 9.3-1.42-1.42 9.3-9.29H14V3z"></path><path d="M5 5h5V3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2v-5h-2v5H5V5z"></path></svg>
      </button>
      <button type="button" class="gdoc-btn gdoc-btn-copy" data-action="copy" title="リンクをコピー" aria-label="リンクをコピー">
        <!-- コピーアイコン -->
        <svg viewbox="0 0 24 24" aria-hidden="true"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></svg>
      </button>
    </div>
  </div>
</div>

<div id="bg-preview-popover" class="gdoc-popover" hidden="">
  <div class="gdoc-popover-inner">
    <div class="gdoc-popover-header">
      <span class="gdoc-popover-title"></span>
    </div>
    <div class="gdoc-popover-actions" role="group" aria-label="ドキュメント内遷移操作">
      <button type="button" class="gdoc-btn gdoc-btn-preview" data-action="preview" title="プレビュー表示" aria-label="プレビュー表示">
        <svg viewbox="0 0 24 24" aria-hidden="true"><path d="M12 5C7 5 3.1 8 1.5 12 3.1 16 7 19 12 19s8.9-3 10.5-7C20.9 8 17 5 12 5zm0 10a3 3 0 110-6 3 3 0 010 6z"></path></svg>
      </button>
      <button type="button" class="gdoc-btn gdoc-btn-go" data-action="go" title="リンク先に遷移" aria-label="リンク先に遷移">
        <svg viewbox="0 0 24 24" aria-hidden="true"><path d="M12 4l-1.41 1.41L16.17 11H4v2h12.17l-5.58 5.59L12 20l8-8z"></path></svg>
      </button>
      <button type="button" class="gdoc-btn gdoc-btn-toast" data-action="toast" title="トーストへ格納" aria-label="トーストへ格納">
        <svg viewbox="0 0 24 24" aria-hidden="true"><path d="M17 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V7l-4-4zm-5 16c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3zm3-10H5V5h10v4z"></path></svg>
      </button>
      <button type="button" class="gdoc-btn gdoc-btn-close" data-action="close" title="閉じる" aria-label="閉じる">
        <svg viewbox="0 0 24 24" aria-hidden="true"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"></path></svg>
      </button>
    </div>
  </div>
</div>

<div id="gdoc-preview-modal" class="gdoc-modal" hidden="">
  <div class="gdoc-modal-dialog" role="dialog" aria-label="Googleドキュメント プレビュー">
    <div class="gdoc-resize-handle gdoc-resize-handle-nw" data-resize-dir="nw"></div>
    <div class="gdoc-resize-handle gdoc-resize-handle-ne" data-resize-dir="ne"></div>
    <div class="gdoc-resize-handle gdoc-resize-handle-sw" data-resize-dir="sw"></div>
    <div class="gdoc-resize-handle gdoc-resize-handle-se" data-resize-dir="se"></div>
    <div class="gdoc-modal-header">
      <div class="gdoc-modal-title"></div>
      <div class="gdoc-modal-header-actions">
        <button type="button" class="gdoc-modal-btn gdoc-modal-btn-reload" title="再読み込み" aria-label="再読み込み">
          <svg viewbox="0 0 24 24" aria-hidden="true"><path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"></path></svg>
        </button>
        <button type="button" class="gdoc-modal-btn gdoc-modal-btn-copy" title="リンクをコピー" aria-label="リンクをコピー">
          <svg viewbox="0 0 24 24" aria-hidden="true"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></svg>
        </button>
        <button type="button" class="gdoc-modal-btn gdoc-modal-btn-open" title="別タブで開く" aria-label="別タブで開く">
          <svg viewbox="0 0 24 24" aria-hidden="true"><path d="M14 3h7v7h-2V6.41l-9.29 9.3-1.42-1.42 9.3-9.29H14V3z"></path><path d="M5 5h5V3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2v-5h-2v5H5V5z"></path></svg>
        </button>
        <button type="button" class="gdoc-modal-btn gdoc-modal-btn-jump" title="本文へ移動" aria-label="本文へ移動">
          <svg viewbox="0 0 24 24" aria-hidden="true"><path d="M12 2c-.55 0-1 .45-1 1v12.59l-4.3-4.3a1 1 0 10-1.4 1.42l6 6a1 1 0 001.4 0l6-6a1 1 0 10-1.4-1.42L13 15.59V3c0-.55-.45-1-1-1z"></path></svg>
        </button>
        <button type="button" class="gdoc-modal-btn gdoc-modal-btn-close" title="閉じる" aria-label="ポップアップを閉じる">
          <svg viewbox="0 0 24 24" aria-hidden="true"><path d="M5.293 6.707l5.293 5.293-5.293 5.293c-.39.39-.39 1.024 0 1.414s1.024.39 1.414 0l5.293-5.293 5.293 5.293c.39.39 1.024.39 1.414 0s.39-1.024 0-1.414L13.414 12l5.293-5.293c.39-.39.39-1.024 0-1.414s-1.024-.39-1.414 0L12 10.586 6.707 5.293c-.39-.39-1.024-.39-1.414 0s-.39 1.024 0 1.414z"></path></svg>
        </button>
      </div>
    </div>
    <div class="gdoc-modal-body">
      <iframe class="gdoc-modal-iframe" src="about:blank" loading="lazy"></iframe>
      <div class="bg-preview-body"></div>
    </div>
</div>
</div>

<div id="gdoc-preview-toast-container" class="gdoc-toast-container" aria-live="polite" aria-atomic="false">
  <div class="gdoc-toast-container-inner"></div>
</div>

<div id="gdoc-preview-list-modal" class="gdoc-list-modal" hidden="">
  <div class="gdoc-list-modal-dialog" role="dialog" aria-modal="true" aria-label="他のプレビュー文書一覧">
    <div class="gdoc-list-modal-header">
      <div class="gdoc-list-modal-title">プレビュー中の文書</div>
      <button type="button" class="gdoc-list-modal-close" aria-label="閉じる">×</button>
    </div>
    <div class="gdoc-list-modal-body">
      <ul class="gdoc-list"></ul>
    </div>
  </div>
</div>

<script>
(function () {
  'use strict';

  var MOBILE_MAX_WIDTH = 768; // ビューポート幅による PC/モバイル判定
  var STORAGE_KEY = 'gdocPreviewState_v2';
  var ZOOM_MIN = 0.5;
  var ZOOM_MAX = 2.0;
  var ZOOM_STEP = 0.05;

  // ブラウザの自動スクロール復元を無効化（自前で制御する）
  if (history && typeof history.scrollRestoration === 'string') {
    try { history.scrollRestoration = 'manual'; } catch (e) {}
  }

  var popover = document.getElementById('gdoc-preview-popover');
  var titleEl = popover ? popover.querySelector('.gdoc-popover-title') : null;
  var previewBtn = popover ? popover.querySelector('.gdoc-btn-preview') : null;
  var openBtn = popover ? popover.querySelector('.gdoc-btn-open') : null;
  var copyBtn = popover ? popover.querySelector('.gdoc-btn-copy') : null;

  var bgPopover = document.getElementById('bg-preview-popover');
  var bgTitleEl = bgPopover ? bgPopover.querySelector('.gdoc-popover-title') : null;
  var bgPreviewBtn = bgPopover ? bgPopover.querySelector('.gdoc-btn-preview') : null;
  var bgGoBtn = bgPopover ? bgPopover.querySelector('.gdoc-btn-go') : null;
  var bgToastBtn = bgPopover ? bgPopover.querySelector('.gdoc-btn-toast') : null;
  var bgCloseBtn = bgPopover ? bgPopover.querySelector('.gdoc-btn-close') : null;

  var modal = document.getElementById('gdoc-preview-modal');
  var modalDialog = modal ? modal.querySelector('.gdoc-modal-dialog') : null;
  var modalHeader = modal ? modal.querySelector('.gdoc-modal-header') : null;
  var modalTitle = modal ? modal.querySelector('.gdoc-modal-title') : null;
  var modalIframe = modal ? modal.querySelector('.gdoc-modal-iframe') : null;
  var bgPreviewBody = modal ? modal.querySelector('.bg-preview-body') : null;
  var modalBtnClose = modal ? modal.querySelector('.gdoc-modal-btn-close') : null;
  var modalBtnOpen = modal ? modal.querySelector('.gdoc-modal-btn-open') : null;
  var modalBtnReload = modal ? modal.querySelector('.gdoc-modal-btn-reload') : null;
  var modalBtnCopy = modal ? modal.querySelector('.gdoc-modal-btn-copy') : null;
  var modalBtnJump = modal ? modal.querySelector('.gdoc-modal-btn-jump') : null;
  var resizeHandles = modalDialog ? modalDialog.querySelectorAll('.gdoc-resize-handle') : [];

  var toastContainer = document.getElementById('gdoc-preview-toast-container');
  var toastInner = toastContainer ? toastContainer.querySelector('.gdoc-toast-container-inner') : null;

  var listModal = document.getElementById('gdoc-preview-list-modal');
  var listModalDialog = listModal ? listModal.querySelector('.gdoc-list-modal-dialog') : null;
  var listModalClose = listModal ? listModal.querySelector('.gdoc-list-modal-close') : null;
  var listEl = listModal ? listModal.querySelector('.gdoc-list') : null;

  if (!popover || !titleEl || !previewBtn || !openBtn || !copyBtn || !bgPopover || !bgTitleEl || !bgPreviewBtn || !bgGoBtn || !bgToastBtn || !bgCloseBtn || !modal || !modalDialog || !modalHeader || !modalTitle || !modalIframe || !bgPreviewBody || !modalBtnClose || !modalBtnOpen || !modalBtnReload || !modalBtnCopy || !modalBtnJump || !toastContainer || !toastInner || !listModal || !listModalDialog || !listModalClose || !listEl) {
    return;
  }

  var currentLink = null; // ポップオーバー対象リンク（Docs用）
  var currentBgLink = null; // ポップオーバー対象リンク（BG用）
  var hideTimer = null;
  var bgHideTimer = null;
  var showTimer = null; // Docs用ポップオーバー表示遅延タイマー
  var bgShowTimer = null; // BG用ポップオーバー表示遅延タイマー
  var POPOVER_SHOW_DELAY = 400; // ポップオーバー表示までの遅延（ms）
  var isDragging = false;
  var dragStartX = 0;
  var dragStartY = 0;
  var dialogStartLeft = 0;
  var dialogStartTop = 0;

  var isResizing = false;
  var resizeDir = '';
  var resizeStartX = 0;
  var resizeStartY = 0;
  var startWidth = 0;
  var startHeight = 0;
  var startLeft = 0;
  var startTop = 0;

  var isMouseDownOnHeader = false;
  var headerMouseDownX = 0;
  var headerMouseDownY = 0;

  var isMobile = false;
  var state = loadState();
  var currentKey = getActiveKeyFromState(state) || null;
  var currentZoom = 1.0;

  // ---- state persistence ----
  function loadState() {
    try {
      var raw = window.localStorage.getItem(STORAGE_KEY);
      if (!raw) return { items: [], lastGeometry: null };
      var parsed = JSON.parse(raw);
      if (!parsed || !Array.isArray(parsed.items)) {
        return { items: [], lastGeometry: null };
      }
      // 既存アイテムにkindがない場合はgdocとして扱う
      for (var i = 0; i < parsed.items.length; i++) {
        if (!parsed.items[i].kind) {
          parsed.items[i].kind = 'gdoc';
        }
      }
      return parsed;
    } catch (e) {
      return { items: [], lastGeometry: null };
    }
  }

  function saveState() {
    try {
      window.localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
    } catch (e) {
      // ignore
    }
  }

  function getActiveKeyFromState(s) {
    if (!s || !Array.isArray(s.items)) return null;
    for (var i = 0; i < s.items.length; i++) {
      if (s.items[i].state === 'active') return s.items[i].key;
    }
    return null;
  }

  function getPreviewKeyFromLink(link) {
    if (!link) return null;
    // プレビューURLがあればそれをキーにする（同じドキュメント内の別タブも区別）
    var previewUrl = link.dataset.gdocPreviewUrl;
    if (previewUrl) return 'preview:' + previewUrl;
    var id = link.dataset.gdocId;
    if (id) return 'id:' + id;
    return 'href:' + link.href;
  }

  // 各リンク要素にプレビューキーを紐付けておく（本文ジャンプ用）
  function initializeLinkKeys() {
    try {
      var links = document.querySelectorAll('a.gdoc-link[data-gdoc-title]');
      for (var i = 0; i < links.length; i++) {
        var link = links[i];
        var key = getPreviewKeyFromLink(link);
        if (key) {
          link.setAttribute('data-gdoc-key', key);
        }
      }
    } catch (e) {
      // ignore
    }
  }

  // 初期化直後にキーを付与
  initializeLinkKeys();

  function ensureItemForLink(link, previewUrl) {
    var key = getPreviewKeyFromLink(link);
    if (!key) return null;
    var title = link.dataset.gdocTitle || link.textContent || link.href || '';
    var href = link.href;
    var items = state.items;
    var item = null;
    for (var i = 0; i < items.length; i++) {
      if (items[i].key === key) {
        item = items[i];
        break;
      }
    }
    if (!item) {
      var sourceElement = link.closest('[id]') || link;
      item = {
        key: key,
        kind: 'gdoc',
        id: link.dataset.gdocId || null,
        href: href,
        previewUrl: previewUrl,
        title: title,
        state: 'active',
        position: null,
        size: null,
        zoom: 1.0,
        lastUpdated: Date.now(),
        sourceId: sourceElement && sourceElement.id ? sourceElement.id : null,
        sourceUrl: window.location.href.split('#')[0]
      };
      if (state.lastGeometry) {
        item.position = {
          left: state.lastGeometry.left,
          top: state.lastGeometry.top
        };
        item.size = {
          width: state.lastGeometry.width,
          height: state.lastGeometry.height
        };
        item.zoom = state.lastGeometry.zoom || 1.0;
      }
      state.items.push(item);
    } else {
      item.href = href;
      item.previewUrl = previewUrl;
      item.title = title;
      item.lastUpdated = Date.now();
      if (!item.sourceUrl) {
        var srcEl = link.closest('[id]') || link;
        item.sourceId = srcEl && srcEl.id ? srcEl.id : (item.sourceId || null);
        item.sourceUrl = window.location.href.split('#')[0];
      }
    }
    return item;
  }

  function getBgPreviewKeyFromLink(link) {
    if (!link) return null;
    var href = link.href || link.getAttribute('href');
    if (!href) return null;
    return 'bg:' + href;
  }

  function ensureBgItemForLink(link) {
    var key = getBgPreviewKeyFromLink(link);
    if (!key) return null;
    var href = link.href || link.getAttribute('href');
    var title = link.textContent || link.getAttribute('title') || href || '';
    var items = state.items;
    var item = null;
    for (var i = 0; i < items.length; i++) {
      if (items[i].key === key) {
        item = items[i];
        break;
      }
    }
    if (!item) {
      var hrefWithoutHash = href.split('#')[0];
      var anchorId = href.indexOf('#') !== -1 ? href.split('#')[1] : null;
      var sourceElement = link.closest('[id]') || link;
      item = {
        key: key,
        kind: 'bg',
        href: href,
        pageUrl: hrefWithoutHash,
        anchorId: anchorId,
        title: title,
        state: 'active',
        position: null,
        size: null,
        zoom: 1.0,
        lastUpdated: Date.now(),
        snippetHtml: null,
        sourceId: sourceElement && sourceElement.id ? sourceElement.id : null,
        sourceUrl: window.location.href.split('#')[0]
      };
      if (state.lastGeometry) {
        item.position = {
          left: state.lastGeometry.left,
          top: state.lastGeometry.top
        };
        item.size = {
          width: state.lastGeometry.width,
          height: state.lastGeometry.height
        };
        item.zoom = state.lastGeometry.zoom || 1.0;
      }
      state.items.push(item);
    } else {
      // 既存のアイテムが見つかった場合
      item.title = title;
      item.lastUpdated = Date.now();
      if (!item.sourceUrl) {
        var srcEl = link.closest('[id]') || link;
        item.sourceId = srcEl && srcEl.id ? srcEl.id : (item.sourceId || null);
        item.sourceUrl = window.location.href.split('#')[0];
      }
      // minimized状態の場合は何もしない（activatePreviewItemで処理される）
    }
    return item;
  }

  function findItemByKey(key) {
    if (!key) return null;
    var items = state.items;
    for (var i = 0; i < items.length; i++) {
      if (items[i].key === key) return items[i];
    }
    return null;
  }

  function setActiveItem(item) {
    if (!item) return;
    var items = state.items;
    for (var i = 0; i < items.length; i++) {
      if (items[i].key === item.key) {
        items[i].state = 'active';
      } else if (items[i].state === 'active') {
        items[i].state = 'minimized';
      }
    }
    item.state = 'active';
    currentKey = item.key;
    item.lastUpdated = Date.now();
    saveState();
  }

  function closeItemByKey(key) {
    if (!key) return;
    var items = state.items;
    var newItems = [];
    for (var i = 0; i < items.length; i++) {
      if (items[i].key !== key) newItems.push(items[i]);
    }
    state.items = newItems;
    if (currentKey === key) {
      currentKey = null;
    }
    saveState();
    if (!isMobile) {
      rebuildToasts();
    }
  }

  function getActiveItem() {
    if (currentKey) {
      var byKey = findItemByKey(currentKey);
      if (byKey && byKey.state === 'active') return byKey;
    }
    if (!state || !Array.isArray(state.items)) return null;
    for (var i = 0; i < state.items.length; i++) {
      if (state.items[i].state === 'active') {
        currentKey = state.items[i].key;
        return state.items[i];
      }
    }
    return null;
  }

  function updateLastGeometryFromActive() {
    var item = getActiveItem();
    if (!item) return;
    if (!item.position || !item.size) return;
    state.lastGeometry = {
      left: item.position.left,
      top: item.position.top,
      width: item.size.width,
      height: item.size.height,
      zoom: item.zoom || 1.0
    };
    saveState();
  }

  // ---- layout mode ----
  function updateMode() {
    isMobile = window.innerWidth <= MOBILE_MAX_WIDTH;
    if (isMobile) {
      modal.classList.add('gdoc-modal-mobile');
      if (toastContainer) {
        toastContainer.style.display = 'none';
      }
      if (!listModal.hidden) {
        listModal.hidden = true;
      }
    } else {
      modal.classList.remove('gdoc-modal-mobile');
      if (toastContainer) {
        toastContainer.style.display = '';
      }
      rebuildToasts();
      var activeItem = getActiveItem();
      if (activeItem) {
        applyGeometry(activeItem);
        applyZoom(activeItem.zoom || 1.0);
      }
    }
  }

  window.addEventListener('resize', function () {
    updateMode();
  });

  // ---- popover (リンク横UI) ----
  function showPopoverForLink(link) {
    if (!link || !link.dataset || !link.dataset.gdocTitle) return;
    currentLink = link;

    var rect = link.getBoundingClientRect();
    titleEl.textContent = link.dataset.gdocTitle || link.textContent || '';

    var top = rect.bottom + window.scrollY + 8;
    var left = rect.left + window.scrollX;

    popover.style.top = top + 'px';
    popover.style.left = left + 'px';
    popover.hidden = false;
  }

  function scheduleHidePopover() {
    hideTimer = window.setTimeout(function () {
      popover.hidden = true;
      currentLink = null;
    }, 180);
  }

  function cancelHidePopover() {
    if (hideTimer) {
      window.clearTimeout(hideTimer);
      hideTimer = null;
    }
  }

  function cancelShowPopover() {
    if (showTimer) {
      window.clearTimeout(showTimer);
      showTimer = null;
    }
  }

  document.addEventListener('mouseover', function (e) {
    var link = e.target.closest && e.target.closest('a.gdoc-link[data-gdoc-title]');
    if (!link) return;
    cancelHidePopover();
    cancelShowPopover();
    showTimer = window.setTimeout(function () {
      showPopoverForLink(link);
    }, POPOVER_SHOW_DELAY);
  });

  document.addEventListener('focusin', function (e) {
    var link = e.target.closest && e.target.closest('a.gdoc-link[data-gdoc-title]');
    if (!link) return;
    cancelHidePopover();
    showPopoverForLink(link);
  });

  document.addEventListener('click', function (e) {
    var link = e.target.closest && e.target.closest('a.gdoc-link[data-gdoc-title]');
    if (!link) return;
    e.preventDefault();
    cancelHidePopover();
    showPopoverForLink(link);
  });

  document.addEventListener('mouseout', function (e) {
    var fromLink = e.target.closest && e.target.closest('a.gdoc-link[data-gdoc-title]');
    if (!fromLink) return;
    var to = e.relatedTarget;
    if (to && (to.closest && (to.closest('a.gdoc-link[data-gdoc-title]') || to.closest('#gdoc-preview-popover')))) {
      return;
    }
    cancelShowPopover();
    scheduleHidePopover();
  });

  popover.addEventListener('mouseenter', cancelHidePopover);
  popover.addEventListener('mouseleave', scheduleHidePopover);

  function openLinkInNewTabFromLink(link) {
    if (!link) return;
    window.open(link.href, '_blank', 'noopener');
  }

  function copyLinkFromLink(link) {
    if (!link) return;
    var url = link.href;
    if (navigator.clipboard && navigator.clipboard.writeText) {
      navigator.clipboard.writeText(url).catch(function () {});
      return;
    }
    var tmp = document.createElement('textarea');
    tmp.style.position = 'fixed';
    tmp.style.opacity = '0';
    tmp.value = url;
    document.body.appendChild(tmp);
    tmp.select();
    try { document.execCommand('copy'); } catch (e) {}
    document.body.removeChild(tmp);
  }

  // ポップオーバーのボタン
  previewBtn.addEventListener('click', function () {
    if (!currentLink) return;
    openPreviewFromLink(currentLink);
  });

  openBtn.addEventListener('click', function () {
    if (!currentLink) return;
    openLinkInNewTabFromLink(currentLink);
  });

  copyBtn.addEventListener('click', function () {
    if (!currentLink) return;
    copyLinkFromLink(currentLink);
  });

  // BGプレビュー用ポップオーバーのボタン
  bgPreviewBtn.addEventListener('click', function () {
    if (!currentBgLink) return;
    openBgPreviewFromLink(currentBgLink);
    bgPopover.hidden = true;
  });

  bgGoBtn.addEventListener('click', function () {
    if (!currentBgLink) return;
    window.location.href = currentBgLink.href;
  });

  bgToastBtn.addEventListener('click', function () {
    if (!currentBgLink) return;
    var item = ensureBgItemForLink(currentBgLink);
    if (item) {
      item.state = 'minimized';
      saveState();
      rebuildToasts();
    }
    bgPopover.hidden = true;
  });

  bgCloseBtn.addEventListener('click', function () {
    bgPopover.hidden = true;
    currentBgLink = null;
  });

  function openBgPreviewFromLink(link) {
    var item = ensureBgItemForLink(link);
    if (!item) return;
    activatePreviewItem(item, true);
  }

  function showBgPopoverForLink(link) {
    if (!link) return;
    currentBgLink = link;

    var rect = link.getBoundingClientRect();
    bgTitleEl.textContent = link.textContent || link.getAttribute('title') || 'プレビュー';

    var top = rect.bottom + window.scrollY + 8;
    var left = rect.left + window.scrollX;

    bgPopover.style.top = top + 'px';
    bgPopover.style.left = left + 'px';
    bgPopover.hidden = false;
  }

  function scheduleHideBgPopover() {
    bgHideTimer = window.setTimeout(function () {
      bgPopover.hidden = true;
      currentBgLink = null;
    }, 180);
  }

  function cancelHideBgPopover() {
    if (bgHideTimer) {
      window.clearTimeout(bgHideTimer);
      bgHideTimer = null;
    }
  }

  function cancelShowBgPopover() {
    if (bgShowTimer) {
      window.clearTimeout(bgShowTimer);
      bgShowTimer = null;
    }
  }

  bgPopover.addEventListener('mouseenter', cancelHideBgPopover);
  bgPopover.addEventListener('mouseleave', scheduleHideBgPopover);

  // ---- ポップアップ（プレビューウィンドウ） ----
  function computePreviewUrlFromLink(link) {
    if (!link) return null;
    var previewUrl = link.dataset.gdocPreviewUrl;
    if (previewUrl) return previewUrl;
    var baseUrl = link.dataset.gdocBaseUrl;
    if (!baseUrl) {
      return link.href;
    }
    return baseUrl.replace(/\/$/, '') + '/preview';
  }

  function applyGeometry(item) {
    if (!item || !item.position || !item.size) {
      // デフォルト: 中央
      modalDialog.style.top = '50%';
      modalDialog.style.left = '50%';
      modalDialog.style.transform = 'translate(-50%, -50%)';
      modalDialog.style.width = '';
      modalDialog.style.height = '';
      return;
    }
    var left = item.position.left;
    var top = item.position.top;
    var width = item.size.width;
    var height = item.size.height;

    var minWidth = 320;
    var minHeight = 220;
    var maxWidth = Math.min(window.innerWidth - 40, 1400);
    var maxHeight = window.innerHeight - 40;

    if (width < minWidth) width = minWidth;
    if (height < minHeight) height = minHeight;
    if (width > maxWidth) width = maxWidth;
    if (height > maxHeight) height = maxHeight;

    if (left + width > window.innerWidth - 10) {
      left = window.innerWidth - 10 - width;
    }
    if (top + height > window.innerHeight - 10) {
      top = window.innerHeight - 10 - height;
    }
    if (left < 0) left = 0;
    if (top < 0) top = 0;

    modalDialog.style.transform = 'none';
    modalDialog.style.left = left + 'px';
    modalDialog.style.top = top + 'px';
    modalDialog.style.width = width + 'px';
    modalDialog.style.height = height + 'px';
  }

  function applyZoom(z) {
    // ズーム機能を廃止し、常に等倍表示に固定する
    currentZoom = 1.0;
    modalIframe.style.transform = 'scale(1)';
  }

  function openPreviewFromLink(link) {
    var previewUrl = computePreviewUrlFromLink(link);
    if (!previewUrl) return;

    var item = ensureItemForLink(link, previewUrl);
    if (!item) return;
    activatePreviewItem(item, true);
  }

  function loadBgSnippetForItem(item, callback) {
    if (!item || item.kind !== 'bg') {
      if (callback) callback(null);
      return;
    }

    if (item.snippetHtml) {
      if (callback) callback(item.snippetHtml);
      return;
    }

    // 単一HTMLファイル（index_single.html）を検出
    var isSinglePage = window.location.pathname.indexOf('index_single.html') !== -1 || 
                       document.querySelector('section.chapter-page') !== null;
    
    console.log('loadBgSnippetForItem:', {
      pageUrl: item.pageUrl,
      anchorId: item.anchorId,
      isSinglePage: isSinglePage,
      pathname: window.location.pathname
    });
    
    // 単一HTMLファイルの場合は常にページセクションから抽出
    if (isSinglePage) {
      console.log('Single-page mode: extracting from page section');
      var snippet = extractSnippetFromSinglePage(item.pageUrl, item.anchorId);
      if (snippet) {
        item.snippetHtml = snippet;
        saveState();
        if (callback) callback(snippet);
        return;
      } else {
        console.warn('Failed to extract from single page, trying current page');
        // フォールバック: 現在のページから抽出
        snippet = extractSnippetFromCurrentPage(item.anchorId);
        item.snippetHtml = snippet;
        saveState();
        if (callback) callback(snippet);
        return;
      }
    }
    
    // 個別HTMLファイルの場合
    var currentPageUrl = window.location.href.split('#')[0];
    var isSamePage = !item.pageUrl || item.pageUrl === '' || item.pageUrl === currentPageUrl;

    if (isSamePage) {
      var snippet = extractSnippetFromCurrentPage(item.anchorId);
      item.snippetHtml = snippet;
      saveState();
      if (callback) callback(snippet);
    } else {
      // 相対パスを絶対URLに変換
      var absoluteUrl = item.pageUrl;
      try {
        absoluteUrl = new URL(item.pageUrl, window.location.href).href;
      } catch (e) {
        console.warn('Failed to resolve URL', item.pageUrl, e);
      }
      
      console.log('Loading BG preview from:', absoluteUrl);
      
      // file:// プロトコルの場合はXHRを使用（fetchはCORS制限がある）
      var isFileProtocol = window.location.protocol === 'file:' || absoluteUrl.indexOf('file:') === 0;
      
      if (isFileProtocol) {
        // XMLHttpRequestを使用（同期的に読み込む）
        try {
          var xhr = new XMLHttpRequest();
          xhr.open('GET', absoluteUrl, true);
          xhr.onload = function () {
            if (xhr.status === 200 || xhr.status === 0) {
              var html = xhr.responseText;
              var snippet = extractSnippetFromHtml(html, item.anchorId, item.pageUrl);
              item.snippetHtml = snippet;
              saveState();
              if (callback) callback(snippet);
            } else {
              console.warn('XHR failed with status:', xhr.status);
              if (callback) callback('<p>プレビューの読み込みに失敗しました。<br>Status: ' + xhr.status + '</p>');
            }
          };
          xhr.onerror = function () {
            console.warn('XHR error loading:', absoluteUrl);
            var errorMsg = '<p>プレビューの読み込みに失敗しました。</p>';
            errorMsg += '<p style="font-size:0.9em;color:#666;">file://プロトコルではブラウザのセキュリティ制限により、別ページの読み込みができません。</p>';
            errorMsg += '<p style="font-size:0.9em;color:#666;">以下のいずれかの方法をお試しください：</p>';
            errorMsg += '<ol style="font-size:0.9em;color:#666;margin-left:20px;">';
            errorMsg += '<li>HTTPサーバーを起動：<pre style="background:#f5f5f5;padding:10px;border-radius:4px;font-size:0.85em;margin:5px 0;">cd out<br>python3 -m http.server 8000<br>open http://localhost:8000/content/' + window.location.pathname.split('/').pop() + '</pre></li>';
            errorMsg += '<li>単一HTMLファイルを使用：<pre style="background:#f5f5f5;padding:10px;border-radius:4px;font-size:0.85em;margin:5px 0;">open out/index_single.html</pre></li>';
            errorMsg += '</ol>';
            if (callback) callback(errorMsg);
          };
          xhr.send();
        } catch (e) {
          console.warn('XHR exception:', e);
          if (callback) callback('<p>プレビューの読み込みに失敗しました。<br>Error: ' + e.message + '</p>');
        }
      } else {
        // HTTPプロトコルの場合はfetchを使用
        fetch(absoluteUrl)
          .then(function (response) {
            if (!response.ok) {
              throw new Error('HTTP ' + response.status + ': ' + response.statusText);
            }
            return response.text();
          })
          .then(function (html) {
            var snippet = extractSnippetFromHtml(html, item.anchorId, item.pageUrl);
            item.snippetHtml = snippet;
            saveState();
            if (callback) callback(snippet);
          })
          .catch(function (err) {
            console.warn('Failed to load BG preview content', err, 'URL:', absoluteUrl);
            if (callback) callback('<p>プレビューの読み込みに失敗しました。<br>URL: ' + item.pageUrl + '</p>');
          });
      }
    }
  }

  function extractSnippetFromSinglePage(pageUrl, anchorId) {
    // 単一HTMLファイルから該当ページのセクションを抽出
    console.log('extractSnippetFromSinglePage:', { pageUrl: pageUrl, anchorId: anchorId });
    
    // pageUrlが空の場合は現在のページから抽出
    if (!pageUrl || pageUrl === '') {
      console.log('No pageUrl, using current page');
      return extractSnippetFromCurrentPage(anchorId);
    }
    
    // pageUrl: "05_ch05.html" -> "05_ch05"
    var pageName = pageUrl.replace(/\.html.*$/, '').replace(/^.*\//, '');
    var pageId = 'page-' + pageName;
    
    console.log('Searching for single-page section:', pageId, 'pageName:', pageName);
    
    // ページセクションを探す
    var pageSection = document.getElementById(pageId);
    if (!pageSection) {
      // 別の形式も試す
      console.log('Trying alternative selectors...');
      var alternatives = [
        'section[id="' + pageId + '"]',
        'section[id*="' + pageName + '"]',
        'section.chapter-page[id*="' + pageName + '"]'
      ];
      
      for (var i = 0; i < alternatives.length; i++) {
        try {
          pageSection = document.querySelector(alternatives[i]);
          if (pageSection) {
            console.log('Found by alternative selector:', alternatives[i]);
            break;
          }
        } catch (e) {
          // 無効なセレクタの場合
        }
      }
    }
    
    if (!pageSection) {
      console.warn('Page section not found:', pageId);
      // 利用可能なページセクションを表示
      var sections = document.querySelectorAll('section.chapter-page');
      var sectionIds = [];
      for (var j = 0; j < Math.min(10, sections.length); j++) {
        sectionIds.push(sections[j].id);
      }
      console.log('Available page sections:', sectionIds);
      
      // フォールバック: 現在のページから抽出
      return extractSnippetFromCurrentPage(anchorId);
    }
    
    console.log('Found page section:', pageSection.id);
    
    // セクション全体を取得
    var clone = pageSection.cloneNode(true);
    removeUiElements(clone);
    
    // 脚注参照の数を確認
    var refsInClone = clone.querySelectorAll('a[role="doc-noteref"], a.footnote-ref');
    console.log('extractSnippetFromSinglePage: Found', refsInClone.length, 'footnote refs in clone');
    
    inlineFootnotes(clone, document);
    simplifyComments(clone);
    fixRelativeLinks(clone, '');
    
    return clone.innerHTML || '';
  }

  function extractSnippetFromCurrentPage(anchorId) {
    var target = anchorId ? document.getElementById(anchorId) : null;
    
    // セクション全体を取得（章レベル）
    var section = target ? target.closest('section') : document.getElementById('quarto-document-content');
    if (!section) section = document.getElementById('quarto-document-content');
    if (!section) return '<p>コンテンツが見つかりません。</p>';

    console.log('extractSnippetFromCurrentPage: Cloning section', section.id || section.className);
    
    var clone = section.cloneNode(true);
    removeUiElements(clone);
    
    // 脚注参照の数を確認
    var refsInClone = clone.querySelectorAll('a[role="doc-noteref"], a.footnote-ref');
    console.log('extractSnippetFromCurrentPage: Found', refsInClone.length, 'footnote refs in clone');
    
    inlineFootnotes(clone, document);
    simplifyComments(clone);
    fixRelativeLinks(clone, '');
    return clone.innerHTML || '';
  }

  function fixRelativeLinks(container, baseUrl) {
    // プレビュー内のリンクを絶対パスに変換
    var links = container.querySelectorAll('a[href]');
    for (var i = 0; i < links.length; i++) {
      var link = links[i];
      var href = link.getAttribute('href');
      if (href && !href.match(/^https?:/) && !href.match(/^#/)) {
        try {
          var absolute = new URL(href, window.location.href).href;
          link.setAttribute('href', absolute);
        } catch (e) {
          // ignore
        }
      }
    }
  }

  function extractSnippetFromHtml(html, anchorId, pageUrl) {
    try {
      var parser = new DOMParser();
      var doc = parser.parseFromString(html, 'text/html');
      var target = anchorId ? doc.getElementById(anchorId) : null;
      
      // セクション全体を取得（章レベル）
      var section = target ? target.closest('section') : doc.getElementById('quarto-document-content');
      if (!section) section = doc.getElementById('quarto-document-content');
      if (!section) return '<p>コンテンツが見つかりません。</p>';

      var clone = section.cloneNode(true);
      removeUiElements(clone);
      inlineFootnotes(clone, doc);
      simplifyComments(clone);
      fixRelativeLinks(clone, pageUrl);
      
      return clone.innerHTML || '';
    } catch (e) {
      console.warn('Failed to parse HTML', e);
      return '<p>コンテンツの解析に失敗しました。</p>';
    }
  }

  function removeUiElements(container) {
    var selectors = [
      'header', '.header-ui', '#quarto-sidebar', '#quarto-margin-sidebar',
      '.right-comments', '.left-panel', '.right-panel', 'nav', '.navbar'
    ];
    selectors.forEach(function (sel) {
      var elements = container.querySelectorAll(sel);
      for (var i = 0; i < elements.length; i++) {
        elements[i].parentNode.removeChild(elements[i]);
      }
    });
  }

  function inlineFootnotes(container, sourceDoc) {
    var refSelector = 'a[role="doc-noteref"], a.footnote-ref';
    var refs = container.querySelectorAll(refSelector);
    
    console.log('inlineFootnotes: Found', refs.length, 'footnote references');
    
    // 既に処理済みかチェック（インラインマーカーが存在する場合）
    var existingMarkers = container.querySelectorAll('.inline-footnote');
    if (existingMarkers.length > 0 && refs.length === 0) {
      console.log('inlineFootnotes: Already processed (found', existingMarkers.length, 'markers)');
      return;
    }
    
    if (!refs.length) {
      console.log('inlineFootnotes: No footnote references found');
      return;
    }

    var doc = sourceDoc || document;
    
    // 脚注参照を配列に変換して、段落ごとにグループ化
    var refsByHost = new Map();
    
    for (var i = 0; i < refs.length; i++) {
      var ref = refs[i];
      var href = ref.getAttribute('href') || ref.getAttribute('data-footnote-href');
      if (!href || !href.startsWith('#')) continue;
      
      var host = findHostParagraph(ref);
      if (!host) continue;
      
      if (!refsByHost.has(host)) {
        refsByHost.set(host, []);
      }
      refsByHost.get(host).push(ref);
    }
    
    console.log('Found', refsByHost.size, 'host paragraphs with footnotes');
    
    // 各段落の脚注を処理
    refsByHost.forEach(function (hostRefs, host) {
      console.log('Processing', hostRefs.length, 'footnotes for paragraph:', host.textContent.substring(0, 50));
      
      // 脚注コンテナを作成
      var footnotesWrapper = document.createElement('div');
      footnotesWrapper.className = 'footnotes-wrapper';
      footnotesWrapper.style.cssText = 'margin: 0.5em 0;';
      
      // 各脚注を処理
      for (var j = 0; j < hostRefs.length; j++) {
        var ref = hostRefs[j];
        var href = ref.getAttribute('href') || ref.getAttribute('data-footnote-href');
        if (!href || !href.startsWith('#')) continue;
        
        var id = href.slice(1);
        // まずcontainer内を探し、なければsourceDocから探す
        var target = container.querySelector('#' + id);
        if (!target && doc) {
          target = doc.getElementById ? doc.getElementById(id) : doc.querySelector('#' + id);
        }
        if (!target) {
          console.warn('Footnote target not found:', id);
          continue;
        }
        
        var numberText = (ref.textContent || '').replace(/[^0-9]/g, '') || '';
        
        var clone = target.cloneNode(true);
        var backlinks = clone.querySelectorAll('.footnote-back, .footnote-backref, [role="doc-backlink"]');
        for (var k = 0; k < backlinks.length; k++) {
          backlinks[k].parentNode.removeChild(backlinks[k]);
        }
        
        var fnContainer = document.createElement('div');
        fnContainer.className = 'footnote-inline';
        fnContainer.style.cssText = 'margin: 0.3em 0; padding: 0.5em 1em; background: #f8f9fa; border-left: 3px solid #1a73e8; font-size: 0.9em;';
        
        var numSpan = document.createElement('span');
        numSpan.className = 'footnote-num';
        numSpan.style.fontWeight = 'bold';
        numSpan.textContent = (numberText ? numberText : '') + '. ';
        fnContainer.appendChild(numSpan);
        
        while (clone.firstChild) {
          fnContainer.appendChild(clone.firstChild);
        }
        
        footnotesWrapper.appendChild(fnContainer);
        
        // 元の脚注参照をインラインマーカーに置き換え
        if (ref.parentNode) {
          var marker = document.createElement('span');
          marker.className = 'inline-footnote';
          marker.style.cssText = 'color: #1a73e8; font-size: 0.9em; margin-left: 2px; font-weight: 600;';
          marker.textContent = '[' + numberText + ']';
          ref.parentNode.replaceChild(marker, ref);
        }
      }
      
      // 段落の直後に脚注ラッパーを挿入
      if (host.nextSibling) {
        host.parentNode.insertBefore(footnotesWrapper, host.nextSibling);
      } else {
        host.parentNode.appendChild(footnotesWrapper);
      }
      
      console.log('Inserted footnotes wrapper after paragraph');
    });
    
    console.log('Finished processing footnotes');
  }

  function findHostParagraph(el) {
    var p = el;
    while (p && p !== document.body) {
      if (p.tagName === 'P' || p.tagName === 'LI') {
        return p;
      }
      p = p.parentElement;
    }
    return null;
  }

  function getElementKey(el) {
    if (!el) return '';
    if (el.id) return 'id:' + el.id;
    var parent = el.parentNode;
    if (!parent) return '';
    var siblings = parent.children;
    for (var i = 0; i < siblings.length; i++) {
      if (siblings[i] === el) {
        return 'idx:' + i;
      }
    }
    return '';
  }

  function scrollToAnchorInPreview(container, anchorId) {
    if (!container || !anchorId) {
      console.warn('scrollToAnchorInPreview: missing container or anchorId');
      return false;
    }
    
    console.log('Searching for anchor:', anchorId, 'in container');
    
    // 単一HTMLファイルの場合、プレフィックス付きIDも試す
    var isSinglePage = window.location.pathname.indexOf('index_single.html') !== -1 || 
                       document.querySelector('section.chapter-page') !== null;
    var anchorVariants = [anchorId];
    
    if (isSinglePage) {
      // ページ名のプレフィックスを試す（例: 05_ch05--toc-5-4-1）
      var pageNames = ['05_ch05', '04_ch04', '03_ch03', '02_ch02', '01_ch01', '06_ch06'];
      for (var p = 0; p < pageNames.length; p++) {
        anchorVariants.push(pageNames[p] + '--' + anchorId);
      }
    }
    
    // アンカー要素を探す（複数の方法を試す）
    var target = null;
    
    // 全てのバリアントを試す
    for (var v = 0; v < anchorVariants.length && !target; v++) {
      var currentAnchorId = anchorVariants[v];
      
      // 方法1: 直接ID検索（特殊文字をエスケープせずに試す）
      try {
        var selector = '#' + currentAnchorId.replace(/[!"#$%&'()*+,.\/:;<=>?@[\\\]^`{|}~]/g, '\\$&');
        target = container.querySelector(selector);
        if (target) {
          console.log('Found by escaped selector (variant ' + v + '):', currentAnchorId);
          anchorId = currentAnchorId; // 見つかったIDを使用
          break;
        }
      } catch (e) {
        // 次の方法を試す
      }
    }
    
    if (!target) {
      console.log('Method 1 failed for all variants');
    }
    
    // 方法2: CSS.escapeを使用（全バリアント）
    if (!target) {
      for (var v2 = 0; v2 < anchorVariants.length && !target; v2++) {
        try {
          if (typeof CSS !== 'undefined' && CSS.escape) {
            target = container.querySelector('#' + CSS.escape(anchorVariants[v2]));
            if (target) {
              console.log('Found by CSS.escape (variant ' + v2 + '):', anchorVariants[v2]);
              anchorId = anchorVariants[v2];
              break;
            }
          }
        } catch (e) {
          // 次を試す
        }
      }
    }
    
    // 方法3: data-anchor-id属性で検索（全バリアント）
    if (!target) {
      for (var v3 = 0; v3 < anchorVariants.length && !target; v3++) {
        try {
          target = container.querySelector('[data-anchor-id="' + anchorVariants[v3] + '"]');
          if (target) {
            console.log('Found by data-anchor-id (variant ' + v3 + '):', anchorVariants[v3]);
            anchorId = anchorVariants[v3];
            break;
          }
        } catch (e) {
          // 次を試す
        }
      }
    }
    
    // 方法4: id属性を直接検索（全要素をスキャン、全バリアント）
    if (!target) {
      var allElements = container.querySelectorAll('[id]');
      console.log('Scanning', allElements.length, 'elements with id');
      for (var i = 0; i < allElements.length; i++) {
        for (var v4 = 0; v4 < anchorVariants.length; v4++) {
          if (allElements[i].id === anchorVariants[v4]) {
            target = allElements[i];
            console.log('Found by direct scan at index', i, 'variant:', anchorVariants[v4]);
            anchorId = anchorVariants[v4];
            break;
          }
        }
        if (target) break;
      }
    }
    
    // 方法5: spanタグの中を探す（idx-アンカーの場合、全バリアント）
    if (!target) {
      var spans = container.querySelectorAll('span[id]');
      for (var j = 0; j < spans.length; j++) {
        for (var v5 = 0; v5 < anchorVariants.length; v5++) {
          if (anchorVariants[v5].indexOf('idx-') !== -1 && spans[j].id === anchorVariants[v5]) {
            target = spans[j];
            console.log('Found idx anchor in span, variant:', anchorVariants[v5]);
            anchorId = anchorVariants[v5];
            break;
          }
        }
        if (target) break;
      }
    }
    
    // 方法6: toc-X-Y-Z形式の場合、セクション番号から推測
    if (!target && anchorId.match(/^toc-\d+-\d+(-\d+)?$/)) {
      console.log('Trying to find section by number pattern:', anchorId);
      // toc-5-4-1 -> 第5章第4節第1項 のようなパターンを探す
      var parts = anchorId.replace('toc-', '').split('-');
      var sectionNum = parts[1]; // 4
      var itemNum = parts[2]; // 1
      
      // 第X節を探す
      var sectionPattern = '第' + sectionNum + '節';
      var sections = container.querySelectorAll('section[id*="' + sectionPattern + '"], h2[id*="' + sectionPattern + '"], h2[data-anchor-id*="' + sectionPattern + '"]');
      console.log('Found sections matching', sectionPattern, ':', sections.length);
      
      if (sections.length > 0) {
        // 第X節が見つかった場合、その中の第Y項を探す
        if (itemNum) {
          var itemPattern = '第' + itemNum + '項';
          var parentSection = sections[0].closest('section') || sections[0].parentElement;
          if (parentSection) {
            var items = parentSection.querySelectorAll('section[id*="' + itemPattern + '"], h3[id*="' + itemPattern + '"], h3[data-anchor-id*="' + itemPattern + '"]');
            console.log('Found items matching', itemPattern, ':', items.length);
            if (items.length > 0) {
              target = items[0];
              console.log('Found by section/item pattern');
            }
          }
        }
        
        // 項が見つからない場合は節を使用
        if (!target) {
          target = sections[0];
          console.log('Using section as fallback');
        }
      }
    }
    
    if (!target) {
      console.warn('Anchor not found in preview after all attempts:', anchorId);
      // デバッグ: 最初の20個のIDを表示
      var ids = [];
      var els = container.querySelectorAll('[id]');
      for (var k = 0; k < Math.min(20, els.length); k++) {
        ids.push(els[k].id);
      }
      console.log('Available IDs (first 20):', ids);
      return false;
    }
    
    console.log('Found anchor:', anchorId, 'Element:', target.tagName, 'ID:', target.id, 'Class:', target.className);
    
    // 索引アンカー（idx-）の場合は、その段落を探す
    if (anchorId.indexOf('idx-') === 0) {
      var paragraph = findHostParagraph(target);
      if (paragraph) {
        console.log('Using host paragraph for idx anchor:', paragraph.tagName);
        target = paragraph;
      }
    }
    
    // 目次アンカー（toc-）の場合は、対応する見出しを探す
    if (anchorId.indexOf('toc-') === 0) {
      // 見出し要素を探す
      if (target.tagName && target.tagName.match(/^H[1-6]$/)) {
        console.log('Target is already a heading');
      } else {
        var heading = target.closest('h1, h2, h3, h4, h5, h6');
        if (heading) {
          console.log('Using heading for toc anchor:', heading.tagName);
          target = heading;
        } else {
          // data-anchor-idを持つ見出しを探す
          var h = container.querySelector('h1[data-anchor-id="' + anchorId + '"], h2[data-anchor-id="' + anchorId + '"], h3[data-anchor-id="' + anchorId + '"], h4[data-anchor-id="' + anchorId + '"]');
          if (h) {
            console.log('Found heading by data-anchor-id:', h.tagName);
            target = h;
          }
        }
      }
    }
    
    // 要素の位置を計算してスクロール
    var targetTop = 0;
    var el = target;
    var iterations = 0;
    while (el && el !== container && iterations < 50) {
      targetTop += el.offsetTop || 0;
      el = el.offsetParent;
      iterations++;
    }
    
    console.log('Scrolling to position:', targetTop, 'Container scrollHeight:', container.scrollHeight);
    
    // スクロール実行
    if (container.scrollTo) {
      container.scrollTo({
        top: targetTop,
        behavior: 'smooth'
      });
    } else {
      container.scrollTop = targetTop;
    }
    
    // ハイライト効果を追加
    try {
      var originalBg = target.style.backgroundColor;
      var originalTransition = target.style.transition;
      target.style.transition = 'background-color 0.3s ease';
      target.style.backgroundColor = 'rgba(26, 115, 232, 0.15)';
      
      setTimeout(function () {
        target.style.backgroundColor = originalBg;
        setTimeout(function () {
          target.style.transition = originalTransition;
        }, 300);
      }, 1500);
    } catch (e) {
      console.warn('Failed to apply highlight:', e);
    }
    
    return true;
  }

  function simplifyComments(container) {
    var markers = container.querySelectorAll('.text-marker[data-comment-id]');
    for (var i = 0; i < markers.length; i++) {
      markers[i].removeAttribute('data-comment-id');
    }
  }

  function activatePreviewItem(item, fromUser) {
    if (!item) return;

    setActiveItem(item);

    modalTitle.textContent = item.title || '';

    if (item.kind === 'bg') {
      modalIframe.style.display = 'none';
      bgPreviewBody.classList.add('active');
      bgPreviewBody.innerHTML = '<p>読み込み中...</p>';
      
      loadBgSnippetForItem(item, function (html) {
        if (!html) html = '<p>コンテンツが見つかりません。</p>';
        bgPreviewBody.innerHTML = html;
        
        console.log('BG preview loaded, anchorId:', item.anchorId);
        
        // DOMが完全に描画されるまで待つ（複数回試行）
        var scrollAttempts = 0;
        var maxAttempts = 5;
        
        function tryScroll() {
          scrollAttempts++;
          
          if (item.anchorId) {
            var success = scrollToAnchorInPreview(bgPreviewBody, item.anchorId);
            if (!success && scrollAttempts < maxAttempts) {
              // スクロールに失敗した場合は再試行
              setTimeout(tryScroll, 100);
            }
          } else {
            // アンカーがない場合は先頭にスクロール
            bgPreviewBody.scrollTop = 0;
          }
        }
        
        // 初回は少し待ってから実行
        setTimeout(tryScroll, 100);
      });
    } else {
      bgPreviewBody.classList.remove('active');
      bgPreviewBody.innerHTML = '';
      modalIframe.style.display = '';
      modalIframe.src = item.previewUrl || item.href;
    }

    if (isMobile) {
      modalDialog.style.transform = 'translate(-50%, -50%)';
      modalDialog.style.top = '50%';
      modalDialog.style.left = '50%';
      modalDialog.style.width = '96vw';
      modalDialog.style.height = '90vh';
      applyZoom(1.0);
    } else {
      if (!item.position || !item.size) {
        // 初回: デフォルト位置・サイズ
        modalDialog.style.top = '50%';
        modalDialog.style.left = '50%';
        modalDialog.style.transform = 'translate(-50%, -50%)';
        modalDialog.style.width = '';
        modalDialog.style.height = '';
      } else {
        applyGeometry(item);
      }
      applyZoom(item.zoom || 1.0);
      rebuildToasts();
    }

    modal.hidden = false;
    saveState();
    
    // トーストを再構築（minimizedから復帰した場合に必要）
    if (!isMobile) {
      rebuildToasts();
    }
  }

  function closeCurrentPreview() {
    var active = getActiveItem();
    if (!active) {
      modal.hidden = true;
      modalIframe.src = 'about:blank';
      return;
    }
    var key = active.key;
    modal.hidden = true;
    modalIframe.src = 'about:blank';
    closeItemByKey(key);
  }

  // モーダルのヘッダーボタン
  modalBtnClose.addEventListener('click', function () {
    closeCurrentPreview();
  });

  modalBtnOpen.addEventListener('click', function () {
    var active = getActiveItem();
    if (!active) return;
    window.open(active.href, '_blank', 'noopener');
  });

  modalBtnReload.addEventListener('click', function () {
    var active = getActiveItem();
    if (!active) return;
    reloadPreviewItem(active);
  });

  modalBtnCopy.addEventListener('click', function () {
    var active = getActiveItem();
    if (!active) return;
    var url = active.href;
    if (navigator.clipboard && navigator.clipboard.writeText) {
      navigator.clipboard.writeText(url).catch(function () {});
      return;
    }
    var tmp = document.createElement('textarea');
    tmp.style.position = 'fixed';
    tmp.style.opacity = '0';
    tmp.value = url;
    document.body.appendChild(tmp);
    tmp.select();
    try { document.execCommand('copy'); } catch (e) {}
    document.body.removeChild(tmp);
  });

  function reloadPreviewItem(item) {
    if (!item) return;
    
    console.log('Reloading preview item:', item.key);
    
    // キャッシュをクリア
    if (item.kind === 'bg') {
      item.snippetHtml = null;
    }
    
    // 現在のスクロール位置を保存
    var currentScrollTop = 0;
    if (item.kind === 'bg' && bgPreviewBody) {
      currentScrollTop = bgPreviewBody.scrollTop;
    }
    
    // 再読み込み
    if (item.kind === 'bg') {
      bgPreviewBody.innerHTML = '<p>読み込み中...</p>';
      loadBgSnippetForItem(item, function (html) {
        if (!html) html = '<p>コンテンツが見つかりません。</p>';
        bgPreviewBody.innerHTML = html;
        
        // 元のアンカー位置にスクロール（優先）
        if (item.anchorId) {
          setTimeout(function () {
            scrollToAnchorInPreview(bgPreviewBody, item.anchorId);
          }, 100);
        } else {
          // アンカーがない場合は元のスクロール位置に戻す
          setTimeout(function () {
            bgPreviewBody.scrollTop = currentScrollTop;
          }, 100);
        }
      });
    } else if (item.kind === 'gdoc') {
      // Google Docsプレビューの場合はiframeを再読み込み
      if (modalIframe) {
        var currentSrc = modalIframe.src;
        modalIframe.src = 'about:blank';
        setTimeout(function () {
          modalIframe.src = currentSrc;
        }, 100);
      }
    }
    
    // 状態を保存
    saveState();
  }

  function getScrollElement() {
    return document.scrollingElement || document.documentElement || document.body;
  }

  function applyJumpHighlight(target) {
    if (!target) return;
    var el = target;
    if (!(el instanceof HTMLElement)) {
      el = target.parentElement || null;
    }
    while (el && el !== document.body && !(el instanceof HTMLElement)) {
      el = el.parentElement;
    }
    if (!el) return;
    try {
      el.scrollIntoView({ block: 'center', behavior: 'smooth' });
      var prevBox = el.style.boxShadow;
      el.style.transition = 'box-shadow 0.3s ease';
      el.style.boxShadow = '0 0 0 3px rgba(26,115,232,0.5)';
      setTimeout(function () {
        el.style.boxShadow = prevBox || '';
      }, 1600);
    } catch (e) {
      try {
        target.scrollIntoView({ block: 'center', behavior: 'smooth' });
      } catch (e2) {}
    }
  }

  function findSourceElementForItem(item) {
    if (!item) return null;

    // まず data-gdoc-key で厳密に一致するリンクを探す（タブ/重複対応）
    if (item.key) {
      try {
        var keySelector = 'a.gdoc-link[data-gdoc-key="' + String(item.key).replace(/"/g, '\"') + '"]';
        var byKey = document.querySelector(keySelector);
        if (byKey) return byKey;
      } catch (e) {
        // fall through to id/href
      }
    }

    var selector = '';
    if (item.id) {
      // Google Docs ID は英数字等なので単純なエスケープで十分
      selector = 'a.gdoc-link[data-gdoc-id="' + String(item.id).replace(/"/g, '\"') + '"]';
    } else if (item.href) {
      selector = 'a.gdoc-link[href="' + String(item.href).replace(/"/g, '\"') + '"]';
    }
    if (!selector) return null;
    try {
      var candidates = document.querySelectorAll(selector);
      if (!candidates || !candidates.length) return null;
      return candidates[0];
    } catch (e) {
      return null;
    }
  }

  function jumpToSourceForItem(item) {
    if (!item) return;

    var currentBase = window.location.href.split('#')[0];
    var sourceUrl = item.sourceUrl || null;
    var sourceId = item.sourceId || null;

    // 別ページに元リンクがある場合は、そのページへ遷移
    if (sourceUrl && sourceUrl !== currentBase) {
      var targetUrl = sourceUrl;
      if (sourceId) {
        // 既にハッシュが含まれていない前提
        targetUrl = sourceUrl + '#' + encodeURIComponent(sourceId);
      }
      try {
        window.location.href = targetUrl;
      } catch (e) {
        window.location.assign(targetUrl);
      }
      return;
    }

    // 同一ページ内: ソースID優先でスクロール
    var target = null;
    if (sourceId) {
      target = document.getElementById(sourceId) || null;
    }
    if (!target) {
      var linkEl = findSourceElementForItem(item);
      if (!linkEl) return;
      target = linkEl.closest('[id]') || linkEl;
    }

    var scrollEl = getScrollElement();
    var currentY = scrollEl.scrollTop;
    try {
      history.pushState({ __gdocScrollRestore: currentY }, '', window.location.href);
    } catch (e2) {}
    applyJumpHighlight(target);
  }

  modalBtnJump.addEventListener('click', function () {
    var active = getActiveItem();
    if (!active) return;
    jumpToSourceForItem(active);
  });

  // ヘッダー: ドラッグ & クリックで格納
  modalHeader.addEventListener('mousedown', function (e) {
    if (e.button !== 0) return;
    if (isMobile) return; // モバイルではドラッグ/格納なし

    isMouseDownOnHeader = true;
    headerMouseDownX = e.clientX;
    headerMouseDownY = e.clientY;

    isDragging = true;
    dragStartX = e.clientX;
    dragStartY = e.clientY;
    var rect = modalDialog.getBoundingClientRect();
    dialogStartLeft = rect.left;
    dialogStartTop = rect.top;
    modalDialog.style.transform = 'none';
    document.addEventListener('mousemove', onDragMove);
    document.addEventListener('mouseup', onHeaderMouseUp);
  });

  function onDragMove(e) {
    if (!isDragging || isMobile) return;
    var dx = e.clientX - dragStartX;
    var dy = e.clientY - dragStartY;
    var newLeft = dialogStartLeft + dx;
    var newTop = dialogStartTop + dy;

    var maxLeft = window.innerWidth - 100;
    var maxTop = window.innerHeight - 60;
    if (newLeft < 0) newLeft = 0;
    if (newTop < 0) newTop = 0;
    if (newLeft > maxLeft) newLeft = maxLeft;
    if (newTop > maxTop) newTop = maxTop;

    modalDialog.style.left = newLeft + 'px';
    modalDialog.style.top = newTop + 'px';
  }

  function onHeaderMouseUp(e) {
    document.removeEventListener('mousemove', onDragMove);
    document.removeEventListener('mouseup', onHeaderMouseUp);

    if (!isDragging) {
      isMouseDownOnHeader = false;
      return;
    }

    isDragging = false;

    var active = getActiveItem();
    if (active && !isMobile) {
      var rect = modalDialog.getBoundingClientRect();
      active.position = { left: rect.left, top: rect.top };
      if (active.size) {
        active.size.width = rect.width;
        active.size.height = rect.height;
      }
      saveState();
      updateLastGeometryFromActive();
    }

    // クリック判定（ドラッグ距離が小さい場合）
    if (isMouseDownOnHeader) {
      var dx = Math.abs(e.clientX - headerMouseDownX);
      var dy = Math.abs(e.clientY - headerMouseDownY);
      if (dx < 3 && dy < 3) {
        // ヘッダーの「ボタンやリサイズハンドル以外」をクリックした場合に格納
        var target = e.target;
        if (!target.closest('.gdoc-modal-btn') && !target.closest('.gdoc-resize-handle')) {
          minimizeActiveToToast();
        }
      }
    }
    isMouseDownOnHeader = false;
  }

  function minimizeActiveToToast() {
    if (isMobile) return;
    var active = getActiveItem();
    if (!active) return;
    active.state = 'minimized';
    active.lastUpdated = Date.now();
    currentKey = null;
    saveState();
    modal.hidden = true;
    modalIframe.src = 'about:blank';
    rebuildToasts();
  }

  // 4隅のリサイズ
  if (resizeHandles && resizeHandles.length) {
    resizeHandles.forEach(function (handle) {
      handle.addEventListener('mousedown', function (e) {
        if (e.button !== 0) return;
        if (isMobile) return;
        e.preventDefault();
        isResizing = true;
        resizeDir = handle.getAttribute('data-resize-dir') || '';
        var rect = modalDialog.getBoundingClientRect();
        resizeStartX = e.clientX;
        resizeStartY = e.clientY;
        startWidth = rect.width;
        startHeight = rect.height;
        startLeft = rect.left;
        startTop = rect.top;
        modalDialog.style.transform = 'none';
        document.addEventListener('mousemove', onResizeMove);
        document.addEventListener('mouseup', onResizeEnd);
      });
    });
  }

  function onResizeMove(e) {
    if (!isResizing || isMobile) return;

    var dx = e.clientX - resizeStartX;
    var dy = e.clientY - resizeStartY;

    var newWidth = startWidth;
    var newHeight = startHeight;
    var newLeft = startLeft;
    var newTop = startTop;

    if (resizeDir.indexOf('e') !== -1) {
      newWidth = startWidth + dx;
    }
    if (resizeDir.indexOf('s') !== -1) {
      newHeight = startHeight + dy;
    }
    if (resizeDir.indexOf('w') !== -1) {
      newWidth = startWidth - dx;
      newLeft = startLeft + dx;
    }
    if (resizeDir.indexOf('n') !== -1) {
      newHeight = startHeight - dy;
      newTop = startTop + dy;
    }

    var minWidth = 320;
    var minHeight = 220;
    var maxWidth = Math.min(window.innerWidth - 40, 1400);
    var maxHeight = window.innerHeight - 40;

    if (newWidth < minWidth) {
      newWidth = minWidth;
      if (resizeDir.indexOf('w') !== -1) {
        newLeft = startLeft + (startWidth - minWidth);
      }
    }
    if (newHeight < minHeight) {
      newHeight = minHeight;
      if (resizeDir.indexOf('n') !== -1) {
        newTop = startTop + (startHeight - minHeight);
      }
    }

    if (newWidth > maxWidth) {
      newWidth = maxWidth;
    }
    if (newHeight > maxHeight) {
      newHeight = maxHeight;
    }

    var maxRight = window.innerWidth - 10;
    var maxBottom = window.innerHeight - 10;
    if (newLeft + newWidth > maxRight) {
      if (resizeDir.indexOf('e') !== -1) {
        newWidth = maxRight - newLeft;
      } else {
        newLeft = maxRight - newWidth;
      }
    }
    if (newTop + newHeight > maxBottom) {
      if (resizeDir.indexOf('s') !== -1) {
        newHeight = maxBottom - newTop;
      } else {
        newTop = maxBottom - newHeight;
      }
    }

    modalDialog.style.width = newWidth + 'px';
    modalDialog.style.height = newHeight + 'px';
    modalDialog.style.left = newLeft + 'px';
    modalDialog.style.top = newTop + 'px';
  }

  function onResizeEnd() {
    if (!isResizing) return;
    document.removeEventListener('mousemove', onResizeMove);
    document.removeEventListener('mouseup', onResizeEnd);
    isResizing = false;

    var active = getActiveItem();
    if (active && !isMobile) {
      var rect = modalDialog.getBoundingClientRect();
      active.position = { left: rect.left, top: rect.top };
      active.size = { width: rect.width, height: rect.height };
      active.zoom = currentZoom;
      saveState();
      updateLastGeometryFromActive();
    }
  }

  // ズーム（ポップアップ内だけ）
  // Ctrl/Command + スクロールによる拡大・縮小は無効化し、
  // 通常スクロールのみを許可する
  modalDialog.addEventListener('wheel', function (e) {
    if (isMobile) return;
    var isZoomGesture = e.ctrlKey || e.metaKey || e.deltaZ !== 0;
    if (!isZoomGesture) return;

    // ブラウザのページズームが発動しないように止める
    e.preventDefault();
  }, { passive: false });

  // ---- トースト（格納状態） ----
  function getMaxIndividualToasts() {
    try {
      var raw = window.localStorage.getItem('gdocPreviewMaxToasts');
      if (raw == null) return 3;
      var n = parseInt(raw, 10);
      if (isNaN(n)) n = 3;
      if (n < 0) n = 0;
      if (n > 9) n = 9;
      return n;
    } catch (e) {
      return 3;
    }
  }

  function rebuildToasts() {
    if (!toastInner || isMobile) return;
    toastInner.innerHTML = '';

    var minimized = [];
    for (var i = 0; i < state.items.length; i++) {
      if (state.items[i].state === 'minimized') minimized.push(state.items[i]);
    }

    if (!minimized.length) return;

    // 更新日時の新しいものが上に来るように並べ替え
    minimized.sort(function (a, b) {
      return (b.lastUpdated || 0) - (a.lastUpdated || 0);
    });

    var maxIndividual = getMaxIndividualToasts();
    var individualCount = Math.min(minimized.length, maxIndividual);

    for (var j = 0; j < individualCount; j++) {
      var item = minimized[j];
      var toast = document.createElement('div');
      toast.className = 'gdoc-toast';
      toast.setAttribute('data-preview-key', item.key);

      var main = document.createElement('div');
      main.className = 'gdoc-toast-main';

      var titleNode = document.createElement('div');
      titleNode.className = 'gdoc-toast-title';
      var prefix = item.kind === 'bg' ? '[BG] ' : '[Docs] ';
      titleNode.textContent = prefix + (item.title || item.href || '');
      main.appendChild(titleNode);

      toast.appendChild(main);

      var actions = document.createElement('div');
      actions.className = 'gdoc-toast-actions';

      var btnCopy = document.createElement('button');
      btnCopy.type = 'button';
      btnCopy.className = 'gdoc-toast-btn';
      btnCopy.setAttribute('data-action', 'copy');
      btnCopy.title = 'リンクをコピー';
      btnCopy.innerHTML = '<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></svg>';
      actions.appendChild(btnCopy);

      var btnOpen = document.createElement('button');
      btnOpen.type = 'button';
      btnOpen.className = 'gdoc-toast-btn';
      btnOpen.setAttribute('data-action', 'open');
      btnOpen.title = '別タブで開く';
      btnOpen.innerHTML = '<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M14 3h7v7h-2V6.41l-9.29 9.3-1.42-1.42 9.3-9.29H14V3z"></path><path d="M5 5h5V3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2v-5h-2v5H5V5z"></path></svg>';
      actions.appendChild(btnOpen);

      var btnJump = document.createElement('button');
      btnJump.type = 'button';
      btnJump.className = 'gdoc-toast-btn';
      btnJump.setAttribute('data-action', 'jump');
      btnJump.title = '本文へ移動';
      btnJump.innerHTML = '<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M12 2c-.55 0-1 .45-1 1v12.59l-4.3-4.3a1 1 0 10-1.4 1.42l6 6a1 1 0 001.4 0l6-6a1 1 0 10-1.4-1.42L13 15.59V3c0-.55-.45-1-1-1z"></path></svg>';
      actions.appendChild(btnJump);

      var btnClose = document.createElement('button');
      btnClose.type = 'button';
      btnClose.className = 'gdoc-toast-btn';
      btnClose.setAttribute('data-action', 'close');
      btnClose.title = '閉じる';
      btnClose.innerHTML = '<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M5.293 6.707l5.293 5.293-5.293 5.293c-.39.39-.39 1.024 0 1.414s1.024.39 1.414 0l5.293-5.293 5.293 5.293c.39.39 1.024.39 1.414 0s.39-1.024 0-1.414L13.414 12l5.293-5.293c.39-.39.39-1.024 0-1.414s-1.024-.39-1.414 0L12 10.586 6.707 5.293c-.39-.39-1.024-.39-1.414 0s-.39 1.024 0 1.414z"></path></svg>';
      actions.appendChild(btnClose);

      toast.appendChild(actions);
      toastInner.appendChild(toast);
    }

    if (minimized.length > maxIndividual) {
      var othersCount = minimized.length - maxIndividual;
      var othersToast = document.createElement('div');
      othersToast.className = 'gdoc-toast';
      othersToast.setAttribute('data-preview-key', 'others');
      othersToast.setAttribute('data-other-toast', '1');

      var main2 = document.createElement('div');
      main2.className = 'gdoc-toast-main';
      var title2 = document.createElement('div');
      title2.className = 'gdoc-toast-title';
      title2.textContent = 'プレビューの他文書 (' + othersCount + ' 件)';
      main2.appendChild(title2);
      othersToast.appendChild(main2);

      toastInner.appendChild(othersToast);
    }
  }

  toastInner.addEventListener('click', function (e) {
    var toast = e.target.closest('.gdoc-toast');
    if (!toast) return;
    var key = toast.getAttribute('data-preview-key');
    var isOthers = toast.hasAttribute('data-other-toast');

    if (isOthers) {
      if (!isMobile) {
        openListModal();
      }
      return;
    }

    var actionEl = e.target.closest('[data-action]');
    var action = actionEl ? actionEl.getAttribute('data-action') : null;
    var item = findItemByKey(key);
    if (!item) return;

    if (!action) {
      // トースト本体クリック → 復帰
      activatePreviewItem(item, true);
      return;
    }

    if (action === 'copy') {
      var url = item.href;
      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(url).catch(function () {});
      } else {
        var tmp = document.createElement('textarea');
        tmp.style.position = 'fixed';
        tmp.style.opacity = '0';
        tmp.value = url;
        document.body.appendChild(tmp);
        tmp.select();
        try { document.execCommand('copy'); } catch (err) {}
        document.body.removeChild(tmp);
      }
    } else if (action === 'open') {
      window.open(item.href, '_blank', 'noopener');
    } else if (action === 'close') {
      closeItemByKey(item.key);
    } else if (action === 'jump') {
      jumpToSourceForItem(item);
    }
  });

  // ---- 他文書一覧モーダル ----
  function renderListModal() {
    listEl.innerHTML = '';
    if (!state.items.length) return;

    for (var i = 0; i < state.items.length; i++) {
      var item = state.items[i];
      var li = document.createElement('li');
      li.className = 'gdoc-list-item';
      li.setAttribute('data-preview-key', item.key);

      var titleDiv = document.createElement('div');
      titleDiv.className = 'gdoc-list-item-title';
      titleDiv.textContent = item.title || item.href || '';
      li.appendChild(titleDiv);

      var actionsDiv = document.createElement('div');
      actionsDiv.className = 'gdoc-list-item-actions';

      var btnActivate = document.createElement('button');
      btnActivate.type = 'button';
      btnActivate.className = 'gdoc-list-item-btn';
      btnActivate.setAttribute('data-action', 'activate');
      btnActivate.textContent = '表示';
      actionsDiv.appendChild(btnActivate);

      var btnJumpBody = document.createElement('button');
      btnJumpBody.type = 'button';
      btnJumpBody.className = 'gdoc-list-item-btn';
      btnJumpBody.setAttribute('data-action', 'jump');
      btnJumpBody.textContent = '本文';
      actionsDiv.appendChild(btnJumpBody);

      var btnOpenTab = document.createElement('button');
      btnOpenTab.type = 'button';
      btnOpenTab.className = 'gdoc-list-item-btn';
      btnOpenTab.setAttribute('data-action', 'openTab');
      btnOpenTab.textContent = '他タブ';
      actionsDiv.appendChild(btnOpenTab);

      var btnClose = document.createElement('button');
      btnClose.type = 'button';
      btnClose.className = 'gdoc-list-item-btn';
      btnClose.setAttribute('data-action', 'close');
      btnClose.textContent = '閉じる';
      actionsDiv.appendChild(btnClose);

      var btnUp = document.createElement('button');
      btnUp.type = 'button';
      btnUp.className = 'gdoc-list-item-btn';
      btnUp.setAttribute('data-action', 'up');
      btnUp.textContent = '↑';
      actionsDiv.appendChild(btnUp);

      var btnDown = document.createElement('button');
      btnDown.type = 'button';
      btnDown.className = 'gdoc-list-item-btn';
      btnDown.setAttribute('data-action', 'down');
      btnDown.textContent = '↓';
      actionsDiv.appendChild(btnDown);

      li.appendChild(actionsDiv);
      listEl.appendChild(li);
    }
  }

  function openListModal() {
    if (isMobile) return;
    renderListModal();
    listModal.hidden = false;
  }

  function closeListModal() {
    listModal.hidden = true;
  }

  listModalClose.addEventListener('click', function () {
    closeListModal();
  });

  listModal.addEventListener('click', function (e) {
    if (e.target === listModal) {
      closeListModal();
    }
  });

  listEl.addEventListener('click', function (e) {
    var li = e.target.closest('.gdoc-list-item');
    if (!li) return;
    var key = li.getAttribute('data-preview-key');
    var item = findItemByKey(key);
    if (!item) return;

    var btn = e.target.closest('[data-action]');
    if (!btn) return;
    var action = btn.getAttribute('data-action');

    if (action === 'openTab') {
      window.open(item.href, '_blank', 'noopener');
    } else if (action === 'close') {
      closeItemByKey(item.key);
      renderListModal();
    } else if (action === 'activate') {
      activatePreviewItem(item, true);
      closeListModal();
    } else if (action === 'jump') {
      jumpToSourceForItem(item);
      closeListModal();
    } else if (action === 'up' || action === 'down') {
      var items = state.items;
      var idx = -1;
      for (var i = 0; i < items.length; i++) {
        if (items[i].key === item.key) { idx = i; break; }
      }
      if (idx === -1) return;
      var newIdx = action === 'up' ? idx - 1 : idx + 1;
      if (newIdx < 0 || newIdx >= items.length) return;
      var tmp = items[idx];
      items[idx] = items[newIdx];
      items[newIdx] = tmp;
      saveState();
      renderListModal();
      rebuildToasts();
    }
  });

  // ---- キーボード ----
  document.addEventListener('keydown', function (e) {
    if (e.key === 'Escape') {
      if (!popover.hidden) {
        popover.hidden = true;
        currentLink = null;
      } else if (!listModal.hidden) {
        closeListModal();
      } else if (!modal.hidden) {
        // ESC ではプレビューを閉じず、トーストへ格納する
        minimizeActiveToToast();
      }
    }
  });

  // ページ内リンクのクリックに対して、戻るボタンで元の位置に戻れるように履歴を積む
  document.addEventListener('click', function (e) {
    var a = e.target.closest && e.target.closest('a[href^="#"]');
    if (!a) return;
    var href = a.getAttribute('href');
    if (!href || href === '#') return;

    var url;
    try {
      url = new URL(a.href, window.location.href);
    } catch (err) {
      return;
    }
    if (url.pathname !== window.location.pathname || url.origin !== window.location.origin) {
      return;
    }

    var id = decodeURIComponent(url.hash.slice(1));
    if (!id) return;
    var target = document.getElementById(id);
    if (!target) return;

    e.preventDefault();

    var scrollEl = getScrollElement();
    var currentY = scrollEl.scrollTop;
    try {
      history.pushState({ __gdocScrollRestore: currentY }, url.hash, url.href);
    } catch (err2) {}

    applyJumpHighlight(target);
  });

  window.addEventListener('popstate', function (e) {
    if (e.state && typeof e.state.__gdocScrollRestore === 'number') {
      var scrollEl = getScrollElement();
      scrollEl.scrollTop = e.state.__gdocScrollRestore;
    }
  });

  // BGプレビュー対象リンクの検出とマーク
  function markBgPreviewLinks() {
    try {
      // 全てのリンクを対象に検索
      var allLinks = document.querySelectorAll('a[href]');
      var markedCount = 0;
      
    for (var i = 0; i < allLinks.length; i++) {
      var link = allLinks[i];
      var href = link.getAttribute('href');
      if (!href) continue;
      if (link.classList && (link.classList.contains('footnote-ref') || link.getAttribute('role') === 'doc-noteref')) {
        continue;
      }
        
        // 既にマークされている場合はスキップ
        if (link.classList.contains('bg-preview-link')) continue;
        
        // 1. 索引リンク（idx- を含む）
        if (href.indexOf('#idx-') !== -1) {
          link.classList.add('bg-preview-link');
          link.setAttribute('data-bg-type', 'index');
          markedCount++;
          continue;
        }
        
        // 2. 目次リンク（toc- を含む）
        if (href.indexOf('#toc-') !== -1 || href.indexOf('toc-') !== -1) {
          link.classList.add('bg-preview-link');
          link.setAttribute('data-bg-type', 'toc');
          markedCount++;
          continue;
        }
        
        // 3. 章ファイルへのリンク（NN_chNN.html 形式）
        if (href.match(/\d+_ch\d+\.html/)) {
          link.classList.add('bg-preview-link');
          link.setAttribute('data-bg-type', 'chapter');
          markedCount++;
          continue;
        }
        
        // 4. 同一ページ内のアンカーリンク（#で始まる）
        if (href.indexOf('#') === 0 && href.length > 1) {
          // ヘッダーナビゲーションは除外
          if (link.closest('header') || link.closest('.header-ui')) continue;
          
          link.classList.add('bg-preview-link');
          link.setAttribute('data-bg-type', 'anchor');
          markedCount++;
          continue;
        }
      }
      
      console.log('BGプレビューリンクをマーク:', markedCount + '個');
    } catch (e) {
      console.warn('markBgPreviewLinks failed', e);
    }
  }

  // BGプレビューリンクのイベントハンドラ
  document.addEventListener('mouseover', function (e) {
    var link = e.target.closest && e.target.closest('a.bg-preview-link');
    if (!link) return;
    
    // プレビュー内のリンクの場合、既存のプレビューを最小化
    if (link.closest('.bg-preview-body')) {
      var activeItem = getActiveItem();
      if (activeItem && activeItem.state === 'active') {
        activeItem.state = 'minimized';
        saveState();
        if (!isMobile) {
          rebuildToasts();
        }
      }
    }
    
    cancelHideBgPopover();
    cancelShowBgPopover();
    bgShowTimer = window.setTimeout(function () {
      showBgPopoverForLink(link);
    }, POPOVER_SHOW_DELAY);
  });

  document.addEventListener('mouseout', function (e) {
    var fromLink = e.target.closest && e.target.closest('a.bg-preview-link');
    if (!fromLink) return;
    var to = e.relatedTarget;
    if (to && (to.closest && (to.closest('a.bg-preview-link') || to.closest('#bg-preview-popover')))) {
      return;
    }
    cancelShowBgPopover();
    scheduleHideBgPopover();
  });

  document.addEventListener('click', function (e) {
    var link = e.target.closest && e.target.closest('a.bg-preview-link');
    if (!link) return;
    
    // ポップオーバー内のボタンクリックの場合は何もしない
    if (e.target.closest('#bg-preview-popover')) {
      return;
    }
    
    // モバイルまたはタッチデバイスの場合
    if (isMobile || ('ontouchstart' in window)) {
      e.preventDefault();
      cancelHideBgPopover();
      if (bgPopover.hidden) {
        showBgPopoverForLink(link);
      } else if (currentBgLink === link) {
        // 2回目のタップで遷移
        window.location.href = link.href;
      } else {
        showBgPopoverForLink(link);
      }
    }
    // PCの場合は通常のクリックで遷移（ポップオーバーは補助的）
    // デフォルトの動作を許可（リンク遷移）
  });

  // 初期化: モード判定と既存状態の復元
  updateMode();
  markBgPreviewLinks();
  
  (function restoreFromState() {
    if (!state || !state.items.length) return;
    if (isMobile) return; // モバイルでは復元しない

    rebuildToasts();
    var active = getActiveItem();
    if (active) {
      activatePreviewItem(active, false);
    }
  })();

  // 外部統合用の簡易API
  window.__gdocPreviewAPI__ = {
    getState: function () {
      return { items: state.items.slice(), currentKey: currentKey };
    },
    getItems: function () {
      return state.items.slice();
    },
    getItemsByKind: function (kind) {
      return state.items.filter(function (item) {
        return item.kind === kind;
      });
    },
    activate: function (key) {
      var item = findItemByKey(key);
      if (item) activatePreviewItem(item, true);
    },
    close: function (key) {
      closeItemByKey(key);
    },
    jumpToSource: function (key) {
      var item = findItemByKey(key);
      if (item) jumpToSourceForItem(item);
    },
    minimizeActive: function () {
      minimizeActiveToToast();
    },
    refreshToasts: function () {
      rebuildToasts();
    },
    openBgPreview: function (href, title) {
      var link = document.createElement('a');
      link.href = href;
      link.textContent = title || href;
      openBgPreviewFromLink(link);
    }
  };
})();
</script>
<script src="../src/js/index-scroll.js"></script>




</body></html>