<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ja" xml:lang="ja"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.25">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>付録 B — 参考文献 – 平和への課題：補遺</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../content/96_index.html" rel="next">
<link href="../content/90_afterword.html" rel="prev">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-d2604bcb90b21ac6bc3164282300c13a.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "一致なし",
    "search-matching-documents-text": "一致した文書",
    "search-copy-link-title": "検索へのリンクをコピー",
    "search-hide-matches-text": "追加の検索結果を非表示",
    "search-more-match-text": "追加の検索結果",
    "search-more-matches-text": "追加の検索結果",
    "search-clear-button-title": "消去",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "取消",
    "search-submit-button-title": "検索",
    "search-label": "サーチ"
  }
}</script>
<style>
  :root {
    --sidebar-width: 280px;
    --margin-width: 150px;
    --gutter-width: 12px;
  }
</style>
<style>
  :root {
    --sidebar-width: 280px;
    --margin-width: 150px;
    --gutter-width: 12px;
  }
</style>
<link rel="preload" href="../fonts/BIZUDPMincho-Regular.woff2" as="font" type="font/woff2" crossorigin="">
<link rel="preload" href="../fonts/BIZUDPMincho-Bold.woff2" as="font" type="font/woff2" crossorigin="">
<link rel="preload" href="../fonts/BIZUDPGothic-Regular.woff2" as="font" type="font/woff2" crossorigin="">
<link rel="preload" href="../fonts/BIZUDPGothic-Bold.woff2" as="font" type="font/woff2" crossorigin="">


<link rel="stylesheet" href="../src/css/font-udpmincho.css">
<link rel="stylesheet" href="../src/css/base.css">
<link rel="stylesheet" href="../src/css/simple-theme.css">
<link rel="stylesheet" href="../src/css/right-panel.css">
</head>

<body class="nav-sidebar floating quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="サイドバーを切り替える" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../content/90_afterword.html">Appendices</a></li><li class="breadcrumb-item"><a href="../content/95_references.html"><span class="chapter-title">参考文献</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="サイドバーを切り替える" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="サーチ" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header sidebar-header-stacked">
      <a href="../index.html" class="sidebar-logo-link">
      </a>
    <div class="sidebar-title mb-0 py-0">
      <a href="../">平和への課題：補遺</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="サーチ"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../index.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">AJMUN 37th 平和への課題：補遺</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/00_front.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">フロント挨拶</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/01_ch01.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">第1章 プロジェクトの概要</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/02_ch02.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">第2章　集団安全保障体制の系譜</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/03_ch03.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">第3章　争点・論点解説</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/04_ch04.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">第4章 国連による紛争処理</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/05_ch05.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">第5章　国連の制度</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/06_ch06.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">第1節　国際法法原論</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Appendices</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="セクションを切り替え">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/90_afterword.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">編集後記</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/95_references.html" class="sidebar-item-text sidebar-link active"><span class="chapter-title">参考文献</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/96_index.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">索引</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">目次</h2>
   
  <ul>
  <li><a href="#参考文献" id="toc-参考文献" class="nav-link active" data-scroll-target="#参考文献">参考文献</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">
<script>
  (function () {
    try {
      var storedTheme = localStorage.getItem('quarto-theme');
      if (!storedTheme || storedTheme === 'auto') return;
      document.documentElement.setAttribute('data-theme', storedTheme);
      var applyThemeToBody = function () {
        if (!document.body) {
          requestAnimationFrame(applyThemeToBody);
          return;
        }
        document.body.setAttribute('data-theme', storedTheme);
      };
      applyThemeToBody();
    } catch (err) {
      console.warn('Failed to apply stored theme early', err);
    }
  })();
</script>
<div class="header-ui">
  <div id="js-header" class="js-header">
    <div class="js-header__inner">
      <div class="js-header__left">
        <div class="js-header__logo">
          <span class="js-header__title"><span class="title-main">平和への課題：補遺</span><span class="title-sub">Background Guide</span></span>
        </div>
      </div>
      <div class="js-header__right">
        <div class="js-header__controls">
          <!-- 設定メニューボタン -->
          <button class="js-settings-toggle-btn" id="settings-toggle-btn" aria-label="設定メニューを開く">
            <span class="settings-toggle-icon" aria-hidden="true"></span>
            <span class="settings-toggle-text">表示設定</span>
          </button>
        </div>
      </div>
    </div>
  </div>
  
  <!-- 格納型設定メニュー -->
  <div class="settings-menu" id="settings-menu">
    <div class="settings-menu__inner">
      <div class="settings-menu__header">
        <h3 class="anchored">表示設定</h3>
        <button class="settings-menu__close" id="settings-menu-close">×</button>
      </div>
      <div class="settings-menu__content">
        <!-- 文字サイズ -->
        <div class="settings-item">
          <label for="font-size-select">文字サイズ：</label>
          <select class="js-font-size-select" id="font-size-select" aria-label="文字サイズ">
            <option value="3XS">3XS</option>
            <option value="2XS">2XS</option>
            <option value="XS">XS</option>
            <option value="S">S</option>
            <option value="M" selected="">M</option>
            <option value="L">L</option>
            <option value="XL">XL</option>
          </select>
        </div>
        
        <!-- テーマ切替 -->
        <div class="settings-item">
          <label for="theme-select">テーマ：</label>
          <select class="js-theme-select" id="theme-select" aria-label="テーマ">
            <option value="light">ライト</option>
            <option value="dark">ダーク</option>
            <option value="auto">自動</option>
          </select>
        </div>
        
        <!-- コメント機能 -->
        <div class="settings-divider"></div>
        <div class="settings-section-title">コメント機能</div>
        <div class="settings-item">
          <button class="js-comments-export-page" id="comments-export-page">コメント出力(このページ)</button>
        </div>
        <div class="settings-item">
          <button class="js-comments-export-all" id="comments-export-all">全コメント出力</button>
        </div>
        <div class="settings-item">
          <label for="comments-import" class="js-comments-import-label">コメント読込：</label>
          <input type="file" id="comments-import" class="js-comments-import" accept="application/json" style="display:none;">
          <button class="js-comments-import-button" id="comments-import-button">ファイル選択</button>
        </div>
        
        <!-- プレビューのトースト表示数 -->
        <div class="settings-item">
          <label for="gdoc-toast-max">プレビューのトースト数：</label>
          <input type="range" id="gdoc-toast-max" min="0" max="9" value="3" aria-label="プレビューのトースト数">
          <span id="gdoc-toast-max-value">3</span>
        </div>

        <!-- 各種設定リセット -->
        <div class="settings-divider"></div>
        <div class="settings-section-title">リセット</div>
        <div class="settings-item settings-item--reset-buttons">
          <button type="button" id="reset-ui-settings">UI系をリセット</button>
          <button type="button" id="reset-memo-settings">メモ系をリセット</button>
          <button type="button" id="reset-preview-settings">プレビューをリセット</button>
          <button type="button" id="reset-all-settings">すべてをリセット</button>
        </div>
      </div>
    </div>
  </div>
  <div class="settings-menu-overlay" id="settings-menu-overlay"></div>
</div>

<div class="toc-overlay">
  <div class="toc-overlay__backdrop"></div>
  <div class="toc-sheet">
    <div class="toc-sheet__header">
      <h3 class="anchored">ナビゲーション</h3>
      <button class="toc-sheet__close">×</button>
    </div>
    <div class="toc-sheet__content">
      <!-- 左パネル相当の内容はJavaScriptで生成 -->
    </div>
  </div>
</div>

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../content/90_afterword.html">Appendices</a></li><li class="breadcrumb-item"><a href="../content/95_references.html"><span class="chapter-title">参考文献</span></a></li></ol></nav>
<div class="quarto-title">
<h1 class="title">付録 B — 参考文献</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="参考文献" class="level1">
<h1>参考文献</h1>
<p>以下に各章で引用された参考文献を章ごとにまとめて表示します。</p>
<div id="d5abfb24" class="cell" data-execution_count="1">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 章ごとの参考文献を生成するスクリプト</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> os</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> re</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> defaultdict</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> generate_chapter_references():</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""章ごとの参考文献リストを生成"""</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 章名マッピング</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    chapter_order <span class="op">=</span> [</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>        (<span class="st">'00_front.bib'</span>, <span class="st">'フロント挨拶'</span>),</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>        (<span class="st">'01_ch01.bib'</span>, <span class="st">'第1章 プロジェクト概要'</span>),</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>        (<span class="st">'02_ch02.bib'</span>, <span class="st">'第2章 技術的課題'</span>),</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>        (<span class="st">'03_ch03.bib'</span>, <span class="st">'第3章 実装方針'</span>),</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>        (<span class="st">'20_col01.bib'</span>, <span class="st">'コラム1'</span>),</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>        (<span class="st">'21_col02.bib'</span>, <span class="st">'コラム2'</span>),</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>        (<span class="st">'04_ch04.bib'</span>, <span class="st">'第4章 ユーザーインタフェース'</span>),</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>        (<span class="st">'05_ch05.bib'</span>, <span class="st">'第5章 パフォーマンス最適化'</span>),</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>        (<span class="st">'06_ch06.bib'</span>, <span class="st">'第6章 品質保証'</span>),</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>        (<span class="st">'07_ch07.bib'</span>, <span class="st">'第7章 プロジェクト完了'</span>),</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>        (<span class="st">'22_col03.bib'</span>, <span class="st">'コラム3'</span>),</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>        (<span class="st">'90_afterword.bib'</span>, <span class="st">'編集後記'</span>)</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>    ]</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>    bib_dir <span class="op">=</span> Path(<span class="st">"../meta/bib"</span>)</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> bib_dir.exists():</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>        bib_dir <span class="op">=</span> Path(<span class="st">"meta/bib"</span>)</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>    references_output <span class="op">=</span> []</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> bib_file, chapter_name <span class="kw">in</span> chapter_order:</span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>        bib_path <span class="op">=</span> bib_dir <span class="op">/</span> bib_file</span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> bib_path.exists():</span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>            references_output.append(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">## </span><span class="sc">{</span>chapter_name<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>            <span class="co"># BibTeXファイルを読み込み</span></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>            <span class="cf">try</span>:</span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>                <span class="cf">with</span> <span class="bu">open</span>(bib_path, <span class="st">'r'</span>, encoding<span class="op">=</span><span class="st">'utf-8'</span>) <span class="im">as</span> f:</span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>                    content <span class="op">=</span> f.read()</span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>                <span class="co"># BibTeXエントリを抽出</span></span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>                entry_pattern <span class="op">=</span> <span class="vs">r'@</span><span class="kw">(</span><span class="dv">\w</span><span class="op">+</span><span class="kw">)</span><span class="dv">\s</span><span class="op">*</span><span class="vs">{</span><span class="dv">\s</span><span class="op">*</span><span class="kw">(</span><span class="dv">\w</span><span class="op">+</span><span class="kw">)</span><span class="dv">\s</span><span class="op">*</span><span class="vs">,</span><span class="kw">(</span><span class="pp">[^@]</span><span class="op">*?</span><span class="kw">)</span><span class="vs">}'</span></span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>                entries <span class="op">=</span> re.findall(entry_pattern, content, re.IGNORECASE <span class="op">|</span> re.DOTALL)</span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> entries:</span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a>                    references_output.append(<span class="st">"</span><span class="ch">\n\\</span><span class="st">begin</span><span class="sc">{enumerate}</span><span class="st">"</span>)</span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a>                    </span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">for</span> i, (entry_type, key, fields) <span class="kw">in</span> <span class="bu">enumerate</span>(entries, <span class="dv">1</span>):</span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a>                        <span class="co"># タイトルを抽出</span></span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a>                        title_match <span class="op">=</span> re.search(<span class="vs">r'title</span><span class="dv">\s</span><span class="op">*</span><span class="vs">=</span><span class="dv">\s</span><span class="op">*</span><span class="vs">{</span><span class="kw">(</span><span class="pp">[^}]</span><span class="op">*</span><span class="kw">)</span><span class="vs">}'</span>, fields)</span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a>                        title <span class="op">=</span> title_match.group(<span class="dv">1</span>) <span class="cf">if</span> title_match <span class="cf">else</span> <span class="ss">f"[未公開タイトル </span><span class="sc">{</span>key<span class="sc">}</span><span class="ss">]"</span></span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a>                        </span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a>                        <span class="co"># 著者を抽出</span></span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a>                        author_match <span class="op">=</span> re.search(<span class="vs">r'author</span><span class="dv">\s</span><span class="op">*</span><span class="vs">=</span><span class="dv">\s</span><span class="op">*</span><span class="vs">{</span><span class="kw">(</span><span class="pp">[^}]</span><span class="op">*</span><span class="kw">)</span><span class="vs">}'</span>, fields)</span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a>                        author <span class="op">=</span> author_match.group(<span class="dv">1</span>) <span class="cf">if</span> author_match <span class="cf">else</span> <span class="st">""</span></span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a>                        </span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a>                        <span class="co"># 出版年を抽出</span></span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a>                        year_match <span class="op">=</span> re.search(<span class="vs">r'year</span><span class="dv">\s</span><span class="op">*</span><span class="vs">=</span><span class="dv">\s</span><span class="op">*</span><span class="vs">{</span><span class="kw">(</span><span class="pp">[^}]</span><span class="op">*</span><span class="kw">)</span><span class="vs">}'</span>, fields)</span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true" tabindex="-1"></a>                        year <span class="op">=</span> year_match.group(<span class="dv">1</span>) <span class="cf">if</span> year_match <span class="cf">else</span> <span class="st">""</span></span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true" tabindex="-1"></a>                        </span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true" tabindex="-1"></a>                        <span class="cf">if</span> year:</span>
<span id="cb1-64"><a href="#cb1-64" aria-hidden="true" tabindex="-1"></a>                            citation <span class="op">=</span> <span class="ss">f"</span><span class="sc">{</span>author<span class="sc">}</span><span class="ss"> (</span><span class="sc">{</span>year<span class="sc">}</span><span class="ss">): *</span><span class="sc">{</span>title<span class="sc">}</span><span class="ss">*"</span></span>
<span id="cb1-65"><a href="#cb1-65" aria-hidden="true" tabindex="-1"></a>                        <span class="cf">else</span>:</span>
<span id="cb1-66"><a href="#cb1-66" aria-hidden="true" tabindex="-1"></a>                            citation <span class="op">=</span> <span class="ss">f"</span><span class="sc">{</span>author<span class="sc">}</span><span class="ss">: *</span><span class="sc">{</span>title<span class="sc">}</span><span class="ss">*"</span></span>
<span id="cb1-67"><a href="#cb1-67" aria-hidden="true" tabindex="-1"></a>                        </span>
<span id="cb1-68"><a href="#cb1-68" aria-hidden="true" tabindex="-1"></a>                        references_output.append(<span class="ss">f"</span><span class="ch">\\</span><span class="ss">item </span><span class="sc">{</span>citation<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb1-69"><a href="#cb1-69" aria-hidden="true" tabindex="-1"></a>                    </span>
<span id="cb1-70"><a href="#cb1-70" aria-hidden="true" tabindex="-1"></a>                    references_output.append(<span class="st">"</span><span class="ch">\\</span><span class="st">end</span><span class="sc">{enumerate}</span><span class="st">"</span>)</span>
<span id="cb1-71"><a href="#cb1-71" aria-hidden="true" tabindex="-1"></a>                <span class="cf">else</span>:</span>
<span id="cb1-72"><a href="#cb1-72" aria-hidden="true" tabindex="-1"></a>                    references_output.append(<span class="st">"</span><span class="ch">\\</span><span class="st">n（この章では参考文献を引用していません）"</span>)</span>
<span id="cb1-73"><a href="#cb1-73" aria-hidden="true" tabindex="-1"></a>                    </span>
<span id="cb1-74"><a href="#cb1-74" aria-hidden="true" tabindex="-1"></a>            <span class="cf">except</span> <span class="pp">Exception</span> <span class="im">as</span> e:</span>
<span id="cb1-75"><a href="#cb1-75" aria-hidden="true" tabindex="-1"></a>                references_output.append(<span class="ss">f"</span><span class="ch">\\</span><span class="ss">n（エラー: </span><span class="sc">{</span>bib_file<span class="sc">}</span><span class="ss"> の読み込みに失敗しました: </span><span class="sc">{</span>e<span class="sc">}</span><span class="ss">）"</span>)</span>
<span id="cb1-76"><a href="#cb1-76" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb1-77"><a href="#cb1-77" aria-hidden="true" tabindex="-1"></a>            references_output.append(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">## </span><span class="sc">{</span>chapter_name<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb1-78"><a href="#cb1-78" aria-hidden="true" tabindex="-1"></a>            references_output.append(<span class="st">"</span><span class="ch">\\</span><span class="st">n（この章では参考文献を引用していません）"</span>)</span>
<span id="cb1-79"><a href="#cb1-79" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-80"><a href="#cb1-80" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 共通技術資料</span></span>
<span id="cb1-81"><a href="#cb1-81" aria-hidden="true" tabindex="-1"></a>    references_output.append(<span class="st">"""</span></span>
<span id="cb1-82"><a href="#cb1-82" aria-hidden="true" tabindex="-1"></a><span class="st">## 共通技術資料</span></span>
<span id="cb1-83"><a href="#cb1-83" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-84"><a href="#cb1-84" aria-hidden="true" tabindex="-1"></a><span class="ch">\\</span><span class="st">begin</span><span class="sc">{itemize}</span></span>
<span id="cb1-85"><a href="#cb1-85" aria-hidden="true" tabindex="-1"></a><span class="ch">\\</span><span class="st">item Quarto.org (2020): *Quarto Technical Documentation*</span></span>
<span id="cb1-86"><a href="#cb1-86" aria-hidden="true" tabindex="-1"></a><span class="ch">\\</span><span class="st">item Pandoc.org (2023): *Pandoc User's Guide*</span></span>
<span id="cb1-87"><a href="#cb1-87" aria-hidden="true" tabindex="-1"></a><span class="ch">\\</span><span class="st">item W3C (2018): *HTML Living Standard*</span></span>
<span id="cb1-88"><a href="#cb1-88" aria-hidden="true" tabindex="-1"></a><span class="ch">\\</span><span class="st">end</span><span class="sc">{itemize}</span></span>
<span id="cb1-89"><a href="#cb1-89" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span>)</span>
<span id="cb1-90"><a href="#cb1-90" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-91"><a href="#cb1-91" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="st">"</span><span class="ch">\\</span><span class="st">n"</span>.join(references_output)</span>
<span id="cb1-92"><a href="#cb1-92" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-93"><a href="#cb1-93" aria-hidden="true" tabindex="-1"></a><span class="co"># 出力</span></span>
<span id="cb1-94"><a href="#cb1-94" aria-hidden="true" tabindex="-1"></a>markdown_content <span class="op">=</span> generate_chapter_references()</span>
<span id="cb1-95"><a href="#cb1-95" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(markdown_content)</span></code></pre></div><button title="コピー" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>
## フロント挨拶\n\n（この章では参考文献を引用していません）\n
## 第1章 プロジェクト概要\n
\begin{enumerate}\n\item : *[未公開タイトル quarto2020]*\n\item : *[未公開タイトル pandoc2023]*\n\item : *[未公開タイトル w3c2018]*\n\end{enumerate}\n
## 第2章 技術的課題\n\n（この章では参考文献を引用していません）\n
## 第3章 実装方針\n\n（この章では参考文献を引用していません）\n
## コラム1\n\n（この章では参考文献を引用していません）\n
## コラム2\n\n（この章では参考文献を引用していません）\n
## 第4章 ユーザーインタフェース\n\n（この章では参考文献を引用していません）\n
## 第5章 パフォーマンス最適化\n\n（この章では参考文献を引用していません）\n
## 第6章 品質保証\n
\begin{enumerate}\n\item : *[未公開タイトル nakatani1996]*\n\item : *[未公開タイトル yoshimura2001]*\n\item : *[未公開タイトル tanada2001]*\n\item : *[未公開タイトル ejil2005]*\n\item : *[未公開タイトル unis_un]*\n\item : *[未公開タイトル un_ga_committees]*\n\item : *[未公開タイトル mofa_unsc]*\n\item : *[未公開タイトル nations_encyclopedia]*\n\item : *[未公開タイトル globalpolicy_sanctions]*\n\item : *[未公開タイトル columbia_2001]*\n\item : *[未公開タイトル yoshimura_un_sanctions]*\n\item : *[未公開タイトル committee_function]*\n\item : *[未公開タイトル legal_problems_sanctions]*\n\item : *[未公開タイトル un_sanctions_management]*\n\item : *[未公開タイトル wet2004]*\n\item : *[未公開タイトル sarooshi2005]*\n\item : *[未公開タイトル cortright_lopes]*\n\item : *[未公開タイトル state_dept_history]*\n\item : *[未公開タイトル frus1951]*\n\item : *[未公開タイトル globalsecurity_mio]*\n\item : *[未公開タイトル namibia_advisory]*\n\end{enumerate}\n
## 第7章 プロジェクト完了\n\n（この章では参考文献を引用していません）\n
## コラム3\n\n（この章では参考文献を引用していません）\n
## 編集後記\n\n（この章では参考文献を引用していません）\n
## 共通技術資料

\begin{itemize}
\item Quarto.org (2020): *Quarto Technical Documentation*
\item Pandoc.org (2023): *Pandoc User's Guide*
\item W3C (2018): *HTML Living Standard*
\end{itemize}
</code></pre>
</div>
</div>
<hr>
<p><em>参考文献は各章のbibTeXファイルから自動的に生成されています</em></p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "コピーしました");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "コピーしました");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../content/90_afterword.html" class="pagination-link" aria-label="編集後記">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-title">編集後記</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../content/96_index.html" class="pagination-link" aria-label="索引">
        <span class="nav-page-text"><span class="chapter-title">索引</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<script>
// Inlined UI script for offline file:// compatibility
// Source: src/js/ui-clean.js (inlined)
(function() {
  'use strict';

const STORAGE_KEYS = {
  tocLocation: 'quarto-toc-location',
  theme: 'quarto-theme',
  fontSize: 'quarto-font-size',
  markers: 'quarto-markers',
  comments: 'quarto-comments',
  scrollPosition: 'quarto-scroll-position',
  rightTab: 'quarto-right-tab',
  readingState: 'quarto-reading-state'
};

  const NAV_DATA_STATE = {
    promise: null,
    data: null,
    rootPrefix: null
  };

  function getRootPrefix() {
    if (NAV_DATA_STATE.rootPrefix != null) return NAV_DATA_STATE.rootPrefix;
    const meta = document.querySelector('meta[name="quarto:offset"]');
    let prefix = meta ? (meta.getAttribute('content') || '') : '';
    if (prefix && !prefix.endsWith('/')) prefix += '/';
    NAV_DATA_STATE.rootPrefix = prefix;
    return prefix;
  }

  function normalizePath(path) {
    const cleaned = (path || '').replace(/\\/g, '/');
    const decoded = decodeURIComponent(cleaned);
    return decoded.replace(/^\/+/, '');
  }

  // =============================
  // 設定リセット系ユーティリティ
  // =============================
  function resetUiSettings() {
    try {
      // 現行UIの表示系
      localStorage.removeItem(STORAGE_KEYS.theme);
      localStorage.removeItem(STORAGE_KEYS.fontSize);
      localStorage.removeItem(STORAGE_KEYS.rightTab);
      localStorage.removeItem('footnotes-sort');
      localStorage.removeItem('comments-sort');

      // 旧UI由来（残っている可能性があるもの）
      localStorage.removeItem('txtSize');
      localStorage.removeItem('theme');
      localStorage.removeItem('tocLocation');
      localStorage.removeItem('scrollPos');
    } catch (e) {
      console.warn('resetUiSettings failed', e);
    }
  }

  function resetMemoSettings() {
    try {
      // マーカー／コメント関連
      localStorage.removeItem(STORAGE_KEYS.markers);
      localStorage.removeItem(STORAGE_KEYS.comments);
    } catch (e) {
      console.warn('resetMemoSettings failed', e);
    }
  }

  function resetPreviewSettings() {
    try {
      // Docs/BG プレビュー関連
      localStorage.removeItem('gdocPreviewMaxToasts');
      localStorage.removeItem('gdocPreviewState_v2');
    } catch (e) {
      console.warn('resetPreviewSettings failed', e);
    }
  }

  function resetAllSettingsHard() {
    try {
      // localStorage 全消去（他サイトのデータは同一オリジン内なので注意が必要だが、
      // このBGビューア専用オリジン前提で、完全リセットとして実装）
      localStorage.clear();
    } catch (e) {
      console.warn('resetAllSettingsHard failed', e);
    }
    try {
      // 読書状態・スクロール状態など sessionStorage 由来のものもクリア
      sessionStorage.clear();
    } catch (e) {
      console.warn('sessionStorage clear failed', e);
    }
  }

  function computeCurrentOutputPath() {
    const currentUrl = new URL(window.location.href);
    let rel = decodeURIComponent(currentUrl.pathname);
    try {
      const rootUrl = new URL(getRootPrefix() || './', window.location.href);
      if (rel.startsWith(rootUrl.pathname)) {
        rel = rel.slice(rootUrl.pathname.length);
      }
    } catch (e) {
      console.warn('computeCurrentOutputPath root resolution failed:', e);
    }
    const outIdx = rel.indexOf('/out/');
    if (outIdx >= 0) rel = rel.slice(outIdx + 5);
    rel = rel.replace(/^\//, '');
    if (!rel) rel = 'index.html';
    if (rel.endsWith('/')) rel += 'index.html';
    return rel;
  }

  function isSamePage(pathA, pathB) {
    return normalizePath(pathA) === normalizePath(pathB);
  }

  function buildHref(pagePath, anchor) {
    const current = computeCurrentOutputPath();
    if (isSamePage(pagePath, current)) {
      return anchor ? `#${anchor}` : '#';
    }
    const prefix = getRootPrefix();
    const base = `${prefix || ''}${pagePath}`;
    return anchor ? `${base}#${anchor}` : base;
  }

  function updateIndexLinksForContext() {
    const currentPath = computeCurrentOutputPath();
    const inContentDir = typeof currentPath === 'string' && currentPath.startsWith('content/');
    const links = document.querySelectorAll('a[data-aj-index-root-href]');
    if (!links.length) return;
    links.forEach(link => {
      const rootHref = link.getAttribute('data-aj-index-root-href');
      const localHref = link.getAttribute('data-aj-index-local-href');
      const target = inContentDir && localHref ? localHref : rootHref;
      if (target) {
        link.setAttribute('href', target);
      }
    });
  }

  function reinforceAnchors(scope) {
    if (!scope || typeof scope.querySelectorAll !== 'function') return;
    const anchors = scope.querySelectorAll('a[href]');
    anchors.forEach(anchor => {
      if (anchor.dataset.ajLinkReinforced === 'true') return;
      anchor.dataset.ajLinkReinforced = 'true';
      const href = anchor.getAttribute('href') || '';
      if (/^https?:\/\//i.test(href)) {
        if (!anchor.getAttribute('target')) {
          anchor.setAttribute('target', '_blank');
        }
        const rel = anchor.getAttribute('rel') || '';
        if (!/noopener/i.test(rel)) {
          anchor.setAttribute('rel', (rel + ' noopener noreferrer').trim());
        }
      }
    });
  }

  function setInlineFootnoteMode(active) {
    const next = !!active;
    if (INLINE_FOOTNOTE_MODE === next) return;
    INLINE_FOOTNOTE_MODE = next;
    if (!INLINE_FOOTNOTE_MODE) {
      hideCommentPopover();
    }
  }

  function ensureCommentMarkerInteractions() {
    const markers = document.querySelectorAll('.text-marker[data-comment-id]');
    markers.forEach(marker => {
      if (marker.dataset.commentMarkerBound === 'true') return;
      marker.dataset.commentMarkerBound = 'true';
      marker.addEventListener('click', handleCommentMarkerClick);
      marker.addEventListener('pointerenter', handleCommentMarkerPointerEnter);
      marker.addEventListener('pointerleave', handleCommentMarkerPointerLeave);
    });
  }

  function handleCommentMarkerClick(event) {
    if (!INLINE_FOOTNOTE_MODE) return;
    event.preventDefault();
    event.stopPropagation();
    const marker = event.currentTarget;
    if (commentPopoverEl && commentPopoverMarker === marker && commentPopoverPersistent) {
      hideCommentPopover();
    } else {
      showCommentPopover(marker, { persistent: true });
    }
  }

  function handleCommentMarkerPointerEnter(event) {
    if (!INLINE_FOOTNOTE_MODE) return;
    if (event.pointerType && event.pointerType !== 'mouse') return;
    const marker = event.currentTarget;
    showCommentPopover(marker, { persistent: false });
    clearCommentPopoverHideTimer();
  }

  function handleCommentMarkerPointerLeave() {
    if (!INLINE_FOOTNOTE_MODE) return;
    scheduleCommentPopoverHide(200);
  }

  function showCommentPopover(marker, opts) {
    if (!marker) return;
    const rec = getCommentRecordById(marker.getAttribute('data-comment-id'));
    if (!rec) return;
    const persistent = !!(opts && opts.persistent);
    clearCommentPopoverHideTimer();
    commentPopoverPersistent = persistent;
    commentPopoverMarker = marker;
    if (commentPopoverEl) {
      commentPopoverEl.remove();
      commentPopoverEl = null;
    }
    commentPopoverEl = document.createElement('div');
    commentPopoverEl.className = 'comment-inline-popover';
    const snippetRaw = (rec.text || '').trim();
    const snippetHtml = snippetRaw ? `対象: ${escapeHtml(snippetRaw.slice(0, 160))}` : '';
    const bodyHtml = escapeHtml(rec.body || '').replace(/\n/g, '<br>');
    commentPopoverEl.innerHTML = `
      ${snippetHtml ? `<div class="comment-inline-popover__snippet">${snippetHtml}</div>` : ''}
      <div class="comment-inline-popover__body">${bodyHtml || '<em>コメント内容がありません。</em>'}</div>
    `;
    commentPopoverEl.addEventListener('pointerenter', clearCommentPopoverHideTimer);
    commentPopoverEl.addEventListener('pointerleave', () => scheduleCommentPopoverHide(200));
    document.body.appendChild(commentPopoverEl);
    positionCommentPopover(marker);
  }

  function hideCommentPopover() {
    clearCommentPopoverHideTimer();
    if (commentPopoverEl) {
      commentPopoverEl.remove();
      commentPopoverEl = null;
    }
    commentPopoverMarker = null;
    commentPopoverPersistent = false;
  }

  function scheduleCommentPopoverHide(delay) {
    if (commentPopoverPersistent || !commentPopoverEl) return;
    clearCommentPopoverHideTimer();
    commentPopoverHideTimer = window.setTimeout(() => {
      hideCommentPopover();
    }, delay || 0);
  }

  function clearCommentPopoverHideTimer() {
    if (commentPopoverHideTimer) {
      clearTimeout(commentPopoverHideTimer);
      commentPopoverHideTimer = null;
    }
  }

  function positionCommentPopover(marker) {
    if (!commentPopoverEl || !marker) return;
    const rect = marker.getBoundingClientRect();
    const popRect = commentPopoverEl.getBoundingClientRect();
    const scrollX = window.scrollX || document.documentElement.scrollLeft || 0;
    const scrollY = window.scrollY || document.documentElement.scrollTop || 0;
    const viewportWidth = document.documentElement.clientWidth || window.innerWidth || popRect.width;
    const viewportHeight = document.documentElement.clientHeight || window.innerHeight || popRect.height;
    let top = scrollY + rect.bottom + 10;
    let left = scrollX + rect.left + (rect.width / 2) - (popRect.width / 2);
    const minLeft = scrollX + 8;
    const maxLeft = scrollX + viewportWidth - popRect.width - 8;
    if (left < minLeft) left = minLeft;
    if (left > maxLeft) left = maxLeft;
    const maxTop = scrollY + viewportHeight - popRect.height - 8;
    if (top > maxTop) {
      top = scrollY + rect.top - popRect.height - 10;
    }
    if (top < scrollY + 8) {
      top = scrollY + 8;
    }
    commentPopoverEl.style.top = `${top}px`;
    commentPopoverEl.style.left = `${left}px`;
  }

  function updateCommentPopoverPosition() {
    if (!INLINE_FOOTNOTE_MODE || !commentPopoverEl || !commentPopoverMarker) return;
    positionCommentPopover(commentPopoverMarker);
  }

  function getCommentRecordById(id) {
    if (!id) return null;
    const list = COMMENTS_DB[pageKey()] || [];
    return list.find(rec => rec && rec.id === id) || null;
  }

  document.addEventListener('click', (event) => {
    if (!INLINE_FOOTNOTE_MODE) return;
    const marker = event.target.closest && event.target.closest('.text-marker[data-comment-id]');
    if (marker) return;
    if (commentPopoverEl && !event.target.closest('.comment-inline-popover')) {
      hideCommentPopover();
    }
  });

  window.addEventListener('scroll', () => updateCommentPopoverPosition(), { passive: true });
  window.addEventListener('resize', () => updateCommentPopoverPosition());

  function cloneTreeWithDepth(nodes, maxLevel) {
    if (!Array.isArray(nodes) || !nodes.length) return [];
    const walk = (list) => {
      const acc = [];
      list.forEach(node => {
        if (!node || typeof node !== 'object') return;
        if (typeof node.level !== 'number' || node.level > maxLevel) return;
        const copy = {
          title: node.title,
          level: node.level,
          anchor: node.anchor,
          children: []
        };
        if (Array.isArray(node.children) && node.children.length) {
          copy.children = walk(node.children);
        }
        acc.push(copy);
      });
      return acc;
    };
    return walk(nodes);
  }

  function resolveNavData(data) {
    if (data && typeof data === 'object' && Array.isArray(data.pages)) {
      NAV_DATA_STATE.data = data;
      return data;
    }
    throw new Error('Invalid navigation data payload');
  }

  function loadNavDataViaScript(prefix) {
    if (typeof document === 'undefined') {
      return Promise.reject(new Error('DOM unavailable for script loading'));
    }
    return new Promise((resolve, reject) => {
      const existing = document.querySelector('script[data-nav-data="true"]');
      if (existing && typeof window.__NAV_DATA__ === 'object' && window.__NAV_DATA__) {
        try {
          resolve(resolveNavData(window.__NAV_DATA__));
        } catch (err) {
          reject(err);
        }
        return;
      }
      const script = document.createElement('script');
      script.type = 'text/javascript';
      script.dataset.navData = 'true';
      script.src = `${prefix}assets/nav-data.js`;
      script.onload = () => {
        try {
          resolve(resolveNavData(window.__NAV_DATA__));
        } catch (err) {
          reject(err);
        }
      };
      script.onerror = () => reject(new Error('Failed to load nav-data.js'));
      document.head.appendChild(script);
    });
  }

  function loadNavData() {
    if (NAV_DATA_STATE.data) return Promise.resolve(NAV_DATA_STATE.data);
    if (typeof window.__NAV_DATA__ === 'object' && window.__NAV_DATA__) {
      try {
        return Promise.resolve(resolveNavData(window.__NAV_DATA__));
      } catch (err) {
        return Promise.reject(err);
      }
    }
    if (NAV_DATA_STATE.promise) return NAV_DATA_STATE.promise;
    const prefix = getRootPrefix() || '';
    if (location.protocol === 'file:') {
      NAV_DATA_STATE.promise = loadNavDataViaScript(prefix)
        .catch(err => {
          console.warn('Failed to load nav data via script:', err);
          NAV_DATA_STATE.data = null;
          return null;
        });
      return NAV_DATA_STATE.promise;
    }

    const url = new URL(`${prefix}assets/nav-data.json`, window.location.href);
    NAV_DATA_STATE.promise = fetch(url.href)
      .then(res => {
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        return res.json();
      })
      .then(json => resolveNavData(json))
      .catch(err => {
        console.warn('Failed to fetch nav data, retrying with script fallback:', err);
        return loadNavDataViaScript(prefix)
          .catch(scriptErr => {
            console.warn('Script fallback failed for nav data:', scriptErr);
            NAV_DATA_STATE.data = null;
            return null;
          });
      });
    return NAV_DATA_STATE.promise;
  }

  function canonicalPageKey(pathname) {
    try {
      let path = (pathname || '').split(/[?#]/)[0];
      path = path.replace(/\\/g, '/').replace(/\/+/g, '/');
      const segments = path.split('/').filter(Boolean);
      if (!segments.length) return 'index.html';
      const last = segments[segments.length - 1];
      if (!last || last.toLowerCase() === 'index.html') {
        const prev = segments.length > 1 ? segments[segments.length - 2] : '';
        return prev ? `${prev}/index.html` : 'index.html';
      }
      return last;
    } catch {
      return pathname || 'index.html';
    }
  }

  function pageKey() {
    return canonicalPageKey(window.location.pathname || '');
  }

  function canonicalizeCommentsDB(db) {
    const merged = {};
    const seenMap = {};
    if (!db || typeof db !== 'object') {
      return {};
    }
    Object.keys(db).forEach(oldKey => {
      const canonical = canonicalPageKey(oldKey);
      if (!merged[canonical]) {
        merged[canonical] = [];
        seenMap[canonical] = new Set();
      }
      const list = db[oldKey] || [];
      list.forEach(rec => {
        if (!rec || !rec.id || seenMap[canonical].has(rec.id)) return;
        merged[canonical].push(rec);
        seenMap[canonical].add(rec.id);
      });
    });
    return merged;
  }

  // コメントDB（ページキー毎に配列）
  let COMMENTS_DB = {};
  try {
    COMMENTS_DB = JSON.parse(localStorage.getItem(STORAGE_KEYS.comments) || '{}') || {};
  } catch {
    COMMENTS_DB = {};
  }
  COMMENTS_DB = canonicalizeCommentsDB(COMMENTS_DB);
  try { localStorage.setItem(STORAGE_KEYS.comments, JSON.stringify(COMMENTS_DB)); } catch {}
  function saveComments() {
    try { localStorage.setItem(STORAGE_KEYS.comments, JSON.stringify(COMMENTS_DB)); }
    catch (e) { console.warn('Save comments failed', e); }
  }

let INLINE_FOOTNOTE_MODE = false;
let commentPopoverEl = null;
let commentPopoverMarker = null;
let commentPopoverPersistent = false;
let commentPopoverHideTimer = null;
let cleanupCommentMarkersDom = () => {};
let refreshCommentMarkersFromDB = () => {};
let readingStateSaveTimer = null;

  function resolveAssetPath(relPath) {
    try {
      // Prefer Quarto's offset meta when available so paths work on index.html and content pages
      const offsetMeta = document.querySelector('meta[name="quarto:offset"]');
      if (offsetMeta) {
        let offset = offsetMeta.getAttribute('content') || '';
        if (offset && !offset.endsWith('/')) offset += '/';
        return offset + relPath;
      }

      // Fallback: derive base from simple-theme.css location if present
      const themeLink = document.querySelector('link[rel="stylesheet"][href*="src/css/simple-theme.css"]');
      if (themeLink) {
        const href = themeLink.getAttribute('href') || '';
        const parts = href.split('/');
        const srcIndex = parts.indexOf('src');
        if (srcIndex >= 0) {
          const prefix = parts.slice(0, srcIndex).join('/');
          const base = prefix ? prefix.replace(/\/*$/, '/') : '';
          return base + relPath;
        }
      }
    } catch (e) {
      console.warn('resolveAssetPath failed', e);
    }
    return relPath;
  }

  let readingMeterState = null;
  let scrollExtensionEl = null;
  let pendingScrollExtensionRaf = 0;
  const SCROLL_EXTENSION_BUFFER = 80;
  const FOOTNOTE_INLINE_BREAKPOINT = 1024;
  let currentFootnoteLayout = null;
  let readingStateSaveTimer = null;

  function formatReadingNumber(value) {
    if (!Number.isFinite(value)) return '0';
    try {
      return value.toLocaleString('ja-JP');
    } catch (error) {
      console.warn('Failed to format number:', error);
      return String(Math.trunc(value));
    }
  }

  function extractReadableText(root) {
    if (!root) return '';
    const clone = root.cloneNode(true);
    const selectorsToRemove = [
      '.header-ui',
      '.settings-menu',
      '.settings-menu-overlay',
      '.scroll-settings-header',
      '#scroll-settings-header',
      '.toc-overlay',
      '.global-search-overlay',
      '.marker-toolbar'
    ];
    selectorsToRemove.forEach((selector) => {
      clone.querySelectorAll(selector).forEach((node) => node.remove());
    });
    return (clone.textContent || '').replace(/\s+/g, '');
  }

  function ensureScrollExtensionElement() {
    if (scrollExtensionEl && document.body.contains(scrollExtensionEl)) {
      return scrollExtensionEl;
    }
    if (!document.body) return null;
    scrollExtensionEl = document.createElement('div');
    scrollExtensionEl.id = 'scroll-extension-anchor';
    scrollExtensionEl.setAttribute('aria-hidden', 'true');
    scrollExtensionEl.style.cssText = 'width:1px;height:0;margin:0;padding:0;';
    document.body.appendChild(scrollExtensionEl);
    return scrollExtensionEl;
  }

  function updateScrollExtensionNow() {
    const placeholder = ensureScrollExtensionElement();
    if (!placeholder) return;
    placeholder.style.height = '0px';
    const docElement = document.documentElement || document.body;
    const baseHeight = Math.max(
      document.body ? document.body.scrollHeight : 0,
      docElement ? docElement.scrollHeight : 0
    );
    let maxBottom = baseHeight;
    let hasTarget = false;
    const targets = [
      document.getElementById('quarto-document-content'),
      document.getElementById('quarto-sidebar'),
      document.getElementById('quarto-margin-sidebar')
    ];
    targets.forEach(el => {
      if (!el) return;
      const rect = el.getBoundingClientRect();
      if (!rect || !Number.isFinite(rect.bottom)) return;
      const bottom = rect.bottom + window.scrollY;
      if (!Number.isFinite(bottom)) return;
      maxBottom = Math.max(maxBottom, bottom);
      hasTarget = true;
    });
    if (!hasTarget) {
      placeholder.style.height = '0px';
      return;
    }
    const needed = Math.max(0, Math.ceil(maxBottom - baseHeight + SCROLL_EXTENSION_BUFFER));
    placeholder.style.height = needed > 0 ? `${needed}px` : '0px';
  }

  function scheduleScrollExtensionUpdate() {
    if (typeof requestAnimationFrame !== 'function') {
      return updateScrollExtensionNow();
    }
    if (pendingScrollExtensionRaf) {
      cancelAnimationFrame(pendingScrollExtensionRaf);
    }
    pendingScrollExtensionRaf = requestAnimationFrame(() => {
      pendingScrollExtensionRaf = 0;
      updateScrollExtensionNow();
    });
  }

  function initializeReadingMeter(displayEl) {
    if (!displayEl) return;

    const readingRoot = document.querySelector('#quarto-document-content');
    if (!readingRoot) {
      displayEl.textContent = '[0/0]';
      displayEl.setAttribute('aria-label', '読書メーター: 0 / 0');
      return;
    }

    const totalText = extractReadableText(readingRoot);
    const totalChars = totalText.length;
    const formattedTotal = formatReadingNumber(totalChars);

    displayEl.textContent = `[0/${formattedTotal}]`;
    displayEl.setAttribute('data-total-chars', `${totalChars}`);
    displayEl.setAttribute('data-current-chars', '0');
    displayEl.setAttribute('aria-live', 'polite');
    displayEl.setAttribute('aria-label', `読書メーター: 0 / ${formattedTotal}`);

    const state = {
      displayEl,
      readingRoot,
      measureElement: readingRoot,
      totalChars,
      formattedTotal,
      lastCurrent: -1,
      lastOutput: '',
      updateScheduled: false,
      cleanup: null
    };

    const computeRatio = () => {
      if (!state.measureElement) return 0;
      const rect = state.measureElement.getBoundingClientRect();
      const contentTop = window.scrollY + rect.top;
      const contentBottom = contentTop + rect.height;
      if (!Number.isFinite(contentTop) || !Number.isFinite(contentBottom) || contentBottom <= contentTop) {
        return 0;
      }

      const scrollTop = window.scrollY;
      const scrollBottom = scrollTop + window.innerHeight;
      const scrollRange = contentBottom - contentTop - window.innerHeight;
      let ratio;

      if (scrollRange <= 0) {
        if (scrollBottom >= contentBottom) {
          ratio = 1;
        } else if (scrollTop <= contentTop) {
          ratio = 0;
        } else {
          ratio = (scrollTop - contentTop) / Math.max(1, contentBottom - contentTop);
        }
      } else {
        ratio = (scrollTop - contentTop) / scrollRange;
      }

      if (!Number.isFinite(ratio)) {
        return 0;
      }
      return Math.min(1, Math.max(0, ratio));
    };

    const applyUpdate = () => {
      state.updateScheduled = false;
      if (state.totalChars <= 0) {
        const output = '[0/0]';
        if (output !== state.lastOutput) {
          state.lastOutput = output;
          state.displayEl.textContent = output;
          state.displayEl.setAttribute('data-current-chars', '0');
          state.displayEl.setAttribute('aria-label', '読書メーター: 0 / 0');
        }
        return;
      }

      const ratio = computeRatio();
      const currentChars = Math.max(0, Math.min(state.totalChars, Math.round(state.totalChars * ratio)));
      if (currentChars === state.lastCurrent && state.lastOutput) {
        return;
      }

      state.lastCurrent = currentChars;
      const formattedCurrent = formatReadingNumber(currentChars);
      const output = `[${formattedCurrent}/${state.formattedTotal}]`;
      if (output !== state.lastOutput) {
        state.lastOutput = output;
        state.displayEl.textContent = output;
        state.displayEl.setAttribute('data-current-chars', `${currentChars}`);
        state.displayEl.setAttribute('aria-label', `読書メーター: ${formattedCurrent} / ${state.formattedTotal}`);
      }
    };

    const scheduleUpdate = () => {
      if (state.updateScheduled) return;
      state.updateScheduled = true;
      requestAnimationFrame(applyUpdate);
    };

    const onScroll = () => scheduleUpdate();
    const onResize = () => scheduleUpdate();

    if (readingMeterState && typeof readingMeterState.cleanup === 'function') {
      readingMeterState.cleanup();
    }

    window.addEventListener('scroll', onScroll, { passive: true });
    window.addEventListener('resize', onResize);

    state.cleanup = () => {
      window.removeEventListener('scroll', onScroll);
      window.removeEventListener('resize', onResize);
    };

    readingMeterState = state;
    scheduleUpdate();
  }

  function getSavedRightTab() {
    try {
      const saved = localStorage.getItem(STORAGE_KEYS.rightTab);
      if (saved && ['footnotes', 'comments', 'both'].includes(saved)) {
        return saved;
      }
    } catch (e) {
      console.warn('Failed to read right tab state', e);
    }
    return 'both';
  }
  function saveRightTab(tab) {
    if (!['footnotes', 'comments', 'both'].includes(tab)) return;
    try { localStorage.setItem(STORAGE_KEYS.rightTab, tab); }
    catch (e) { console.warn('Failed to save right tab state', e); }
  }

  function setupTopChapterNavigation() {
    if (document.querySelector('nav.page-navigation-top')) return;
    const header = document.querySelector('header.quarto-title-block');
    const bottomNav = document.querySelector('nav.page-navigation');
    if (!header || !bottomNav) return;
    const topNav = bottomNav.cloneNode(true);
    topNav.classList.add('page-navigation-top');
    header.parentNode.insertBefore(topNav, header);
  }

  function getActiveChapterSection() {
    return document.querySelector('section.chapter-page.active') || null;
  }
  function getCurrentChapterSlug() {
    const active = getActiveChapterSection();
    if (!active) return null;
    const id = active.getAttribute('id') || '';
    return id.startsWith('page-') ? id.slice(5) : (id || null);
  }

  function getSectionSlugFromElement(el) {
    if (!el || !(el instanceof HTMLElement)) return null;
    const sec = el.closest('section.chapter-page');
    if (!sec || !sec.id) return null;
    const id = sec.id;
    return id.startsWith('page-') ? id.slice(5) : id;
  }

  function findCommentAnchorElement(rec) {
    if (!rec || !Array.isArray(rec.ranges)) return null;
    for (const range of rec.ranges) {
      const node = getNodeByPathSafe(range?.s);
      if (!node) continue;
      let el = node.nodeType === Node.ELEMENT_NODE ? node : node.parentElement;
      while (el && !(el instanceof HTMLElement)) el = el.parentElement;
      if (el) return el;
    }
    return null;
  }

  function detectCommentSlug(rec) {
    const el = findCommentAnchorElement(rec);
    return el ? getSectionSlugFromElement(el) : null;
  }

  function isCommentInSection(rec, section) {
    if (!section) return true;
    const el = findCommentAnchorElement(rec);
    return !!(el && section.contains(el));
  }

  function getActiveComments() {
    const list = (COMMENTS_DB[pageKey()] || []);
    // 章タブやセクションに関わらず、このページ上のコメントをすべて返す
    return list.filter(rec => !!rec);
  }

  function gatherActiveCommentsWithElements() {
    return getActiveComments()
      .map(rec => {
        const el = findCommentAnchorElement(rec);
        return el ? { rec, el } : null;
      })
      .filter(Boolean);
  }

  function gatherActiveFootnotes() {
    const active = getActiveChapterSection();
    const refSelector = 'a[role="doc-noteref"], a.footnote-ref';
    const refMap = new Map();
    const scope = active || document;
    Array.from(scope.querySelectorAll(refSelector)).forEach(ref => {
      if (active && !active.contains(ref)) return;
      const href = ref.getAttribute('href') || ref.getAttribute('data-footnote-href');
      if (!href || !href.startsWith('#')) return;
      const id = href.slice(1);
      const top = ref.getBoundingClientRect().top + window.scrollY;
      const label = (() => {
        const sup = ref.querySelector('sup');
        const raw = (sup ? sup.textContent : ref.textContent) || '';
        return raw.replace(/\s+/g, ' ').trim();
      })();
      const existing = refMap.get(id);
      if (!existing || top < existing.pos) {
        refMap.set(id, { id, ref, pos: top, number: label });
      }
    });
    const items = [];
    refMap.forEach(entry => {
      let def = document.getElementById(entry.id);
      if (!def) return;
      if (!(def instanceof HTMLElement)) def = def.parentElement;
      if (!def) return;
      let li = def;
      if (li.tagName && li.tagName.toLowerCase() !== 'li') {
        const nearestLi = li.closest('li');
        if (nearestLi) li = nearestLi;
      }
      if (!(li instanceof HTMLElement)) return;
      if (active) {
        const parentSection = li.closest('section.chapter-page');
        if (parentSection && parentSection !== active) return;
      }
      const fallbackLabel = entry.number || entry.id.replace(/[^0-9]+/g, '').trim();
      items.push({ id: entry.id, li, ref: entry.ref, pos: entry.pos, number: fallbackLabel });
    });
    return items;
  }

  async function initUI() {
    let navData = null;
    try {
      navData = await loadNavData();
    } catch (e) {
      console.warn('Nav data load failed:', e);
    }

    const safeInvoke = async (label, action) => {
      try {
        const result = action();
        if (result && typeof result.then === 'function') {
          await result;
        }
      } catch (err) {
        console.error(`UI init step failed (${label}):`, err);
      }
    };

    const steps = [
      ['header-controls', () => setupHeaderControls()],
      ['left-sidebar-tabs', () => setupLeftPanelTabs(navData)],
      ['site-title-enhancements', () => applySiteTitleEnhancements(navData)],
      ['mobile-nav-drawer', () => setupMobileNavDrawer(navData)],
      ['left-sidebar-stability', () => setupLeftSidebarStability()],
      ['right-sidebar', () => setupRightSidebar()],
      ['top-nav', () => setupTopChapterNavigation()],
      ['markers', () => setupMarkerFunctionality()],
      ['mobile-footnotes', () => setupMobileFootnoteToggle()],
      ['disable-default-search', () => disableDefaultQuartoSearch()],
      ['sidebar-search', () => setupSidebarSearch()],
      ['global-search', () => setupGlobalSearch()],
      ['shortcuts', () => setupKeyboardShortcuts()],
      ['scroll-position', () => setupScrollPosition()],
      ['body-links', () => reinforceAnchors(document.getElementById('quarto-document-content'))],
      ['index-links', () => updateIndexLinksForContext()],
      ['custom-toc', () => setTimeout(() => CustomTOC.initializeCustomTOC(navData), 100)],
    ];

    for (const [label, action] of steps) {
      await safeInvoke(label, action);
    }

    console.log('UI initialized');
    window.addEventListener('resize', () => scheduleScrollExtensionUpdate(), { passive: true });
    window.addEventListener('orientationchange', () => scheduleScrollExtensionUpdate());
    window.addEventListener('load', () => scheduleScrollExtensionUpdate(), { once: true });
    scheduleScrollExtensionUpdate();
    setTimeout(() => {
      refreshRightPanels();
      restoreReadingState();
    }, 120);
  }
  const queueInit = () => window.setTimeout(initUI, 0);
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', queueInit, { once: true });
  } else {
    queueInit();
  }

  function setupHeaderControls() {
    const settingsToggleBtn = document.getElementById('settings-toggle-btn');
    const settingsMenu = document.getElementById('settings-menu');
    const settingsMenuClose = document.getElementById('settings-menu-close');
    const settingsMenuOverlay = document.getElementById('settings-menu-overlay');
    const themeSelect = document.getElementById('theme-select');
    const fontSizeSelect = document.getElementById('font-size-select');
    const commentsExportPage = document.getElementById('comments-export-page');
    const commentsExportAll = document.getElementById('comments-export-all');
    const commentsImport = document.getElementById('comments-import');
    const commentsImportButton = document.getElementById('comments-import-button');
    const toastMaxRange = document.getElementById('gdoc-toast-max');
    const toastMaxValue = document.getElementById('gdoc-toast-max-value');
    const resetUiBtn = document.getElementById('reset-ui-settings');
    const resetMemoBtn = document.getElementById('reset-memo-settings');
    const resetPreviewBtn = document.getElementById('reset-preview-settings');
    const resetAllBtn = document.getElementById('reset-all-settings');

    // ハンバーガーメニューは廃止

    // 一般の画像についても data-asset 属性があれば resolveAssetPath で解決する
    try {
      const assetImgs = document.querySelectorAll('img[data-asset]');
      assetImgs.forEach(img => {
        const rel = img.getAttribute('data-asset');
        if (!rel) return;
        const resolved = resolveAssetPath(rel);
        if (resolved && img.src !== resolved) {
          img.src = resolved;
        }
      });
    } catch (e) {
      console.warn('resolveAssetPath for img[data-asset] failed', e);
    }

    if (settingsToggleBtn && settingsMenu && settingsMenuOverlay) {
      const openSettingsMenu = () => {
        settingsMenu.classList.add('open');
        settingsMenuOverlay.classList.add('open');
      };

      const closeSettingsMenu = () => {
        settingsMenu.classList.remove('open');
        settingsMenuOverlay.classList.remove('open');
      };

      settingsToggleBtn.addEventListener('click', openSettingsMenu);
      settingsMenuClose.addEventListener('click', closeSettingsMenu);
      settingsMenuOverlay.addEventListener('click', closeSettingsMenu);

      // ESCキーでメニューを閉じる
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && settingsMenu.classList.contains('open')) {
          closeSettingsMenu();
        }
      });
    }

    // テーマ切替機能
    if (themeSelect) {
      const mq = window.matchMedia('(prefers-color-scheme: dark)');
      function applyTheme(mode) {
        const target = mode === 'auto' ? (mq.matches ? 'dark' : 'light') : mode;
        document.body.setAttribute('data-theme', target);
        document.documentElement.setAttribute('data-theme', target);
      }
      const saved = localStorage.getItem(STORAGE_KEYS.theme) || 'auto';
      themeSelect.value = saved;
      applyTheme(saved);
      mq.addEventListener('change', () => { if ((localStorage.getItem(STORAGE_KEYS.theme) || 'auto') === 'auto') applyTheme('auto'); });
      themeSelect.addEventListener('change', (e) => {
        const theme = e.target.value;
        localStorage.setItem(STORAGE_KEYS.theme, theme);
        applyTheme(theme);
      });
    }

    // 文字サイズ変更機能
    if (fontSizeSelect) {
      const currentSize = localStorage.getItem(STORAGE_KEYS.fontSize) || 'M';
      fontSizeSelect.value = currentSize;
      document.body.setAttribute('data-font-size', currentSize);
      fontSizeSelect.addEventListener('change', (e) => {
        const size = e.target.value;
        document.body.setAttribute('data-font-size', size);
        localStorage.setItem(STORAGE_KEYS.fontSize, size);
      });
    }

    // コメント出力機能
    if (commentsExportPage) {
      commentsExportPage.addEventListener('click', () => exportComments(true));
    }
    if (commentsExportAll) {
      commentsExportAll.addEventListener('click', () => exportComments(false));
    }

    // コメントインポート機能
    if (commentsImport && commentsImportButton) {
      commentsImport.addEventListener('change', (e) => importCommentsFromFile(e.target.files[0]));
      commentsImportButton.addEventListener('click', () => commentsImport.click());
    }

    // リセットボタン群
    if (resetUiBtn) {
      resetUiBtn.addEventListener('click', () => {
        const ok = window.confirm('UI系の設定（テーマ・文字サイズ・右パネルタブ・ソート設定など）をリセットしますか？');
        if (!ok) return;
        resetUiSettings();
        // 即時反映のため、ページを再読み込み
        window.location.reload();
      });
    }

    if (resetMemoBtn) {
      resetMemoBtn.addEventListener('click', () => {
        const ok = window.confirm('メモ系（マーカー・コメント）の保存データをすべてリセットしますか？\\n※元に戻すことはできません。');
        if (!ok) return;
        resetMemoSettings();
        window.location.reload();
      });
    }

    if (resetPreviewBtn) {
      resetPreviewBtn.addEventListener('click', () => {
        const ok = window.confirm('プレビュー関連の設定（Docs/BGプレビューの状態・トースト表示数）をリセットしますか？');
        if (!ok) return;
        resetPreviewSettings();
        window.location.reload();
      });
    }

    if (resetAllBtn) {
      resetAllBtn.addEventListener('click', () => {
        const ok = window.confirm('すべての設定と保存データを完全にリセットします。\\nlocalStorage / sessionStorage を初期化しますが、本当に実行しますか？');
        if (!ok) return;
        resetAllSettingsHard();
        window.location.reload();
      });
    }

    // プレビューのトースト表示数スライダー
    if (toastMaxRange && toastMaxValue) {
      let stored = 3;
      try {
        const raw = localStorage.getItem('gdocPreviewMaxToasts');
        if (raw != null) {
          const n = parseInt(raw, 10);
          if (!isNaN(n)) stored = Math.min(9, Math.max(0, n));
        }
      } catch (e) {
        // ignore
      }
      toastMaxRange.value = String(stored);
      toastMaxValue.textContent = String(stored);

      toastMaxRange.addEventListener('input', () => {
        toastMaxValue.textContent = String(toastMaxRange.value);
      });
      toastMaxRange.addEventListener('change', () => {
        const n = parseInt(toastMaxRange.value, 10) || 0;
        try {
          localStorage.setItem('gdocPreviewMaxToasts', String(Math.min(9, Math.max(0, n))));
        } catch (e) {}
        if (window.__gdocPreviewAPI__ && typeof window.__gdocPreviewAPI__.refreshToasts === 'function') {
          window.__gdocPreviewAPI__.refreshToasts();
        }
      });
    }

    ensureHeaderListButtons();
    document.addEventListener('quarto-hrChanged', ensureHeaderListButtons);
    window.addEventListener('resize', ensureHeaderListButtons);
  }

  function ensureHeaderListButtons() {
    try {
      const searchButtons = document.querySelectorAll('.quarto-search-button');
      if (!searchButtons.length) return;
      searchButtons.forEach(searchButton => {
        const parent = searchButton.parentElement;
        if (!parent) return;
        if (parent.querySelector('.quarto-list-button')) return;
        const listBtn = document.createElement('button');
        listBtn.type = 'button';
        listBtn.className = 'btn quarto-list-button';
        listBtn.setAttribute('aria-label', 'プレビュー・コメント・マーカー一覧を開く');
        const icon = document.createElement('img');
        icon.alt = '';
        icon.decoding = 'async';
        icon.loading = 'lazy';
        icon.setAttribute('aria-hidden', 'true');
        icon.src = resolveAssetPath('assets/list.png');
        listBtn.appendChild(icon);
        listBtn.addEventListener('click', (event) => {
          event.preventDefault();
          openGlobalListOverlay();
        });
        parent.insertBefore(listBtn, searchButton);
      });
    } catch (e) {
      console.warn('inject list button failed', e);
    }
  }

  function renderNavDrawerContent(container, navData) {
    if (!container) return;
    container.innerHTML = '';
    const switcher = document.createElement('div');
    switcher.className = 'toc-switcher nav-drawer-switcher';
    switcher.innerHTML = `
      <div class="toc-tabs">
        <button type="button" class="toc-tab active" data-tab="site">各章</button>
        <button type="button" class="toc-tab" data-tab="page">章内</button>
        <button type="button" class="toc-tab" data-tab="all">全体</button>
      </div>
      <div class="toc-panel toc-site-content"></div>
      <div class="toc-panel toc-page-content hidden"></div>
      <div class="toc-panel toc-all-content hidden"></div>
    `;
    container.appendChild(switcher);
    const sitePanel = switcher.querySelector('.toc-site-content');
    const pagePanel = switcher.querySelector('.toc-page-content');
    const allPanel = switcher.querySelector('.toc-all-content');
    if (sitePanel) CustomTOC.renderChapterTab(sitePanel, navData);
    if (pagePanel) CustomTOC.renderPageTab(pagePanel, navData, 4);
    if (allPanel) CustomTOC.renderAllTab(allPanel, navData);
    const tabButtons = switcher.querySelectorAll('.toc-tab');
    tabButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        const target = btn.dataset.tab;
        tabButtons.forEach(other => other.classList.remove('active'));
        btn.classList.add('active');
        switcher.querySelectorAll('.toc-panel').forEach(panel => {
          panel.classList.add('hidden');
        });
        const panel = switcher.querySelector(`.toc-${target}-content`);
        if (panel) panel.classList.remove('hidden');
      });
    });
  }

  function setupMobileNavDrawer(navData) {
    const overlay = document.querySelector('.toc-overlay');
    if (!overlay) return;
    const closeBtn = overlay.querySelector('.toc-sheet__close');
    const backdrop = overlay.querySelector('.toc-overlay__backdrop');
    const content = overlay.querySelector('.toc-sheet__content');
    const toggleButtons = document.querySelectorAll('.quarto-btn-toggle, [data-bs-target=".quarto-sidebar-collapse-item"]');
    const buttons = Array.from(new Set(Array.from(toggleButtons)));
    if (!buttons.length) return;

    const closeDrawer = () => {
      document.body.classList.remove('toc-open');
    };

    const openDrawer = () => {
      renderNavDrawerContent(content, navData);
      document.body.classList.add('toc-open');
    };

    const toggleDrawer = () => {
      if (document.body.classList.contains('toc-open')) {
        closeDrawer();
      } else {
        openDrawer();
      }
    };

    const interceptToggle = (event) => {
      if (window.innerWidth > 1024) {
        closeDrawer();
        return;
      }
      event.preventDefault();
      event.stopPropagation();
      if (typeof event.stopImmediatePropagation === 'function') {
        event.stopImmediatePropagation();
      }
      toggleDrawer();
    };

    buttons.forEach(btn => {
      btn.addEventListener('click', interceptToggle, true);
    });

    if (closeBtn) closeBtn.addEventListener('click', closeDrawer);
    if (backdrop) backdrop.addEventListener('click', closeDrawer);
    overlay.addEventListener('click', (event) => {
      if (event.target.classList.contains('toc-overlay')) {
        closeDrawer();
      }
    });
    if (content) {
      content.addEventListener('click', (event) => {
        const anchor = event.target.closest('a');
        if (anchor) closeDrawer();
      });
    }
    document.addEventListener('keydown', (event) => {
      if (event.key === 'Escape' && document.body.classList.contains('toc-open')) {
        closeDrawer();
      }
    });
    window.addEventListener('resize', () => {
      if (window.innerWidth > 1024) closeDrawer();
    });
  }

  function setupLeftPanelTabs(navData) {
    const sidebar = document.getElementById('quarto-sidebar');
    if (!sidebar) return;
    const menuContainer = sidebar.querySelector('.sidebar-menu-container');
    if (!menuContainer) return;

    const tabWrapper = document.createElement('div');
    tabWrapper.className = 'toc-switcher';
    tabWrapper.innerHTML = `
      <div class="toc-tabs">
        <button type="button" class="toc-tab active" data-tab="site">各章</button>
        <button type="button" class="toc-tab" data-tab="page">章内</button>
        <button type="button" class="toc-tab" data-tab="all">全体</button>
      </div>
      <div class="toc-panel toc-site-content"></div>
      <div class="toc-panel toc-page-content hidden"></div>
      <div class="toc-panel toc-all-content hidden"></div>
    `;

    const parent = menuContainer.parentNode;
    parent.replaceChild(tabWrapper, menuContainer);

    const sitePanel = tabWrapper.querySelector('.toc-site-content');
    const pagePanel = tabWrapper.querySelector('.toc-page-content');
    const allPanel = tabWrapper.querySelector('.toc-all-content');

    sitePanel.innerHTML = '';
    pagePanel.innerHTML = '';
    allPanel.innerHTML = '';

    menuContainer.innerHTML = '';
    sitePanel.appendChild(menuContainer);

    const allContainer = document.createElement('div');
    allContainer.className = 'toc-all-container';
    allPanel.appendChild(allContainer);

    if (!navData || !Array.isArray(navData.pages) || !navData.pages.length) {
      menuContainer.innerHTML = '<p class="toc-empty">目次データを読み込めませんでした。</p>';
      allContainer.innerHTML = '<p class="toc-empty">目次データを読み込めませんでした。</p>';
      pagePanel.innerHTML = '<p class="toc-empty">目次データを読み込めませんでした。</p>';
    } else {
      CustomTOC.renderChapterTab(menuContainer, navData);
      CustomTOC.renderAllTab(allContainer, navData);
      CustomTOC.renderPageTab(pagePanel, navData, 4);
    }

    const tabButtons = tabWrapper.querySelectorAll('.toc-tab');
    const panels = { site: sitePanel, page: pagePanel, all: allPanel };
    tabButtons.forEach(button => {
      button.addEventListener('click', () => {
        const target = button.dataset.tab;
        tabButtons.forEach(btn => btn.classList.remove('active'));
        button.classList.add('active');
        Object.values(panels).forEach(p => p.classList.add('hidden'));
        if (panels[target]) {
          panels[target].classList.remove('hidden');
          if (target === 'page' && navData) {
            CustomTOC.renderPageTab(pagePanel, navData, 4);
          }
        }
      });
    });
    scheduleScrollExtensionUpdate();
  }

  function setupLeftSidebarStability() {
    const sidebar = document.getElementById('quarto-sidebar');
    const toggles = document.querySelectorAll('[data-bs-target=".quarto-sidebar-collapse-item"]');
    if (!sidebar || !toggles.length) return;
    let pendingState = null;
    let pendingExpiry = 0;
    let restoreHandle = null;

    const applyPendingState = () => {
      if (!pendingState) return;
      scrollToReadingState(pendingState);
      if (Date.now() > pendingExpiry) {
        pendingState = null;
      }
    };

    const scheduleRestore = () => {
      if (!pendingState) return;
      if (restoreHandle) {
        cancelAnimationFrame(restoreHandle);
        restoreHandle = null;
      }
      restoreHandle = requestAnimationFrame(() => {
        restoreHandle = requestAnimationFrame(() => {
          applyPendingState();
        });
      });
    };

    const captureStateBeforeToggle = () => {
      const snapshot = captureReadingState({ captureNodeRef: true });
      if (!snapshot) return;
      pendingState = snapshot;
      pendingExpiry = Date.now() + 1200;
      scheduleRestore();
    };

    toggles.forEach(btn => {
      btn.addEventListener('click', captureStateBeforeToggle, true);
      btn.addEventListener('keydown', (event) => {
        if (event.key === 'Enter' || event.key === ' ') {
          captureStateBeforeToggle();
        }
      }, true);
    });

    sidebar.addEventListener('transitionstart', () => {
      if (!pendingState) {
        captureStateBeforeToggle();
      }
    });

    sidebar.addEventListener('animationstart', () => {
      if (!pendingState) {
        captureStateBeforeToggle();
      }
    });

    sidebar.addEventListener('transitionend', (event) => {
      if (!pendingState) return;
      if (event && event.propertyName && !/width|flex|margin|padding/i.test(event.propertyName)) return;
      scheduleRestore();
    });

    const sidebarMutationObserver = new MutationObserver(() => {
      if (pendingState) scheduleRestore();
    });
    sidebarMutationObserver.observe(sidebar, { attributes: true, attributeFilter: ['class', 'style'] });

    window.addEventListener('resize', () => {
      if (pendingState) {
        scheduleRestore();
      }
    });
  }

  function applySiteTitleEnhancements(navData) {
    enhanceSidebarSiteTitle();
    updateMainHeaderTitle(navData);
  }

  function enhanceSidebarSiteTitle() {
    try {
      const link = document.querySelector('#quarto-sidebar .sidebar-title a');
      if (!link || link.dataset.siteTitleEnhanced === 'true') return;
      const mainText = (link.textContent || '').trim() || '平和への課題：補遺';
      const safeMain = escapeHtml(mainText);
      const subtitle = 'Background Guide';
      link.innerHTML = `<span class="site-title-main">${safeMain}</span><span class="site-title-sub">${subtitle}</span>`;
      link.dataset.siteTitleEnhanced = 'true';
    } catch (e) {
      console.warn('enhanceSidebarSiteTitle failed', e);
    }
  }

  function updateMainHeaderTitle(navData) {
    const header = document.querySelector('header.quarto-title-block');
    if (!header) return;
    const titleEl = header.querySelector('.quarto-title .title');
    if (!titleEl) return;
    const existingSpan = titleEl.querySelector('.chapter-title') || titleEl.firstElementChild;
    const current = computeCurrentOutputPath();
    let pageTitle = '';
    try {
      if (navData && Array.isArray(navData.pages)) {
        const entry = navData.pages.find(page => {
          if (!page) return false;
          const paths = [page.output, page.url, page.source];
          return paths.some(p => isSamePage(p, current));
        });
        if (entry && entry.title) {
          pageTitle = entry.title;
        }
      }
    } catch (e) {
      console.warn('updateMainHeaderTitle nav data lookup failed', e);
    }
    if (!pageTitle && existingSpan) {
      pageTitle = (existingSpan.textContent || '').trim();
    }
    if (!pageTitle) {
      const contentHeading = document.querySelector('main h1, main h2');
      if (contentHeading) {
        pageTitle = (contentHeading.textContent || '').trim();
      }
    }
    if (!pageTitle) {
      header.style.display = 'none';
      return;
    }
    header.style.display = 'none';
  }

  function setupRightSidebar() {
    ensureRightTabs();
    refreshRightPanels();
    const onResize = debounce(() => {
      ensureRightTabs();
      refreshRightPanels();
    }, 200);
    window.addEventListener('resize', onResize);
    window.addEventListener('orientationchange', onResize);
    window.addEventListener('hashchange', () => { setTimeout(refreshRightPanels, 60); });
  }

  function refreshRightPanels() {
    applyFootnoteLayout();
    renderCommentsPanel();
    if (SIDENOTES_ON) {
      renderSidenotes(currentRightTab());
    }
    if (typeof enumerateReadingNodes === 'function') {
      enumerateReadingNodes();
    }
    if (typeof scheduleReadingStateSave === 'function') {
      scheduleReadingStateSave();
    }
    scheduleScrollExtensionUpdate();
  }

  function ensureRightTabs() {
    const marginSidebar = document.getElementById('quarto-margin-sidebar');
    if (!marginSidebar) return;
    let wrapper = marginSidebar.querySelector('.right-switcher');
    if (!wrapper) {
      wrapper = document.createElement('div');
      wrapper.className = 'right-switcher';
      wrapper.innerHTML = `
        <div class="toc-tabs">
          <button type="button" class="toc-tab" data-tab="footnotes">脚注</button>
          <button type="button" class="toc-tab" data-tab="comments">ｺﾒﾝﾄ</button>
          <button type="button" class="toc-tab" data-tab="both">両方</button>
        </div>
        <div class="toc-panel right-footnotes"></div>
        <div class="toc-panel right-comments" style="display:none"></div>
        <div class="toc-panel right-both" style="display:none"></div>
      `;
      marginSidebar.innerHTML = '';
      marginSidebar.appendChild(wrapper);

      const tabs = wrapper.querySelectorAll('.toc-tab');
      tabs.forEach(btn => {
        btn.addEventListener('click', () => {
          activateRightTab(btn.dataset.tab || 'footnotes');
        });
      });
      const savedTab = getSavedRightTab();
      activateRightTab(savedTab, { skipSave: true });
      // 傍注表示は常に ON とする
      setSidenotesMode(true);
    } else {
      activateRightTab(getSavedRightTab(), { skipSave: true });
      // 既存 DOM 再利用時も傍注モードを維持
      if (!SIDENOTES_ON) setSidenotesMode(true);
    }
  }

  let SIDENOTES_ON = false;
  let SIDENOTES_ITEMS = [];

  function activateRightTab(tab, opts = {}) {
    const marginSidebar = document.getElementById('quarto-margin-sidebar');
    if (!marginSidebar) return;
    const wrapper = marginSidebar.querySelector('.right-switcher');
    if (!wrapper) return;
    const tabs = Array.from(wrapper.querySelectorAll('.toc-tab'));
    const normalized = ['footnotes', 'comments', 'both'].includes(tab) ? tab : 'both';
    tabs.forEach(btn => btn.classList.toggle('active', btn.dataset.tab === normalized));
    const footPanel = wrapper.querySelector('.right-footnotes');
    const commPanel = wrapper.querySelector('.right-comments');
    const bothPanel = wrapper.querySelector('.right-both');
    if (SIDENOTES_ON) {
      if (footPanel) footPanel.style.display = 'none';
      if (commPanel) commPanel.style.display = 'none';
      if (bothPanel) bothPanel.style.display = 'none';
      renderSidenotes(normalized);
    } else {
      if (footPanel) footPanel.style.display = normalized === 'footnotes' ? '' : 'none';
      if (commPanel) commPanel.style.display = normalized === 'comments' ? '' : 'none';
      if (bothPanel) bothPanel.style.display = normalized === 'both' ? '' : 'none';
    }
    if (!opts.skipSave) saveRightTab(normalized);
  }

  function currentRightTab() {
    const active = document.querySelector('#quarto-margin-sidebar .toc-tab.active');
    if (active) return active.getAttribute('data-tab') || 'footnotes';
    return getSavedRightTab();
  }

  function setSidenotesMode(on) {
    const ms = document.getElementById('quarto-margin-sidebar');
    if (!ms) return;
    const foot = ms.querySelector('.right-footnotes');
    const comm = ms.querySelector('.right-comments');
    const both = ms.querySelector('.right-both');
    SIDENOTES_ON = !!on;
    if (SIDENOTES_ON) {
      ms.classList.add('sidenotes-on');
      if (foot) foot.style.display = 'none';
      if (comm) comm.style.display = 'none';
      if (both) both.style.display = 'none';
      renderSidenotes(currentRightTab());
      window.addEventListener('scroll', updateSidenotesPositions, { passive: true });
      window.addEventListener('resize', updateSidenotesPositions);
    } else {
      ms.classList.remove('sidenotes-on');
      clearSidenotes();
      window.removeEventListener('scroll', updateSidenotesPositions);
      window.removeEventListener('resize', updateSidenotesPositions);
      activateRightTab(currentRightTab(), { skipSave: true });
    }
  }

  function clearSidenotes() {
    const ms = document.getElementById('quarto-margin-sidebar');
    ms.querySelectorAll('.margin-note').forEach(n => n.remove());
    SIDENOTES_ITEMS = [];
  }

  function renderSidenotes(mode) {
    clearSidenotes();
    const ms = document.getElementById('quarto-margin-sidebar');
    if (!ms) return;
    const makeNote = (opts) => {
      const note = document.createElement('div');
      note.className = 'margin-note' + (opts.kind==='comment' ? ' comment' : '');
      note.innerHTML = `
        <div class=\"meta\"><span>${opts.time||''}</span>${opts.moveHtml||''}${opts.showMenu ? '<button class="menu" title="メニュー" style="margin-left:auto;background:none;border:none;cursor:pointer;font-size:16px;line-height:1;">⋯</button>' : ''}</div>
        ${opts.targetHtml||''}
        <div class=\"body\">${opts.bodyHtml||''}</div>
      `;
      ms.appendChild(note);
      return note;
    };

    const footnotes = gatherActiveFootnotes();
    const comments = gatherActiveCommentsWithElements();

    const entries = [];
    if (mode !== 'comments') {
      footnotes.forEach(fn => {
        if (!fn.ref) return;
        entries.push({ kind: 'foot', el: fn.ref, def: fn.li, label: fn.number });
      });
    }
    if (mode !== 'footnotes') {
      comments.forEach(item => {
        if (!item.el) return;
        entries.push({ kind: 'comment', el: item.el, rec: item.rec });
      });
    }

    SIDENOTES_ITEMS = entries.map(entry => {
      if (entry.kind === 'comment') {
        const rec = entry.rec;
        const note = makeNote({
          kind: 'comment',
          time: fmtMMDDHHmm(rec.t),
          moveHtml: `<a href="#" class="mv">移動</a>`,
          targetHtml: `<div class="target">${escapeHtml((rec.text||'').slice(0,80))}</div>`,
          bodyHtml: escapeHtml(rec.body||''),
          showMenu: true
        });
        note.querySelector('.mv')?.addEventListener('click', (e)=>{ e.preventDefault(); scrollToComment(rec); });
        note.querySelector('.menu')?.addEventListener('click', (e)=>{ e.stopPropagation(); openCommentMenu(note, rec, { x: e.clientX, y: e.clientY }); });
        return { kind: 'comment', el: entry.el, node: note };
      } else {
        // 脚注の傍注では、元の脚注HTMLを元にクローンを作り、
        // 先頭に [番号] スパンを 1 個だけ挿入して同一行に表示する
        let bodyHtml = '';
        if (entry.def) {
          const clone = entry.def.cloneNode(true);
          clone.querySelectorAll('.footnote-back, .footnote-backref, [role="doc-backlink"]').forEach(a => a.remove());
          const hasNum = clone.querySelector('.footnote-num');
          if (!hasNum) {
            const numSpan = document.createElement('span');
            numSpan.className = 'footnote-num';
            const labelText = (entry.label && String(entry.label).trim().length)
              ? String(entry.label).trim()
              : '';
            numSpan.textContent = labelText ? (labelText + '. ') : '';
            clone.insertBefore(numSpan, clone.firstChild);
          }
          bodyHtml = clone.innerHTML;
        }
        const note = makeNote({
          kind: 'foot',
          bodyHtml: bodyHtml,
          moveHtml: '',
          showMenu: false
        });
        note.querySelector('.menu')?.remove();
        return { kind: 'foot', el: entry.el, node: note };
      }
    });

    updateSidenotesPositions();
    reinforceAnchors(ms);
  }

  function rightSidebarBaseOffset() {
    const ms = document.getElementById('quarto-margin-sidebar');
    if (!ms) return 0;
    const switcher = ms.querySelector('.right-switcher');
    return switcher ? switcher.offsetHeight + 12 : 0;
  }

  function updateSidenotesPositions() {
    if (!SIDENOTES_ON) return;
    const ms = document.getElementById('quarto-margin-sidebar');
    if (!ms) return;
    const msRect = ms.getBoundingClientRect();
    const viewH = window.innerHeight || document.documentElement.clientHeight || 0;
    const msHeight = ms.clientHeight || (viewH || 0);
    if (!msHeight) return;
    const buffer = viewH || msHeight; // 1画面分のバッファ
    const baseOffset = rightSidebarBaseOffset();

    // アンカー位置に応じて傍注の理想位置を決める
    const entries = SIDENOTES_ITEMS
      .filter(item => item.el && item.node && item.el.getClientRects().length)
      .map(item => {
        const rect = item.el.getBoundingClientRect();
        const node = item.node;
        const nodeHeight = node.offsetHeight || 0;
        // アンカーの上端を右パネル座標系に合わせる
        const anchorTopInSidebar = rect.top - msRect.top;
        // 傍注はタブ行の直下から並ぶので baseOffset を足す
        const desiredTop = anchorTopInSidebar + baseOffset;
        return { item, desiredTop, nodeHeight };
      })
      .sort((a, b) => a.desiredTop - b.desiredTop);

    // ノート同士が重ならないように、手前のノートの下に最小限だけずらして配置する。
    // アンカーが画面外に出ていっても entries からは除外しないことで、
    // 上のノートが非表示になった瞬間に下のノートが大きくジャンプすることを防ぐ。
    const gap = 4;
    let cursor = -Infinity;
    entries.forEach(({ item, desiredTop, nodeHeight }) => {
      const node = item.node;
      if (!node) return;
      const height = nodeHeight || node.offsetHeight || 0;
      // 直前のノートの直下までは押し下げるが、それ以上はアンカーに追随
      const top = Math.max(desiredTop, cursor);
      const bottom = top + height;
      // 1画面分のバッファを考慮し、完全に表示範囲から外れたときだけ非表示にする
      const visible = bottom > (baseOffset - buffer) && top < (msHeight + buffer);
      if (!visible) {
        node.style.display = 'none';
        return;
      }
      node.style.display = 'block';
      node.style.top = top + 'px';
      cursor = top + height + gap;
    });
  }

  function applyFootnoteLayout() {
    const inlineQuery = window.matchMedia(`(max-width: ${FOOTNOTE_INLINE_BREAKPOINT}px)`);
    const shouldInline = inlineQuery.matches || window.innerWidth <= FOOTNOTE_INLINE_BREAKPOINT;
    const nextMode = shouldInline ? 'inline' : 'sidebar';
    if (currentFootnoteLayout !== nextMode) {
      currentFootnoteLayout = nextMode;
      document.body && document.body.classList.toggle('footnotes-inline-mode', shouldInline);
      document.body && document.body.classList.toggle('footnotes-sidebar-mode', !shouldInline);
    }
    const rendered = shouldInline ? !!renderInlineFootnotes() : !!renderSidebarFootnotes();
    try {
      if (document.body) {
        document.body.classList.toggle('js-footnotes-enhanced', rendered);
      }
    } catch (e) {
      console.warn('applyFootnoteLayout: failed to mark enhanced footnotes state', e);
    }
  }

  function renderSidebarFootnotes() {
    setInlineFootnoteMode(false);
    document.querySelectorAll('.footnote-inline').forEach(n => n.remove());
    let marginSidebar = document.getElementById('quarto-margin-sidebar');
    if (!marginSidebar) return false;

    if (marginSidebar.style.display === 'none') {
      const prev = marginSidebar.dataset.prevDisplay || '';
      marginSidebar.style.display = prev;
      delete marginSidebar.dataset.prevDisplay;
    }

    if (!marginSidebar.querySelector('.right-switcher')) {
      ensureRightTabs();
      marginSidebar = document.getElementById('quarto-margin-sidebar');
    }

    let footHost = marginSidebar.querySelector('.right-footnotes');
    if (!footHost) {
      footHost = document.createElement('div');
      footHost.className = 'toc-panel right-footnotes';
      marginSidebar.appendChild(footHost);
    }

    let bothHost = marginSidebar.querySelector('.right-both');
    if (!bothHost) {
      bothHost = document.createElement('div');
      bothHost.className = 'toc-panel right-both';
      bothHost.style.display = 'none';
      marginSidebar.appendChild(bothHost);
    }

    footHost.innerHTML = '';
    if (bothHost) bothHost.innerHTML = '';

    const headerRow = document.createElement('div');
    headerRow.style.cssText = 'display:flex;align-items:center;justify-content:space-between;margin-bottom:6px;';
    const header = document.createElement('h2');
    header.className = 'footnotes-title';
    header.textContent = '脚注';
    const sort = document.createElement('select');
    sort.innerHTML = '<option value="pos">本文位置順</option><option value="num">番号順</option>';
    sort.value = localStorage.getItem('footnotes-sort') || 'pos';
    sort.addEventListener('change', () => { localStorage.setItem('footnotes-sort', sort.value); renderSidebarFootnotes(); });
    headerRow.appendChild(header); headerRow.appendChild(sort);
    footHost.appendChild(headerRow);

    const footnotes = gatherActiveFootnotes();
    if (!footnotes.length) {
      footHost.insertAdjacentHTML('beforeend','<p class="footnotes-empty">このページには脚注がありません。</p>');
      if (bothHost) bothHost.insertAdjacentHTML('beforeend','<p class="footnotes-empty">このページには脚注/コメントがありません。</p>');
      return false;
    }

    const items = footnotes.slice();
    const mode = sort.value;
    const getSortableNumber = (item) => {
      const primary = Number(item.number);
      if (!Number.isNaN(primary)) return primary;
      const fallbackFromId = Number(String(item.id || '').replace(/[^0-9]+/g, ''));
      if (!Number.isNaN(fallbackFromId)) return fallbackFromId;
      return Number.POSITIVE_INFINITY;
    };
    if (mode === 'pos') {
      items.sort((a,b)=>a.pos-b.pos);
    } else {
      items.sort((a,b)=> {
        const numA = getSortableNumber(a);
        const numB = getSortableNumber(b);
        if (numA !== numB) return numA - numB;
        const labelA = (a.number || '').toString();
        const labelB = (b.number || '').toString();
        const cmpLabel = labelA.localeCompare(labelB, undefined, { numeric: true, sensitivity: 'base' });
        if (cmpLabel !== 0) return cmpLabel;
        return (a.id || '').localeCompare(b.id || '');
      });
    }

    const wrapper = document.createElement('div');
    wrapper.className = 'margin-footnotes';
    const ol = document.createElement('ol');
    items.forEach((it, idx) => {
      const clone = it.li.cloneNode(true);
      const displayLabel = (it.number && String(it.number).trim().length) ? String(it.number).trim() : String(idx + 1);
      if (!clone.querySelector('.footnote-num')) {
        const num = document.createElement('span');
        num.className = 'footnote-num';
        num.textContent = displayLabel + '. ';
        clone.insertBefore(num, clone.firstChild);
      }
      it.number = displayLabel;
      it.displayIndex = displayLabel;
      it.clone = clone;
      ol.appendChild(clone);
    });
    wrapper.appendChild(ol);
    footHost.appendChild(wrapper);
    reinforceAnchors(footHost);

    // 両方タブ: コメントと脚注を本文位置で混在
    if (bothHost) {
      renderBothPanel(bothHost, items);
      reinforceAnchors(bothHost);
    }

    setupScrollSyncForFootnotes(footHost, items);
    refreshCommentMarkersFromDB({ preserveExisting: true });
    scheduleScrollExtensionUpdate();
    return true;
  }

  function renderBothPanel(host, footItems) {
    const commentAnchors = gatherActiveCommentsWithElements();
    const commItems = commentAnchors.map(({ rec, el }) => {
      const rect = el ? el.getBoundingClientRect() : null;
      const top = rect ? (rect.top + window.scrollY) : Infinity;
      return { type: 'comment', top, rec };
    });
    const footMixed = (footItems || []).map((f) => ({
      type: 'foot',
      top: f.pos,
      id: f.id,
      displayIndex: f.displayIndex,
      number: f.number,
      clone: f.li.cloneNode(true)
    }));
    const merged = commItems.concat(footMixed).sort((a, b) => a.top - b.top);

    host.innerHTML = '';
    const header = document.createElement('h2');
    header.className = 'footnotes-title';
    header.textContent = '両方';
    host.appendChild(header);

    const list = document.createElement('div');
    list.className = 'both-mixed-list';
    list.style.cssText = 'display:flex; flex-direction:column; gap:8px;';

    merged.forEach(item => {
      if (item.type === 'comment') {
        const rec = item.rec;
        const card = document.createElement('div');
        card.className = 'comment-card';
        card.style.cssText = 'padding:10px;background:#fff;border-radius:6px;border-left:3px solid #ff9800;box-shadow:0 1px 3px rgba(0,0,0,0.08);';
        const meta = document.createElement('div');
        meta.className = 'comment-meta';
        meta.style.cssText = 'font-size:12px;color:#6c757d;margin-bottom:6px;display:flex;gap:8px;align-items:center;';
        const t = document.createElement('span');
        t.textContent = fmtMMDDHHmm(rec.t);
        const move = document.createElement('a');
        move.href = '#';
        move.textContent = '移動';
        move.addEventListener('click', (e) => { e.preventDefault(); scrollToComment(rec); });
        meta.appendChild(t);
        meta.appendChild(move);
        const target = document.createElement('div');
        target.className = 'comment-snippet';
        target.style.cssText = 'font-size:13px;color:#495057;background:#fff3e0;padding:6px 8px;border-radius:4px;margin-bottom:6px;';
        target.textContent = rec.text || '';
        const body = document.createElement('div');
        body.className = 'comment-body';
        body.style.cssText = 'white-space:pre-wrap; line-height:1.5;';
        body.textContent = rec.body || '';
        card.appendChild(meta);
        card.appendChild(target);
        card.appendChild(body);
        list.appendChild(card);
      } else {
        const wrapper = document.createElement('div');
        wrapper.className = 'both-footnote-card';
        wrapper.style.cssText = 'padding:10px;background:#fff;border-radius:6px;border-left:3px solid #6c757d;box-shadow:0 1px 3px rgba(0,0,0,0.06);';
        const clone = item.clone;
        if (!clone.querySelector('.footnote-num')) {
          const num = document.createElement('span');
          num.className = 'footnote-num';
          const label = (item.displayIndex && String(item.displayIndex).trim().length)
            ? String(item.displayIndex).trim()
            : (item.number && String(item.number).trim().length)
              ? String(item.number).trim()
              : String(footMixed.indexOf(item) + 1);
          num.textContent = label + '. ';
          clone.insertBefore(num, clone.firstChild);
        }
        wrapper.appendChild(clone);
        list.appendChild(wrapper);
      }
    });
    host.appendChild(list);
    reinforceAnchors(list);
    setupScrollSyncForBoth(host, merged);
  }

  // 本文側のスクロール位置と右パネル内部スクロールの同期ユーティリティ
  function computeScrollRatioFromPositions(positions) {
    if (!Array.isArray(positions) || !positions.length) return null;
    let minPos = Infinity;
    let maxPos = -Infinity;
    positions.forEach(p => {
      if (typeof p !== 'number' || !isFinite(p)) return;
      if (p < minPos) minPos = p;
      if (p > maxPos) maxPos = p;
    });
    if (!isFinite(minPos) || !isFinite(maxPos)) return null;

    const scrollY = window.scrollY || window.pageYOffset || document.documentElement.scrollTop || 0;
    const viewH = window.innerHeight || document.documentElement.clientHeight || 0;
    const center = scrollY + viewH / 2;

    if (maxPos === minPos) {
      return center <= minPos ? 0 : 1;
    }
    let ratio = (center - minPos) / (maxPos - minPos);
    if (ratio < 0) ratio = 0;
    else if (ratio > 1) ratio = 1;
    return ratio;
  }

  function scrollRightSidebarToRatio(ratio, host) {
    if (ratio == null) return;
    const container = document.getElementById('quarto-margin-sidebar') || host;
    if (!container) return;
    const maxScroll = container.scrollHeight - container.clientHeight;
    if (!(maxScroll > 0)) return;
    const clamped = Math.max(0, Math.min(1, ratio));
    container.scrollTop = maxScroll * clamped;
  }

  function setupScrollSyncForFootnotes(host, items) {
    const mode = localStorage.getItem('footnotes-sort') || 'pos';
    if (mode !== 'pos') return;
    if (!Array.isArray(items) || !items.length) return;
    const positions = items
      .map(it => (typeof it.pos === 'number' ? it.pos : null))
      .filter(p => typeof p === 'number' && isFinite(p));
    if (!positions.length) return;

    const onScroll = () => {
      const ratio = computeScrollRatioFromPositions(positions);
      scrollRightSidebarToRatio(ratio, host);
    };
    window.addEventListener('scroll', onScroll, { passive: true });
  }

  function setupScrollSyncForBoth(host, items) {
    const onScroll = () => {
      if (!Array.isArray(items) || !items.length) return;
      const positions = items
        .map(it => (typeof it.top === 'number' ? it.top : null))
        .filter(p => typeof p === 'number' && isFinite(p));
      const ratio = computeScrollRatioFromPositions(positions);
      scrollRightSidebarToRatio(ratio, host);
    };
    window.addEventListener('scroll', onScroll, { passive: true });
  }

  function renderCommentsPanel() {
    const marginSidebar = document.getElementById('quarto-margin-sidebar');
    if (!marginSidebar) return;
    const commHost = marginSidebar.querySelector('.right-comments');
    if (!commHost) return;
    const list = getActiveComments();
    commHost.innerHTML = '';

    const header = document.createElement('div');
    header.style.cssText = 'display:flex;align-items:center;justify-content:space-between;margin-bottom:6px;';
    const title = document.createElement('h2');
    title.className = 'footnotes-title';
    title.textContent = 'コメント';
    const sort = document.createElement('select');
    sort.innerHTML = '<option value="new">新しい順</option><option value="pos">本文位置順</option><option value="old">古い順</option>';
    sort.value = localStorage.getItem('comments-sort') || 'new';
    sort.addEventListener('change', () => { localStorage.setItem('comments-sort', sort.value); renderCommentsPanel(); });
    header.appendChild(title); header.appendChild(sort);
    commHost.appendChild(header);

    if (!list.length) { commHost.insertAdjacentHTML('beforeend','<p class="footnotes-empty">コメントはありません。</p>'); return; }

    const computePos = (rec) => {
      const el = findCommentAnchorElement(rec);
      const top = el ? (el.getBoundingClientRect().top + window.scrollY) : Infinity;
      return top;
    };

    let arr = list.slice();
    const mode = sort.value;
    if (mode === 'new') arr.sort((a,b)=>b.t-a.t);
    else if (mode === 'old') arr.sort((a,b)=>a.t-b.t);
    else if (mode === 'pos') arr.sort((a,b)=>computePos(a)-computePos(b));

    const ul = document.createElement('ul');
    ul.className = 'comment-list';
    ul.style.listStyle = 'none'; ul.style.padding = '0'; ul.style.margin = '0';

    arr.forEach(rec => {
      const li = document.createElement('li');
      li.dataset.id = rec.id;
      li.className = 'comment-item';
      li.style.cssText = 'margin:12px 0; padding:10px; background:#fff; border-radius:6px; border-left:3px solid #6c757d; box-shadow:0 1px 3px rgba(0,0,0,0.08); position:relative;';
      const meta = document.createElement('div');
      meta.className = 'comment-meta';
      meta.style.cssText = 'font-size:12px; color:#6c757d; margin-bottom:6px; display:flex; gap:8px; align-items:center;';
      const time = fmtMMDDHHmm(rec.t);
      const move = document.createElement('a');
      move.href = '#'; move.textContent = '移動';
      move.addEventListener('click', (e) => { e.preventDefault(); scrollToComment(rec); });
      const menuBtn = document.createElement('button');
      menuBtn.textContent = '⋯';
      menuBtn.setAttribute('aria-label','メニュー');
      menuBtn.style.cssText = 'margin-left:auto;background:none;border:none;cursor:pointer;font-size:18px;line-height:1;';
      menuBtn.addEventListener('click', (e) => { e.stopPropagation(); openCommentMenu(li, rec, {x:e.clientX,y:e.clientY}); });
      meta.innerHTML = `<span>${time}</span>`;
      meta.appendChild(move);
      meta.appendChild(menuBtn);

      const target = document.createElement('div');
      target.className = 'comment-snippet';
      target.style.cssText = 'font-size:13px; color:#495057; background:#f8f9fa; padding:6px 8px; border-radius:4px; margin-bottom:6px;';
      target.textContent = rec.text || '';
      const body = document.createElement('div');
      body.className = 'comment-body';
      body.style.cssText = 'white-space:pre-wrap; line-height:1.5;';
      body.textContent = rec.body || '';
      li.appendChild(meta); li.appendChild(target); li.appendChild(body);
      ul.appendChild(li);
    });

    commHost.appendChild(ul);
    setupScrollSyncForComments(commHost, arr);
  }

  let commentMenuCleanup = null;

  function openCommentMenu(li, rec, pt) {
    closeAnyInlineMenu();
    const menu = document.createElement('div');
    menu.className = 'comment-menu-popup';
    menu.style.cssText = 'position:fixed; background:#fff; border:1px solid #e1e5eb; box-shadow:0 4px 12px rgba(0,0,0,0.12); border-radius:6px; z-index:10001; padding:6px;';
    menu.innerHTML = '<button type="button" data-act="edit" style="display:block;width:100%;text-align:left;padding:6px 10px;background:none;border:none;cursor:pointer;">編集</button>\n<button type="button" data-act="del" style="display:block;width:100%;text-align:left;padding:6px 10px;background:none;border:none;cursor:pointer;">削除</button>';
    document.body.appendChild(menu);
    const x = pt?.x || (li.getBoundingClientRect().right - 10);
    const y = pt?.y || (li.getBoundingClientRect().top + 20);
    menu.style.left = x + 'px';
    menu.style.top = y + 'px';
    const onDoc = (e)=>{ if (!menu.contains(e.target)) { closeAnyInlineMenu(); } };
    const onViewportChange = () => closeAnyInlineMenu();
    document.addEventListener('mousedown', onDoc, true);
    window.addEventListener('scroll', onViewportChange, true);
    window.addEventListener('resize', onViewportChange);
    commentMenuCleanup = () => {
      document.removeEventListener('mousedown', onDoc, true);
      window.removeEventListener('scroll', onViewportChange, true);
      window.removeEventListener('resize', onViewportChange);
      commentMenuCleanup = null;
    };
    menu.addEventListener('click', (e) => {
      const act = e.target?.getAttribute('data-act');
      if (act === 'edit') editComment(rec);
      if (act === 'del') deleteComment(rec);
      closeAnyInlineMenu();
    });
  }

  function closeAnyInlineMenu(){
    document.querySelectorAll('.comment-menu-popup').forEach(n=>n.remove());
    if (typeof commentMenuCleanup === 'function') {
      commentMenuCleanup();
    }
  }

  function editComment(rec) {
    const overlay = document.createElement('div');
    overlay.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.4);z-index:10000;display:flex;align-items:center;justify-content:center;';
    const dialog = document.createElement('div');
    dialog.style.cssText = 'background:#fff;color:#222;max-width:600px;width:92%;padding:16px;border-radius:8px;box-shadow:0 10px 30px rgba(0,0,0,0.25);';
    dialog.innerHTML = `
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
        <h3 style="margin:0;font-size:16px;">コメント編集</h3>
        <button type=\"button\" aria-label=\"閉じる\" style=\"background:none;border:none;font-size:18px;cursor:pointer;\">×</button>
      </div>
      <div style="font-size:13px;color:#555;background:#f8f9fa;border:1px solid #e9ecef;padding:8px;border-radius:4px;margin-bottom:8px;">対象: ${(rec.text||'').slice(0,140)}</div>
      <textarea id="comment-edit-area" rows="6" style="width:100%;font-size:14px;padding:8px;border-radius:6px;border:1px solid #ced4da;resize:vertical;">${(rec.body||'')}</textarea>
      <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:10px;">
        <button type="button" id="comment-edit-cancel" style="padding:6px 12px;border:1px solid #dee2e6;border-radius:4px;background:#f8f9fa;cursor:pointer;">キャンセル</button>
        <button type="button" id="comment-edit-save" style="padding:6px 12px;border:1px solid #0d6efd;border-radius:4px;background:#0d6efd;color:#fff;cursor:pointer;">保存</button>
      </div>
    `;
    overlay.appendChild(dialog);
    document.body.appendChild(overlay);
    const close = ()=>{
      overlay.remove();
      document.removeEventListener('keydown', onKey);
    };
    const onKey = (evt) => {
      if (evt.key === 'Escape') {
        evt.preventDefault();
        close();
      }
    };
    dialog.querySelector('[aria-label="閉じる"]').addEventListener('click', close);
    dialog.querySelector('#comment-edit-cancel').addEventListener('click', close);
    overlay.addEventListener('click', (evt) => {
      if (evt.target === overlay) {
        close();
      }
    });
    document.addEventListener('keydown', onKey);
    const editTextarea = dialog.querySelector('#comment-edit-area');
    const editSaveBtn = dialog.querySelector('#comment-edit-save');
    editSaveBtn.addEventListener('click', () => {
      if (editSaveBtn.disabled) return;
      const v = (editTextarea.value||'').trim();
      if (!v) { editTextarea.focus(); return; }
      editSaveBtn.disabled = true;
      const originalLabel = editSaveBtn.textContent;
      editSaveBtn.textContent = '保存中…';
      let success = false;
      try {
        const key = pageKey();
        const arr = COMMENTS_DB[key]||[];
        const idx = arr.findIndex(x=>x.id===rec.id);
        if (idx>=0) {
          arr[idx].body = v;
          arr[idx].t = Date.now();
          COMMENTS_DB[key]=arr;
          saveComments();
          refreshRightPanels();
          refreshCommentMarkersFromDB();
        }
        success = true;
      } catch (error) {
        console.warn('Failed to update comment', error);
      }
      if (success) {
        Promise.resolve().then(() => {
          closeAnyInlineMenu();
          close();
        });
      } else {
        editSaveBtn.disabled = false;
        editSaveBtn.textContent = originalLabel;
      }
    });
  }

  function deleteComment(rec) {
    closeAnyInlineMenu();
    if (!confirm('このコメントを削除しますか？')) return;
    const key = pageKey();
    const arr = COMMENTS_DB[key]||[];
    COMMENTS_DB[key] = arr.filter(x=>x.id!==rec.id);
    saveComments();
    // マーカーも削除
    document.querySelectorAll(`.text-marker[data-comment-id="${rec.id}"]`).forEach(el => {
      const p = el.parentNode; while (el.firstChild) p.insertBefore(el.firstChild, el); p.removeChild(el);
    });
    refreshCommentMarkersFromDB();
    refreshRightPanels();
  }

  function setupScrollSyncForComments(host, items) {
    const mode = localStorage.getItem('comments-sort') || 'new';
    if (mode !== 'pos') return;
    if (!Array.isArray(items) || !items.length) return;
    const positions = items
      .map(rec => {
        const el = findCommentAnchorElement(rec);
        if (!el) return null;
        const rect = el.getBoundingClientRect();
        return rect ? (rect.top + window.scrollY) : null;
      })
      .filter(p => typeof p === 'number' && isFinite(p));
    if (!positions.length) return;

    const onScroll = () => {
      const ratio = computeScrollRatioFromPositions(positions);
      scrollRightSidebarToRatio(ratio, host);
    };
    window.addEventListener('scroll', onScroll, { passive: true });
  }

  function scrollToComment(rec) {
    try {
      const first = (rec.ranges && rec.ranges[0]);
      if (!first) return;
      const node = getNodeByPathSafe(first.s);
      if (!node) return;
      let el = node.nodeType === Node.ELEMENT_NODE ? node : node.parentElement;
      while (el && el !== document.body && !(el instanceof HTMLElement)) el = el.parentElement;
      if (!el) return;
      el.scrollIntoView({ behavior: 'smooth', block: 'center' });
      const prev = el.style.boxShadow;
      el.style.transition = 'box-shadow 0.3s ease';
      el.style.boxShadow = '0 0 0 3px rgba(26,115,232,0.5)';
      setTimeout(() => { el.style.boxShadow = prev || ''; }, 1600);
    } catch (e) { console.warn('scrollToComment failed', e); }
  }

  function getNodeByPathSafe(path) {
    try { let n=document.body; for (const idx of path||[]) { if (!n || !n.childNodes[idx]) return null; n = n.childNodes[idx]; } return n; } catch { return null; }
  }

  function renderInlineFootnotes() {
    setInlineFootnoteMode(true);
    const marginSidebar = document.getElementById('quarto-margin-sidebar');
    if (marginSidebar && marginSidebar.style.display !== 'none') {
      marginSidebar.dataset.prevDisplay = marginSidebar.style.display || '';
      marginSidebar.style.display = 'none';
    }
    document.querySelectorAll('.footnote-inline').forEach(n => n.remove());
    const active = getActiveChapterSection();
    const scope = active || document;
    const refSelector = 'a[role="doc-noteref"], a.footnote-ref';
    const refs = Array.from(scope.querySelectorAll(refSelector)).filter(ref => !active || active.contains(ref));
    if (!refs.length) return false;
    const hostTailMap = new Map();
    let inserted = false;
    refs.forEach(ref => {
      const href = ref.getAttribute('href') || ref.getAttribute('data-footnote-href');
      if (!href || !href.startsWith('#')) return;
      const id = href.slice(1);
      const target = document.getElementById(id);
      if (!target) return;
      if (active) {
        const section = target.closest('section.chapter-page');
        if (section && section !== active) return;
      }
      const numberText = (ref.textContent || '').replace(/[^0-9]/g, '') || '';
      const host = findHostParagraph(ref);
      if (!host) return;
      const clone = target.cloneNode(true);
      clone.querySelectorAll('.footnote-back, .footnote-backref, [role="doc-backlink"]').forEach(a => a.remove());
      const container = document.createElement('div');
      container.className = 'footnote-inline';
      const numSpan = document.createElement('span');
      numSpan.className = 'footnote-num';
      numSpan.textContent = (numberText ? numberText : '') + '. ';
      container.appendChild(numSpan);
      while (clone.firstChild) container.appendChild(clone.firstChild);
      const tail = hostTailMap.get(host);
      if (tail && tail.parentNode) {
        tail.insertAdjacentElement('afterend', container);
      } else {
        host.insertAdjacentElement('afterend', container);
      }
      hostTailMap.set(host, container);
      reinforceAnchors(container);
      inserted = true;
    });
    ensureCommentMarkerInteractions();
    scheduleScrollExtensionUpdate();
    return inserted;
  }

  function findHostParagraph(el) {
    let p = el;
    while (p && p !== document.body) {
      if (p.tagName === 'P' || p.tagName === 'LI') return p;
      p = p.parentElement;
    }
    return null;
  }

  function debounce(fn, ms) {
    let t;
    return (...args) => { clearTimeout(t); t = setTimeout(() => fn.apply(this, args), ms); };
  }

function setupMarkerFunctionality() {
    let markersDB = JSON.parse(localStorage.getItem(STORAGE_KEYS.markers) || '{}');
    let pendingSerializedRange = null;

    const handleSelectionEvent = (e) => {
      if (closestInteractive(e.target)) return;
      const sel = window.getSelection();
      if (!sel || sel.rangeCount === 0) {
        hideMarkerToolbar();
        pendingSerializedRange = null;
        return;
}

  function getHeadingElements() {
    const scope = document.getElementById('quarto-document-content');
    if (!scope) return [];
    return scope.querySelectorAll('h1, h2, h3, h4, h5, h6');
  }

  function enumerateReadingNodes() {}

  function findReadableElement(node) {
    const scope = document.getElementById('quarto-document-content');
    if (!scope) return null;
    let current = node;
    while (current && current !== document.body) {
      if (current.tagName) {
        const tag = current.tagName.toLowerCase();
        if (['p','li','blockquote','pre','table','figure','dd','dt'].includes(tag)) {
          return current;
        }
      }
      current = current.parentElement;
    }
    return null;
  }

  function captureReadingState(options) {
    const opts = options || {};
    const headings = getHeadingElements();
    const docEl = document.documentElement;
    const body = document.body;
    const scrollTop = (docEl && docEl.scrollTop) || (body && body.scrollTop) || 0;
    const viewportHeight = window.innerHeight || docEl.clientHeight || 0;
    const viewportWidth = window.innerWidth || docEl.clientWidth || body.clientWidth || 0;
    const focusLine = scrollTop + viewportHeight * 0.35;
    let current = null;
    for (let i = 0; i < headings.length; i += 1) {
      const el = headings[i];
      const top = el.offsetTop;
      if (top <= focusLine) {
        current = el;
      } else {
        break;
      }
    }
    if (!current && headings.length) {
      current = headings[0];
    }
    const pageHeight = Math.max(1, (docEl && docEl.scrollHeight) || (body && body.scrollHeight) || 1) - viewportHeight;
    const pageRatio = pageHeight > 0 ? scrollTop / pageHeight : 0;
    const state = { pageRatio };
    const centerX = viewportWidth / 2;
    let focusNode = null;
    try {
      focusNode = document.elementFromPoint(centerX, viewportHeight * 0.4);
    } catch (e) {
      focusNode = null;
    }
    if (current) {
      const currentId = current.getAttribute('id') || current.getAttribute('data-anchor-id') || '';
      const next = current.nextElementSibling ? current.nextElementSibling.closest('h1, h2, h3, h4, h5, h6') : null;
      let nextTop = null;
      if (next) {
        nextTop = next.offsetTop;
      } else {
        nextTop = (docEl && docEl.scrollHeight) || (body && body.scrollHeight) || (current.offsetTop + viewportHeight);
      }
      const currentTop = current.offsetTop;
      const sectionHeight = Math.max(1, nextTop - currentTop);
      const rel = (focusLine - currentTop) / sectionHeight;
      if (currentId) {
        state.sectionId = currentId;
        state.sectionOffset = Math.min(0.995, Math.max(0, rel));
      }
    }
    const focusElement = findReadableElement(focusNode);
    if (focusElement) {
      const rect = focusElement.getBoundingClientRect();
      const elementHeight = Math.max(1, rect.height || focusElement.offsetHeight || 1);
      const elementTop = focusElement.offsetTop;
      const relInElement = Math.min(0.995, Math.max(0, (focusLine - elementTop) / elementHeight));
      state.focusElementOffset = relInElement;
      const id = focusElement.getAttribute('id') || focusElement.getAttribute('data-anchor-id') || '';
      if (id) state.focusElementId = id;
      if (opts.captureNodeRef) {
        state.__focusNode = focusElement;
      }
    }
    return state;
  }

  function scrollToReadingState(state) {
    if (!state) return false;
    const docEl = document.documentElement;
    const body = document.body;
    const viewportHeight = window.innerHeight || docEl.clientHeight || 0;
    const focusRatio = typeof state.focusElementOffset === 'number' ? state.focusElementOffset : null;
    const resolveFocusTarget = () => {
      if (state.__focusNode && state.__focusNode instanceof HTMLElement && document.body.contains(state.__focusNode)) {
        return state.__focusNode;
      }
      if (state.focusElementId) {
        return document.getElementById(state.focusElementId) || document.querySelector(`[data-anchor-id="${state.focusElementId}"]`);
      }
      return null;
    };
    const focusTarget = resolveFocusTarget();
    if (focusTarget) {
      const ratio = focusRatio != null ? focusRatio : 0.35;
      const targetTop = focusTarget.offsetTop + ratio * Math.max(1, focusTarget.offsetHeight || 1);
      const desired = targetTop - viewportHeight * 0.35;
      window.scrollTo({ top: Math.max(0, desired), behavior: 'auto' });
      return true;
    }
    if (state.sectionId) {
      const selector = `#${escapeCssId(state.sectionId)}`;
      let target = document.querySelector(selector);
      if (!target) {
        target = document.querySelector(`[data-anchor-id="${state.sectionId}"]`);
      }
      if (target) {
        const headings = Array.from(getHeadingElements());
        const idx = headings.indexOf(target);
        let nextTop = null;
        if (idx >= 0 && idx + 1 < headings.length) {
          nextTop = headings[idx + 1].offsetTop;
        } else {
          nextTop = (docEl && docEl.scrollHeight) || (body && body.scrollHeight) || (target.offsetTop + viewportHeight);
        }
        const currentTop = target.offsetTop;
        const sectionHeight = Math.max(1, nextTop - currentTop);
        const rel = typeof state.sectionOffset === 'number' ? state.sectionOffset : 0;
        const dest = currentTop + rel * sectionHeight;
        window.scrollTo({ top: Math.max(0, dest), behavior: 'auto' });
        return true;
      }
    }
    if (typeof state.pageRatio === 'number') {
      const docHeight = Math.max(1, ((docEl && docEl.scrollHeight) || (body && body.scrollHeight) || 1) - viewportHeight);
      const targetY = state.pageRatio * docHeight;
      window.scrollTo({ top: Math.max(0, targetY), behavior: 'auto' });
      return true;
    }
    return false;
  }

  function escapeCssId(id) {
    if (window.CSS && typeof window.CSS.escape === 'function') {
      return window.CSS.escape(id);
    }
    return id.replace(/[^a-zA-Z0-9_\-]/g, '\\$&');
  }

  function restoreReadingState() {
    let raw = null;
    try {
      raw = sessionStorage.getItem(STORAGE_KEYS.readingState);
    } catch (e) {
      raw = null;
    }
    if (!raw) return;
    let state = null;
    try {
      state = JSON.parse(raw);
    } catch (e) {
      state = null;
    }
    scrollToReadingState(state);
  }

  function persistReadingState() {
    let state = null;
    try {
      state = captureReadingState();
    } catch (e) {
      state = null;
    }
    if (!state) return;
    try {
      sessionStorage.setItem(STORAGE_KEYS.readingState, JSON.stringify(state));
    } catch (e) {
      // ignore
    }
  }

  function scheduleReadingStateSave() {
    if (readingStateSaveTimer) return;
    readingStateSaveTimer = window.setTimeout(() => {
      readingStateSaveTimer = null;
      persistReadingState();
    }, 500);
  }
      const text = sel.toString().trim();
      if (text) {
        const rect = getSelectionRect(sel);
        const fallbackPoint = { x: e.clientX, y: e.clientY };
        try {
          pendingSerializedRange = serializeRange(sel.getRangeAt(0));
        } catch {
          pendingSerializedRange = null;
        }
        showMarkerToolbar(rect, fallbackPoint);
      } else {
        hideMarkerToolbar();
        pendingSerializedRange = null;
      }
    };

    // テキスト選択でツールバーを表示（UI要素上は無効）
    document.addEventListener('mouseup', handleSelectionEvent);
    document.addEventListener('touchend', handleSelectionEvent);

    function closestInteractive(el){
      return el.closest('.marker-toolbar, .js-header, .global-search-dialog, #quarto-sidebar');
    }

    function getSelectionRect(selection) {
      if (!selection || selection.rangeCount === 0) return null;
      try {
        const range = selection.getRangeAt(0).cloneRange();
        const rect = range.getBoundingClientRect();
        if (rect && (rect.width || rect.height)) return rect;
        const rects = range.getClientRects();
        for (const r of rects) {
          if (r.width || r.height) return r;
        }
      } catch (err) {
        console.warn('getSelectionRect failed', err);
      }
      const focusContainer = selection.focusNode instanceof Element ? selection.focusNode : selection.focusNode?.parentElement;
      return focusContainer ? focusContainer.getBoundingClientRect() : null;
    }

    function showMarkerToolbar(rect, fallbackPoint) {
      let toolbar = document.querySelector('.marker-toolbar');
      if (!toolbar) {
        toolbar = createMarkerToolbar();
        document.body.appendChild(toolbar);
      }
      toolbar.classList.add('show');
      toolbar.style.display = 'flex';
      toolbar.style.flexDirection = 'column';
      toolbar.style.gap = '6px';
      toolbar.style.position = 'absolute';
      toolbar.style.removeProperty('right');
      toolbar.style.removeProperty('bottom');
      positionMarkerToolbar(toolbar, rect, fallbackPoint);
    }

    function positionMarkerToolbar(toolbar, rect, fallbackPoint) {
      requestAnimationFrame(() => {
        if (!toolbar.classList.contains('show')) return;
        let targetRect = rect;
        if (!targetRect || (!(targetRect.width || targetRect.height))) {
          if (fallbackPoint && typeof fallbackPoint.x === 'number' && typeof fallbackPoint.y === 'number') {
            targetRect = {
              top: fallbackPoint.y,
              bottom: fallbackPoint.y,
              left: fallbackPoint.x,
              right: fallbackPoint.x,
              width: 0,
              height: 0
            };
          } else {
            const vw = window.innerWidth || document.documentElement.clientWidth || 0;
            const vh = window.innerHeight || document.documentElement.clientHeight || 0;
            targetRect = {
              top: vh / 2,
              bottom: vh / 2,
              left: vw / 2,
              right: vw / 2,
              width: 0,
              height: 0
            };
          }
        }
        const scrollX = window.scrollX ?? window.pageXOffset ?? document.documentElement.scrollLeft ?? 0;
        const scrollY = window.scrollY ?? window.pageYOffset ?? document.documentElement.scrollTop ?? 0;
        const toolbarWidth = toolbar.offsetWidth;
        const toolbarHeight = toolbar.offsetHeight;
        const margin = 12;
        const viewportWidth = document.documentElement.clientWidth || window.innerWidth || toolbarWidth;
        const rectWidth = targetRect.width ?? (targetRect.right - targetRect.left) ?? 0;
        const rectCenterX = targetRect.left + rectWidth / 2;
        let left = scrollX + rectCenterX - toolbarWidth / 2;
        left = Math.max(scrollX + 8, Math.min(left, scrollX + viewportWidth - toolbarWidth - 8));
        const rectBottom = targetRect.bottom ?? (targetRect.top + targetRect.height) ?? targetRect.top;
        let top = scrollY + targetRect.top - toolbarHeight - margin;
        if (top < scrollY + 8) {
          top = scrollY + rectBottom + margin;
        }
        const viewportHeight = document.documentElement.clientHeight || window.innerHeight || toolbarHeight;
        const maxTop = scrollY + viewportHeight - toolbarHeight - 8;
        top = Math.min(top, maxTop);
        toolbar.style.left = `${Math.round(left)}px`;
        toolbar.style.top = `${Math.round(top)}px`;
      });
    }

    function createMarkerToolbar() {
      const toolbar = document.createElement('div');
      toolbar.className = 'marker-toolbar';
      toolbar.innerHTML = `
        <div class="marker-controls" role="toolbar" aria-label="ハイライト色選択">
          <div class="marker-colors">
            <button type="button" class="marker-color-btn" data-color="yellow" title="黄"></button>
            <button type="button" class="marker-color-btn" data-color="green" title="緑"></button>
            <button type="button" class="marker-color-btn" data-color="blue" title="青"></button>
            <button type="button" class="marker-color-btn" data-color="pink" title="ピンク"></button>
          </div>
          <button type="button" class="marker-comment-btn" title="選択範囲にコメント" aria-label="選択範囲にコメント">コメント</button>
        </div>
      `;
      toolbar.querySelectorAll('.marker-color-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          applyMarker(btn.dataset.color);
          hideMarkerToolbar();
        });
      });
      const commentBtn = toolbar.querySelector('.marker-comment-btn');
      if (commentBtn) {
        commentBtn.addEventListener('click', () => {
          openCommentDialog();
        });
      }
      return toolbar;
    }

    function openCommentDialog() {
      const selection = window.getSelection();
      let baseRange = null;
      if (selection && selection.rangeCount > 0 && selection.toString().trim()) {
        baseRange = selection.getRangeAt(0);
      } else if (pendingSerializedRange) {
        baseRange = deserializeRange(pendingSerializedRange);
      }
      if (!baseRange || baseRange.collapsed) return;

      const overlay = document.createElement('div');
      overlay.className = 'comment-dialog-overlay';
      const dialog = document.createElement('div');
      dialog.className = 'comment-dialog';
      dialog.innerHTML = `
        <div class="comment-dialog__header">
          <h3 class="comment-dialog__title">コメントを追加</h3>
          <button type="button" aria-label="閉じる" class="comment-dialog__close">×</button>
        </div>
        <div class="comment-dialog__snippet" id="comment-snippet"></div>
        <textarea id="comment-textarea" rows="6" class="comment-dialog__textarea" placeholder="ここにコメントを入力（長文可）"></textarea>
        <div class="comment-dialog__actions">
          <button type="button" id="comment-cancel" class="comment-dialog__btn comment-dialog__btn--muted">キャンセル</button>
          <button type="button" id="comment-save" class="comment-dialog__btn comment-dialog__btn--primary">保存</button>
        </div>
      `;
      overlay.appendChild(dialog);
      document.body.appendChild(overlay);

      const close = () => overlay.remove();
      dialog.querySelector('button[aria-label="閉じる"]').addEventListener('click', close);
      dialog.querySelector('#comment-cancel').addEventListener('click', close);

      // 選択スニペット表示
      const snippet = baseRange.cloneContents().textContent || window.getSelection().toString();
      dialog.querySelector('#comment-snippet').textContent = `対象: ${snippet?.slice(0,140) || ''}`;

      const saveBtn = dialog.querySelector('#comment-save');
      const commentTextarea = dialog.querySelector('#comment-textarea');
      const originalLabel = saveBtn.textContent;
      saveBtn.addEventListener('click', () => {
        if (saveBtn.disabled) return;
        const body = (commentTextarea.value || '').trim();
        if (!body) { commentTextarea.focus(); return; }
        const segs = getTextSegments(baseRange);
        if (!segs.length) { close(); return; }
        saveBtn.disabled = true;
        saveBtn.textContent = '保存中…';
        let saved = false;
        try {
          const serializedRanges = segs.map(seg => ({ s: getPath(seg.node), so: seg.start, e: getPath(seg.node), eo: seg.end }));
          const rec = { id: `comment-${Date.now()}-${Math.floor(Math.random()*1000)}`, ranges: serializedRanges, text: snippet, body, t: Date.now(), slug: getCurrentChapterSlug() || null };
          const key = pageKey();
          if (!COMMENTS_DB[key]) COMMENTS_DB[key] = [];
          COMMENTS_DB[key].push(rec);
          saveComments();
          saved = true;
          segs.forEach(seg => {
            const span = document.createElement('span');
            span.className = 'text-marker marker-orange';
            span.setAttribute('data-comment-id', rec.id);
            applyColorStyles(span, 'orange');
            wrapBySplitText(seg.node, seg.start, seg.end, span);
          });
          ensureCommentMarkerInteractions();
          try {
            refreshRightPanels();
          } catch (panelError) {
            console.warn('Refresh right panels failed after comment', panelError);
          }
          hideMarkerToolbar();
          const selection = window.getSelection();
          if (selection && typeof selection.removeAllRanges === 'function') {
            selection.removeAllRanges();
          }
          pendingSerializedRange = null;
        } catch (error) {
          console.warn('Failed to save comment', error);
          saveBtn.disabled = false;
          saveBtn.textContent = originalLabel;
          return;
        }
        close();
      });
    }

    function applyMarker(color) {
      const selection = window.getSelection();
      let baseRange = null;
      if (selection && selection.rangeCount > 0 && selection.toString().trim()) {
        baseRange = selection.getRangeAt(0);
      } else if (pendingSerializedRange) {
        baseRange = deserializeRange(pendingSerializedRange);
      }
      if (!baseRange || baseRange.collapsed) return;

      const markerId = `marker-${Date.now()}-${Math.floor(Math.random()*1000)}`;
      const segments = getTextSegments(baseRange);
      if (!segments.length) return;

      const serializedRanges = [];
      segments.forEach(seg => {
        // 分割済みサブレンジをスタイル付与
        const span = document.createElement('span');
        span.className = `text-marker marker-${color}`;
        span.setAttribute('data-marker-id', markerId);
        applyColorStyles(span, color);
        span.addEventListener('dblclick', () => removeMarkerGroup(markerId));
        span.addEventListener('contextmenu', (e) => { e.preventDefault(); cycleMarkerColorGroup(markerId); });

        // 信頼性の高いsplitTextベースのラップ（file://でも安定）
        const serialized = { s: getPath(seg.node), so: seg.start, e: getPath(seg.node), eo: seg.end };
        wrapBySplitText(seg.node, seg.start, seg.end, span);
        serializedRanges.push(serialized);
      });

      selection.removeAllRanges();

      const page = window.location.pathname;
      if (!markersDB[page]) markersDB[page] = [];
      markersDB[page].push({ id: markerId, color, ranges: serializedRanges, t: Date.now() });
      saveMarkers();
      pendingSerializedRange = null;
    }

    // 選択範囲に交差するテキストノードをサブレンジに分割
    function getTextSegments(range) {
      const segments = [];

      // ルートがテキストノードの場合を考慮
      if (range.commonAncestorContainer && range.commonAncestorContainer.nodeType === Node.TEXT_NODE) {
        const node = range.commonAncestorContainer;
        const start = (node === range.startContainer) ? range.startOffset : 0;
        const end = (node === range.endContainer) ? range.endOffset : (node.nodeValue || '').length;
        if (start !== end) segments.push({ node, start, end });
        return segments;
      }

      const walker = document.createTreeWalker(
        range.commonAncestorContainer,
        NodeFilter.SHOW_TEXT,
        {
          acceptNode: (node) => {
            try {
              return range.intersectsNode(node) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;
            } catch (e) {
              // フォールバック: compareBoundaryPoints
              if (!node.nodeValue) return NodeFilter.FILTER_REJECT;
              const r = document.createRange();
              r.selectNodeContents(node);
              const endVsStart = range.compareBoundaryPoints(Range.END_TO_START, r);
              if (endVsStart <= 0) return NodeFilter.FILTER_REJECT;
              const startVsEnd = range.compareBoundaryPoints(Range.START_TO_END, r);
              if (startVsEnd >= 0) return NodeFilter.FILTER_REJECT;
              return NodeFilter.FILTER_ACCEPT;
            }
          }
        }
      );

      let node;
      while ((node = walker.nextNode())) {
        let start = 0;
        let end = node.nodeValue.length;
        if (node === range.startContainer && range.startContainer.nodeType === Node.TEXT_NODE) start = range.startOffset;
        if (node === range.endContainer && range.endContainer.nodeType === Node.TEXT_NODE) end = range.endOffset;
        if (start !== end) segments.push({ node, start, end });
      }
      return segments;
    }

    function hideMarkerToolbar() {
      const toolbar = document.querySelector('.marker-toolbar');
      if (toolbar) {
        toolbar.classList.remove('show');
        toolbar.style.display = 'none';
      }
    }

    function removeMarkerGroup(markerId) {
      document.querySelectorAll(`.text-marker[data-marker-id="${markerId}"]`).forEach(el => {
        const parent = el.parentNode;
        while (el.firstChild) parent.insertBefore(el.firstChild, el);
        parent.removeChild(el);
      });
      const page = window.location.pathname;
      if (markersDB[page]) {
        markersDB[page] = markersDB[page].filter(m => m.id !== markerId);
        if (!markersDB[page].length) delete markersDB[page];
        saveMarkers();
      }
    }

    function clearAllMarkers() {
      document.querySelectorAll('.text-marker').forEach(n => {
        const parent = n.parentNode;
        while (n.firstChild) parent.insertBefore(n.firstChild, n);
        parent.removeChild(n);
      });
      delete markersDB[window.location.pathname];
      saveMarkers();
    }

    function cycleMarkerColorGroup(markerId) {
      const order = ['yellow','green','blue','pink'];
      const els = Array.from(document.querySelectorAll(`.text-marker[data-marker-id="${markerId}"]`));
      if (!els.length) return;
      const el = els[0];
      const current = order.find(c => el.classList.contains(`marker-${c}`)) || 'yellow';
      const next = order[(order.indexOf(current)+1)%order.length];
      els.forEach(e => { order.forEach(c => e.classList.remove(`marker-${c}`)); e.classList.add(`marker-${next}`); applyColorStyles(e, next); });
      const page = window.location.pathname;
      const rec = (markersDB[page]||[]).find(m => m.id === markerId);
      if (rec) { rec.color = next; saveMarkers(); }
    }

    function saveMarkers(){ localStorage.setItem(STORAGE_KEYS.markers, JSON.stringify(markersDB)); }

    function restoreMarkers() {
      const page = window.location.pathname;
      const list = (markersDB[page] || []);
      list.forEach(m => {
        // 互換性: 古い形式 {range} を {ranges:[range]} に変換
        const ranges = m.ranges || (m.range ? [m.range] : []);
        ranges.forEach(rSerialized => {
        const tn = getNodeByPath(rSerialized.s);
        if (!tn || tn.nodeType !== Node.TEXT_NODE) return;
        const span = document.createElement('span');
        span.className = `text-marker marker-${m.color}`;
        span.setAttribute('data-marker-id', m.id);
        applyColorStyles(span, m.color);
        span.addEventListener('dblclick', () => removeMarkerGroup(m.id));
        span.addEventListener('contextmenu', (e) => { e.preventDefault(); cycleMarkerColorGroup(m.id); });
        wrapBySplitText(tn, rSerialized.so, rSerialized.eo, span);
        });
      });
    }

    function restoreCommentMarkers() {
      try {
        const list = (COMMENTS_DB[pageKey()] || []);
        list.forEach(rec => {
          (rec.ranges || []).forEach(r => {
            if (!r || typeof r.so !== 'number' || typeof r.eo !== 'number' || r.so === r.eo) return;
            const tn = getNodeByPath(r.s);
            if (!tn || tn.nodeType !== Node.TEXT_NODE) return;
            const span = document.createElement('span');
            span.className = 'text-marker marker-orange';
            span.setAttribute('data-comment-id', rec.id);
            applyColorStyles(span, 'orange');
            wrapBySplitText(tn, r.so, r.eo, span);
          });
        });
      } catch (e) {
        console.warn('restoreCommentMarkers failed', e);
      }
    }

    cleanupCommentMarkersDom = function() {
      document.querySelectorAll('.text-marker[data-comment-id]').forEach(span => {
        const parent = span.parentNode;
        if (!parent) return;
        while (span.firstChild) parent.insertBefore(span.firstChild, span);
        parent.removeChild(span);
      });
    };

    refreshCommentMarkersFromDB = function(options) {
      const preserveExisting = !!(options && options.preserveExisting);
      const existingCount = document.querySelectorAll('.text-marker[data-comment-id]').length;
      if (preserveExisting && existingCount > 0) {
        ensureCommentMarkerInteractions();
        return;
      }
      cleanupCommentMarkersDom();
      restoreCommentMarkers();
      ensureCommentMarkerInteractions();
    };

    // 既存マーカー / コメントマーカー再描画
    restoreMarkers();
    refreshCommentMarkersFromDB();

    // 範囲のシリアライズ/デシリアライズ
    function serializeRange(range) {
      return {
        s: getPath(range.startContainer), so: range.startOffset,
        e: getPath(range.endContainer), eo: range.endOffset
      };
    }
    function deserializeRange(obj) {
      try {
        const sc = getNodeByPath(obj.s);
        const ec = getNodeByPath(obj.e);
        if (!sc || !ec) return null;
        const r = document.createRange();
        r.setStart(sc, Math.min(obj.so, nodeMaxOffset(sc)));
        r.setEnd(ec, Math.min(obj.eo, nodeMaxOffset(ec)));
        return r;
      } catch { return null; }
    }
    function nodeIndex(node){ let i=0; while(node && node.previousSibling){ node = node.previousSibling; i++; } return i; }
    function getPath(node){ const p=[]; let n=node; while(n && n !== document.body){ p.push(nodeIndex(n)); n = n.parentNode; } return p.reverse(); }
    function getNodeByPath(path){ let n=document.body; for(const idx of path){ if(!n || !n.childNodes[idx]) return null; n = n.childNodes[idx]; } return n; }
    function nodeMaxOffset(n){ return n.nodeType===Node.TEXT_NODE ? (n.nodeValue||'').length : (n.childNodes?n.childNodes.length:0); }

    function wrapBySplitText(textNode, start, end, wrapper) {
      try {
        let mid = textNode;
        if (start > 0) mid = textNode.splitText(start);
        let tail = mid;
        const len = end - start;
        if (len < mid.nodeValue.length) tail = mid.splitText(len);
        const parent = mid.parentNode;
        parent.insertBefore(wrapper, mid);
        wrapper.appendChild(mid);
      } catch (e) {
        console.warn('wrapBySplitText failed', e);
      }
    }

    function applyColorStyles(el, color) {
      // インラインスタイルで確実に可視化（CSSが読み込めないfile://時の保険）
      const map = {
        yellow: 'rgba(255, 235, 59, 0.6)',
        green:  'rgba(129, 199, 132, 0.5)',
        blue:   'rgba(100, 181, 246, 0.5)',
        pink:   'rgba(244, 143, 177, 0.5)',
        orange: 'rgba(255, 152, 0, 0.45)'
      };
      el.style.backgroundColor = map[color] || 'rgba(255, 235, 59, 0.6)';
      el.style.boxShadow = 'inset 0 -0.15em 0 rgba(0,0,0,0.08)';
    }
  }

  function setupMobileFootnoteToggle() {
    document.querySelectorAll('.footnote-ref').forEach(footnote => {
      footnote.addEventListener('click', (e) => {
        e.preventDefault();
        const footnoteId = footnote.getAttribute('href');
        const footnoteDef = document.querySelector(footnoteId);
        if (footnoteDef) footnoteDef.classList.toggle('expanded');
      });
    });
  }

  function disableDefaultQuartoSearch() {
    try {
      const defaultBtn = document.getElementById('quarto-search');
      if (defaultBtn) defaultBtn.remove();
      const defaultPanel = document.getElementById('quarto-search-results');
      if (defaultPanel) defaultPanel.remove();
      const defaultOptions = document.getElementById('quarto-search-options');
      if (defaultOptions) defaultOptions.remove();
      if (window.Quarto && typeof window.Quarto.doc === 'object') {
        window.Quarto.doc.disableSearch = true;
      }
    } catch (e) {
      console.warn('Failed to disable default Quarto search', e);
    }
  }

  function setupSidebarSearch() {
    const sidebarSearch = document.querySelector('#quarto-sidebar .sidebar-search');
    if (!sidebarSearch) return;

    sidebarSearch.innerHTML = '';
    sidebarSearch.style.display = '';

    const utilityBar = document.createElement('div');
    utilityBar.className = 'sidebar-search-utility';

    const searchButton = document.createElement('button');
    searchButton.type = 'button';
    searchButton.className = 'sidebar-search-button';
    searchButton.setAttribute('aria-label', '検索を開く (Cmd+K)');
    searchButton.title = '検索 (Cmd+K)';

    const searchIcon = document.createElement('img');
    searchIcon.className = 'sidebar-search-button-icon';
    searchIcon.alt = '';
    searchIcon.decoding = 'async';
    searchIcon.loading = 'lazy';
    searchIcon.setAttribute('aria-hidden', 'true');
    searchIcon.src = resolveAssetPath('assets/search.png');

    searchButton.appendChild(searchIcon);
    searchButton.addEventListener('click', () => {
      const handle = openSearchOverlay('');
      if (handle && handle.input) {
        const inputEl = handle.input;
        const end = inputEl.value.length;
        inputEl.focus();
        inputEl.setSelectionRange(end, end);
      }
    });

    utilityBar.appendChild(searchButton);

    // プレビュー・コメント・マーカー一覧を開くボタン（検索アイコンのすぐ右）
    const listButton = document.createElement('button');
    listButton.type = 'button';
    listButton.className = 'sidebar-search-button sidebar-list-button';
    listButton.setAttribute('aria-label', 'プレビュー・コメント一覧を開く');
    listButton.title = 'プレビュー・コメント・マーカー一覧';
    listButton.style.marginLeft = '6px';

    const listIcon = document.createElement('img');
    listIcon.className = 'sidebar-search-button-icon';
    listIcon.alt = '';
    listIcon.decoding = 'async';
    listIcon.loading = 'lazy';
    listIcon.setAttribute('aria-hidden', 'true');
    listIcon.src = resolveAssetPath('assets/list.png');
    listButton.appendChild(listIcon);

    listButton.addEventListener('click', () => {
      openGlobalListOverlay();
    });

    utilityBar.appendChild(listButton);

    const meterWrapper = document.createElement('div');
    meterWrapper.className = 'sidebar-reading-meter';
    meterWrapper.setAttribute('role', 'status');
    meterWrapper.setAttribute('aria-label', '読書メーター');
    meterWrapper.title = '読書メーター';

    const meterValue = document.createElement('span');
    meterValue.className = 'sidebar-reading-meter-value';
    meterValue.textContent = '[0/0]';

    meterWrapper.appendChild(meterValue);
    utilityBar.appendChild(meterWrapper);

    sidebarSearch.appendChild(utilityBar);

    SEARCH_RESULTS_VIEW.sidebarContainer = null;
    SEARCH_RESULTS_VIEW.sidebarSummary = null;
    SEARCH_RESULTS_VIEW.sidebarList = null;
    SEARCH_RESULTS_VIEW.sidebarQuery = null;
    SEARCH_RESULTS_VIEW.sidebarClearBtn = null;

    initializeReadingMeter(meterValue);
    restoreSearchSession();
  }

  const SEARCH_SESSION_KEY = 'quarto-search-session';

  function saveSearchSession(session) {
    try {
      sessionStorage.setItem(SEARCH_SESSION_KEY, JSON.stringify(session));
    } catch (error) {
      console.warn('Search session save failed', error);
    }
  }

  function loadSearchSession() {
    try {
      const raw = sessionStorage.getItem(SEARCH_SESSION_KEY);
      if (!raw) return null;
      return JSON.parse(raw);
    } catch (error) {
      console.warn('Search session load failed', error);
      return null;
    }
  }

  function restoreSearchSession() {
    const session = loadSearchSession();
    if (!session || !Array.isArray(session.results) || !session.results.length) {
      clearSidebarSearchResults();
      return;
    }

    SEARCH_RESULTS_VIEW.sidebarData = session;
    renderSidebarSearchResults(session);

    const currentUrl = new URL(window.location.href, window.location.origin);
    if (session.active) {
      const target = new URL(session.active.url, window.location.href);
      if (target.origin === currentUrl.origin && target.pathname === currentUrl.pathname) {
        requestAnimationFrame(() => {
          clearSearchHighlights();
          scrollToMatchOnPage(session.query, session.active.matchIndex || 0);
        });
      }
    }
  }

  function clearSidebarSearchResults() {
    if (SEARCH_RESULTS_VIEW.sidebarContainer) {
      SEARCH_RESULTS_VIEW.sidebarContainer.classList.add('hidden');
      const empty = SEARCH_RESULTS_VIEW.sidebarContainer.querySelector('.sidebar-search-empty');
      if (empty) empty.classList.remove('hidden');
    }
    if (SEARCH_RESULTS_VIEW.sidebarSummary) {
      SEARCH_RESULTS_VIEW.sidebarSummary.innerHTML = '';
    }
    if (SEARCH_RESULTS_VIEW.sidebarList) {
      SEARCH_RESULTS_VIEW.sidebarList.innerHTML = '';
    }
    if (SEARCH_RESULTS_VIEW.sidebarQuery) {
      SEARCH_RESULTS_VIEW.sidebarQuery.textContent = '';
    }
    SEARCH_RESULTS_VIEW.sidebarData = null;
    clearSearchHighlights();
    try {
      sessionStorage.removeItem(SEARCH_SESSION_KEY);
    } catch (error) {
      console.warn('Failed to clear search session', error);
    }
  }

  function renderSidebarSearchResults(session) {
    const container = SEARCH_RESULTS_VIEW.sidebarContainer;
    if (!container) return;

    SEARCH_RESULTS_VIEW.sidebarData = session;

    const empty = container.querySelector('.sidebar-search-empty');
    const summary = SEARCH_RESULTS_VIEW.sidebarSummary;
    const list = SEARCH_RESULTS_VIEW.sidebarList;
    const queryLabel = SEARCH_RESULTS_VIEW.sidebarQuery;

    if (!session || !Array.isArray(session.results) || !session.results.length) {
      clearSidebarSearchResults();
      return;
    }

    container.classList.remove('hidden');
    if (empty) empty.classList.add('hidden');
    if (queryLabel) {
      queryLabel.textContent = `「${session.query}」`;
    }
    if (summary) {
      const hiddenCount = session.results.reduce((sum, item) => sum + (item.remainingMatches || 0), 0);
      const totalMatches = session.results.length + hiddenCount;
      summary.innerHTML = `<p><strong>${totalMatches}</strong>件の結果（「${escapeHtml(session.query)}」）</p>`;
    }
    if (list) {
      list.innerHTML = '';
      session.results.forEach((result, index) => {
        const itemBtn = document.createElement('button');
        itemBtn.type = 'button';
        itemBtn.className = 'sidebar-search-item';
        if (session.active &&
            session.active.url === result.url &&
            session.active.matchIndex === result.matchIndex) {
          itemBtn.classList.add('active');
        }

        itemBtn.innerHTML = `
          <span class="sidebar-search-item-title">${escapeHtml(result.title || result.url)}</span>
          <span class="sidebar-search-item-order">${result.matchIndex + 1}/${result.totalMatches || result.matchCount || 1}</span>
          <span class="sidebar-search-item-count">${result.totalMatches || result.matchCount || 1}件</span>
          <div class="sidebar-search-item-context">${result.context}</div>
        `;

        itemBtn.addEventListener('click', () => {
          handleSidebarResultSelection(result, index);
        });
        list.appendChild(itemBtn);
      });
    }
  }

  function handleSidebarResultSelection(result, index) {
    if (!SEARCH_RESULTS_VIEW.sidebarData) return;
    const session = SEARCH_RESULTS_VIEW.sidebarData;
    session.active = {
      url: result.url,
      matchIndex: result.matchIndex,
      index
    };
    session.timestamp = Date.now();
    saveSearchSession(session);
    renderSidebarSearchResults(session);
    navigateToSearchResult(result, session.query);
  }

  function handleOverlayResultSelection(result) {
    if (!result) return;
    const activePayload = convertResultToSession(result);
    const session = {
      query: SEARCH_RESULTS_VIEW.query,
      results: convertOverlayResultsForSession(SEARCH_RESULTS_VIEW.results),
      active: {
        url: activePayload.url,
        matchIndex: activePayload.matchIndex || 0
      },
      timestamp: Date.now()
    };
    SEARCH_RESULTS_VIEW.sidebarData = session;
    saveSearchSession(session);
    renderSidebarSearchResults(session);
    if (typeof SEARCH_RESULTS_VIEW.closeOverlay === 'function') {
      SEARCH_RESULTS_VIEW.closeOverlay();
    }
    navigateToSearchResult(activePayload, session.query);
  }

  function resolveResultUrl(url) {
    try {
      const resolved = new URL(url, window.location.href);
      return resolved.href;
    } catch {
      return url;
    }
  }

  function convertOverlayResultsForSession(results) {
    return results.map(convertResultToSession);
  }

  function convertResultToSession(result) {
    const page = result.page || {};
    return {
      url: resolveResultUrl(page.url || result.url || window.location.href),
      title: page.title || result.title || (page.url || 'ページ'),
      chapter: page.chapter || result.chapter || '',
      context: result.context || '',
      matchCount: result.matchCount || 1,
      totalMatches: result.totalMatches || result.matchCount || 1,
      remainingMatches: result.remainingMatches || 0,
      matchIndex: result.matchIndex || 0
    };
  }

  function navigateToSearchResult(result, query) {
    if (!result) return;
    const targetUrl = new URL(result.url, window.location.href);
    const currentUrl = new URL(window.location.href);
    const sameDocument = targetUrl.origin === currentUrl.origin && targetUrl.pathname === currentUrl.pathname;

    if (sameDocument) {
      if (targetUrl.hash && targetUrl.hash !== window.location.hash) {
        window.location.hash = targetUrl.hash;
      }
      requestAnimationFrame(() => {
        if (!scrollToMatchOnPage(query, result.matchIndex || 0) && targetUrl.hash) {
          const targetEl = document.querySelector(targetUrl.hash);
          if (targetEl && typeof targetEl.scrollIntoView === 'function') {
            targetEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
          }
        }
      });
    } else {
      window.location.href = targetUrl.href;
    }
  }

  let activeSearchHighlights = [];

  function clearSearchHighlights() {
    if (!activeSearchHighlights.length) return;
    activeSearchHighlights.forEach(span => {
      try {
        if (!span || !span.parentNode) return;
        const parent = span.parentNode;
        while (span.firstChild) {
          parent.insertBefore(span.firstChild, span);
        }
        parent.removeChild(span);
      } catch (error) {
        console.warn('Failed clearing highlight', error);
      }
    });
    activeSearchHighlights = [];
  }

  function highlightRange(range) {
    if (!range) return;
    const mark = document.createElement('mark');
    mark.className = 'search-hit-highlight';
    try {
      range.surroundContents(mark);
      activeSearchHighlights.push(mark);
      mark.scrollIntoView({ behavior: 'smooth', block: 'center' });
      setTimeout(() => {
        mark.classList.add('search-hit-fade');
      }, 100);
    } catch (error) {
      console.warn('Failed to highlight range', error);
    }
  }

  function scrollToMatchOnPage(query, matchIndex) {
    if (!query) return false;
    clearSearchHighlights();
    const walker = document.createTreeWalker(document.body, NodeFilter.SHOW_TEXT, null);
    const target = query.toLowerCase();
    let occurrence = -1;
    let node = walker.nextNode();
    while (node) {
      if (!(node.parentElement && node.parentElement.closest('.global-search-overlay'))) {
        const text = node.textContent || '';
        const lower = text.toLowerCase();
        let pos = 0;
        while (true) {
          const found = lower.indexOf(target, pos);
          if (found === -1) break;
          occurrence += 1;
          if (occurrence === matchIndex) {
            const range = document.createRange();
            range.setStart(node, found);
            range.setEnd(node, found + query.length);
            highlightRange(range);
            return true;
          }
          pos = found + query.length;
        }
      }
      node = walker.nextNode();
    }
    return false;
  }
  function setupGlobalSearch() {
    const openBtn = document.getElementById('search-open-btn');
    if (openBtn) openBtn.addEventListener('click', (e) => { e.preventDefault(); openSearchOverlay(); });

    window.quartoOpenSearch = (initialQuery = '') => {
      if (typeof initialQuery !== 'string') initialQuery = '';
      openSearchOverlay(initialQuery);
    };

    document.addEventListener('keydown', (e) => {
      if ((e.ctrlKey || e.metaKey) && (e.key === 'k' || e.key === 'K')) {
        e.preventDefault();
        openSearchOverlay();
      }
    }, true);
  }

  const SEARCH_STATE = {
    pages: [],
    index: {},
    loading: false,
    loaded: false,
    localSections: []
  };

  const SEARCH_RESULTS_VIEW = {
    results: [],
    query: '',
    rendered: 0,
    chunkSize: 20,
    totalCount: 0,
    summaryEl: null,
    listEl: null,
    loadMoreWrapper: null,
    loadMoreBtn: null,
    lastChapter: '',
    lastPage: '',
    closeOverlay: null,
    overlayKeyHandler: null,
    overlayClickHandler: null,
    sidebarContainer: null,
    sidebarSummary: null,
    sidebarList: null,
    sidebarQuery: null,
    sidebarClearBtn: null,
    sidebarData: null
  };

  const MAX_SNIPPETS_PER_PAGE = 20;
  const MAX_MATCHES_SCAN = 400;

  function collectBookPages() {
    if (SEARCH_STATE.pages.length) return SEARCH_STATE.pages;
    // file:// では他ページfetchがブロックされるため現在ページのみ
    if (location.protocol === 'file:') {
      const sections = Array.from(document.querySelectorAll('section.chapter-page'));
      const baseUrl = window.location.href.split('#')[0];
      if (!sections.length) {
        SEARCH_STATE.localSections = [];
        SEARCH_STATE.pages = [baseUrl];
        return SEARCH_STATE.pages;
      }
      SEARCH_STATE.localSections = sections.map(section => {
        const id = section.id || '';
        const url = id ? `${baseUrl}#${id}` : baseUrl;
        return { id, url, element: section };
      });
      SEARCH_STATE.pages = SEARCH_STATE.localSections.map(entry => entry.url);
      return SEARCH_STATE.pages;
    }
    const sidebar = document.querySelector('#quarto-sidebar .sidebar-menu-container');
    const hrefs = new Set();
    if (sidebar) {
      sidebar.querySelectorAll('a[href]')?.forEach(a => {
        const href = a.getAttribute('href');
        if (!href) return;
        if (href.startsWith('http')) return;
        if (href.startsWith('#')) return;
        hrefs.add(new URL(href, window.location.href).href);
      });
    }
    // Also add current page
    hrefs.add(window.location.href);
    SEARCH_STATE.pages = Array.from(hrefs);
    SEARCH_STATE.localSections = [];
    return SEARCH_STATE.pages;
  }

  function normalizeWhitespace(text) {
    return (text || '').replace(/\s+/g, ' ').trim();
  }

  function deriveSectionTitle(section, fallback) {
    if (!section) return fallback || 'このページ';
    const selectors = ['h1 .chapter-title', 'h1', '.chapter-title', 'header .title', 'h2', 'h3'];
    for (const sel of selectors) {
      const el = section.querySelector(sel);
      if (el) {
        const txt = normalizeWhitespace(el.textContent);
        if (txt) return txt;
      }
    }
    const heading = Array.from(section.querySelectorAll('h1, h2, h3, h4, h5')).find(h => normalizeWhitespace(h.textContent));
    if (heading) return normalizeWhitespace(heading.textContent);
    const id = section.id || '';
    if (id) return normalizeWhitespace(id.replace(/^page-/, '').replace(/[-_]+/g, ' ')) || (fallback || 'このページ');
    return fallback || 'このページ';
  }

  function extractSectionText(section) {
    if (!section) return '';
    const clone = section.cloneNode(true);
    const removable = [
      'script',
      'style',
      'nav',
      '.single-pager',
      '.margin-note',
      '.right-footnotes',
      '.right-comments',
      '.right-both',
      '.comment-menu-popup',
      '.global-search-overlay',
      '.global-search-dialog',
      '.marker-toolbar'
    ];
    removable.forEach(sel => clone.querySelectorAll(sel).forEach(el => el.remove()));
    return normalizeWhitespace(clone.textContent || '');
  }

  async function buildSearchIndex() {
    if (SEARCH_STATE.loaded || SEARCH_STATE.loading) return;
    SEARCH_STATE.loading = true;
    SEARCH_STATE.index = {};
    const pages = collectBookPages();

    if (location.protocol === 'file:') {
      const baseUrl = window.location.href.split('#')[0];
      if (!SEARCH_STATE.localSections || !SEARCH_STATE.localSections.length) {
        collectBookPages();
      }
      const docTitle = normalizeWhitespace(document.querySelector('header .title')?.textContent || document.title || '');
      const sections = (SEARCH_STATE.localSections && SEARCH_STATE.localSections.length)
        ? SEARCH_STATE.localSections
        : [];
      const seen = new Set();
      if (sections.length) {
        sections.forEach(entry => {
          const section = entry.element;
          const url = entry.url || (entry.id ? `${baseUrl}#${entry.id}` : baseUrl);
          const title = deriveSectionTitle(section, docTitle || baseUrl);
          const text = extractSectionText(section);
          SEARCH_STATE.index[url] = { url, title, text, slug: entry.id };
          seen.add(url);
        });
        const hasIndex = sections.some(entry => (entry.id || '').toLowerCase() === 'page-index');
        if (!hasIndex) {
          const main = document.querySelector('main#quarto-document-content') || document.querySelector('main') || document.body;
          if (main) {
            const text = extractSectionText(main);
            const url = baseUrl;
            if (!seen.has(url)) {
              const title = deriveSectionTitle(main, docTitle || baseUrl);
              SEARCH_STATE.index[url] = { url, title, text };
            }
          }
        }
      } else {
        const main = document.querySelector('main#quarto-document-content') || document.querySelector('main') || document.body;
        const text = extractSectionText(main);
        SEARCH_STATE.index[baseUrl] = { url: baseUrl, title: docTitle || baseUrl, text };
      }
      SEARCH_STATE.loaded = true;
      SEARCH_STATE.loading = false;
      return;
    }

    const fetchPage = async (url) => {
      try {
        const res = await fetch(url);
        const html = await res.text();
        const doc = new DOMParser().parseFromString(html, 'text/html');
        const title = (doc.querySelector('header .title')?.textContent || doc.querySelector('title')?.textContent || '').trim();
        const main = doc.querySelector('main') || doc.querySelector('#quarto-document-content') || doc.body;
        const text = (main.textContent || '').replace(/\s+/g, ' ').trim();
        return { url, title, text };
      } catch (e) {
        console.warn('Search: failed to fetch', url, e);
        return { url, title: url, text: '' };
      }
    };

    const results = await Promise.all(pages.map(fetchPage));
    results.forEach(r => { SEARCH_STATE.index[r.url] = r; });
    SEARCH_STATE.loaded = true;
    SEARCH_STATE.loading = false;
  }

  function openSearchOverlay(initialQuery = '') {
    const startQuery = (typeof initialQuery === 'string') ? initialQuery.trim() : '';
    let overlay = document.querySelector('.global-search-overlay');
    if (overlay) overlay.remove();

    overlay = document.createElement('div');
    overlay.className = 'global-search-overlay';
    overlay.innerHTML = `
      <div class="global-search-dialog" role="dialog" aria-modal="true" aria-label="全ページ検索">
        <div class="global-search-header">
          <h3>検索</h3>
          <button class="global-search-close" aria-label="閉じる">×</button>
        </div>
        <div class="global-search-input-wrapper">
          <input id="global-search-input" type="text" placeholder="キーワードを入力 (Ctrl/Cmd + K)" autocomplete="off" />
          <button id="global-search-btn">検索</button>
        </div>
        <div class="global-search-results">
          <div class="search-help">検索語を入力してください。</div>
        </div>
      </div>
    `;
    document.body.appendChild(overlay);
    overlay.style.display = 'block';
    document.body.classList.add('search-overlay-active');

    const close = () => {
      if (overlay && overlay.parentNode) {
        overlay.parentNode.removeChild(overlay);
      }
      document.body.classList.remove('search-overlay-active');
      if (SEARCH_RESULTS_VIEW.overlayKeyHandler) {
        document.removeEventListener('keydown', SEARCH_RESULTS_VIEW.overlayKeyHandler, true);
        SEARCH_RESULTS_VIEW.overlayKeyHandler = null;
      }
      if (SEARCH_RESULTS_VIEW.overlayClickHandler) {
        document.removeEventListener('click', SEARCH_RESULTS_VIEW.overlayClickHandler, true);
        SEARCH_RESULTS_VIEW.overlayClickHandler = null;
      }
      resetSearchResultsView();
      SEARCH_RESULTS_VIEW.closeOverlay = null;
    };
    overlay.addEventListener('click', (e) => { if (e.target === overlay) close(); });
    overlay.querySelector('.global-search-close')?.addEventListener('click', close);

    const input = overlay.querySelector('#global-search-input');
    const btn = overlay.querySelector('#global-search-btn');
    const syncSidebarInput = () => {};
    input.value = startQuery;
    input.focus();

    const ensureIndex = async () => {
      if (!SEARCH_STATE.loaded) {
        const results = overlay.querySelector('.global-search-results');
        results.innerHTML = '<div class="search-loading">索引を作成中...</div>';
        await buildSearchIndex();
      }
    };

    const doSearch = async () => {
      const q = (input.value || '').trim();
      syncSidebarInput(q);
      const resultsEl = overlay.querySelector('.global-search-results');
      if (!q) {
        resultsEl.innerHTML = '<div class="search-help">検索語を入力してください。</div>';
        resetSearchResultsView();
        return;
      }
      await ensureIndex();
      const results = [];
      for (const url of Object.keys(SEARCH_STATE.index)) {
        const item = SEARCH_STATE.index[url];
        if (!item || !item.text) continue;
        const page = {
          url,
          title: item.title || url,
          chapter: item.title || ''
        };
        const matches = findMatches(item.text, q, MAX_SNIPPETS_PER_PAGE);
        matches.forEach(match => {
          results.push({
            page,
            context: match.context,
            matchCount: match.totalMatches,
            totalMatches: match.totalMatches,
            matchIndex: match.matchIndex,
            remainingMatches: match.remainingMatches
          });
        });
      }
      renderResults(resultsEl, results, q);
    };

    const debouncedSearch = debounce(doSearch, 200);

    const dialog = overlay.querySelector('.global-search-dialog');
    const keyHandler = (event) => {
      if (event.key === 'Escape') {
        event.preventDefault();
        close();
      }
    };
    const clickHandler = (event) => {
      if (dialog && !dialog.contains(event.target)) {
        close();
      }
    };
    document.addEventListener('keydown', keyHandler, true);
    document.addEventListener('click', clickHandler, true);
    SEARCH_RESULTS_VIEW.overlayKeyHandler = keyHandler;
    SEARCH_RESULTS_VIEW.overlayClickHandler = clickHandler;
    SEARCH_RESULTS_VIEW.closeOverlay = close;

    input.addEventListener('input', () => { debouncedSearch(); });
    input.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') { e.preventDefault(); doSearch(); }
      if (e.key === 'Escape') { e.preventDefault(); close(); }
    });
    btn.addEventListener('click', () => { doSearch(); });

    if (startQuery.length) {
      doSearch();
      const end = input.value.length;
      input.setSelectionRange(end, end);
    }

    return { overlay, input, close };
  }

  function findMatches(text, query, limit) {
    if (!text || !query) return [];
    const sanitized = text.replace(/\s+/g, ' ');
    const hay = sanitized.toLowerCase();
    const needle = query.toLowerCase();
    const indices = [];
    let pos = 0;
    let safety = 0;
    while (pos < hay.length) {
      const idx = hay.indexOf(needle, pos);
      if (idx === -1) break;
      indices.push(idx);
      pos = idx + needle.length;
      safety += 1;
      if (safety >= MAX_MATCHES_SCAN) break;
    }
    const total = indices.length;
    if (!total) return [];
    const clamp = Math.min(total, limit || MAX_SNIPPETS_PER_PAGE);
    const results = [];
    for (let i = 0; i < clamp; i += 1) {
      const start = Math.max(0, indices[i] - 80);
      const end = Math.min(sanitized.length, indices[i] + query.length + 80);
      let snippet = sanitized.slice(start, end);
      snippet = highlight(snippet, query);
      if (start > 0) snippet = '…' + snippet;
      if (end < sanitized.length) snippet = snippet + '…';
      const remainingMatches = (total > clamp && i === clamp - 1) ? total - clamp : 0;
      if (remainingMatches > 0) {
        snippet += `<span class="search-result-more">他${remainingMatches}件の一致</span>`;
      }
      results.push({
        context: snippet,
        matchIndex: i,
        totalMatches: total,
        remainingMatches
      });
    }
    return results;
  }

  function escapeHtml(s) {
    return (s || '').replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[c]));
  }

  function highlight(text, query) {
    const escQ = query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    return text.replace(new RegExp(escQ, 'gi'), m => `<mark>${escapeHtml(m)}</mark>`);
  }

  function fmtMMDDHHmm(t){
    const d = new Date(t); const pad = (n)=>String(n).padStart(2,'0');
    return `${pad(d.getMonth()+1)}/${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}`;
  }

  // --- グローバル一覧モーダル（プレビュー / コメント / マーカー） ---
  function openGlobalListOverlay() {
    try {
      const existing = document.querySelector('.global-list-overlay');
      if (existing) existing.remove();

      const overlay = document.createElement('div');
      overlay.className = 'global-list-overlay';
      overlay.style.position = 'fixed';
      overlay.style.inset = '0';
      overlay.style.background = 'rgba(0,0,0,0.45)';
      overlay.style.zIndex = '1700';
      overlay.style.display = 'flex';
      overlay.style.alignItems = 'center';
      overlay.style.justifyContent = 'center';

      const dialog = document.createElement('div');
      dialog.className = 'global-list-dialog';
      dialog.style.background = '#fff';
      dialog.style.borderRadius = '10px';
      dialog.style.boxShadow = '0 10px 30px rgba(0,0,0,0.3)';
      dialog.style.maxWidth = '720px';
      dialog.style.width = '96vw';
      dialog.style.maxHeight = '80vh';
      dialog.style.display = 'flex';
      dialog.style.flexDirection = 'column';
      dialog.style.overflow = 'hidden';

      const header = document.createElement('div');
      header.style.display = 'flex';
      header.style.alignItems = 'center';
      header.style.justifyContent = 'space-between';
      header.style.padding = '10px 14px';
      header.style.borderBottom = '1px solid #e1e5e9';
      const title = document.createElement('h3');
      title.textContent = 'プレビュー / コメント / マーカー一覧';
      title.style.margin = '0';
      title.style.fontSize = '15px';
      title.style.fontWeight = '600';
      const closeBtn = document.createElement('button');
      closeBtn.type = 'button';
      closeBtn.textContent = '×';
      closeBtn.setAttribute('aria-label', '閉じる');
      closeBtn.style.border = 'none';
      closeBtn.style.background = 'none';
      closeBtn.style.cursor = 'pointer';
      closeBtn.style.fontSize = '18px';
      closeBtn.style.lineHeight = '1';
      closeBtn.style.marginLeft = '12px';
      header.appendChild(title);
      header.appendChild(closeBtn);

      const tabs = document.createElement('div');
      tabs.style.display = 'flex';
      tabs.style.borderBottom = '1px solid #e1e5e9';

      const tabNames = [
        { id: 'previews-docs', label: 'Docsプレビュー' },
        { id: 'previews-bg', label: 'BGプレビュー' },
        { id: 'comments', label: 'コメント' },
        { id: 'markers', label: 'マーカー' }
      ];
      const panels = {};

      tabNames.forEach((t, idx) => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.textContent = t.label;
        btn.dataset.tab = t.id;
        btn.style.flex = '1';
        btn.style.padding = '8px 10px';
        btn.style.border = 'none';
        btn.style.borderBottom = idx === 0 ? '2px solid #1a73e8' : '2px solid transparent';
        btn.style.background = idx === 0 ? '#ffffff' : '#f8f9fa';
        btn.style.cursor = 'pointer';
        btn.style.fontSize = '13px';
        btn.style.fontWeight = idx === 0 ? '600' : '500';
        btn.addEventListener('click', () => {
          const current = dialog.querySelectorAll('.global-list-tab');
          for (let i = 0; i < current.length; i++) {
            const b = current[i];
            const active = b === btn;
            b.style.borderBottom = active ? '2px solid #1a73e8' : '2px solid transparent';
            b.style.background = active ? '#ffffff' : '#f8f9fa';
            b.style.fontWeight = active ? '600' : '500';
          }
          Object.keys(panels).forEach(id => {
            panels[id].style.display = id === t.id ? 'block' : 'none';
          });
          if (t.id === 'previews-docs') renderGlobalPreviewList(panels['previews-docs'], 'gdoc');
          if (t.id === 'previews-bg') renderGlobalPreviewList(panels['previews-bg'], 'bg');
          if (t.id === 'comments') renderGlobalCommentList(panels.comments);
          if (t.id === 'markers') renderGlobalMarkerList(panels.markers);
        });
        btn.className = 'global-list-tab';
        tabs.appendChild(btn);
      });

      const body = document.createElement('div');
      body.style.flex = '1';
      body.style.overflowY = 'auto';
      body.style.padding = '10px 14px 12px';
      body.style.fontSize = '13px';

      tabNames.forEach((t, idx) => {
        const panel = document.createElement('div');
        panel.className = 'global-list-panel global-list-' + t.id;
        panel.style.display = idx === 0 ? 'block' : 'none';
        body.appendChild(panel);
        panels[t.id] = panel;
      });

      dialog.appendChild(header);
      dialog.appendChild(tabs);
      dialog.appendChild(body);
      overlay.appendChild(dialog);
      document.body.appendChild(overlay);

      const close = () => {
        if (overlay && overlay.parentNode) overlay.parentNode.removeChild(overlay);
      };
      closeBtn.addEventListener('click', close);
      overlay.addEventListener('click', (e) => {
        if (e.target === overlay) close();
      });

      // 初期タブ: Docsプレビュー
      renderGlobalPreviewList(panels['previews-docs'], 'gdoc');
    } catch (e) {
      console.warn('openGlobalListOverlay failed', e);
    }
  }

  function loadPreviewItemsForGlobalList() {
    var items = [];
    try {
      if (window.__gdocPreviewAPI__ && typeof window.__gdocPreviewAPI__.getItems === 'function') {
        items = window.__gdocPreviewAPI__.getItems() || [];
      } else {
        var raw = window.localStorage.getItem('gdocPreviewState_v2');
        if (raw) {
          var parsed = JSON.parse(raw);
          if (parsed && Array.isArray(parsed.items)) items = parsed.items;
        }
      }
    } catch (e) {
      console.warn('loadPreviewItemsForGlobalList failed', e);
      items = [];
    }
    return items;
  }

  function renderGlobalPreviewList(panel, kind) {
    if (!panel) return;
    panel.innerHTML = '';
    var allItems = loadPreviewItemsForGlobalList();
    var items = kind ? allItems.filter(function (item) {
      return item.kind === kind;
    }) : allItems;
    
    if (!items || !items.length) {
      var empty = document.createElement('p');
      var msg = kind === 'gdoc' ? '現在Docsプレビュー中の文書はありません。' :
                kind === 'bg' ? '現在BGプレビュー中の文書はありません。' :
                '現在プレビュー中の文書はありません。';
      empty.textContent = msg;
      empty.style.cssText = 'margin:4px 0;color:#6c757d;';
      panel.appendChild(empty);
      return;
    }

    var list = document.createElement('ul');
    list.style.listStyle = 'none';
    list.style.padding = '0';
    list.style.margin = '0';

    items.forEach(function (item) {
      var li = document.createElement('li');
      li.style.cssText = 'margin:6px 0;padding:6px 8px;border-radius:6px;border:1px solid #e1e5e9;display:flex;flex-direction:column;gap:4px;';

      var titleRow = document.createElement('div');
      titleRow.style.cssText = 'display:flex;align-items:center;gap:8px;';
      var titleSpan = document.createElement('span');
      titleSpan.style.flex = '1';
      titleSpan.style.fontWeight = '500';
      titleSpan.textContent = item.title || item.href || item.id || '(無題)';
      var stateSpan = document.createElement('span');
      stateSpan.style.fontSize = '11px';
      stateSpan.style.color = '#6c757d';
      stateSpan.textContent = item.state === 'active' ? '表示中' : '格納中';
      titleRow.appendChild(titleSpan);
      titleRow.appendChild(stateSpan);

      var actions = document.createElement('div');
      actions.style.cssText = 'display:flex;gap:4px;flex-wrap:wrap;';

      // 「表示」ボタン（目アイコン）
      var btnShow = document.createElement('button');
      btnShow.type = 'button';
      btnShow.className = 'gdoc-toast-btn';
      btnShow.setAttribute('aria-label', 'プレビュー表示');
      btnShow.title = 'プレビュー表示';
      btnShow.innerHTML = '<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M12 5C7 5 3.1 8 1.5 12 3.1 16 7 19 12 19s8.9-3 10.5-7C20.9 8 17 5 12 5zm0 10a3 3 0 110-6 3 3 0 010 6z"></path></svg>';
      btnShow.addEventListener('click', function () {
        if (window.__gdocPreviewAPI__ && typeof window.__gdocPreviewAPI__.activate === 'function') {
          window.__gdocPreviewAPI__.activate(item.key);
        }
      });

      // 「本文へ」ボタン（ジャンプアイコン）
      var btnJump = document.createElement('button');
      btnJump.type = 'button';
      btnJump.className = 'gdoc-toast-btn';
      btnJump.setAttribute('aria-label', '本文へ移動');
      btnJump.title = '本文へ移動';
      btnJump.innerHTML = '<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M12 2c-.55 0-1 .45-1 1v12.59l-4.3-4.3a1 1 0 10-1.4 1.42l6 6a1 1 0 001.4 0l6-6a1 1 0 10-1.4-1.42L13 15.59V3c0-.55-.45-1-1-1z"></path></svg>';
      btnJump.addEventListener('click', function () {
        if (window.__gdocPreviewAPI__ && typeof window.__gdocPreviewAPI__.jumpToSource === 'function') {
          window.__gdocPreviewAPI__.jumpToSource(item.key);
        }
      });

      // 「他タブで開く」ボタン（外部リンクアイコン）
      var btnTab = document.createElement('button');
      btnTab.type = 'button';
      btnTab.className = 'gdoc-toast-btn';
      btnTab.setAttribute('aria-label', '別タブで開く');
      btnTab.title = '別タブで開く';
      btnTab.innerHTML = '<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M14 3h7v7h-2V6.41l-9.29 9.3-1.42-1.42 9.3-9.29H14V3z"></path><path d="M5 5h5V3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2v-5h-2v5H5V5z"></path></svg>';
      btnTab.addEventListener('click', function () {
        var url = item.href || item.previewUrl;
        if (url) window.open(url, '_blank', 'noopener');
      });

      // 「閉じる」ボタン（×アイコン）
      var btnClose = document.createElement('button');
      btnClose.type = 'button';
      btnClose.className = 'gdoc-toast-btn';
      btnClose.setAttribute('aria-label', '閉じる');
      btnClose.title = '閉じる';
      btnClose.innerHTML = '<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M5.293 6.707l5.293 5.293-5.293 5.293c-.39.39-.39 1.024 0 1.414s1.024.39 1.414 0l5.293-5.293 5.293 5.293c.39.39 1.024.39 1.414 0s.39-1.024 0-1.414L13.414 12l5.293-5.293c.39-.39.39-1.024 0-1.414s-1.024-.39-1.414 0L12 10.586 6.707 5.293c-.39-.39-1.024-.39-1.414 0s-.39 1.024 0 1.414z"></path></svg>';
      btnClose.addEventListener('click', function () {
        if (window.__gdocPreviewAPI__ && typeof window.__gdocPreviewAPI__.close === 'function') {
          window.__gdocPreviewAPI__.close(item.key);
          renderGlobalPreviewList(panel);
        }
      });

      actions.appendChild(btnShow);
      actions.appendChild(btnJump);
      actions.appendChild(btnTab);
      actions.appendChild(btnClose);

      li.appendChild(titleRow);
      li.appendChild(actions);
      list.appendChild(li);
    });

    panel.appendChild(list);
  }

  var GLOBAL_LIST_SCOPE = {
    comments: 'page',
    markers: 'page'
  };

  function renderGlobalCommentList(panel) {
    if (!panel) return;
    panel.innerHTML = '';
    var scope = GLOBAL_LIST_SCOPE.comments || 'page';

    // スコープ切り替えトグル（このページ / 全ページ）
    var ctrl = document.createElement('div');
    ctrl.style.cssText = 'display:flex;align-items:center;justify-content:flex-end;margin-bottom:6px;gap:6px;font-size:11px;color:#6c757d;';
    var label = document.createElement('label');
    label.style.display = 'inline-flex';
    label.style.alignItems = 'center';
    label.style.gap = '4px';
    var checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.checked = scope === 'all';
    checkbox.addEventListener('change', function () {
      GLOBAL_LIST_SCOPE.comments = checkbox.checked ? 'all' : 'page';
      renderGlobalCommentList(panel);
    });
    label.appendChild(checkbox);
    label.appendChild(document.createTextNode('全ページ'));
    ctrl.appendChild(label);
    panel.appendChild(ctrl);

    var key = typeof pageKey === 'function' ? pageKey() : window.location.pathname;
    var list = [];
    if (scope === 'page') {
      // コメントパネルと同じロジックで、このページ上のコメントを取得
      if (typeof getActiveComments === 'function') {
        list = getActiveComments().slice();
      } else if (typeof COMMENTS_DB === 'object' && COMMENTS_DB && COMMENTS_DB[key]) {
        list = COMMENTS_DB[key].slice();
      } else {
        list = [];
      }
    } else {
      if (typeof COMMENTS_DB === 'object' && COMMENTS_DB) {
        Object.keys(COMMENTS_DB).forEach(function (k) {
          (COMMENTS_DB[k] || []).forEach(function (rec) {
            list.push({ __pageKey: k, rec: rec });
          });
        });
      }
    }
    if (!list.length) {
      var empty = document.createElement('p');
      empty.textContent = scope === 'page' ? 'このページにはコメントがありません。' : '全ページにコメントがありません。';
      empty.style.cssText = 'margin:4px 0;color:#6c757d;';
      panel.appendChild(empty);
      return;
    }

    // 並び替え（新しい順）
    list.sort(function (a, b) {
      var ra = scope === 'page' ? a : a.rec;
      var rb = scope === 'page' ? b : b.rec;
      return (rb.t || 0) - (ra.t || 0);
    });

    var ul = document.createElement('ul');
    ul.style.listStyle = 'none';
    ul.style.padding = '0';
    ul.style.margin = '0';

    list.forEach(function (entry) {
      var rec = scope === 'page' ? entry : entry.rec;
      var pageKeyForRec = scope === 'page' ? key : entry.__pageKey;

      var li = document.createElement('li');
      li.style.cssText = 'margin:6px 0;padding:6px 8px;border-radius:6px;border:1px solid #e1e5e9;';

      var meta = document.createElement('div');
      meta.style.cssText = 'font-size:11px;color:#6c757d;display:flex;gap:8px;align-items:center;margin-bottom:4px;';
      var time = document.createElement('span');
      time.textContent = fmtMMDDHHmm(rec.t || Date.now());
      meta.appendChild(time);
      if (scope === 'all' && pageKeyForRec !== key) {
        var pageLabel = document.createElement('span');
        pageLabel.textContent = pageKeyForRec;
        pageLabel.style.maxWidth = '220px';
        pageLabel.style.overflow = 'hidden';
        pageLabel.style.textOverflow = 'ellipsis';
        meta.appendChild(pageLabel);
      }
      var move = document.createElement('button');
      move.type = 'button';
      move.textContent = '移動';
      move.style.cssText = 'padding:2px 6px;font-size:11px;border-radius:4px;border:1px solid #6c757d;background:#fff;cursor:pointer;';
      move.addEventListener('click', function () {
        if (scope === 'page' || pageKeyForRec === key) {
          scrollToComment(rec);
        } else {
          // 別ページのコメントの場合はそのページを開く
          try {
            window.location.href = pageKeyForRec;
          } catch (e) {
            window.location.assign(pageKeyForRec);
          }
        }
      });
      meta.appendChild(move);

      var target = document.createElement('div');
      target.style.cssText = 'font-size:13px;color:#495057;background:#f8f9fa;padding:4px 6px;border-radius:4px;margin-bottom:4px;';
      target.textContent = rec.text || '';
      var body = document.createElement('div');
      body.style.cssText = 'white-space:pre-wrap;line-height:1.5;';
      body.textContent = rec.body || '';

      li.appendChild(meta);
      li.appendChild(target);
      li.appendChild(body);
      ul.appendChild(li);
    });

    panel.appendChild(ul);
  }

  function renderGlobalMarkerList(panel) {
    if (!panel) return;
    panel.innerHTML = '';
    var scope = GLOBAL_LIST_SCOPE.markers || 'page';

    var ctrl = document.createElement('div');
    ctrl.style.cssText = 'display:flex;align-items:center;justify-content:flex-end;margin-bottom:6px;gap:6px;font-size:11px;color:#6c757d;';
    var label = document.createElement('label');
    label.style.display = 'inline-flex';
    label.style.alignItems = 'center';
    label.style.gap = '4px';
    var checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.checked = scope === 'all';
    checkbox.addEventListener('change', function () {
      GLOBAL_LIST_SCOPE.markers = checkbox.checked ? 'all' : 'page';
      renderGlobalMarkerList(panel);
    });
    label.appendChild(checkbox);
    label.appendChild(document.createTextNode('全ページ'));
    ctrl.appendChild(label);
    panel.appendChild(ctrl);

    var markersDB;
    try {
      markersDB = JSON.parse(window.localStorage.getItem(STORAGE_KEYS.markers) || '{}') || {};
    } catch (e) {
      markersDB = {};
    }
    var page = window.location.pathname;
    var list = [];
    if (scope === 'page') {
      list = markersDB[page] || [];
    } else {
      Object.keys(markersDB).forEach(function (k) {
        (markersDB[k] || []).forEach(function (m) {
          list.push({ __pageKey: k, marker: m });
        });
      });
    }
    if (!list.length) {
      var empty = document.createElement('p');
      empty.textContent = scope === 'page' ? 'このページにはマーカーがありません。' : '全ページにマーカーがありません。';
      empty.style.cssText = 'margin:4px 0;color:#6c757d;';
      panel.appendChild(empty);
      return;
    }

    var ul = document.createElement('ul');
    ul.style.listStyle = 'none';
    ul.style.padding = '0';
    ul.style.margin = '0';

    list.forEach(function (entry) {
      var m = scope === 'page' ? entry : entry.marker;
      var pageKeyForMarker = scope === 'page' ? page : entry.__pageKey;

      var li = document.createElement('li');
      li.style.cssText = 'margin:6px 0;padding:6px 8px;border-radius:6px;border:1px solid #e1e5e9;display:flex;flex-direction:column;gap:4px;';

      var row = document.createElement('div');
      row.style.cssText = 'display:flex;align-items:center;gap:8px;';
      var label = document.createElement('span');
      label.style.flex = '1';
      label.textContent = (function () {
        var span = document.querySelector('.text-marker[data-marker-id="' + m.id + '"]');
        if (span && span.textContent) return span.textContent.slice(0, 80);
        return '(マーカー)';
      })();
      if (scope === 'all' && pageKeyForMarker !== page) {
        label.textContent = '[' + pageKeyForMarker + '] ' + label.textContent;
      }
      var colorSwatch = document.createElement('span');
      colorSwatch.style.display = 'inline-block';
      colorSwatch.style.width = '10px';
      colorSwatch.style.height = '10px';
      colorSwatch.style.borderRadius = '2px';
      var colorMap = { yellow:'#fff59d', green:'#c8e6c9', blue:'#bbdefb', pink:'#f8bbd0', orange:'#ffcc80' };
      colorSwatch.style.backgroundColor = colorMap[m.color] || '#fff59d';
      row.appendChild(label);
      row.appendChild(colorSwatch);

      var actions = document.createElement('div');
      actions.style.cssText = 'display:flex;gap:6px;flex-wrap:wrap;';
      var btnMove = document.createElement('button');
      btnMove.type = 'button';
      btnMove.textContent = '移動';
      btnMove.style.cssText = 'padding:3px 8px;font-size:11px;border-radius:4px;border:1px solid #6c757d;background:#fff;cursor:pointer;';
      btnMove.addEventListener('click', function () {
        try {
          if (scope === 'page' || pageKeyForMarker === page) {
            var span = document.querySelector('.text-marker[data-marker-id="' + m.id + '"]');
            if (span && typeof span.scrollIntoView === 'function') {
              var el = span;
              while (el && el !== document.body && !(el instanceof HTMLElement)) {
                el = el.parentElement;
              }
              if (!el) el = span;
              el.scrollIntoView({ behavior: 'smooth', block: 'center' });
              try {
                var prevBox = el.style.boxShadow;
                el.style.transition = 'box-shadow 0.3s ease';
                el.style.boxShadow = '0 0 0 3px rgba(26,115,232,0.5)';
                setTimeout(function () {
                  el.style.boxShadow = prevBox || '';
                }, 1600);
              } catch (e2) {}
            }
          } else {
            window.location.href = pageKeyForMarker;
          }
        } catch (e) {}
      });
      var btnDelete = document.createElement('button');
      btnDelete.type = 'button';
      btnDelete.textContent = '削除';
      btnDelete.style.cssText = 'padding:3px 8px;font-size:11px;border-radius:4px;border:1px solid #dc3545;background:#fff;color:#dc3545;cursor:pointer;';
      btnDelete.addEventListener('click', function () {
        try {
          // remove spans
          document.querySelectorAll('.text-marker[data-marker-id="' + m.id + '"]').forEach(function (el) {
            var parent = el.parentNode;
            while (el.firstChild) parent.insertBefore(el.firstChild, el);
            parent.removeChild(el);
          });
          // update storage
          var db = markersDB[page] || [];
          markersDB[page] = db.filter(function (x) { return x.id !== m.id; });
          if (!markersDB[page].length) delete markersDB[page];
          window.localStorage.setItem(STORAGE_KEYS.markers, JSON.stringify(markersDB));
          renderGlobalMarkerList(panel);
        } catch (e) {
          console.warn('failed to delete marker group', e);
        }
      });

      actions.appendChild(btnMove);
      actions.appendChild(btnDelete);

      li.appendChild(row);
      li.appendChild(actions);
      ul.appendChild(li);
    });

    panel.appendChild(ul);
  }

  function renderResults(container, results, query) {
    if (!container) return;

    if (!results.length) {
      container.innerHTML = `<div class="search-no-results"><p>一致が見つかりませんでした。</p><ul><li>語句を短くする</li><li>別のキーワードを試す</li></ul></div>`;
      resetSearchResultsView();
      return;
    }

    resetSearchResultsView();
    clearSearchHighlights();
    SEARCH_RESULTS_VIEW.results = results;
    SEARCH_RESULTS_VIEW.query = query;
    SEARCH_RESULTS_VIEW.totalCount = results.length + results.reduce((sum, r) => sum + (r.remainingMatches || 0), 0);

    container.innerHTML = '';

    const summary = document.createElement('div');
    summary.className = 'search-results-summary';
    container.appendChild(summary);
    SEARCH_RESULTS_VIEW.summaryEl = summary;

    const listWrap = document.createElement('div');
    listWrap.className = 'search-results-items';
    container.appendChild(listWrap);
    SEARCH_RESULTS_VIEW.listEl = listWrap;

    const loadMoreWrapper = document.createElement('div');
    loadMoreWrapper.className = 'search-load-more-wrapper';
    const loadMoreBtn = document.createElement('button');
    loadMoreBtn.type = 'button';
    loadMoreBtn.className = 'search-load-more-btn';
    loadMoreBtn.textContent = 'さらに表示';
    loadMoreWrapper.appendChild(loadMoreBtn);
    container.appendChild(loadMoreWrapper);
    SEARCH_RESULTS_VIEW.loadMoreWrapper = loadMoreWrapper;
    SEARCH_RESULTS_VIEW.loadMoreBtn = loadMoreBtn;
    loadMoreBtn.addEventListener('click', () => renderOverlayResultsChunk());

    renderOverlayResultsChunk(true);
  }

  function renderOverlayResultsChunk(reset = false) {
    const state = SEARCH_RESULTS_VIEW;
    if (!state.listEl) return;

    if (reset) {
      state.listEl.innerHTML = '';
      state.rendered = 0;
      state.lastChapter = '';
      state.lastPage = '';
    }

    const total = state.results.length;
    if (state.rendered >= total) {
      updateOverlayResultsSummary();
      if (state.loadMoreWrapper) state.loadMoreWrapper.style.display = 'none';
      return;
    }

    const limit = Math.min(total, state.rendered + state.chunkSize);
    for (let i = state.rendered; i < limit; i += 1) {
      const result = state.results[i];
      const chapter = result.page?.chapter || '';
      const pageUrl = result.page?.url || '';

      if (chapter && (chapter !== state.lastChapter || pageUrl !== state.lastPage)) {
        const section = document.createElement('section');
        section.className = 'search-chapter-section';
        const heading = document.createElement('h4');
        heading.className = 'search-chapter-title';
        heading.textContent = chapter;
        section.appendChild(heading);
        state.listEl.appendChild(section);
        state.lastChapter = chapter;
        state.lastPage = pageUrl;
      }

      const item = document.createElement('div');
      item.className = 'search-result-item';

      const titleRow = document.createElement('div');
      titleRow.className = 'search-result-title';

      const link = document.createElement('a');
      link.className = 'search-result-link';
      link.href = result.page?.url || '#';
      link.textContent = result.page?.title || result.page?.url || 'ページ';
      link.addEventListener('click', (event) => {
        event.preventDefault();
        handleOverlayResultSelection(result);
      });

      const order = document.createElement('span');
      order.className = 'search-snippet-order';
      order.textContent = `${(result.matchIndex || 0) + 1}/${result.totalMatches || result.matchCount || 1}`;

      const badge = document.createElement('span');
      badge.className = 'search-match-count';
      badge.textContent = `${result.totalMatches || result.matchCount || 1}件`;

      titleRow.appendChild(link);
      titleRow.appendChild(order);
      titleRow.appendChild(badge);
      item.appendChild(titleRow);

      const ctx = document.createElement('div');
      ctx.className = 'search-result-context';
      ctx.innerHTML = result.context;
      item.appendChild(ctx);

      state.listEl.appendChild(item);
    }

    state.rendered = limit;
    updateOverlayResultsSummary();

    if (state.loadMoreWrapper) {
      state.loadMoreWrapper.style.display = state.rendered >= total ? 'none' : '';
    }
  }

  function updateOverlayResultsSummary() {
    const state = SEARCH_RESULTS_VIEW;
    if (!state.summaryEl) return;
    const hiddenCount = state.results.reduce((sum, item) => sum + (item.remainingMatches || 0), 0);
    const totalMatches = state.results.length + hiddenCount;
    const shownMatches = Math.min(state.rendered, state.results.length);
    const escapedQuery = escapeHtml(state.query);
    state.summaryEl.innerHTML = `
      <p><strong>${totalMatches}</strong>件の結果（「${escapedQuery}」）</p>
      <p class="search-results-muted">${shownMatches}件を表示中${hiddenCount > 0 ? `（他${hiddenCount}件）` : ''}</p>
    `;
  }

  function resetSearchResultsView() {
    SEARCH_RESULTS_VIEW.results = [];
    SEARCH_RESULTS_VIEW.query = '';
    SEARCH_RESULTS_VIEW.rendered = 0;
    SEARCH_RESULTS_VIEW.totalCount = 0;
    SEARCH_RESULTS_VIEW.summaryEl = null;
    SEARCH_RESULTS_VIEW.listEl = null;
    SEARCH_RESULTS_VIEW.loadMoreWrapper = null;
    SEARCH_RESULTS_VIEW.loadMoreBtn = null;
    SEARCH_RESULTS_VIEW.lastChapter = '';
    SEARCH_RESULTS_VIEW.lastPage = '';
  }

  function setupKeyboardShortcuts() {
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        const dialogs = document.querySelectorAll('.global-search-dialog');
        dialogs.forEach(dialog => dialog.remove());
      }
    });
  }

  function setupScrollPosition() {
    const scrollY = sessionStorage.getItem(STORAGE_KEYS.scrollPosition);
    if (scrollY) window.scrollTo(0, parseInt(scrollY));
  window.addEventListener('beforeunload', () => {
    sessionStorage.setItem(STORAGE_KEYS.scrollPosition, window.scrollY);
    persistReadingState();
  });
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'hidden') {
        persistReadingState();
      }
    });
    if (typeof scheduleReadingStateSave === 'function') {
      window.addEventListener('scroll', scheduleReadingStateSave, { passive: true });
      window.addEventListener('resize', scheduleReadingStateSave);
    }
  }

  function expandAllInMenu(root) {
    try {
      root.querySelectorAll('.collapse').forEach(el => {
        el.classList.add('show');
        el.style.height = 'auto';
      });
      root.querySelectorAll('[data-bs-toggle="collapse"]').forEach(tg => {
        tg.setAttribute('aria-expanded', 'true');
      });
      root.querySelectorAll('[data-bs-toggle="collapse"]').forEach(tg => {
        tg.removeAttribute('data-bs-toggle');
        tg.removeAttribute('data-bs-target');
      });
    } catch (e) {
      console.warn('Failed to expand all menu levels:', e);
    }
  }

  // Quarto左サイドバー（各章/全体）: 指定階層まで展開、それ以降を折りたたみ
  function setSidebarDepth(root, maxDepth) {
    try {
      const togglers = root.querySelectorAll('[data-bs-toggle="collapse"][data-bs-target]');
      const getDepthForTarget = (target) => {
        let d = 1; let n = target;
        while (n && n !== root) { if (n.tagName === 'UL') d++; n = n.parentElement; }
        return d;
      };
      togglers.forEach(tg => {
        const sel = tg.getAttribute('data-bs-target');
        if (!sel || sel[0] !== '#') return;
        const target = root.querySelector(sel);
        if (!target) return;
        const depth = getDepthForTarget(target);
        const open = (maxDepth === Infinity) || (depth <= maxDepth);
        target.classList.toggle('show', !!open);
        target.style.height = open ? 'auto' : '';
        tg.setAttribute('aria-expanded', open ? 'true' : 'false');
      });
    } catch (e) {
      console.warn('setSidebarDepth error:', e);
    }
  }

  // ページ内目次: ツリー化 + 展開/格納トグルを付与（デフォルト階層まで展開）
  // 階層判定は必ずMarkdownの#数（= 見出しタグH1..H6のレベル）に従う
  function enhancePageToc(panel, defaultDepth) {
    const nav = panel.querySelector('nav#TOC');
    if (!nav) return;
    const getHeadingLevelFromLink = (a) => {
      try {
        if (!a) return null;
        const href = a.getAttribute('href') || '';
        if (!href.startsWith('#')) return null;
        const id = href.slice(1);
        const h = document.getElementById(id);
        if (!h) return null;
        const tag = (h.tagName || '').toUpperCase();
        if (/^H[1-6]$/.test(tag)) return parseInt(tag.slice(1), 10);
        return null;
      } catch { return null; }
    };

    nav.querySelectorAll('li').forEach(li => {
      const childUl = li.querySelector(':scope > ul');
      const link = li.querySelector(':scope > a');
      const level = getHeadingLevelFromLink(link);

      if (childUl) {
        li.classList.add('has-children');
        const toggle = document.createElement('span');
        toggle.className = 'toc-toggle';
        toggle.textContent = '▾';
        if (link && link.parentNode === li) {
          const row = document.createElement('div');
          row.className = 'li-row';
          li.insertBefore(row, link);
          row.appendChild(toggle);
          row.appendChild(link);
        } else {
          li.insertBefore(toggle, li.firstChild);
        }
        toggle.addEventListener('click', () => {
          li.classList.toggle('collapsed');
          toggle.textContent = li.classList.contains('collapsed') ? '▸' : '▾';
        });
      }

      // 初期展開状態は # のレベルで判定
      if (level != null) {
        const open = (defaultDepth === Infinity) || (level <= defaultDepth);
        if (open) {
          li.classList.remove('collapsed');
          const t = li.querySelector(':scope > .toc-toggle');
          if (t) t.textContent = '▾';
        } else {
          li.classList.add('collapsed');
          const t = li.querySelector(':scope > .toc-toggle');
          if (t) t.textContent = '▸';
        }
      }
    });
  }

  // 独自TOCシステム
  const CustomTOC = {
    // 現在のページの見出しを取得
    getPageHeadings: function() {
      const headmap = new Map();
      let maxDepth = 0;
      
      // メインコンテンツから見出しを取得
      const allHeadings = document.querySelectorAll('main h1, main h2, main h3, main h4, main h5, main h6');
      
      allHeadings.forEach(heading => {
        const text = heading.textContent || heading.innerText || '';
        if (!text.trim()) return;
        
        const level = parseInt(heading.tagName.slice(1), 10);
        const id = heading.id || this.generateIdFromText(text);
        
        headmap.set(id, {
          id: id,
          text: text,
          level: level,
          element: heading,
          children: []
        });
        maxDepth = Math.max(maxDepth, level);
      });
      
      return { headings: headmap, maxDepth: maxDepth };
    },
    
    // テキストからIDを生成（Quarto互換）
    generateIdFromText: function(text) {
      return text
        .replace(/\s+/g, ' ')
        .trim()
        .toLowerCase()
        .replace(/[^\w\s-]/g, '')
        .replace(/\s+/g, '-');
    },
    
    // ページ外TOC：すべてのページ情報（静的データ）
    getAllPagesTOC: function() {
      // ページ構成を静的に定義する
      return [
        {
          title: "AJMUN 37th 平和への課題：補遺",
          url: "../index.html",
          type: "cover"
        },
        {
          title: "フロント挨拶",
          url: "../content/00_front.html",
          type: "front"
        },
        {
          title: "第1章 プロジェクトの概要",
          url: "../content/01_ch01.html",
          type: "chapter",
          sections: [
            "1.1 はじめに",
            "1.2 プロジェクトの目的",
            "1.2.1 課題認識",
            "1.2.2 解決方針",
            "1.3 技術選定",
            "1.3.1 Quarto + Pandoc",
            "1.3.2 UDP明朝フォント",
            "1.4 プロジェクト構成",
            "1.4.1 ディレクトリ構造",
            "1.4.2 ファイル配置戦略",
            "1.5 開発アプローチ",
            "1.5.1 プログレッシブエンハンスメント",
            "1.5.2 アクセシビリティ優先"
          ]
        },
        {
          title: "第2章 技術的課題と解決策",
          url: "../content/02_ch02.html",
          type: "chapter",
          sections: [
            "2.1 日本語組版の課題",
            "2.1.1 文字エンコーディング",
            "2.1.2 フォントの扱い",
            "2.2 レスポンシブデザイン",
            "2.2.1 標長画面の制約",
            "2.2.2 モバイルへの対応",
            "2.3 パフォーマンスの最適化",
            "2.3.1 読み込み時間の短縮",
            "2.3.2 スムーズな操作感"
          ]
        },
        {
          title: "第3章 実装方針",
          url: "../content/03_ch03.html",
          type: "chapter",
          sections: [
            "3.1 開発アプローチ",
            "3.1.1 プロジェクト構造",
            "3.1.2 ビルドシステム",
            "3.2 技術選択",
            "3.3 品質保証"
          ]
        },
        {
          title: "コラム1：Webフォントの歴史",
          url: "../content/20_col01.html",
          type: "column",
          sections: [
            "デジタルタイポグラフィの発展",
            "画像フォントの時代",
            "Webフォントの登場",
            "日本語対応の課題",
            "サブセット化の重要性"
          ]
        },
        {
          title: "コラム2：アクセシビリティの重要性",
          url: "../content/21_col02.html",
          type: "column",
          sections: [
            "リテラシーの多様性",
            "視覚的配慮",
            "聴覚的配慮",
            "身体的配慮",
            "技術的な実装"
          ]
        },
        {
          title: "第4章 UI/UX設計",
          url: "../content/04_ch04.html",
          type: "chapter",
          sections: [
            "4.1 基本原則",
            "4.2 コンポーネント設計",
            "4.3 アクセシビリティ"
          ]
        },
        {
          title: "第5章 パフォーマンス最適化",
          url: "../content/05_ch05.html",
          type: "chapter",
          sections: [
            "5.1 読み込み速度",
            "5.2 レンダリングの効率化",
            "5.3 キャッシュ戦略"
          ]
        },
        {
          title: "第6章 国連の制度",
          url: "./06_ch06.html",
          type: "chapter",
          sections: [
            "はじめに",
            "第1節 国連という組織",
            "第1項 概要・組織構造",
            "第2項 安全保障理事会",
            "第3項 国連の紛争対処",
            "第4項 安保理決議に基づく義務",
            "コラム 安保理決議の拘束力",
            "第2節 国連財政",
            "第2項 PKO予算",
            "第3節 国連による経済制裁",
            "第1項 国際連合憲章における経済制裁措置",
            "第2項 冷戦下の経済制裁",
            "第3項 冷戦後の経済制裁",
            "第3項 経済制裁に伴う問題とその後",
            "第4項 国連憲章第50条の注解",
            "第4節 国連平和維持活動(PKO)",
            "参考文献"
          ]
        },
        {
          title: "第7章 まとめと展望",
          url: "../content/07_ch07.html",
          type: "chapter",
          sections: [
            "7.1 プロジェクトの成果",
            "7.2 技術的貢献",
            "7.3 今後の発展",
            "まとめ"
          ]
        },
        {
          title: "コラム3：今後の技術動向",
          url: "../content/22_col03.html",
          type: "column",
          sections: [
            "新しい技術の登場",
            "Variable Fonts",
            "Container Queries",
            "Web Components",
            "発展の可能性",
            "PWA化",
            "オフライン対応",
            "マルチデバイス同期"
          ]
        },
        {
          title: "編集後記",
          url: "../content/90_afterword.html",
          type: "appendix",
          sections: [
            "執筆の経緯",
            "技術的な挑戦",
            "フォント埋込",
            "レスポンシブ設計",
            "脚注処理",
            "読者の皆様へ",
            "今後の展望",
            "結びに"
          ]
        },
        {
          title: "参考文献",
          url: "../content/95_references.html",
          type: "appendix"
        },
        {
          title: "索引",
          url: "../content/96_index.html",
          type: "appendix",
          sections: [
            "あ", "う", "か", "こ", "し", "た", "は", "ろ"
          ]
        }
      ];
    },
    
    // ページ内TOCを生成（章内タブ用）
    generatePageTOC: function(maxDepth) {
      const { headings } = this.getPageHeadings();
      
      if (headings.size === 0) {
        return '<p class="toc-empty">このページには見出しがありません。</p>';
      }
      
      const items = [];
      headings.forEach((heading, id) => {
        const level = Math.min(Math.max(heading.level, 1), 6);
        if (level > maxDepth) return;
        const levelClass = `page-toc-level-${level}`;
        const liClasses = ['page-toc-item', levelClass].join(' ');
        items.push(`<li class="${liClasses}"><a class="page-toc-link" href="#${id}">${heading.text}</a></li>`);
      });

      if (!items.length) {
        return '<p class="toc-empty">このページには見出しがありません。</p>';
      }

      return `<ul class="page-toc-list">${items.join('')}</ul>`;
    },
    
    // 全体TOCを生成（全体タブ用）
    generateAllPagesTOC: function() {
      const pages = this.getAllPagesTOC();
      const currentPath = (window.location.pathname || '').split('/').pop() || 'index.html';
      
      let html = '<ul class="all-toc-list">';
      
      pages.forEach(page => {
        const normalizedPage = (page.url || '').replace(/^\.\//, '').split('/').pop() || '';
        const isActive = normalizedPage === currentPath;
        const itemClasses = ['all-toc-item', `all-toc-item--${page.type || 'other'}`];
        if (isActive) itemClasses.push('active');
        
        html += `<li class="${itemClasses.join(' ')}">`;
        html += `<a href="${page.url}" class="all-toc-link">${page.title}</a>`;
        
        if (Array.isArray(page.sections) && page.sections.length) {
          html += '<ul class="all-toc-sublist">';
          page.sections.forEach(sectionName => {
            const sectionId = this.generateIdFromText(sectionName);
            const link = `${page.url}#${sectionId}`;
            html += `<li class="all-toc-subitem"><a href="${link}" class="all-toc-sublink">${sectionName}</a></li>`;
          });
          html += '</ul>';
        }
        
        html += '</li>';
      });
      
      html += '</ul>';
      return html;
    },
    
    // TOC構造をHTMLに変換
    renderTOCStructure: function(structure, maxDepth = Infinity, options = {}) {
      const {
        listClass = 'custom-toc-list',
        childListClass = 'custom-toc-child-list',
        itemClass = (item, active) => `custom-toc-item level-${item.level} ${active}`,
        linkClass = (item, active) => `custom-toc-link ${active}`
      } = options;

      const normalizeClass = (value) => (value || '').trim().replace(/\s+/g, ' ');

      const renderItems = (items, currentDepth = 1) => {
        let resultHtml = '';

        items.forEach(item => {
          if (Array.isArray(item)) {
            if (currentDepth <= maxDepth) {
              resultHtml += `<ul class="${normalizeClass(childListClass)}">`;
              item.forEach(childItem => {
                resultHtml += renderItems([childItem], currentDepth + 1);
              });
              resultHtml += '</ul>';
            }
          } else if (item && item.id) {
            const isActive = document.getElementById(item.id)?.classList.contains('active');
            const activeClass = isActive ? 'active' : '';
            const liClass = typeof itemClass === 'function' ? itemClass(item, activeClass) : itemClass;
            const linkClassName = typeof linkClass === 'function' ? linkClass(item, activeClass) : linkClass;

            resultHtml += `<li class="${normalizeClass(liClass)}">`;
            resultHtml += `<a href="#${item.id}" class="${normalizeClass(linkClassName)}">${item.text}</a>`;

            if (item.children && item.children.length > 0 && currentDepth < maxDepth) {
              resultHtml += `<ul class="${normalizeClass(childListClass)}">`;
              item.children.forEach(child => {
                resultHtml += renderItems([child], currentDepth + 1);
              });
              resultHtml += '</ul>';
            }

            resultHtml += '</li>';
          }
        });

        return resultHtml;
      };

      let html = `<ul class="${normalizeClass(listClass)}">`;
      structure.forEach(item => {
        html += renderItems([item], 1);
      });
      html += '</ul>';
      return html;
    },
    
    // TOCを初期化
    initializeCustomTOC: function() {
      // 章内タブ用TOC
      const pageTOCPanel = document.querySelector('.toc-page-content');
      if (pageTOCPanel) {
        const pageTOC = this.generatePageTOC(Infinity);
        pageTOCPanel.innerHTML = pageTOC;
      }
      
      // 全体タブ用TOC
      const allTOCPanel = document.querySelector('.toc-all-content');
      if (allTOCPanel) {
        const allTOC = this.generateAllPagesTOC();
        allTOCPanel.innerHTML = allTOC;
        
        // 階層折りたたみ機能
        this.setupTOCToggling(allTOCPanel);
      }
    },
    
    // TOCの階層展開/折りたたみ機能
    setupTOCToggling: function(container) {
      const toggleButtons = container.querySelectorAll('.custom-toc-item > .custom-toc-link');
      
      toggleButtons.forEach(link => {
        const listItem = link.closest('.custom-toc-item');
        const childList = listItem.querySelector('.custom-toc-child-list');
        
        if (childList) {
          // 開閉ボタンを追加
          const toggleBtn = document.createElement('span');
          toggleBtn.className = 'custom-toc-toggle';
          toggleBtn.textContent = '▾';
          
          link.parentNode.insertBefore(toggleBtn, link);
          link.style.paddingLeft = '20px';
          
          // 第4階層以下はデフォルトで折りたたむ
          const level = parseInt(listItem.className.match(/level-(\d+)/)?.[1] || 1, 10);
          const collapsed = level >= 4;
          
          if (collapsed) {
            childList.style.display = 'none';
            toggleBtn.textContent = '▸';
          }
          
          toggleBtn.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            
            const isCollapsed = childList.style.display === 'none';
            childList.style.display = isCollapsed ? '' : 'none';
            toggleBtn.textContent = isCollapsed ? '▾' : '▸';
          });
          
          // 親リンクのクリック動作
          link.addEventListener('click', (e) => {
            e.stopPropagation();
          });
        }
      });
    }
  };

  CustomTOC.getNavData = function(navData) {
    return navData || NAV_DATA_STATE.data;
  };

  CustomTOC.normalizeText = function(text) {
    return (text || '').replace(/\s+/g, ' ').trim();
  };

  CustomTOC.getCurrentPage = function(navData) {
    const data = this.getNavData(navData);
    if (!data || !Array.isArray(data.pages)) return null;
    const current = computeCurrentOutputPath();
    return data.pages.find(page => isSamePage(page.output, current)) || null;
  };

  CustomTOC.createTree = function(nodes, pageOutput, options = {}) {
    const { variant } = options;
    const ul = document.createElement('ul');
    ul.className = 'toc-tree';
    if (variant) ul.classList.add(variant);

    nodes.forEach((node, index) => {
      if (!node) return;
      const depth = Math.min(node.level || 1, 6);
      const li = document.createElement('li');
      li.className = `toc-item toc-level-${depth}`;
      if (index === nodes.length - 1) li.classList.add('is-last');

      const row = document.createElement('div');
      row.className = 'toc-row';

      const link = document.createElement('a');
      link.className = `toc-link toc-level-${depth}`;
      link.href = buildHref(pageOutput, node.anchor || null);
      link.textContent = node.title || '';
      row.appendChild(link);
      li.appendChild(row);

      const hasChildren = Array.isArray(node.children) && node.children.length > 0;
      if (hasChildren) {
        const childList = this.createTree(node.children, pageOutput, options);
        li.appendChild(childList);
        li.classList.add('has-children');
      }

      ul.appendChild(li);
    });

    return ul;
  };

  CustomTOC.cloneNodeWithLevelOffset = function(node, offset) {
    if (!node) return null;
    const level = Math.max(1, (node.level || 1) + offset);
    const clone = {
      title: node.title,
      level,
      anchor: node.anchor,
      children: []
    };
    if (Array.isArray(node.children) && node.children.length) {
      clone.children = node.children
        .map(child => this.cloneNodeWithLevelOffset(child, offset))
        .filter(Boolean);
    }
    return clone;
  };

  CustomTOC.rebasePageHeadings = function(nodes) {
    if (!Array.isArray(nodes) || !nodes.length) return [];

    const rebased = [];
    let consumedLevel1 = false;

    nodes.forEach(node => {
      if (!node) return;
      const level = node.level || 1;
      if (level <= 1) {
        consumedLevel1 = true;
        if (Array.isArray(node.children) && node.children.length) {
          node.children.forEach(child => {
            const adjusted = this.cloneNodeWithLevelOffset(child, -1);
            if (adjusted) rebased.push(adjusted);
          });
        }
      } else {
        const adjusted = this.cloneNodeWithLevelOffset(node, -1);
        if (adjusted) rebased.push(adjusted);
      }
    });

    if (!rebased.length && !consumedLevel1) {
      return nodes
        .map(node => this.cloneNodeWithLevelOffset(node, -1))
        .filter(Boolean);
    }

    return rebased;
  };

  CustomTOC.renderChapterTab = function(container, navData) {
    if (!container) return;
    const data = this.getNavData(navData);
    container.innerHTML = '';

    if (!data || !Array.isArray(data.pages) || !data.pages.length) {
      container.innerHTML = '<p class="toc-empty">目次データを読み込めませんでした。</p>';
      return;
    }

    const list = document.createElement('ul');
    list.className = 'toc-chapter-list toc-tree';
    const current = computeCurrentOutputPath();

    data.pages.forEach(page => {
      if (!page) return;
      const li = document.createElement('li');
      li.className = 'toc-chapter-item';
      if (isSamePage(page.output, current)) li.classList.add('active');

      const headingTree = cloneTreeWithDepth(page.headings || [], 1);
      const nodes = headingTree.length ? headingTree : [{
        title: page.title,
        level: 1,
        anchor: page.headings && page.headings.length ? page.headings[0].anchor : null,
        children: []
      }];

      const primary = nodes[0];
      const link = document.createElement('a');
      link.className = 'toc-link toc-chapter-link';
      link.href = buildHref(page.output, primary.anchor || null);
      link.textContent = primary.title || page.title;
      li.appendChild(link);

      if (nodes.length > 1) {
        const childList = document.createElement('ul');
        childList.className = 'toc-tree toc-chapter-sublist';
        nodes.slice(1).forEach(node => {
          const subLi = document.createElement('li');
          subLi.className = 'toc-item toc-level-1';
          const subLink = document.createElement('a');
          subLink.className = 'toc-link';
          subLink.href = buildHref(page.output, node.anchor || null);
          subLink.textContent = node.title || '';
          subLi.appendChild(subLink);
          childList.appendChild(subLi);
        });
        li.appendChild(childList);
      }

      list.appendChild(li);
    });

    container.appendChild(list);
  };

  CustomTOC.renderAllTab = function(container, navData) {
    if (!container) return;
    const data = this.getNavData(navData);
    container.innerHTML = '';
    container.classList.add('toc-all-container-ready');

    if (!data || !Array.isArray(data.pages) || !data.pages.length) {
      container.innerHTML = '<p class="toc-empty">目次データを読み込めませんでした。</p>';
      return;
    }

    const list = document.createElement('ul');
    list.className = 'toc-all-list toc-tree toc-tree-root toc-tree-all-root';
    const current = computeCurrentOutputPath();

    data.pages.forEach(page => {
      if (!page) return;
      const li = document.createElement('li');
      li.className = 'toc-all-item';
      if (isSamePage(page.output, current)) li.classList.add('active');

      const headingTree = cloneTreeWithDepth(page.headings || [], 3);
      let sectionNodes = headingTree;
      let chapterAnchor = page.headings && page.headings.length ? page.headings[0].anchor : null;
      if (
        headingTree.length === 1 &&
        this.normalizeText(headingTree[0].title) === this.normalizeText(page.title)
      ) {
        chapterAnchor = headingTree[0].anchor || chapterAnchor;
        sectionNodes = headingTree[0].children || [];
      }

      const link = document.createElement('a');
      link.className = 'toc-link toc-all-link';
      link.href = buildHref(page.output, chapterAnchor || null);
      link.textContent = page.title;
      li.appendChild(link);

      if (sectionNodes.length) {
        const childTree = this.createTree(sectionNodes, page.output, { variant: 'toc-tree-all' });
        li.appendChild(childTree);
      }

      list.appendChild(li);
    });

    container.appendChild(list);
  };

  CustomTOC.renderPageTab = function(container, navData, maxDepth = 4) {
    if (!container) return;
    const page = this.getCurrentPage(navData);
    container.innerHTML = '';
    container.classList.add('toc-page-container');

    if (!page) {
      container.innerHTML = '<p class="toc-empty">このページには見出しがありません。</p>';
      return;
    }

    const headingTree = cloneTreeWithDepth(page.headings || [], maxDepth);
    const rebasedTree = this.rebasePageHeadings(headingTree)
      .filter(node => (node.level || 1) >= 1);

    if (!rebasedTree.length) {
      container.innerHTML = '<p class="toc-empty">このページには見出しがありません。</p>';
      return;
    }

    const tree = this.createTree(rebasedTree, page.output, { variant: 'toc-tree-page' });
    tree.classList.add('toc-tree-root', 'toc-tree-page-root');
    container.appendChild(tree);
  };

  CustomTOC.initializeCustomTOC = function(navData) {
    const data = this.getNavData(navData);
    if (!data) return;

    const pagePanel = document.querySelector('.toc-page-content');
    if (pagePanel) {
      this.renderPageTab(pagePanel, data, 4);
    }

    const allPanel = document.querySelector('.toc-all-content .toc-all-container') || document.querySelector('.toc-all-content');
    if (allPanel) {
      this.renderAllTab(allPanel, data);
    }

    const sitePanel = document.querySelector('.toc-site-content .sidebar-menu-container');
    if (sitePanel) {
      this.renderChapterTab(sitePanel, data);
    }
  };

  CustomTOC.generatePageTOC = function(maxDepth = 4) {
    const temp = document.createElement('div');
    this.renderPageTab(temp, this.getNavData(), maxDepth);
    return temp.innerHTML || '<p class="toc-empty">このページには見出しがありません。</p>';
  };

  CustomTOC.generateAllPagesTOC = function() {
    const temp = document.createElement('div');
    this.renderAllTab(temp, this.getNavData());
    return temp.innerHTML || '<p class="toc-empty">目次データを読み込めませんでした。</p>';
  };

  // コメントエクスポート/インポート
  function exportComments(pageOnly) {
    try {
      const data = pageOnly ? { [pageKey()]: COMMENTS_DB[pageKey()]||[] } : COMMENTS_DB;
      const blob = new Blob([JSON.stringify({ version:'1.0', exportedAt: new Date().toISOString(), data }, null, 2)], { type:'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      const base = pageOnly ? (pageKey().split('/').pop()||'page') : 'all';
      a.download = `comments_${base}_${new Date().toISOString().slice(0,10)}.json`;
      document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
    } catch (e) { alert('コメント出力に失敗しました'); }
  }
  function importCommentsFromFile(file) {
    if (!file) return;
    const reader = new FileReader();
    reader.onload = () => {
      try {
        const json = JSON.parse(reader.result);
        const incoming = json.data || {};
        // マージ
        Object.keys(incoming).forEach(k => {
          if (!Array.isArray(incoming[k])) return;
          if (!COMMENTS_DB[k]) COMMENTS_DB[k] = [];
          const existingIds = new Set(COMMENTS_DB[k].map(r=>r.id));
          incoming[k].forEach(rec => { if (!existingIds.has(rec.id)) COMMENTS_DB[k].push(rec); });
        });
        saveComments();
        refreshRightPanels();
        alert('コメントをインポートしました');
      } catch (e) {
        alert('コメント読込に失敗しました');
      }
    };
    reader.readAsText(file, 'utf-8');
  }

})();
</script>
<style>
  .gdoc-popover {
    position: absolute;
    z-index: 1100;
    max-width: 320px;
    background: var(--gdoc-popover-bg, #fff);
    color: inherit;
    border-radius: 6px;
    box-shadow: 0 4px 16px rgba(0,0,0,0.18);
    border: 1px solid rgba(0,0,0,0.07);
    font-size: 14px;
  }
  .gdoc-popover[hidden] {
    display: none !important;
  }
  .gdoc-popover-inner {
    padding: 8px 10px;
  }
  .gdoc-popover-header {
    margin-bottom: 6px;
    font-weight: 600;
    line-height: 1.3;
    max-height: 3.2em;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .gdoc-popover-title {
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
  }
  .gdoc-popover-actions {
    display: flex;
    gap: 6px;
    justify-content: flex-end;
  }
  .gdoc-popover-actions .gdoc-btn {
    border: none;
    background: transparent;
    padding: 4px 6px;
    border-radius: 4px;
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: 13px;
    color: inherit;
  }
  .gdoc-popover-actions .gdoc-btn:hover {
    background: rgba(0,0,0,0.06);
  }
  .gdoc-popover-actions .gdoc-btn svg {
    width: 16px;
    height: 16px;
  }

.gdoc-modal {
    position: static;
    z-index: auto;
  }
  .gdoc-modal[hidden] {
    display: none !important;
  }
  .gdoc-modal-dialog {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: min(900px, 90vw);
    height: min(600px, 80vh);
    min-width: 320px;
    min-height: 220px;
    max-width: 95vw;
    max-height: 95vh;
    background: #fff;
    border-radius: 8px;
    overflow: hidden;
    box-shadow: 0 10px 30px rgba(0,0,0,0.35);
    display: flex;
    flex-direction: column;
    z-index: 1500;
  }
  .gdoc-modal-header {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 6px 10px;
    border-bottom: 1px solid rgba(0,0,0,0.08);
    background: #f5f5f5;
    cursor: move;
    user-select: none;
  }
  .gdoc-modal-title {
    font-size: 14px;
    font-weight: 600;
    margin-right: 8px;
    max-width: 60vw;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .gdoc-modal-header-actions {
    display: inline-flex;
    align-items: center;
    gap: 4px;
  }
  .gdoc-modal-header-actions .gdoc-modal-btn {
    border: none;
    background: transparent;
    padding: 4px 6px;
    border-radius: 4px;
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: 13px;
    color: inherit;
  }
  .gdoc-modal-header-actions .gdoc-modal-btn:hover {
    background: rgba(0,0,0,0.06);
  }
  .gdoc-modal-header-actions .gdoc-modal-btn svg {
    width: 15px;
    height: 15px;
  }
  .gdoc-modal-body {
    flex: 1 1 auto;
    position: relative;
    overflow: auto;
  }
  .gdoc-modal-iframe {
    border: none;
    width: 100%;
    height: 100%;
    transform-origin: 0 0;
  }
  .bg-preview-body {
    display: none;
    padding: 20px 40px;
    max-width: 900px;
    margin: 0 auto;
    font-size: inherit; /* 設定された文字サイズを継承 */
    line-height: 1.8;
    overflow-y: auto;
    height: 100%;
  }
  
  /* 文字サイズクラスに対応 */
  .font-size-small .bg-preview-body { font-size: 14px; }
  .font-size-medium .bg-preview-body { font-size: 16px; }
  .font-size-large .bg-preview-body { font-size: 18px; }
  .font-size-xlarge .bg-preview-body { font-size: 20px; }
  .bg-preview-body.active {
    display: block;
  }
  .bg-preview-body .inline-footnote {
    color: #1a73e8;
    font-size: 0.9em;
    margin-left: 2px;
  }
  .bg-preview-body .text-marker {
    background: rgba(255, 235, 59, 0.3);
    padding: 0 2px;
  }

  body[data-theme="dark"] .gdoc-popover {
    --gdoc-popover-bg: #111827;
    background: #111827;
    color: #e2e8f0;
    border-color: rgba(138, 180, 248, 0.25);
    box-shadow: 0 18px 36px rgba(0, 0, 0, 0.55);
  }

  body[data-theme="dark"] .gdoc-popover-actions .gdoc-btn:hover {
    background: rgba(255, 255, 255, 0.08);
  }

  body[data-theme="dark"] .gdoc-modal-dialog {
    background: #0b101a;
    color: #e1e5ed;
    border: 1px solid rgba(138, 180, 248, 0.35);
    box-shadow: 0 24px 48px rgba(0, 0, 0, 0.7);
  }

  body[data-theme="dark"] .gdoc-modal-header {
    background: rgba(255, 255, 255, 0.05);
    border-bottom-color: rgba(255, 255, 255, 0.12);
    color: inherit;
  }

  body[data-theme="dark"] .gdoc-modal-header-actions .gdoc-modal-btn:hover {
    background: rgba(255, 255, 255, 0.08);
  }

  body[data-theme="dark"] .bg-preview-body {
    color: #e5e9f0;
    background: transparent;
  }

  body[data-theme="dark"] .bg-preview-body a {
    color: #8ab4f8;
  }

  /* プレビュー内のポップオーバーを最前面に */
  .bg-preview-body .gdoc-popover,
  .bg-preview-body #bg-preview-popover {
    z-index: 10001 !important;
  }
  .bg-preview-body h1,
  .bg-preview-body h2,
  .bg-preview-body h3,
  .bg-preview-body h4 {
    margin-top: 1.5em;
    margin-bottom: 0.5em;
  }
  .bg-preview-body p {
    margin-bottom: 1em;
  }
  .bg-preview-body a {
    color: #1a73e8;
    text-decoration: none;
  }
  .bg-preview-body a:hover {
    text-decoration: underline;
  }
  /* モバイルモードでは画面全体を覆うモーダルとして動作 */
  .gdoc-modal.gdoc-modal-mobile {
    position: fixed;
    inset: 0;
    z-index: 1500;
    background: rgba(0,0,0,0.35);
  }
  .gdoc-modal.gdoc-modal-mobile .gdoc-modal-dialog {
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 96vw;
    height: 90vh;
    min-width: 0;
    min-height: 0;
    max-width: none;
    max-height: none;
    border-radius: 8px;
  }
  
  /* モバイル版でのウィンドウサイズ変更対応 */
  @media (max-width: 768px) {
    .gdoc-modal-dialog {
      position: fixed !important;
      top: 50% !important;
      left: 50% !important;
      transform: translate(-50%, -50%) !important;
      width: 95vw !important;
      height: 95vh !important;
    }
  }
  .gdoc-resize-handle {
    position: absolute;
    width: 12px;
    height: 12px;
    z-index: 1600;
    background: transparent;
    /* 視認性が必要なら、以下のコメントアウトを外す
    background: rgba(0,0,0,0.15);
    border-radius: 50%;
    */
  }
  .gdoc-resize-handle-nw {
    top: -4px;
    left: -4px;
    cursor: nwse-resize;
  }
  .gdoc-resize-handle-ne {
    top: -4px;
    right: -4px;
    cursor: nesw-resize;
  }
  .gdoc-resize-handle-sw {
    bottom: -4px;
    left: -4px;
    cursor: nesw-resize;
  }
  .gdoc-resize-handle-se {
    bottom: -4px;
    right: -4px;
    cursor: nwse-resize;
  }

  /* 右下に積まれる格納トースト */
  .gdoc-toast-container {
    position: fixed;
    right: 16px;
    bottom: 16px;
    z-index: 1400;
    display: flex;
    flex-direction: column;
    gap: 8px;
    max-width: 480px;
    pointer-events: none;
  }
  .gdoc-toast-container-inner {
    pointer-events: auto;
    display: flex;
    flex-direction: column;
    gap: 8px;
  }
.gdoc-toast {
    width: 480px;
    max-width: 100vw;
    background: #f5f5f5;
    color: #222;
    border-radius: 8px;
    box-shadow: 0 4px 16px rgba(0,0,0,0.18);
    display: flex;
    align-items: center;
    padding: 6px 10px;
    box-sizing: border-box;
  }
  .gdoc-toast-main {
    flex: 1 1 auto;
    min-width: 0;
    display: flex;
    align-items: center;
    gap: 8px;
    cursor: pointer;
  }
  .gdoc-toast-title {
    flex: 1 1 auto;
    min-width: 0;
    font-size: 13px;
    font-weight: 500;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .gdoc-toast-actions {
    flex: 0 0 auto;
    display: inline-flex;
    align-items: center;
    gap: 4px;
  }
  .gdoc-toast-btn {
    border: none;
    background: transparent;
    padding: 2px 4px;
    border-radius: 4px;
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    color: inherit;
  }
  .gdoc-toast-btn:hover {
    background: rgba(255,255,255,0.12);
  }
  .gdoc-toast-btn svg {
    width: 14px;
    height: 14px;
  }

  /* トーストのダークテーマ */
  body[data-theme="dark"] .gdoc-toast {
    background: #303134;
    color: #e0e0e0;
    box-shadow: 0 4px 16px rgba(0,0,0,0.6);
  }

  body[data-theme="dark"] .gdoc-toast-btn:hover {
    background: rgba(255,255,255,0.08);
  }

  /* 他文書一覧モーダル */
  .gdoc-list-modal {
    position: fixed;
    inset: 0;
    z-index: 1550;
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(0,0,0,0.4);
  }
  .gdoc-list-modal[hidden] {
    display: none !important;
  }
  .gdoc-list-modal-dialog {
    width: min(640px, 96vw);
    max-height: 80vh;
    background: #fff;
    border-radius: 8px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.35);
    display: flex;
    flex-direction: column;
    overflow: hidden;
  }
  .gdoc-list-modal-header {
    padding: 8px 12px;
    border-bottom: 1px solid rgba(0,0,0,0.08);
    display: flex;
    align-items: center;
    justify-content: space-between;
  }
  .gdoc-list-modal-title {
    font-size: 14px;
    font-weight: 600;
  }
  .gdoc-list-modal-close {
    border: none;
    background: transparent;
    cursor: pointer;
    font-size: 18px;
    line-height: 1;
  }
  .gdoc-list-modal-body {
    padding: 8px 12px;
    overflow: auto;
  }
  .gdoc-list {
    list-style: none;
    margin: 0;
    padding: 0;
    display: flex;
    flex-direction: column;
    gap: 6px;
  }
  .gdoc-list-item {
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 4px 6px;
    border-radius: 4px;
  }
  .gdoc-list-item:hover {
    background: rgba(0,0,0,0.03);
  }
  .gdoc-list-item-title {
    flex: 1 1 auto;
    min-width: 0;
    font-size: 13px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .gdoc-list-item-actions {
    flex: 0 0 auto;
    display: inline-flex;
    align-items: center;
    gap: 4px;
  }
  .gdoc-list-item-btn {
    border: none;
    background: transparent;
    cursor: pointer;
    padding: 2px 4px;
    border-radius: 4px;
    font-size: 12px;
  }
  .gdoc-list-item-btn:hover {
    background: rgba(0,0,0,0.06);
  }
</style>

<div id="gdoc-preview-popover" class="gdoc-popover" hidden="">
  <div class="gdoc-popover-inner">
    <div class="gdoc-popover-header">
      <span class="gdoc-popover-title"></span>
    </div>
    <div class="gdoc-popover-actions" role="group" aria-label="Googleドキュメント操作">
      <button type="button" class="gdoc-btn gdoc-btn-preview" data-action="preview" title="プレビュー表示" aria-label="プレビュー表示">
        <!-- 目アイコン -->
        <svg viewbox="0 0 24 24" aria-hidden="true"><path d="M12 5C7 5 3.1 8 1.5 12 3.1 16 7 19 12 19s8.9-3 10.5-7C20.9 8 17 5 12 5zm0 10a3 3 0 110-6 3 3 0 010 6z"></path></svg>
      </button>
      <button type="button" class="gdoc-btn gdoc-btn-open" data-action="open" title="別タブで開く" aria-label="別タブで開く">
        <!-- 外部リンクアイコン -->
        <svg viewbox="0 0 24 24" aria-hidden="true"><path d="M14 3h7v7h-2V6.41l-9.29 9.3-1.42-1.42 9.3-9.29H14V3z"></path><path d="M5 5h5V3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2v-5h-2v5H5V5z"></path></svg>
      </button>
      <button type="button" class="gdoc-btn gdoc-btn-copy" data-action="copy" title="リンクをコピー" aria-label="リンクをコピー">
        <!-- コピーアイコン -->
        <svg viewbox="0 0 24 24" aria-hidden="true"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></svg>
      </button>
    </div>
  </div>
</div>

<div id="bg-preview-popover" class="gdoc-popover" hidden="">
  <div class="gdoc-popover-inner">
    <div class="gdoc-popover-header">
      <span class="gdoc-popover-title"></span>
    </div>
    <div class="gdoc-popover-actions" role="group" aria-label="ドキュメント内遷移操作">
      <button type="button" class="gdoc-btn gdoc-btn-preview" data-action="preview" title="プレビュー表示" aria-label="プレビュー表示">
        <svg viewbox="0 0 24 24" aria-hidden="true"><path d="M12 5C7 5 3.1 8 1.5 12 3.1 16 7 19 12 19s8.9-3 10.5-7C20.9 8 17 5 12 5zm0 10a3 3 0 110-6 3 3 0 010 6z"></path></svg>
      </button>
      <button type="button" class="gdoc-btn gdoc-btn-go" data-action="go" title="リンク先に遷移" aria-label="リンク先に遷移">
        <svg viewbox="0 0 24 24" aria-hidden="true"><path d="M12 4l-1.41 1.41L16.17 11H4v2h12.17l-5.58 5.59L12 20l8-8z"></path></svg>
      </button>
      <button type="button" class="gdoc-btn gdoc-btn-toast" data-action="toast" title="トーストへ格納" aria-label="トーストへ格納">
        <svg viewbox="0 0 24 24" aria-hidden="true"><path d="M17 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V7l-4-4zm-5 16c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3zm3-10H5V5h10v4z"></path></svg>
      </button>
      <button type="button" class="gdoc-btn gdoc-btn-close" data-action="close" title="閉じる" aria-label="閉じる">
        <svg viewbox="0 0 24 24" aria-hidden="true"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"></path></svg>
      </button>
    </div>
  </div>
</div>

<div id="gdoc-preview-modal" class="gdoc-modal" hidden="">
  <div class="gdoc-modal-dialog" role="dialog" aria-label="Googleドキュメント プレビュー">
    <div class="gdoc-resize-handle gdoc-resize-handle-nw" data-resize-dir="nw"></div>
    <div class="gdoc-resize-handle gdoc-resize-handle-ne" data-resize-dir="ne"></div>
    <div class="gdoc-resize-handle gdoc-resize-handle-sw" data-resize-dir="sw"></div>
    <div class="gdoc-resize-handle gdoc-resize-handle-se" data-resize-dir="se"></div>
    <div class="gdoc-modal-header">
      <div class="gdoc-modal-title"></div>
      <div class="gdoc-modal-header-actions">
        <button type="button" class="gdoc-modal-btn gdoc-modal-btn-reload" title="再読み込み" aria-label="再読み込み">
          <svg viewbox="0 0 24 24" aria-hidden="true"><path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"></path></svg>
        </button>
        <button type="button" class="gdoc-modal-btn gdoc-modal-btn-copy" title="リンクをコピー" aria-label="リンクをコピー">
          <svg viewbox="0 0 24 24" aria-hidden="true"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></svg>
        </button>
        <button type="button" class="gdoc-modal-btn gdoc-modal-btn-open" title="別タブで開く" aria-label="別タブで開く">
          <svg viewbox="0 0 24 24" aria-hidden="true"><path d="M14 3h7v7h-2V6.41l-9.29 9.3-1.42-1.42 9.3-9.29H14V3z"></path><path d="M5 5h5V3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2v-5h-2v5H5V5z"></path></svg>
        </button>
        <button type="button" class="gdoc-modal-btn gdoc-modal-btn-jump" title="本文へ移動" aria-label="本文へ移動">
          <svg viewbox="0 0 24 24" aria-hidden="true"><path d="M12 2c-.55 0-1 .45-1 1v12.59l-4.3-4.3a1 1 0 10-1.4 1.42l6 6a1 1 0 001.4 0l6-6a1 1 0 10-1.4-1.42L13 15.59V3c0-.55-.45-1-1-1z"></path></svg>
        </button>
        <button type="button" class="gdoc-modal-btn gdoc-modal-btn-close" title="閉じる" aria-label="ポップアップを閉じる">
          <svg viewbox="0 0 24 24" aria-hidden="true"><path d="M5.293 6.707l5.293 5.293-5.293 5.293c-.39.39-.39 1.024 0 1.414s1.024.39 1.414 0l5.293-5.293 5.293 5.293c.39.39 1.024.39 1.414 0s.39-1.024 0-1.414L13.414 12l5.293-5.293c.39-.39.39-1.024 0-1.414s-1.024-.39-1.414 0L12 10.586 6.707 5.293c-.39-.39-1.024-.39-1.414 0s-.39 1.024 0 1.414z"></path></svg>
        </button>
      </div>
    </div>
    <div class="gdoc-modal-body">
      <iframe class="gdoc-modal-iframe" src="about:blank" loading="lazy"></iframe>
      <div class="bg-preview-body"></div>
    </div>
</div>
</div>

<div id="gdoc-preview-toast-container" class="gdoc-toast-container" aria-live="polite" aria-atomic="false">
  <div class="gdoc-toast-container-inner"></div>
</div>

<div id="gdoc-preview-list-modal" class="gdoc-list-modal" hidden="">
  <div class="gdoc-list-modal-dialog" role="dialog" aria-modal="true" aria-label="他のプレビュー文書一覧">
    <div class="gdoc-list-modal-header">
      <div class="gdoc-list-modal-title">プレビュー中の文書</div>
      <button type="button" class="gdoc-list-modal-close" aria-label="閉じる">×</button>
    </div>
    <div class="gdoc-list-modal-body">
      <ul class="gdoc-list"></ul>
    </div>
  </div>
</div>

<script>
(function () {
  'use strict';

  var MOBILE_MAX_WIDTH = 768; // ビューポート幅による PC/モバイル判定
  var STORAGE_KEY = 'gdocPreviewState_v2';
  var ZOOM_MIN = 0.5;
  var ZOOM_MAX = 2.0;
  var ZOOM_STEP = 0.05;

  // ブラウザの自動スクロール復元を無効化（自前で制御する）
  if (history && typeof history.scrollRestoration === 'string') {
    try { history.scrollRestoration = 'manual'; } catch (e) {}
  }

  var popover = document.getElementById('gdoc-preview-popover');
  var titleEl = popover ? popover.querySelector('.gdoc-popover-title') : null;
  var previewBtn = popover ? popover.querySelector('.gdoc-btn-preview') : null;
  var openBtn = popover ? popover.querySelector('.gdoc-btn-open') : null;
  var copyBtn = popover ? popover.querySelector('.gdoc-btn-copy') : null;

  var bgPopover = document.getElementById('bg-preview-popover');
  var bgTitleEl = bgPopover ? bgPopover.querySelector('.gdoc-popover-title') : null;
  var bgPreviewBtn = bgPopover ? bgPopover.querySelector('.gdoc-btn-preview') : null;
  var bgGoBtn = bgPopover ? bgPopover.querySelector('.gdoc-btn-go') : null;
  var bgToastBtn = bgPopover ? bgPopover.querySelector('.gdoc-btn-toast') : null;
  var bgCloseBtn = bgPopover ? bgPopover.querySelector('.gdoc-btn-close') : null;

  var modal = document.getElementById('gdoc-preview-modal');
  var modalDialog = modal ? modal.querySelector('.gdoc-modal-dialog') : null;
  var modalHeader = modal ? modal.querySelector('.gdoc-modal-header') : null;
  var modalTitle = modal ? modal.querySelector('.gdoc-modal-title') : null;
  var modalIframe = modal ? modal.querySelector('.gdoc-modal-iframe') : null;
  var bgPreviewBody = modal ? modal.querySelector('.bg-preview-body') : null;
  var modalBtnClose = modal ? modal.querySelector('.gdoc-modal-btn-close') : null;
  var modalBtnOpen = modal ? modal.querySelector('.gdoc-modal-btn-open') : null;
  var modalBtnReload = modal ? modal.querySelector('.gdoc-modal-btn-reload') : null;
  var modalBtnCopy = modal ? modal.querySelector('.gdoc-modal-btn-copy') : null;
  var modalBtnJump = modal ? modal.querySelector('.gdoc-modal-btn-jump') : null;
  var resizeHandles = modalDialog ? modalDialog.querySelectorAll('.gdoc-resize-handle') : [];

  var toastContainer = document.getElementById('gdoc-preview-toast-container');
  var toastInner = toastContainer ? toastContainer.querySelector('.gdoc-toast-container-inner') : null;

  var listModal = document.getElementById('gdoc-preview-list-modal');
  var listModalDialog = listModal ? listModal.querySelector('.gdoc-list-modal-dialog') : null;
  var listModalClose = listModal ? listModal.querySelector('.gdoc-list-modal-close') : null;
  var listEl = listModal ? listModal.querySelector('.gdoc-list') : null;

  if (!popover || !titleEl || !previewBtn || !openBtn || !copyBtn || !bgPopover || !bgTitleEl || !bgPreviewBtn || !bgGoBtn || !bgToastBtn || !bgCloseBtn || !modal || !modalDialog || !modalHeader || !modalTitle || !modalIframe || !bgPreviewBody || !modalBtnClose || !modalBtnOpen || !modalBtnReload || !modalBtnCopy || !modalBtnJump || !toastContainer || !toastInner || !listModal || !listModalDialog || !listModalClose || !listEl) {
    return;
  }

  var currentLink = null; // ポップオーバー対象リンク（Docs用）
  var currentBgLink = null; // ポップオーバー対象リンク（BG用）
  var hideTimer = null;
  var bgHideTimer = null;
  var showTimer = null; // Docs用ポップオーバー表示遅延タイマー
  var bgShowTimer = null; // BG用ポップオーバー表示遅延タイマー
  var POPOVER_SHOW_DELAY = 400; // ポップオーバー表示までの遅延（ms）
  var isDragging = false;
  var dragStartX = 0;
  var dragStartY = 0;
  var dialogStartLeft = 0;
  var dialogStartTop = 0;

  var isResizing = false;
  var resizeDir = '';
  var resizeStartX = 0;
  var resizeStartY = 0;
  var startWidth = 0;
  var startHeight = 0;
  var startLeft = 0;
  var startTop = 0;

  var isMouseDownOnHeader = false;
  var headerMouseDownX = 0;
  var headerMouseDownY = 0;

  var isMobile = false;
  var state = loadState();
  var currentKey = getActiveKeyFromState(state) || null;
  var currentZoom = 1.0;

  // ---- state persistence ----
  function loadState() {
    try {
      var raw = window.localStorage.getItem(STORAGE_KEY);
      if (!raw) return { items: [], lastGeometry: null };
      var parsed = JSON.parse(raw);
      if (!parsed || !Array.isArray(parsed.items)) {
        return { items: [], lastGeometry: null };
      }
      // 既存アイテムにkindがない場合はgdocとして扱う
      for (var i = 0; i < parsed.items.length; i++) {
        if (!parsed.items[i].kind) {
          parsed.items[i].kind = 'gdoc';
        }
      }
      return parsed;
    } catch (e) {
      return { items: [], lastGeometry: null };
    }
  }

  function saveState() {
    try {
      window.localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
    } catch (e) {
      // ignore
    }
  }

  function getActiveKeyFromState(s) {
    if (!s || !Array.isArray(s.items)) return null;
    for (var i = 0; i < s.items.length; i++) {
      if (s.items[i].state === 'active') return s.items[i].key;
    }
    return null;
  }

  function getPreviewKeyFromLink(link) {
    if (!link) return null;
    // プレビューURLがあればそれをキーにする（同じドキュメント内の別タブも区別）
    var previewUrl = link.dataset.gdocPreviewUrl;
    if (previewUrl) return 'preview:' + previewUrl;
    var id = link.dataset.gdocId;
    if (id) return 'id:' + id;
    return 'href:' + link.href;
  }

  // 各リンク要素にプレビューキーを紐付けておく（本文ジャンプ用）
  function initializeLinkKeys() {
    try {
      var links = document.querySelectorAll('a.gdoc-link[data-gdoc-title]');
      for (var i = 0; i < links.length; i++) {
        var link = links[i];
        var key = getPreviewKeyFromLink(link);
        if (key) {
          link.setAttribute('data-gdoc-key', key);
        }
      }
    } catch (e) {
      // ignore
    }
  }

  // 初期化直後にキーを付与
  initializeLinkKeys();

  function ensureItemForLink(link, previewUrl) {
    var key = getPreviewKeyFromLink(link);
    if (!key) return null;
    var title = link.dataset.gdocTitle || link.textContent || link.href || '';
    var href = link.href;
    var items = state.items;
    var item = null;
    for (var i = 0; i < items.length; i++) {
      if (items[i].key === key) {
        item = items[i];
        break;
      }
    }
    if (!item) {
      var sourceElement = link.closest('[id]') || link;
      item = {
        key: key,
        kind: 'gdoc',
        id: link.dataset.gdocId || null,
        href: href,
        previewUrl: previewUrl,
        title: title,
        state: 'active',
        position: null,
        size: null,
        zoom: 1.0,
        lastUpdated: Date.now(),
        sourceId: sourceElement && sourceElement.id ? sourceElement.id : null,
        sourceUrl: window.location.href.split('#')[0]
      };
      if (state.lastGeometry) {
        item.position = {
          left: state.lastGeometry.left,
          top: state.lastGeometry.top
        };
        item.size = {
          width: state.lastGeometry.width,
          height: state.lastGeometry.height
        };
        item.zoom = state.lastGeometry.zoom || 1.0;
      }
      state.items.push(item);
    } else {
      item.href = href;
      item.previewUrl = previewUrl;
      item.title = title;
      item.lastUpdated = Date.now();
      if (!item.sourceUrl) {
        var srcEl = link.closest('[id]') || link;
        item.sourceId = srcEl && srcEl.id ? srcEl.id : (item.sourceId || null);
        item.sourceUrl = window.location.href.split('#')[0];
      }
    }
    return item;
  }

  function getBgPreviewKeyFromLink(link) {
    if (!link) return null;
    var href = link.href || link.getAttribute('href');
    if (!href) return null;
    return 'bg:' + href;
  }

  function ensureBgItemForLink(link) {
    var key = getBgPreviewKeyFromLink(link);
    if (!key) return null;
    var href = link.href || link.getAttribute('href');
    var title = link.textContent || link.getAttribute('title') || href || '';
    var items = state.items;
    var item = null;
    for (var i = 0; i < items.length; i++) {
      if (items[i].key === key) {
        item = items[i];
        break;
      }
    }
    if (!item) {
      var hrefWithoutHash = href.split('#')[0];
      var anchorId = href.indexOf('#') !== -1 ? href.split('#')[1] : null;
      var sourceElement = link.closest('[id]') || link;
      item = {
        key: key,
        kind: 'bg',
        href: href,
        pageUrl: hrefWithoutHash,
        anchorId: anchorId,
        title: title,
        state: 'active',
        position: null,
        size: null,
        zoom: 1.0,
        lastUpdated: Date.now(),
        snippetHtml: null,
        sourceId: sourceElement && sourceElement.id ? sourceElement.id : null,
        sourceUrl: window.location.href.split('#')[0]
      };
      if (state.lastGeometry) {
        item.position = {
          left: state.lastGeometry.left,
          top: state.lastGeometry.top
        };
        item.size = {
          width: state.lastGeometry.width,
          height: state.lastGeometry.height
        };
        item.zoom = state.lastGeometry.zoom || 1.0;
      }
      state.items.push(item);
    } else {
      // 既存のアイテムが見つかった場合
      item.title = title;
      item.lastUpdated = Date.now();
      if (!item.sourceUrl) {
        var srcEl = link.closest('[id]') || link;
        item.sourceId = srcEl && srcEl.id ? srcEl.id : (item.sourceId || null);
        item.sourceUrl = window.location.href.split('#')[0];
      }
      // minimized状態の場合は何もしない（activatePreviewItemで処理される）
    }
    return item;
  }

  function findItemByKey(key) {
    if (!key) return null;
    var items = state.items;
    for (var i = 0; i < items.length; i++) {
      if (items[i].key === key) return items[i];
    }
    return null;
  }

  function setActiveItem(item) {
    if (!item) return;
    var items = state.items;
    for (var i = 0; i < items.length; i++) {
      if (items[i].key === item.key) {
        items[i].state = 'active';
      } else if (items[i].state === 'active') {
        items[i].state = 'minimized';
      }
    }
    item.state = 'active';
    currentKey = item.key;
    item.lastUpdated = Date.now();
    saveState();
  }

  function closeItemByKey(key) {
    if (!key) return;
    var items = state.items;
    var newItems = [];
    for (var i = 0; i < items.length; i++) {
      if (items[i].key !== key) newItems.push(items[i]);
    }
    state.items = newItems;
    if (currentKey === key) {
      currentKey = null;
    }
    saveState();
    if (!isMobile) {
      rebuildToasts();
    }
  }

  function getActiveItem() {
    if (currentKey) {
      var byKey = findItemByKey(currentKey);
      if (byKey && byKey.state === 'active') return byKey;
    }
    if (!state || !Array.isArray(state.items)) return null;
    for (var i = 0; i < state.items.length; i++) {
      if (state.items[i].state === 'active') {
        currentKey = state.items[i].key;
        return state.items[i];
      }
    }
    return null;
  }

  function updateLastGeometryFromActive() {
    var item = getActiveItem();
    if (!item) return;
    if (!item.position || !item.size) return;
    state.lastGeometry = {
      left: item.position.left,
      top: item.position.top,
      width: item.size.width,
      height: item.size.height,
      zoom: item.zoom || 1.0
    };
    saveState();
  }

  // ---- layout mode ----
  function updateMode() {
    isMobile = window.innerWidth <= MOBILE_MAX_WIDTH;
    if (isMobile) {
      modal.classList.add('gdoc-modal-mobile');
      if (toastContainer) {
        toastContainer.style.display = 'none';
      }
      if (!listModal.hidden) {
        listModal.hidden = true;
      }
    } else {
      modal.classList.remove('gdoc-modal-mobile');
      if (toastContainer) {
        toastContainer.style.display = '';
      }
      rebuildToasts();
      var activeItem = getActiveItem();
      if (activeItem) {
        applyGeometry(activeItem);
        applyZoom(activeItem.zoom || 1.0);
      }
    }
  }

  window.addEventListener('resize', function () {
    updateMode();
  });

  // ---- popover (リンク横UI) ----
  function showPopoverForLink(link) {
    if (!link || !link.dataset || !link.dataset.gdocTitle) return;
    currentLink = link;

    var rect = link.getBoundingClientRect();
    titleEl.textContent = link.dataset.gdocTitle || link.textContent || '';

    var top = rect.bottom + window.scrollY + 8;
    var left = rect.left + window.scrollX;

    popover.style.top = top + 'px';
    popover.style.left = left + 'px';
    popover.hidden = false;
  }

  function scheduleHidePopover() {
    hideTimer = window.setTimeout(function () {
      popover.hidden = true;
      currentLink = null;
    }, 180);
  }

  function cancelHidePopover() {
    if (hideTimer) {
      window.clearTimeout(hideTimer);
      hideTimer = null;
    }
  }

  function cancelShowPopover() {
    if (showTimer) {
      window.clearTimeout(showTimer);
      showTimer = null;
    }
  }

  document.addEventListener('mouseover', function (e) {
    var link = e.target.closest && e.target.closest('a.gdoc-link[data-gdoc-title]');
    if (!link) return;
    cancelHidePopover();
    cancelShowPopover();
    showTimer = window.setTimeout(function () {
      showPopoverForLink(link);
    }, POPOVER_SHOW_DELAY);
  });

  document.addEventListener('focusin', function (e) {
    var link = e.target.closest && e.target.closest('a.gdoc-link[data-gdoc-title]');
    if (!link) return;
    cancelHidePopover();
    showPopoverForLink(link);
  });

  document.addEventListener('click', function (e) {
    var link = e.target.closest && e.target.closest('a.gdoc-link[data-gdoc-title]');
    if (!link) return;
    e.preventDefault();
    cancelHidePopover();
    showPopoverForLink(link);
  });

  document.addEventListener('mouseout', function (e) {
    var fromLink = e.target.closest && e.target.closest('a.gdoc-link[data-gdoc-title]');
    if (!fromLink) return;
    var to = e.relatedTarget;
    if (to && (to.closest && (to.closest('a.gdoc-link[data-gdoc-title]') || to.closest('#gdoc-preview-popover')))) {
      return;
    }
    cancelShowPopover();
    scheduleHidePopover();
  });

  popover.addEventListener('mouseenter', cancelHidePopover);
  popover.addEventListener('mouseleave', scheduleHidePopover);

  function openLinkInNewTabFromLink(link) {
    if (!link) return;
    window.open(link.href, '_blank', 'noopener');
  }

  function copyLinkFromLink(link) {
    if (!link) return;
    var url = link.href;
    if (navigator.clipboard && navigator.clipboard.writeText) {
      navigator.clipboard.writeText(url).catch(function () {});
      return;
    }
    var tmp = document.createElement('textarea');
    tmp.style.position = 'fixed';
    tmp.style.opacity = '0';
    tmp.value = url;
    document.body.appendChild(tmp);
    tmp.select();
    try { document.execCommand('copy'); } catch (e) {}
    document.body.removeChild(tmp);
  }

  // ポップオーバーのボタン
  previewBtn.addEventListener('click', function () {
    if (!currentLink) return;
    openPreviewFromLink(currentLink);
  });

  openBtn.addEventListener('click', function () {
    if (!currentLink) return;
    openLinkInNewTabFromLink(currentLink);
  });

  copyBtn.addEventListener('click', function () {
    if (!currentLink) return;
    copyLinkFromLink(currentLink);
  });

  // BGプレビュー用ポップオーバーのボタン
  bgPreviewBtn.addEventListener('click', function () {
    if (!currentBgLink) return;
    openBgPreviewFromLink(currentBgLink);
    bgPopover.hidden = true;
  });

  bgGoBtn.addEventListener('click', function () {
    if (!currentBgLink) return;
    window.location.href = currentBgLink.href;
  });

  bgToastBtn.addEventListener('click', function () {
    if (!currentBgLink) return;
    var item = ensureBgItemForLink(currentBgLink);
    if (item) {
      item.state = 'minimized';
      saveState();
      rebuildToasts();
    }
    bgPopover.hidden = true;
  });

  bgCloseBtn.addEventListener('click', function () {
    bgPopover.hidden = true;
    currentBgLink = null;
  });

  function openBgPreviewFromLink(link) {
    var item = ensureBgItemForLink(link);
    if (!item) return;
    activatePreviewItem(item, true);
  }

  function showBgPopoverForLink(link) {
    if (!link) return;
    currentBgLink = link;

    var rect = link.getBoundingClientRect();
    bgTitleEl.textContent = link.textContent || link.getAttribute('title') || 'プレビュー';

    var top = rect.bottom + window.scrollY + 8;
    var left = rect.left + window.scrollX;

    bgPopover.style.top = top + 'px';
    bgPopover.style.left = left + 'px';
    bgPopover.hidden = false;
  }

  function scheduleHideBgPopover() {
    bgHideTimer = window.setTimeout(function () {
      bgPopover.hidden = true;
      currentBgLink = null;
    }, 180);
  }

  function cancelHideBgPopover() {
    if (bgHideTimer) {
      window.clearTimeout(bgHideTimer);
      bgHideTimer = null;
    }
  }

  function cancelShowBgPopover() {
    if (bgShowTimer) {
      window.clearTimeout(bgShowTimer);
      bgShowTimer = null;
    }
  }

  bgPopover.addEventListener('mouseenter', cancelHideBgPopover);
  bgPopover.addEventListener('mouseleave', scheduleHideBgPopover);

  // ---- ポップアップ（プレビューウィンドウ） ----
  function computePreviewUrlFromLink(link) {
    if (!link) return null;
    var previewUrl = link.dataset.gdocPreviewUrl;
    if (previewUrl) return previewUrl;
    var baseUrl = link.dataset.gdocBaseUrl;
    if (!baseUrl) {
      return link.href;
    }
    return baseUrl.replace(/\/$/, '') + '/preview';
  }

  function applyGeometry(item) {
    if (!item || !item.position || !item.size) {
      // デフォルト: 中央
      modalDialog.style.top = '50%';
      modalDialog.style.left = '50%';
      modalDialog.style.transform = 'translate(-50%, -50%)';
      modalDialog.style.width = '';
      modalDialog.style.height = '';
      return;
    }
    var left = item.position.left;
    var top = item.position.top;
    var width = item.size.width;
    var height = item.size.height;

    var minWidth = 320;
    var minHeight = 220;
    var maxWidth = Math.min(window.innerWidth - 40, 1400);
    var maxHeight = window.innerHeight - 40;

    if (width < minWidth) width = minWidth;
    if (height < minHeight) height = minHeight;
    if (width > maxWidth) width = maxWidth;
    if (height > maxHeight) height = maxHeight;

    if (left + width > window.innerWidth - 10) {
      left = window.innerWidth - 10 - width;
    }
    if (top + height > window.innerHeight - 10) {
      top = window.innerHeight - 10 - height;
    }
    if (left < 0) left = 0;
    if (top < 0) top = 0;

    modalDialog.style.transform = 'none';
    modalDialog.style.left = left + 'px';
    modalDialog.style.top = top + 'px';
    modalDialog.style.width = width + 'px';
    modalDialog.style.height = height + 'px';
  }

  function applyZoom(z) {
    // ズーム機能を廃止し、常に等倍表示に固定する
    currentZoom = 1.0;
    modalIframe.style.transform = 'scale(1)';
  }

  function openPreviewFromLink(link) {
    var previewUrl = computePreviewUrlFromLink(link);
    if (!previewUrl) return;

    var item = ensureItemForLink(link, previewUrl);
    if (!item) return;
    activatePreviewItem(item, true);
  }

  function loadBgSnippetForItem(item, callback) {
    if (!item || item.kind !== 'bg') {
      if (callback) callback(null);
      return;
    }

    if (item.snippetHtml) {
      if (callback) callback(item.snippetHtml);
      return;
    }

    // 単一HTMLファイル（index_single.html）を検出
    var isSinglePage = window.location.pathname.indexOf('index_single.html') !== -1 || 
                       document.querySelector('section.chapter-page') !== null;
    
    console.log('loadBgSnippetForItem:', {
      pageUrl: item.pageUrl,
      anchorId: item.anchorId,
      isSinglePage: isSinglePage,
      pathname: window.location.pathname
    });
    
    // 単一HTMLファイルの場合は常にページセクションから抽出
    if (isSinglePage) {
      console.log('Single-page mode: extracting from page section');
      var snippet = extractSnippetFromSinglePage(item.pageUrl, item.anchorId);
      if (snippet) {
        item.snippetHtml = snippet;
        saveState();
        if (callback) callback(snippet);
        return;
      } else {
        console.warn('Failed to extract from single page, trying current page');
        // フォールバック: 現在のページから抽出
        snippet = extractSnippetFromCurrentPage(item.anchorId);
        item.snippetHtml = snippet;
        saveState();
        if (callback) callback(snippet);
        return;
      }
    }
    
    // 個別HTMLファイルの場合
    var currentPageUrl = window.location.href.split('#')[0];
    var isSamePage = !item.pageUrl || item.pageUrl === '' || item.pageUrl === currentPageUrl;

    if (isSamePage) {
      var snippet = extractSnippetFromCurrentPage(item.anchorId);
      item.snippetHtml = snippet;
      saveState();
      if (callback) callback(snippet);
    } else {
      // 相対パスを絶対URLに変換
      var absoluteUrl = item.pageUrl;
      try {
        absoluteUrl = new URL(item.pageUrl, window.location.href).href;
      } catch (e) {
        console.warn('Failed to resolve URL', item.pageUrl, e);
      }
      
      console.log('Loading BG preview from:', absoluteUrl);
      
      // file:// プロトコルの場合はXHRを使用（fetchはCORS制限がある）
      var isFileProtocol = window.location.protocol === 'file:' || absoluteUrl.indexOf('file:') === 0;
      
      if (isFileProtocol) {
        // XMLHttpRequestを使用（同期的に読み込む）
        try {
          var xhr = new XMLHttpRequest();
          xhr.open('GET', absoluteUrl, true);
          xhr.onload = function () {
            if (xhr.status === 200 || xhr.status === 0) {
              var html = xhr.responseText;
              var snippet = extractSnippetFromHtml(html, item.anchorId, item.pageUrl);
              item.snippetHtml = snippet;
              saveState();
              if (callback) callback(snippet);
            } else {
              console.warn('XHR failed with status:', xhr.status);
              if (callback) callback('<p>プレビューの読み込みに失敗しました。<br>Status: ' + xhr.status + '</p>');
            }
          };
          xhr.onerror = function () {
            console.warn('XHR error loading:', absoluteUrl);
            var errorMsg = '<p>プレビューの読み込みに失敗しました。</p>';
            errorMsg += '<p style="font-size:0.9em;color:#666;">file://プロトコルではブラウザのセキュリティ制限により、別ページの読み込みができません。</p>';
            errorMsg += '<p style="font-size:0.9em;color:#666;">以下のいずれかの方法をお試しください：</p>';
            errorMsg += '<ol style="font-size:0.9em;color:#666;margin-left:20px;">';
            errorMsg += '<li>HTTPサーバーを起動：<pre style="background:#f5f5f5;padding:10px;border-radius:4px;font-size:0.85em;margin:5px 0;">cd out<br>python3 -m http.server 8000<br>open http://localhost:8000/content/' + window.location.pathname.split('/').pop() + '</pre></li>';
            errorMsg += '<li>単一HTMLファイルを使用：<pre style="background:#f5f5f5;padding:10px;border-radius:4px;font-size:0.85em;margin:5px 0;">open out/index_single.html</pre></li>';
            errorMsg += '</ol>';
            if (callback) callback(errorMsg);
          };
          xhr.send();
        } catch (e) {
          console.warn('XHR exception:', e);
          if (callback) callback('<p>プレビューの読み込みに失敗しました。<br>Error: ' + e.message + '</p>');
        }
      } else {
        // HTTPプロトコルの場合はfetchを使用
        fetch(absoluteUrl)
          .then(function (response) {
            if (!response.ok) {
              throw new Error('HTTP ' + response.status + ': ' + response.statusText);
            }
            return response.text();
          })
          .then(function (html) {
            var snippet = extractSnippetFromHtml(html, item.anchorId, item.pageUrl);
            item.snippetHtml = snippet;
            saveState();
            if (callback) callback(snippet);
          })
          .catch(function (err) {
            console.warn('Failed to load BG preview content', err, 'URL:', absoluteUrl);
            if (callback) callback('<p>プレビューの読み込みに失敗しました。<br>URL: ' + item.pageUrl + '</p>');
          });
      }
    }
  }

  function extractSnippetFromSinglePage(pageUrl, anchorId) {
    // 単一HTMLファイルから該当ページのセクションを抽出
    console.log('extractSnippetFromSinglePage:', { pageUrl: pageUrl, anchorId: anchorId });
    
    // pageUrlが空の場合は現在のページから抽出
    if (!pageUrl || pageUrl === '') {
      console.log('No pageUrl, using current page');
      return extractSnippetFromCurrentPage(anchorId);
    }
    
    // pageUrl: "05_ch05.html" -> "05_ch05"
    var pageName = pageUrl.replace(/\.html.*$/, '').replace(/^.*\//, '');
    var pageId = 'page-' + pageName;
    
    console.log('Searching for single-page section:', pageId, 'pageName:', pageName);
    
    // ページセクションを探す
    var pageSection = document.getElementById(pageId);
    if (!pageSection) {
      // 別の形式も試す
      console.log('Trying alternative selectors...');
      var alternatives = [
        'section[id="' + pageId + '"]',
        'section[id*="' + pageName + '"]',
        'section.chapter-page[id*="' + pageName + '"]'
      ];
      
      for (var i = 0; i < alternatives.length; i++) {
        try {
          pageSection = document.querySelector(alternatives[i]);
          if (pageSection) {
            console.log('Found by alternative selector:', alternatives[i]);
            break;
          }
        } catch (e) {
          // 無効なセレクタの場合
        }
      }
    }
    
    if (!pageSection) {
      console.warn('Page section not found:', pageId);
      // 利用可能なページセクションを表示
      var sections = document.querySelectorAll('section.chapter-page');
      var sectionIds = [];
      for (var j = 0; j < Math.min(10, sections.length); j++) {
        sectionIds.push(sections[j].id);
      }
      console.log('Available page sections:', sectionIds);
      
      // フォールバック: 現在のページから抽出
      return extractSnippetFromCurrentPage(anchorId);
    }
    
    console.log('Found page section:', pageSection.id);
    
    // セクション全体を取得
    var clone = pageSection.cloneNode(true);
    removeUiElements(clone);
    
    // 脚注参照の数を確認
    var refsInClone = clone.querySelectorAll('a[role="doc-noteref"], a.footnote-ref');
    console.log('extractSnippetFromSinglePage: Found', refsInClone.length, 'footnote refs in clone');
    
    inlineFootnotes(clone, document);
    simplifyComments(clone);
    fixRelativeLinks(clone, '');
    
    return clone.innerHTML || '';
  }

  function extractSnippetFromCurrentPage(anchorId) {
    var target = anchorId ? document.getElementById(anchorId) : null;
    
    // セクション全体を取得（章レベル）
    var section = target ? target.closest('section') : document.getElementById('quarto-document-content');
    if (!section) section = document.getElementById('quarto-document-content');
    if (!section) return '<p>コンテンツが見つかりません。</p>';

    console.log('extractSnippetFromCurrentPage: Cloning section', section.id || section.className);
    
    var clone = section.cloneNode(true);
    removeUiElements(clone);
    
    // 脚注参照の数を確認
    var refsInClone = clone.querySelectorAll('a[role="doc-noteref"], a.footnote-ref');
    console.log('extractSnippetFromCurrentPage: Found', refsInClone.length, 'footnote refs in clone');
    
    inlineFootnotes(clone, document);
    simplifyComments(clone);
    fixRelativeLinks(clone, '');
    return clone.innerHTML || '';
  }

  function fixRelativeLinks(container, baseUrl) {
    // プレビュー内のリンクを絶対パスに変換
    var links = container.querySelectorAll('a[href]');
    for (var i = 0; i < links.length; i++) {
      var link = links[i];
      var href = link.getAttribute('href');
      if (href && !href.match(/^https?:/) && !href.match(/^#/)) {
        try {
          var absolute = new URL(href, window.location.href).href;
          link.setAttribute('href', absolute);
        } catch (e) {
          // ignore
        }
      }
    }
  }

  function extractSnippetFromHtml(html, anchorId, pageUrl) {
    try {
      var parser = new DOMParser();
      var doc = parser.parseFromString(html, 'text/html');
      var target = anchorId ? doc.getElementById(anchorId) : null;
      
      // セクション全体を取得（章レベル）
      var section = target ? target.closest('section') : doc.getElementById('quarto-document-content');
      if (!section) section = doc.getElementById('quarto-document-content');
      if (!section) return '<p>コンテンツが見つかりません。</p>';

      var clone = section.cloneNode(true);
      removeUiElements(clone);
      inlineFootnotes(clone, doc);
      simplifyComments(clone);
      fixRelativeLinks(clone, pageUrl);
      
      return clone.innerHTML || '';
    } catch (e) {
      console.warn('Failed to parse HTML', e);
      return '<p>コンテンツの解析に失敗しました。</p>';
    }
  }

  function removeUiElements(container) {
    var selectors = [
      'header', '.header-ui', '#quarto-sidebar', '#quarto-margin-sidebar',
      '.right-comments', '.left-panel', '.right-panel', 'nav', '.navbar'
    ];
    selectors.forEach(function (sel) {
      var elements = container.querySelectorAll(sel);
      for (var i = 0; i < elements.length; i++) {
        elements[i].parentNode.removeChild(elements[i]);
      }
    });
  }

  function inlineFootnotes(container, sourceDoc) {
    var refSelector = 'a[role="doc-noteref"], a.footnote-ref';
    var refs = container.querySelectorAll(refSelector);
    
    console.log('inlineFootnotes: Found', refs.length, 'footnote references');
    
    // 既に処理済みかチェック（インラインマーカーが存在する場合）
    var existingMarkers = container.querySelectorAll('.inline-footnote');
    if (existingMarkers.length > 0 && refs.length === 0) {
      console.log('inlineFootnotes: Already processed (found', existingMarkers.length, 'markers)');
      return;
    }
    
    if (!refs.length) {
      console.log('inlineFootnotes: No footnote references found');
      return;
    }

    var doc = sourceDoc || document;
    
    // 脚注参照を配列に変換して、段落ごとにグループ化
    var refsByHost = new Map();
    
    for (var i = 0; i < refs.length; i++) {
      var ref = refs[i];
      var href = ref.getAttribute('href') || ref.getAttribute('data-footnote-href');
      if (!href || !href.startsWith('#')) continue;
      
      var host = findHostParagraph(ref);
      if (!host) continue;
      
      if (!refsByHost.has(host)) {
        refsByHost.set(host, []);
      }
      refsByHost.get(host).push(ref);
    }
    
    console.log('Found', refsByHost.size, 'host paragraphs with footnotes');
    
    // 各段落の脚注を処理
    refsByHost.forEach(function (hostRefs, host) {
      console.log('Processing', hostRefs.length, 'footnotes for paragraph:', host.textContent.substring(0, 50));
      
      // 脚注コンテナを作成
      var footnotesWrapper = document.createElement('div');
      footnotesWrapper.className = 'footnotes-wrapper';
      footnotesWrapper.style.cssText = 'margin: 0.5em 0;';
      
      // 各脚注を処理
      for (var j = 0; j < hostRefs.length; j++) {
        var ref = hostRefs[j];
        var href = ref.getAttribute('href') || ref.getAttribute('data-footnote-href');
        if (!href || !href.startsWith('#')) continue;
        
        var id = href.slice(1);
        // まずcontainer内を探し、なければsourceDocから探す
        var target = container.querySelector('#' + id);
        if (!target && doc) {
          target = doc.getElementById ? doc.getElementById(id) : doc.querySelector('#' + id);
        }
        if (!target) {
          console.warn('Footnote target not found:', id);
          continue;
        }
        
        var numberText = (ref.textContent || '').replace(/[^0-9]/g, '') || '';
        
        var clone = target.cloneNode(true);
        var backlinks = clone.querySelectorAll('.footnote-back, .footnote-backref, [role="doc-backlink"]');
        for (var k = 0; k < backlinks.length; k++) {
          backlinks[k].parentNode.removeChild(backlinks[k]);
        }
        
        var fnContainer = document.createElement('div');
        fnContainer.className = 'footnote-inline';
        fnContainer.style.cssText = 'margin: 0.3em 0; padding: 0.5em 1em; background: #f8f9fa; border-left: 3px solid #1a73e8; font-size: 0.9em;';
        
        var numSpan = document.createElement('span');
        numSpan.className = 'footnote-num';
        numSpan.style.fontWeight = 'bold';
        numSpan.textContent = (numberText ? numberText : '') + '. ';
        fnContainer.appendChild(numSpan);
        
        while (clone.firstChild) {
          fnContainer.appendChild(clone.firstChild);
        }
        
        footnotesWrapper.appendChild(fnContainer);
        
        // 元の脚注参照をインラインマーカーに置き換え
        if (ref.parentNode) {
          var marker = document.createElement('span');
          marker.className = 'inline-footnote';
          marker.style.cssText = 'color: #1a73e8; font-size: 0.9em; margin-left: 2px; font-weight: 600;';
          marker.textContent = '[' + numberText + ']';
          ref.parentNode.replaceChild(marker, ref);
        }
      }
      
      // 段落の直後に脚注ラッパーを挿入
      if (host.nextSibling) {
        host.parentNode.insertBefore(footnotesWrapper, host.nextSibling);
      } else {
        host.parentNode.appendChild(footnotesWrapper);
      }
      
      console.log('Inserted footnotes wrapper after paragraph');
    });
    
    console.log('Finished processing footnotes');
  }

  function findHostParagraph(el) {
    var p = el;
    while (p && p !== document.body) {
      if (p.tagName === 'P' || p.tagName === 'LI') {
        return p;
      }
      p = p.parentElement;
    }
    return null;
  }

  function getElementKey(el) {
    if (!el) return '';
    if (el.id) return 'id:' + el.id;
    var parent = el.parentNode;
    if (!parent) return '';
    var siblings = parent.children;
    for (var i = 0; i < siblings.length; i++) {
      if (siblings[i] === el) {
        return 'idx:' + i;
      }
    }
    return '';
  }

  function scrollToAnchorInPreview(container, anchorId) {
    if (!container || !anchorId) {
      console.warn('scrollToAnchorInPreview: missing container or anchorId');
      return false;
    }
    
    console.log('Searching for anchor:', anchorId, 'in container');
    
    // 単一HTMLファイルの場合、プレフィックス付きIDも試す
    var isSinglePage = window.location.pathname.indexOf('index_single.html') !== -1 || 
                       document.querySelector('section.chapter-page') !== null;
    var anchorVariants = [anchorId];
    
    if (isSinglePage) {
      // ページ名のプレフィックスを試す（例: 05_ch05--toc-5-4-1）
      var pageNames = ['05_ch05', '04_ch04', '03_ch03', '02_ch02', '01_ch01', '06_ch06'];
      for (var p = 0; p < pageNames.length; p++) {
        anchorVariants.push(pageNames[p] + '--' + anchorId);
      }
    }
    
    // アンカー要素を探す（複数の方法を試す）
    var target = null;
    
    // 全てのバリアントを試す
    for (var v = 0; v < anchorVariants.length && !target; v++) {
      var currentAnchorId = anchorVariants[v];
      
      // 方法1: 直接ID検索（特殊文字をエスケープせずに試す）
      try {
        var selector = '#' + currentAnchorId.replace(/[!"#$%&'()*+,.\/:;<=>?@[\\\]^`{|}~]/g, '\\$&');
        target = container.querySelector(selector);
        if (target) {
          console.log('Found by escaped selector (variant ' + v + '):', currentAnchorId);
          anchorId = currentAnchorId; // 見つかったIDを使用
          break;
        }
      } catch (e) {
        // 次の方法を試す
      }
    }
    
    if (!target) {
      console.log('Method 1 failed for all variants');
    }
    
    // 方法2: CSS.escapeを使用（全バリアント）
    if (!target) {
      for (var v2 = 0; v2 < anchorVariants.length && !target; v2++) {
        try {
          if (typeof CSS !== 'undefined' && CSS.escape) {
            target = container.querySelector('#' + CSS.escape(anchorVariants[v2]));
            if (target) {
              console.log('Found by CSS.escape (variant ' + v2 + '):', anchorVariants[v2]);
              anchorId = anchorVariants[v2];
              break;
            }
          }
        } catch (e) {
          // 次を試す
        }
      }
    }
    
    // 方法3: data-anchor-id属性で検索（全バリアント）
    if (!target) {
      for (var v3 = 0; v3 < anchorVariants.length && !target; v3++) {
        try {
          target = container.querySelector('[data-anchor-id="' + anchorVariants[v3] + '"]');
          if (target) {
            console.log('Found by data-anchor-id (variant ' + v3 + '):', anchorVariants[v3]);
            anchorId = anchorVariants[v3];
            break;
          }
        } catch (e) {
          // 次を試す
        }
      }
    }
    
    // 方法4: id属性を直接検索（全要素をスキャン、全バリアント）
    if (!target) {
      var allElements = container.querySelectorAll('[id]');
      console.log('Scanning', allElements.length, 'elements with id');
      for (var i = 0; i < allElements.length; i++) {
        for (var v4 = 0; v4 < anchorVariants.length; v4++) {
          if (allElements[i].id === anchorVariants[v4]) {
            target = allElements[i];
            console.log('Found by direct scan at index', i, 'variant:', anchorVariants[v4]);
            anchorId = anchorVariants[v4];
            break;
          }
        }
        if (target) break;
      }
    }
    
    // 方法5: spanタグの中を探す（idx-アンカーの場合、全バリアント）
    if (!target) {
      var spans = container.querySelectorAll('span[id]');
      for (var j = 0; j < spans.length; j++) {
        for (var v5 = 0; v5 < anchorVariants.length; v5++) {
          if (anchorVariants[v5].indexOf('idx-') !== -1 && spans[j].id === anchorVariants[v5]) {
            target = spans[j];
            console.log('Found idx anchor in span, variant:', anchorVariants[v5]);
            anchorId = anchorVariants[v5];
            break;
          }
        }
        if (target) break;
      }
    }
    
    // 方法6: toc-X-Y-Z形式の場合、セクション番号から推測
    if (!target && anchorId.match(/^toc-\d+-\d+(-\d+)?$/)) {
      console.log('Trying to find section by number pattern:', anchorId);
      // toc-5-4-1 -> 第5章第4節第1項 のようなパターンを探す
      var parts = anchorId.replace('toc-', '').split('-');
      var sectionNum = parts[1]; // 4
      var itemNum = parts[2]; // 1
      
      // 第X節を探す
      var sectionPattern = '第' + sectionNum + '節';
      var sections = container.querySelectorAll('section[id*="' + sectionPattern + '"], h2[id*="' + sectionPattern + '"], h2[data-anchor-id*="' + sectionPattern + '"]');
      console.log('Found sections matching', sectionPattern, ':', sections.length);
      
      if (sections.length > 0) {
        // 第X節が見つかった場合、その中の第Y項を探す
        if (itemNum) {
          var itemPattern = '第' + itemNum + '項';
          var parentSection = sections[0].closest('section') || sections[0].parentElement;
          if (parentSection) {
            var items = parentSection.querySelectorAll('section[id*="' + itemPattern + '"], h3[id*="' + itemPattern + '"], h3[data-anchor-id*="' + itemPattern + '"]');
            console.log('Found items matching', itemPattern, ':', items.length);
            if (items.length > 0) {
              target = items[0];
              console.log('Found by section/item pattern');
            }
          }
        }
        
        // 項が見つからない場合は節を使用
        if (!target) {
          target = sections[0];
          console.log('Using section as fallback');
        }
      }
    }
    
    if (!target) {
      console.warn('Anchor not found in preview after all attempts:', anchorId);
      // デバッグ: 最初の20個のIDを表示
      var ids = [];
      var els = container.querySelectorAll('[id]');
      for (var k = 0; k < Math.min(20, els.length); k++) {
        ids.push(els[k].id);
      }
      console.log('Available IDs (first 20):', ids);
      return false;
    }
    
    console.log('Found anchor:', anchorId, 'Element:', target.tagName, 'ID:', target.id, 'Class:', target.className);
    
    // 索引アンカー（idx-）の場合は、その段落を探す
    if (anchorId.indexOf('idx-') === 0) {
      var paragraph = findHostParagraph(target);
      if (paragraph) {
        console.log('Using host paragraph for idx anchor:', paragraph.tagName);
        target = paragraph;
      }
    }
    
    // 目次アンカー（toc-）の場合は、対応する見出しを探す
    if (anchorId.indexOf('toc-') === 0) {
      // 見出し要素を探す
      if (target.tagName && target.tagName.match(/^H[1-6]$/)) {
        console.log('Target is already a heading');
      } else {
        var heading = target.closest('h1, h2, h3, h4, h5, h6');
        if (heading) {
          console.log('Using heading for toc anchor:', heading.tagName);
          target = heading;
        } else {
          // data-anchor-idを持つ見出しを探す
          var h = container.querySelector('h1[data-anchor-id="' + anchorId + '"], h2[data-anchor-id="' + anchorId + '"], h3[data-anchor-id="' + anchorId + '"], h4[data-anchor-id="' + anchorId + '"]');
          if (h) {
            console.log('Found heading by data-anchor-id:', h.tagName);
            target = h;
          }
        }
      }
    }
    
    // 要素の位置を計算してスクロール
    var targetTop = 0;
    var el = target;
    var iterations = 0;
    while (el && el !== container && iterations < 50) {
      targetTop += el.offsetTop || 0;
      el = el.offsetParent;
      iterations++;
    }
    
    console.log('Scrolling to position:', targetTop, 'Container scrollHeight:', container.scrollHeight);
    
    // スクロール実行
    if (container.scrollTo) {
      container.scrollTo({
        top: targetTop,
        behavior: 'smooth'
      });
    } else {
      container.scrollTop = targetTop;
    }
    
    // ハイライト効果を追加
    try {
      var originalBg = target.style.backgroundColor;
      var originalTransition = target.style.transition;
      target.style.transition = 'background-color 0.3s ease';
      target.style.backgroundColor = 'rgba(26, 115, 232, 0.15)';
      
      setTimeout(function () {
        target.style.backgroundColor = originalBg;
        setTimeout(function () {
          target.style.transition = originalTransition;
        }, 300);
      }, 1500);
    } catch (e) {
      console.warn('Failed to apply highlight:', e);
    }
    
    return true;
  }

  function simplifyComments(container) {
    var markers = container.querySelectorAll('.text-marker[data-comment-id]');
    for (var i = 0; i < markers.length; i++) {
      markers[i].removeAttribute('data-comment-id');
    }
  }

  function activatePreviewItem(item, fromUser) {
    if (!item) return;

    setActiveItem(item);

    modalTitle.textContent = item.title || '';

    if (item.kind === 'bg') {
      modalIframe.style.display = 'none';
      bgPreviewBody.classList.add('active');
      bgPreviewBody.innerHTML = '<p>読み込み中...</p>';
      
      loadBgSnippetForItem(item, function (html) {
        if (!html) html = '<p>コンテンツが見つかりません。</p>';
        bgPreviewBody.innerHTML = html;
        
        console.log('BG preview loaded, anchorId:', item.anchorId);
        
        // DOMが完全に描画されるまで待つ（複数回試行）
        var scrollAttempts = 0;
        var maxAttempts = 5;
        
        function tryScroll() {
          scrollAttempts++;
          
          if (item.anchorId) {
            var success = scrollToAnchorInPreview(bgPreviewBody, item.anchorId);
            if (!success && scrollAttempts < maxAttempts) {
              // スクロールに失敗した場合は再試行
              setTimeout(tryScroll, 100);
            }
          } else {
            // アンカーがない場合は先頭にスクロール
            bgPreviewBody.scrollTop = 0;
          }
        }
        
        // 初回は少し待ってから実行
        setTimeout(tryScroll, 100);
      });
    } else {
      bgPreviewBody.classList.remove('active');
      bgPreviewBody.innerHTML = '';
      modalIframe.style.display = '';
      modalIframe.src = item.previewUrl || item.href;
    }

    if (isMobile) {
      modalDialog.style.transform = 'translate(-50%, -50%)';
      modalDialog.style.top = '50%';
      modalDialog.style.left = '50%';
      modalDialog.style.width = '96vw';
      modalDialog.style.height = '90vh';
      applyZoom(1.0);
    } else {
      if (!item.position || !item.size) {
        // 初回: デフォルト位置・サイズ
        modalDialog.style.top = '50%';
        modalDialog.style.left = '50%';
        modalDialog.style.transform = 'translate(-50%, -50%)';
        modalDialog.style.width = '';
        modalDialog.style.height = '';
      } else {
        applyGeometry(item);
      }
      applyZoom(item.zoom || 1.0);
      rebuildToasts();
    }

    modal.hidden = false;
    saveState();
    
    // トーストを再構築（minimizedから復帰した場合に必要）
    if (!isMobile) {
      rebuildToasts();
    }
  }

  function closeCurrentPreview() {
    var active = getActiveItem();
    if (!active) {
      modal.hidden = true;
      modalIframe.src = 'about:blank';
      return;
    }
    var key = active.key;
    modal.hidden = true;
    modalIframe.src = 'about:blank';
    closeItemByKey(key);
  }

  // モーダルのヘッダーボタン
  modalBtnClose.addEventListener('click', function () {
    closeCurrentPreview();
  });

  modalBtnOpen.addEventListener('click', function () {
    var active = getActiveItem();
    if (!active) return;
    window.open(active.href, '_blank', 'noopener');
  });

  modalBtnReload.addEventListener('click', function () {
    var active = getActiveItem();
    if (!active) return;
    reloadPreviewItem(active);
  });

  modalBtnCopy.addEventListener('click', function () {
    var active = getActiveItem();
    if (!active) return;
    var url = active.href;
    if (navigator.clipboard && navigator.clipboard.writeText) {
      navigator.clipboard.writeText(url).catch(function () {});
      return;
    }
    var tmp = document.createElement('textarea');
    tmp.style.position = 'fixed';
    tmp.style.opacity = '0';
    tmp.value = url;
    document.body.appendChild(tmp);
    tmp.select();
    try { document.execCommand('copy'); } catch (e) {}
    document.body.removeChild(tmp);
  });

  function reloadPreviewItem(item) {
    if (!item) return;
    
    console.log('Reloading preview item:', item.key);
    
    // キャッシュをクリア
    if (item.kind === 'bg') {
      item.snippetHtml = null;
    }
    
    // 現在のスクロール位置を保存
    var currentScrollTop = 0;
    if (item.kind === 'bg' && bgPreviewBody) {
      currentScrollTop = bgPreviewBody.scrollTop;
    }
    
    // 再読み込み
    if (item.kind === 'bg') {
      bgPreviewBody.innerHTML = '<p>読み込み中...</p>';
      loadBgSnippetForItem(item, function (html) {
        if (!html) html = '<p>コンテンツが見つかりません。</p>';
        bgPreviewBody.innerHTML = html;
        
        // 元のアンカー位置にスクロール（優先）
        if (item.anchorId) {
          setTimeout(function () {
            scrollToAnchorInPreview(bgPreviewBody, item.anchorId);
          }, 100);
        } else {
          // アンカーがない場合は元のスクロール位置に戻す
          setTimeout(function () {
            bgPreviewBody.scrollTop = currentScrollTop;
          }, 100);
        }
      });
    } else if (item.kind === 'gdoc') {
      // Google Docsプレビューの場合はiframeを再読み込み
      if (modalIframe) {
        var currentSrc = modalIframe.src;
        modalIframe.src = 'about:blank';
        setTimeout(function () {
          modalIframe.src = currentSrc;
        }, 100);
      }
    }
    
    // 状態を保存
    saveState();
  }

  function getScrollElement() {
    return document.scrollingElement || document.documentElement || document.body;
  }

  function applyJumpHighlight(target) {
    if (!target) return;
    var el = target;
    if (!(el instanceof HTMLElement)) {
      el = target.parentElement || null;
    }
    while (el && el !== document.body && !(el instanceof HTMLElement)) {
      el = el.parentElement;
    }
    if (!el) return;
    try {
      el.scrollIntoView({ block: 'center', behavior: 'smooth' });
      var prevBox = el.style.boxShadow;
      el.style.transition = 'box-shadow 0.3s ease';
      el.style.boxShadow = '0 0 0 3px rgba(26,115,232,0.5)';
      setTimeout(function () {
        el.style.boxShadow = prevBox || '';
      }, 1600);
    } catch (e) {
      try {
        target.scrollIntoView({ block: 'center', behavior: 'smooth' });
      } catch (e2) {}
    }
  }

  function findSourceElementForItem(item) {
    if (!item) return null;

    // まず data-gdoc-key で厳密に一致するリンクを探す（タブ/重複対応）
    if (item.key) {
      try {
        var keySelector = 'a.gdoc-link[data-gdoc-key="' + String(item.key).replace(/"/g, '\"') + '"]';
        var byKey = document.querySelector(keySelector);
        if (byKey) return byKey;
      } catch (e) {
        // fall through to id/href
      }
    }

    var selector = '';
    if (item.id) {
      // Google Docs ID は英数字等なので単純なエスケープで十分
      selector = 'a.gdoc-link[data-gdoc-id="' + String(item.id).replace(/"/g, '\"') + '"]';
    } else if (item.href) {
      selector = 'a.gdoc-link[href="' + String(item.href).replace(/"/g, '\"') + '"]';
    }
    if (!selector) return null;
    try {
      var candidates = document.querySelectorAll(selector);
      if (!candidates || !candidates.length) return null;
      return candidates[0];
    } catch (e) {
      return null;
    }
  }

  function jumpToSourceForItem(item) {
    if (!item) return;

    var currentBase = window.location.href.split('#')[0];
    var sourceUrl = item.sourceUrl || null;
    var sourceId = item.sourceId || null;

    // 別ページに元リンクがある場合は、そのページへ遷移
    if (sourceUrl && sourceUrl !== currentBase) {
      var targetUrl = sourceUrl;
      if (sourceId) {
        // 既にハッシュが含まれていない前提
        targetUrl = sourceUrl + '#' + encodeURIComponent(sourceId);
      }
      try {
        window.location.href = targetUrl;
      } catch (e) {
        window.location.assign(targetUrl);
      }
      return;
    }

    // 同一ページ内: ソースID優先でスクロール
    var target = null;
    if (sourceId) {
      target = document.getElementById(sourceId) || null;
    }
    if (!target) {
      var linkEl = findSourceElementForItem(item);
      if (!linkEl) return;
      target = linkEl.closest('[id]') || linkEl;
    }

    var scrollEl = getScrollElement();
    var currentY = scrollEl.scrollTop;
    try {
      history.pushState({ __gdocScrollRestore: currentY }, '', window.location.href);
    } catch (e2) {}
    applyJumpHighlight(target);
  }

  modalBtnJump.addEventListener('click', function () {
    var active = getActiveItem();
    if (!active) return;
    jumpToSourceForItem(active);
  });

  // ヘッダー: ドラッグ & クリックで格納
  modalHeader.addEventListener('mousedown', function (e) {
    if (e.button !== 0) return;
    if (isMobile) return; // モバイルではドラッグ/格納なし

    isMouseDownOnHeader = true;
    headerMouseDownX = e.clientX;
    headerMouseDownY = e.clientY;

    isDragging = true;
    dragStartX = e.clientX;
    dragStartY = e.clientY;
    var rect = modalDialog.getBoundingClientRect();
    dialogStartLeft = rect.left;
    dialogStartTop = rect.top;
    modalDialog.style.transform = 'none';
    document.addEventListener('mousemove', onDragMove);
    document.addEventListener('mouseup', onHeaderMouseUp);
  });

  function onDragMove(e) {
    if (!isDragging || isMobile) return;
    var dx = e.clientX - dragStartX;
    var dy = e.clientY - dragStartY;
    var newLeft = dialogStartLeft + dx;
    var newTop = dialogStartTop + dy;

    var maxLeft = window.innerWidth - 100;
    var maxTop = window.innerHeight - 60;
    if (newLeft < 0) newLeft = 0;
    if (newTop < 0) newTop = 0;
    if (newLeft > maxLeft) newLeft = maxLeft;
    if (newTop > maxTop) newTop = maxTop;

    modalDialog.style.left = newLeft + 'px';
    modalDialog.style.top = newTop + 'px';
  }

  function onHeaderMouseUp(e) {
    document.removeEventListener('mousemove', onDragMove);
    document.removeEventListener('mouseup', onHeaderMouseUp);

    if (!isDragging) {
      isMouseDownOnHeader = false;
      return;
    }

    isDragging = false;

    var active = getActiveItem();
    if (active && !isMobile) {
      var rect = modalDialog.getBoundingClientRect();
      active.position = { left: rect.left, top: rect.top };
      if (active.size) {
        active.size.width = rect.width;
        active.size.height = rect.height;
      }
      saveState();
      updateLastGeometryFromActive();
    }

    // クリック判定（ドラッグ距離が小さい場合）
    if (isMouseDownOnHeader) {
      var dx = Math.abs(e.clientX - headerMouseDownX);
      var dy = Math.abs(e.clientY - headerMouseDownY);
      if (dx < 3 && dy < 3) {
        // ヘッダーの「ボタンやリサイズハンドル以外」をクリックした場合に格納
        var target = e.target;
        if (!target.closest('.gdoc-modal-btn') && !target.closest('.gdoc-resize-handle')) {
          minimizeActiveToToast();
        }
      }
    }
    isMouseDownOnHeader = false;
  }

  function minimizeActiveToToast() {
    if (isMobile) return;
    var active = getActiveItem();
    if (!active) return;
    active.state = 'minimized';
    active.lastUpdated = Date.now();
    currentKey = null;
    saveState();
    modal.hidden = true;
    modalIframe.src = 'about:blank';
    rebuildToasts();
  }

  // 4隅のリサイズ
  if (resizeHandles && resizeHandles.length) {
    resizeHandles.forEach(function (handle) {
      handle.addEventListener('mousedown', function (e) {
        if (e.button !== 0) return;
        if (isMobile) return;
        e.preventDefault();
        isResizing = true;
        resizeDir = handle.getAttribute('data-resize-dir') || '';
        var rect = modalDialog.getBoundingClientRect();
        resizeStartX = e.clientX;
        resizeStartY = e.clientY;
        startWidth = rect.width;
        startHeight = rect.height;
        startLeft = rect.left;
        startTop = rect.top;
        modalDialog.style.transform = 'none';
        document.addEventListener('mousemove', onResizeMove);
        document.addEventListener('mouseup', onResizeEnd);
      });
    });
  }

  function onResizeMove(e) {
    if (!isResizing || isMobile) return;

    var dx = e.clientX - resizeStartX;
    var dy = e.clientY - resizeStartY;

    var newWidth = startWidth;
    var newHeight = startHeight;
    var newLeft = startLeft;
    var newTop = startTop;

    if (resizeDir.indexOf('e') !== -1) {
      newWidth = startWidth + dx;
    }
    if (resizeDir.indexOf('s') !== -1) {
      newHeight = startHeight + dy;
    }
    if (resizeDir.indexOf('w') !== -1) {
      newWidth = startWidth - dx;
      newLeft = startLeft + dx;
    }
    if (resizeDir.indexOf('n') !== -1) {
      newHeight = startHeight - dy;
      newTop = startTop + dy;
    }

    var minWidth = 320;
    var minHeight = 220;
    var maxWidth = Math.min(window.innerWidth - 40, 1400);
    var maxHeight = window.innerHeight - 40;

    if (newWidth < minWidth) {
      newWidth = minWidth;
      if (resizeDir.indexOf('w') !== -1) {
        newLeft = startLeft + (startWidth - minWidth);
      }
    }
    if (newHeight < minHeight) {
      newHeight = minHeight;
      if (resizeDir.indexOf('n') !== -1) {
        newTop = startTop + (startHeight - minHeight);
      }
    }

    if (newWidth > maxWidth) {
      newWidth = maxWidth;
    }
    if (newHeight > maxHeight) {
      newHeight = maxHeight;
    }

    var maxRight = window.innerWidth - 10;
    var maxBottom = window.innerHeight - 10;
    if (newLeft + newWidth > maxRight) {
      if (resizeDir.indexOf('e') !== -1) {
        newWidth = maxRight - newLeft;
      } else {
        newLeft = maxRight - newWidth;
      }
    }
    if (newTop + newHeight > maxBottom) {
      if (resizeDir.indexOf('s') !== -1) {
        newHeight = maxBottom - newTop;
      } else {
        newTop = maxBottom - newHeight;
      }
    }

    modalDialog.style.width = newWidth + 'px';
    modalDialog.style.height = newHeight + 'px';
    modalDialog.style.left = newLeft + 'px';
    modalDialog.style.top = newTop + 'px';
  }

  function onResizeEnd() {
    if (!isResizing) return;
    document.removeEventListener('mousemove', onResizeMove);
    document.removeEventListener('mouseup', onResizeEnd);
    isResizing = false;

    var active = getActiveItem();
    if (active && !isMobile) {
      var rect = modalDialog.getBoundingClientRect();
      active.position = { left: rect.left, top: rect.top };
      active.size = { width: rect.width, height: rect.height };
      active.zoom = currentZoom;
      saveState();
      updateLastGeometryFromActive();
    }
  }

  // ズーム（ポップアップ内だけ）
  // Ctrl/Command + スクロールによる拡大・縮小は無効化し、
  // 通常スクロールのみを許可する
  modalDialog.addEventListener('wheel', function (e) {
    if (isMobile) return;
    var isZoomGesture = e.ctrlKey || e.metaKey || e.deltaZ !== 0;
    if (!isZoomGesture) return;

    // ブラウザのページズームが発動しないように止める
    e.preventDefault();
  }, { passive: false });

  // ---- トースト（格納状態） ----
  function getMaxIndividualToasts() {
    try {
      var raw = window.localStorage.getItem('gdocPreviewMaxToasts');
      if (raw == null) return 3;
      var n = parseInt(raw, 10);
      if (isNaN(n)) n = 3;
      if (n < 0) n = 0;
      if (n > 9) n = 9;
      return n;
    } catch (e) {
      return 3;
    }
  }

  function rebuildToasts() {
    if (!toastInner || isMobile) return;
    toastInner.innerHTML = '';

    var minimized = [];
    for (var i = 0; i < state.items.length; i++) {
      if (state.items[i].state === 'minimized') minimized.push(state.items[i]);
    }

    if (!minimized.length) return;

    // 更新日時の新しいものが上に来るように並べ替え
    minimized.sort(function (a, b) {
      return (b.lastUpdated || 0) - (a.lastUpdated || 0);
    });

    var maxIndividual = getMaxIndividualToasts();
    var individualCount = Math.min(minimized.length, maxIndividual);

    for (var j = 0; j < individualCount; j++) {
      var item = minimized[j];
      var toast = document.createElement('div');
      toast.className = 'gdoc-toast';
      toast.setAttribute('data-preview-key', item.key);

      var main = document.createElement('div');
      main.className = 'gdoc-toast-main';

      var titleNode = document.createElement('div');
      titleNode.className = 'gdoc-toast-title';
      var prefix = item.kind === 'bg' ? '[BG] ' : '[Docs] ';
      titleNode.textContent = prefix + (item.title || item.href || '');
      main.appendChild(titleNode);

      toast.appendChild(main);

      var actions = document.createElement('div');
      actions.className = 'gdoc-toast-actions';

      var btnCopy = document.createElement('button');
      btnCopy.type = 'button';
      btnCopy.className = 'gdoc-toast-btn';
      btnCopy.setAttribute('data-action', 'copy');
      btnCopy.title = 'リンクをコピー';
      btnCopy.innerHTML = '<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></svg>';
      actions.appendChild(btnCopy);

      var btnOpen = document.createElement('button');
      btnOpen.type = 'button';
      btnOpen.className = 'gdoc-toast-btn';
      btnOpen.setAttribute('data-action', 'open');
      btnOpen.title = '別タブで開く';
      btnOpen.innerHTML = '<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M14 3h7v7h-2V6.41l-9.29 9.3-1.42-1.42 9.3-9.29H14V3z"></path><path d="M5 5h5V3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2v-5h-2v5H5V5z"></path></svg>';
      actions.appendChild(btnOpen);

      var btnJump = document.createElement('button');
      btnJump.type = 'button';
      btnJump.className = 'gdoc-toast-btn';
      btnJump.setAttribute('data-action', 'jump');
      btnJump.title = '本文へ移動';
      btnJump.innerHTML = '<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M12 2c-.55 0-1 .45-1 1v12.59l-4.3-4.3a1 1 0 10-1.4 1.42l6 6a1 1 0 001.4 0l6-6a1 1 0 10-1.4-1.42L13 15.59V3c0-.55-.45-1-1-1z"></path></svg>';
      actions.appendChild(btnJump);

      var btnClose = document.createElement('button');
      btnClose.type = 'button';
      btnClose.className = 'gdoc-toast-btn';
      btnClose.setAttribute('data-action', 'close');
      btnClose.title = '閉じる';
      btnClose.innerHTML = '<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M5.293 6.707l5.293 5.293-5.293 5.293c-.39.39-.39 1.024 0 1.414s1.024.39 1.414 0l5.293-5.293 5.293 5.293c.39.39 1.024.39 1.414 0s.39-1.024 0-1.414L13.414 12l5.293-5.293c.39-.39.39-1.024 0-1.414s-1.024-.39-1.414 0L12 10.586 6.707 5.293c-.39-.39-1.024-.39-1.414 0s-.39 1.024 0 1.414z"></path></svg>';
      actions.appendChild(btnClose);

      toast.appendChild(actions);
      toastInner.appendChild(toast);
    }

    if (minimized.length > maxIndividual) {
      var othersCount = minimized.length - maxIndividual;
      var othersToast = document.createElement('div');
      othersToast.className = 'gdoc-toast';
      othersToast.setAttribute('data-preview-key', 'others');
      othersToast.setAttribute('data-other-toast', '1');

      var main2 = document.createElement('div');
      main2.className = 'gdoc-toast-main';
      var title2 = document.createElement('div');
      title2.className = 'gdoc-toast-title';
      title2.textContent = 'プレビューの他文書 (' + othersCount + ' 件)';
      main2.appendChild(title2);
      othersToast.appendChild(main2);

      toastInner.appendChild(othersToast);
    }
  }

  toastInner.addEventListener('click', function (e) {
    var toast = e.target.closest('.gdoc-toast');
    if (!toast) return;
    var key = toast.getAttribute('data-preview-key');
    var isOthers = toast.hasAttribute('data-other-toast');

    if (isOthers) {
      if (!isMobile) {
        openListModal();
      }
      return;
    }

    var actionEl = e.target.closest('[data-action]');
    var action = actionEl ? actionEl.getAttribute('data-action') : null;
    var item = findItemByKey(key);
    if (!item) return;

    if (!action) {
      // トースト本体クリック → 復帰
      activatePreviewItem(item, true);
      return;
    }

    if (action === 'copy') {
      var url = item.href;
      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(url).catch(function () {});
      } else {
        var tmp = document.createElement('textarea');
        tmp.style.position = 'fixed';
        tmp.style.opacity = '0';
        tmp.value = url;
        document.body.appendChild(tmp);
        tmp.select();
        try { document.execCommand('copy'); } catch (err) {}
        document.body.removeChild(tmp);
      }
    } else if (action === 'open') {
      window.open(item.href, '_blank', 'noopener');
    } else if (action === 'close') {
      closeItemByKey(item.key);
    } else if (action === 'jump') {
      jumpToSourceForItem(item);
    }
  });

  // ---- 他文書一覧モーダル ----
  function renderListModal() {
    listEl.innerHTML = '';
    if (!state.items.length) return;

    for (var i = 0; i < state.items.length; i++) {
      var item = state.items[i];
      var li = document.createElement('li');
      li.className = 'gdoc-list-item';
      li.setAttribute('data-preview-key', item.key);

      var titleDiv = document.createElement('div');
      titleDiv.className = 'gdoc-list-item-title';
      titleDiv.textContent = item.title || item.href || '';
      li.appendChild(titleDiv);

      var actionsDiv = document.createElement('div');
      actionsDiv.className = 'gdoc-list-item-actions';

      var btnActivate = document.createElement('button');
      btnActivate.type = 'button';
      btnActivate.className = 'gdoc-list-item-btn';
      btnActivate.setAttribute('data-action', 'activate');
      btnActivate.textContent = '表示';
      actionsDiv.appendChild(btnActivate);

      var btnJumpBody = document.createElement('button');
      btnJumpBody.type = 'button';
      btnJumpBody.className = 'gdoc-list-item-btn';
      btnJumpBody.setAttribute('data-action', 'jump');
      btnJumpBody.textContent = '本文';
      actionsDiv.appendChild(btnJumpBody);

      var btnOpenTab = document.createElement('button');
      btnOpenTab.type = 'button';
      btnOpenTab.className = 'gdoc-list-item-btn';
      btnOpenTab.setAttribute('data-action', 'openTab');
      btnOpenTab.textContent = '他タブ';
      actionsDiv.appendChild(btnOpenTab);

      var btnClose = document.createElement('button');
      btnClose.type = 'button';
      btnClose.className = 'gdoc-list-item-btn';
      btnClose.setAttribute('data-action', 'close');
      btnClose.textContent = '閉じる';
      actionsDiv.appendChild(btnClose);

      var btnUp = document.createElement('button');
      btnUp.type = 'button';
      btnUp.className = 'gdoc-list-item-btn';
      btnUp.setAttribute('data-action', 'up');
      btnUp.textContent = '↑';
      actionsDiv.appendChild(btnUp);

      var btnDown = document.createElement('button');
      btnDown.type = 'button';
      btnDown.className = 'gdoc-list-item-btn';
      btnDown.setAttribute('data-action', 'down');
      btnDown.textContent = '↓';
      actionsDiv.appendChild(btnDown);

      li.appendChild(actionsDiv);
      listEl.appendChild(li);
    }
  }

  function openListModal() {
    if (isMobile) return;
    renderListModal();
    listModal.hidden = false;
  }

  function closeListModal() {
    listModal.hidden = true;
  }

  listModalClose.addEventListener('click', function () {
    closeListModal();
  });

  listModal.addEventListener('click', function (e) {
    if (e.target === listModal) {
      closeListModal();
    }
  });

  listEl.addEventListener('click', function (e) {
    var li = e.target.closest('.gdoc-list-item');
    if (!li) return;
    var key = li.getAttribute('data-preview-key');
    var item = findItemByKey(key);
    if (!item) return;

    var btn = e.target.closest('[data-action]');
    if (!btn) return;
    var action = btn.getAttribute('data-action');

    if (action === 'openTab') {
      window.open(item.href, '_blank', 'noopener');
    } else if (action === 'close') {
      closeItemByKey(item.key);
      renderListModal();
    } else if (action === 'activate') {
      activatePreviewItem(item, true);
      closeListModal();
    } else if (action === 'jump') {
      jumpToSourceForItem(item);
      closeListModal();
    } else if (action === 'up' || action === 'down') {
      var items = state.items;
      var idx = -1;
      for (var i = 0; i < items.length; i++) {
        if (items[i].key === item.key) { idx = i; break; }
      }
      if (idx === -1) return;
      var newIdx = action === 'up' ? idx - 1 : idx + 1;
      if (newIdx < 0 || newIdx >= items.length) return;
      var tmp = items[idx];
      items[idx] = items[newIdx];
      items[newIdx] = tmp;
      saveState();
      renderListModal();
      rebuildToasts();
    }
  });

  // ---- キーボード ----
  document.addEventListener('keydown', function (e) {
    if (e.key === 'Escape') {
      if (!popover.hidden) {
        popover.hidden = true;
        currentLink = null;
      } else if (!listModal.hidden) {
        closeListModal();
      } else if (!modal.hidden) {
        // ESC ではプレビューを閉じず、トーストへ格納する
        minimizeActiveToToast();
      }
    }
  });

  // ページ内リンクのクリックに対して、戻るボタンで元の位置に戻れるように履歴を積む
  document.addEventListener('click', function (e) {
    var a = e.target.closest && e.target.closest('a[href^="#"]');
    if (!a) return;
    var href = a.getAttribute('href');
    if (!href || href === '#') return;

    var url;
    try {
      url = new URL(a.href, window.location.href);
    } catch (err) {
      return;
    }
    if (url.pathname !== window.location.pathname || url.origin !== window.location.origin) {
      return;
    }

    var id = decodeURIComponent(url.hash.slice(1));
    if (!id) return;
    var target = document.getElementById(id);
    if (!target) return;

    e.preventDefault();

    var scrollEl = getScrollElement();
    var currentY = scrollEl.scrollTop;
    try {
      history.pushState({ __gdocScrollRestore: currentY }, url.hash, url.href);
    } catch (err2) {}

    applyJumpHighlight(target);
  });

  window.addEventListener('popstate', function (e) {
    if (e.state && typeof e.state.__gdocScrollRestore === 'number') {
      var scrollEl = getScrollElement();
      scrollEl.scrollTop = e.state.__gdocScrollRestore;
    }
  });

  // BGプレビュー対象リンクの検出とマーク
  function markBgPreviewLinks() {
    try {
      // 全てのリンクを対象に検索
      var allLinks = document.querySelectorAll('a[href]');
      var markedCount = 0;
      
    for (var i = 0; i < allLinks.length; i++) {
      var link = allLinks[i];
      var href = link.getAttribute('href');
      if (!href) continue;
      if (link.classList && (link.classList.contains('footnote-ref') || link.getAttribute('role') === 'doc-noteref')) {
        continue;
      }
        
        // 既にマークされている場合はスキップ
        if (link.classList.contains('bg-preview-link')) continue;
        
        // 1. 索引リンク（idx- を含む）
        if (href.indexOf('#idx-') !== -1) {
          link.classList.add('bg-preview-link');
          link.setAttribute('data-bg-type', 'index');
          markedCount++;
          continue;
        }
        
        // 2. 目次リンク（toc- を含む）
        if (href.indexOf('#toc-') !== -1 || href.indexOf('toc-') !== -1) {
          link.classList.add('bg-preview-link');
          link.setAttribute('data-bg-type', 'toc');
          markedCount++;
          continue;
        }
        
        // 3. 章ファイルへのリンク（NN_chNN.html 形式）
        if (href.match(/\d+_ch\d+\.html/)) {
          link.classList.add('bg-preview-link');
          link.setAttribute('data-bg-type', 'chapter');
          markedCount++;
          continue;
        }
        
        // 4. 同一ページ内のアンカーリンク（#で始まる）
        if (href.indexOf('#') === 0 && href.length > 1) {
          // ヘッダーナビゲーションは除外
          if (link.closest('header') || link.closest('.header-ui')) continue;
          
          link.classList.add('bg-preview-link');
          link.setAttribute('data-bg-type', 'anchor');
          markedCount++;
          continue;
        }
      }
      
      console.log('BGプレビューリンクをマーク:', markedCount + '個');
    } catch (e) {
      console.warn('markBgPreviewLinks failed', e);
    }
  }

  // BGプレビューリンクのイベントハンドラ
  document.addEventListener('mouseover', function (e) {
    var link = e.target.closest && e.target.closest('a.bg-preview-link');
    if (!link) return;
    
    // プレビュー内のリンクの場合、既存のプレビューを最小化
    if (link.closest('.bg-preview-body')) {
      var activeItem = getActiveItem();
      if (activeItem && activeItem.state === 'active') {
        activeItem.state = 'minimized';
        saveState();
        if (!isMobile) {
          rebuildToasts();
        }
      }
    }
    
    cancelHideBgPopover();
    cancelShowBgPopover();
    bgShowTimer = window.setTimeout(function () {
      showBgPopoverForLink(link);
    }, POPOVER_SHOW_DELAY);
  });

  document.addEventListener('mouseout', function (e) {
    var fromLink = e.target.closest && e.target.closest('a.bg-preview-link');
    if (!fromLink) return;
    var to = e.relatedTarget;
    if (to && (to.closest && (to.closest('a.bg-preview-link') || to.closest('#bg-preview-popover')))) {
      return;
    }
    cancelShowBgPopover();
    scheduleHideBgPopover();
  });

  document.addEventListener('click', function (e) {
    var link = e.target.closest && e.target.closest('a.bg-preview-link');
    if (!link) return;
    
    // ポップオーバー内のボタンクリックの場合は何もしない
    if (e.target.closest('#bg-preview-popover')) {
      return;
    }
    
    // モバイルまたはタッチデバイスの場合
    if (isMobile || ('ontouchstart' in window)) {
      e.preventDefault();
      cancelHideBgPopover();
      if (bgPopover.hidden) {
        showBgPopoverForLink(link);
      } else if (currentBgLink === link) {
        // 2回目のタップで遷移
        window.location.href = link.href;
      } else {
        showBgPopoverForLink(link);
      }
    }
    // PCの場合は通常のクリックで遷移（ポップオーバーは補助的）
    // デフォルトの動作を許可（リンク遷移）
  });

  // 初期化: モード判定と既存状態の復元
  updateMode();
  markBgPreviewLinks();
  
  (function restoreFromState() {
    if (!state || !state.items.length) return;
    if (isMobile) return; // モバイルでは復元しない

    rebuildToasts();
    var active = getActiveItem();
    if (active) {
      activatePreviewItem(active, false);
    }
  })();

  // 外部統合用の簡易API
  window.__gdocPreviewAPI__ = {
    getState: function () {
      return { items: state.items.slice(), currentKey: currentKey };
    },
    getItems: function () {
      return state.items.slice();
    },
    getItemsByKind: function (kind) {
      return state.items.filter(function (item) {
        return item.kind === kind;
      });
    },
    activate: function (key) {
      var item = findItemByKey(key);
      if (item) activatePreviewItem(item, true);
    },
    close: function (key) {
      closeItemByKey(key);
    },
    jumpToSource: function (key) {
      var item = findItemByKey(key);
      if (item) jumpToSourceForItem(item);
    },
    minimizeActive: function () {
      minimizeActiveToToast();
    },
    refreshToasts: function () {
      rebuildToasts();
    },
    openBgPreview: function (href, title) {
      var link = document.createElement('a');
      link.href = href;
      link.textContent = title || href;
      openBgPreviewFromLink(link);
    }
  };
})();
</script>
<script src="../src/js/index-scroll.js"></script>




</body></html>