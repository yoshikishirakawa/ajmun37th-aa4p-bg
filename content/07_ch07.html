<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ja" xml:lang="ja"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.25">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>ç¬¬7ç«  ã¾ã¨ã‚ã¨å±•æœ› â€“ å¹³å’Œã¸ã®èª²é¡Œï¼šè£œéº</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../content/22_col03.html" rel="next">
<link href="../content/06_ch06.html" rel="prev">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-d2604bcb90b21ac6bc3164282300c13a.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "ä¸€è‡´ãªã—",
    "search-matching-documents-text": "ä¸€è‡´ã—ãŸæ–‡æ›¸",
    "search-copy-link-title": "æ¤œç´¢ã¸ã®ãƒªãƒ³ã‚¯ã‚’ã‚³ãƒ”ãƒ¼",
    "search-hide-matches-text": "è¿½åŠ ã®æ¤œç´¢çµæœã‚’éè¡¨ç¤º",
    "search-more-match-text": "è¿½åŠ ã®æ¤œç´¢çµæœ",
    "search-more-matches-text": "è¿½åŠ ã®æ¤œç´¢çµæœ",
    "search-clear-button-title": "æ¶ˆå»",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "å–æ¶ˆ",
    "search-submit-button-title": "æ¤œç´¢",
    "search-label": "ã‚µãƒ¼ãƒ"
  }
}</script>
<style>
  :root {
    --sidebar-width: 280px;
    --margin-width: 150px;
    --gutter-width: 12px;
  }
</style>
<style>
  :root {
    --sidebar-width: 280px;
    --margin-width: 150px;
    --gutter-width: 12px;
  }
</style>
<link rel="preload" href="../fonts/BIZUDPMincho-Regular.woff2" as="font" type="font/woff2" crossorigin="">
<link rel="preload" href="../fonts/BIZUDPMincho-Bold.woff2" as="font" type="font/woff2" crossorigin="">
<link rel="preload" href="../fonts/BIZUDPGothic-Regular.woff2" as="font" type="font/woff2" crossorigin="">
<link rel="preload" href="../fonts/BIZUDPGothic-Bold.woff2" as="font" type="font/woff2" crossorigin="">


<link rel="stylesheet" href="../src/css/font-udpmincho.css">
<link rel="stylesheet" href="../src/css/base.css">
<link rel="stylesheet" href="../src/css/simple-theme.css">
<link rel="stylesheet" href="../src/css/right-panel.css">
</head>

<body class="nav-sidebar floating quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="ã‚µã‚¤ãƒ‰ãƒãƒ¼ã‚’åˆ‡ã‚Šæ›¿ãˆã‚‹" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../content/07_ch07.html"><span class="chapter-title">ç¬¬7ç«  ã¾ã¨ã‚ã¨å±•æœ›</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="ã‚µã‚¤ãƒ‰ãƒãƒ¼ã‚’åˆ‡ã‚Šæ›¿ãˆã‚‹" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="ã‚µãƒ¼ãƒ" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header sidebar-header-stacked">
      <a href="../index.html" class="sidebar-logo-link">
      </a>
    <div class="sidebar-title mb-0 py-0">
      <a href="../">å¹³å’Œã¸ã®èª²é¡Œï¼šè£œéº</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="ã‚µãƒ¼ãƒ"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../index.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">AJMUN 37th å¹³å’Œã¸ã®èª²é¡Œï¼šè£œéº</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/00_front.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">ãƒ•ãƒ­ãƒ³ãƒˆæŒ¨æ‹¶</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/01_ch01.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">ç¬¬1ç«  ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®æ¦‚è¦</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/02_ch02.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">ç¬¬2ç«  æŠ€è¡“çš„èª²é¡Œã¨è§£æ±ºç­–</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/03_ch03.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">ç¬¬3ç«  å®Ÿè£…æ–¹é‡</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/20_col01.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">ã‚³ãƒ©ãƒ 1ï¼šWebãƒ•ã‚©ãƒ³ãƒˆã®æ­´å²</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/21_col02.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">ã‚³ãƒ©ãƒ 2ï¼šã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£ã®é‡è¦æ€§</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/04_ch04.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">ç¬¬4ç«  UI/UXè¨­è¨ˆ</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/05_ch05.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">ç¬¬5ç«  ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/06_ch06.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">ç¬¬6ç« ã€€å›½é€£ã®åˆ¶åº¦</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/07_ch07.html" class="sidebar-item-text sidebar-link active"><span class="chapter-title">ç¬¬7ç«  ã¾ã¨ã‚ã¨å±•æœ›</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/22_col03.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">ã‚³ãƒ©ãƒ 3ï¼šä»Šå¾Œã®æŠ€è¡“å‹•å‘</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Appendices</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’åˆ‡ã‚Šæ›¿ãˆ">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/90_afterword.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">ç·¨é›†å¾Œè¨˜</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/95_references.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">å‚è€ƒæ–‡çŒ®</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/96_index.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">ç´¢å¼•</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">ç›®æ¬¡</h2>
   
  <ul>
  <li><a href="#ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®æˆæœ" id="toc-ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®æˆæœ" class="nav-link active" data-scroll-target="#ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®æˆæœ">7.1 ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®æˆæœ</a></li>
  <li><a href="#æŠ€è¡“çš„è²¢çŒ®" id="toc-æŠ€è¡“çš„è²¢çŒ®" class="nav-link" data-scroll-target="#æŠ€è¡“çš„è²¢çŒ®">7.2 æŠ€è¡“çš„è²¢çŒ®</a></li>
  <li><a href="#ä»Šå¾Œã®ç™ºå±•" id="toc-ä»Šå¾Œã®ç™ºå±•" class="nav-link" data-scroll-target="#ä»Šå¾Œã®ç™ºå±•">7.3 ä»Šå¾Œã®ç™ºå±•</a></li>
  <li><a href="#ã¾ã¨ã‚" id="toc-ã¾ã¨ã‚" class="nav-link" data-scroll-target="#ã¾ã¨ã‚">ã¾ã¨ã‚</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">
<div class="header-ui">
  <!-- ãƒãƒ³ãƒãƒ¼ã‚¬ãƒ¼ãƒ¡ãƒ‹ãƒ¥ãƒ¼ãƒœã‚¿ãƒ³ï¼ˆå·¦ä¸Šå¸¸è¨­ï¼‰ -->
  <button class="hamburger-menu-btn" id="hamburger-menu-btn" aria-label="ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚’é–‹ã" aria-expanded="false" aria-controls="hamburger-menu-panel">
    <span class="hamburger-menu-icon">
      <span></span>
      <span></span>
      <span></span>
    </span>
  </button>

  <!-- ãƒãƒ³ãƒãƒ¼ã‚¬ãƒ¼ãƒ¡ãƒ‹ãƒ¥ãƒ¼ï¼ˆå±•é–‹ãƒ‘ãƒãƒ«ï¼‰ -->
  <div id="hamburger-menu-panel" class="hamburger-menu-panel" role="menu">
    <div class="hamburger-menu-content">
      <!-- ãƒ¡ãƒ‹ãƒ¥ãƒ¼é …ç›®ã¯JavaScriptã§ç”Ÿæˆ -->
    </div>
    <div class="hamburger-menu-notch"></div>
  </div>
  <div class="hamburger-menu-overlay" id="hamburger-menu-overlay"></div>

  <div id="js-header" class="js-header">
    <div class="js-header__inner">
      <div class="js-header__left">
        <div class="js-header__logo">
          <span class="js-header__title">å¹³å’Œã¸ã®èª²é¡Œï¼šè£œéº</span>
        </div>
      </div>
      <div class="js-header__right">
        <div class="js-header__controls">
          <!-- ãƒ¢ãƒã‚¤ãƒ«ç”¨ç›®æ¬¡ãƒœã‚¿ãƒ³ -->
          <button class="js-toc-mobile-btn" id="toc-mobile-btn" aria-label="ç›®æ¬¡">â˜°</button>
          
          <!-- è¨­å®šãƒ¡ãƒ‹ãƒ¥ãƒ¼ãƒœã‚¿ãƒ³ -->
          <button class="js-settings-toggle-btn" id="settings-toggle-btn" aria-label="è¨­å®šãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚’é–‹ã">âš™ï¸</button>
        </div>
      </div>
    </div>
  </div>
  
  <!-- æ ¼ç´å‹è¨­å®šãƒ¡ãƒ‹ãƒ¥ãƒ¼ -->
  <div class="settings-menu" id="settings-menu">
    <div class="settings-menu__inner">
      <div class="settings-menu__header">
        <h3 class="anchored">è¡¨ç¤ºè¨­å®š</h3>
        <button class="settings-menu__close" id="settings-menu-close">Ã—</button>
      </div>
      <div class="settings-menu__content">
        <!-- æ–‡å­—ã‚µã‚¤ã‚º -->
        <div class="settings-item">
          <label for="font-size-select">æ–‡å­—ã‚µã‚¤ã‚ºï¼š</label>
          <select class="js-font-size-select" id="font-size-select" aria-label="æ–‡å­—ã‚µã‚¤ã‚º">
            <option value="XS">XS</option>
            <option value="S">S</option>
            <option value="M" selected="">M</option>
            <option value="L">L</option>
            <option value="XL">XL</option>
          </select>
        </div>
        
        <!-- ãƒ†ãƒ¼ãƒåˆ‡æ›¿ -->
        <div class="settings-item">
          <label for="theme-select">ãƒ†ãƒ¼ãƒï¼š</label>
          <select class="js-theme-select" id="theme-select" aria-label="ãƒ†ãƒ¼ãƒ">
            <option value="light">ãƒ©ã‚¤ãƒˆ</option>
            <option value="dark">ãƒ€ãƒ¼ã‚¯</option>
            <option value="auto">è‡ªå‹•</option>
          </select>
        </div>
        
        <!-- ã‚³ãƒ¡ãƒ³ãƒˆæ©Ÿèƒ½ -->
        <div class="settings-divider"></div>
        <div class="settings-section-title">ã‚³ãƒ¡ãƒ³ãƒˆæ©Ÿèƒ½</div>
        <div class="settings-item">
          <button class="js-comments-export-page" id="comments-export-page">ã‚³ãƒ¡ãƒ³ãƒˆå‡ºåŠ›(ã“ã®ãƒšãƒ¼ã‚¸)</button>
        </div>
        <div class="settings-item">
          <button class="js-comments-export-all" id="comments-export-all">å…¨ã‚³ãƒ¡ãƒ³ãƒˆå‡ºåŠ›</button>
        </div>
        <div class="settings-item">
          <label for="comments-import" class="js-comments-import-label">ã‚³ãƒ¡ãƒ³ãƒˆèª­è¾¼ï¼š</label>
          <input type="file" id="comments-import" class="js-comments-import" accept="application/json" style="display:none;">
          <button class="js-comments-import-button" id="comments-import-button">ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠ</button>
        </div>
      </div>
    </div>
  </div>
  <div class="settings-menu-overlay" id="settings-menu-overlay"></div>
</div>

<div class="toc-overlay">
  <div class="toc-overlay__backdrop"></div>
  <div class="toc-sheet">
    <div class="toc-sheet__header">
      <h3 class="anchored">ç›®æ¬¡</h3>
      <button class="toc-sheet__close">Ã—</button>
    </div>
    <div class="toc-sheet__content">
      <!-- ç›®æ¬¡ã¯JavaScriptã§ç”Ÿæˆ -->
    </div>
  </div>
</div>

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-title">ç¬¬7ç«  ã¾ã¨ã‚ã¨å±•æœ›</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®æˆæœ" class="level2">
<h2 class="anchored" data-anchor-id="ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®æˆæœ">7.1 ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®æˆæœ</h2>
</section>
<section id="æŠ€è¡“çš„è²¢çŒ®" class="level2">
<h2 class="anchored" data-anchor-id="æŠ€è¡“çš„è²¢çŒ®">7.2 æŠ€è¡“çš„è²¢çŒ®</h2>
</section>
<section id="ä»Šå¾Œã®ç™ºå±•" class="level2">
<h2 class="anchored" data-anchor-id="ä»Šå¾Œã®ç™ºå±•">7.3 ä»Šå¾Œã®ç™ºå±•</h2>
<hr>
</section>
<section id="ã¾ã¨ã‚" class="level2">
<h2 class="anchored" data-anchor-id="ã¾ã¨ã‚">ã¾ã¨ã‚</h2>
<p>æœ¬æ›¸ã§è­°è«–ã—ãŸã‚¢ãƒ—ãƒ­ãƒ¼ãƒã¯ã€æ—¥æœ¬èªé•·æ–‡ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã®Webé…å¸ƒã«æœ‰åŠ¹ãªè§£æ±ºç­–ã‚’æä¾›ã—ã¾ã™ã€‚</p>
<hr>
<p><strong>ç¬¬7ç«  å®Œäº†</strong></p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "î§‹";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../content/06_ch06.html" class="pagination-link" aria-label="ç¬¬6ç« ã€€å›½é€£ã®åˆ¶åº¦">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-title">ç¬¬6ç« ã€€å›½é€£ã®åˆ¶åº¦</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../content/22_col03.html" class="pagination-link" aria-label="ã‚³ãƒ©ãƒ 3ï¼šä»Šå¾Œã®æŠ€è¡“å‹•å‘">
        <span class="nav-page-text"><span class="chapter-title">ã‚³ãƒ©ãƒ 3ï¼šä»Šå¾Œã®æŠ€è¡“å‹•å‘</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<script>
// Inlined UI script for offline file:// compatibility
// Source: src/js/ui-clean.js (inlined)
(function() {
  'use strict';

  const STORAGE_KEYS = {
    tocLocation: 'quarto-toc-location',
    theme: 'quarto-theme',
    fontSize: 'quarto-font-size',
    markers: 'quarto-markers',
    comments: 'quarto-comments',
    scrollPosition: 'quarto-scroll-position',
    rightTab: 'quarto-right-tab'
  };

  // ã‚³ãƒ¡ãƒ³ãƒˆDBï¼ˆãƒšãƒ¼ã‚¸ãƒ‘ã‚¹æ¯ã«é…åˆ—ï¼‰
  let COMMENTS_DB = {};
  try { COMMENTS_DB = JSON.parse(localStorage.getItem(STORAGE_KEYS.comments) || '{}') || {}; } catch { COMMENTS_DB = {}; }
  function saveComments() { try { localStorage.setItem(STORAGE_KEYS.comments, JSON.stringify(COMMENTS_DB)); } catch (e) { console.warn('Save comments failed', e); } }
  function pageKey() { return window.location.pathname; }

  function readRightTabState() {
    try { return JSON.parse(localStorage.getItem(STORAGE_KEYS.rightTab) || '{}') || {}; }
    catch (e) { console.warn('Failed to read right tab state', e); return {}; }
  }
  function getSavedRightTab() {
    const map = readRightTabState();
    return map[pageKey()] || 'footnotes';
  }
  function saveRightTab(tab) {
    try {
      const map = readRightTabState();
      map[pageKey()] = tab;
      localStorage.setItem(STORAGE_KEYS.rightTab, JSON.stringify(map));
    } catch (e) {
      console.warn('Failed to save right tab state', e);
    }
  }

  function getActiveChapterSection() {
    return document.querySelector('section.chapter-page.active') || null;
  }
  function getCurrentChapterSlug() {
    const active = getActiveChapterSection();
    if (!active) return null;
    const id = active.getAttribute('id') || '';
    return id.startsWith('page-') ? id.slice(5) : (id || null);
  }

  function getSectionSlugFromElement(el) {
    if (!el || !(el instanceof HTMLElement)) return null;
    const sec = el.closest('section.chapter-page');
    if (!sec || !sec.id) return null;
    const id = sec.id;
    return id.startsWith('page-') ? id.slice(5) : id;
  }

  function findCommentAnchorElement(rec) {
    if (!rec || !Array.isArray(rec.ranges)) return null;
    for (const range of rec.ranges) {
      const node = getNodeByPathSafe(range?.s);
      if (!node) continue;
      let el = node.nodeType === Node.ELEMENT_NODE ? node : node.parentElement;
      while (el && !(el instanceof HTMLElement)) el = el.parentElement;
      if (el) return el;
    }
    return null;
  }

  function detectCommentSlug(rec) {
    const el = findCommentAnchorElement(rec);
    return el ? getSectionSlugFromElement(el) : null;
  }

  function isCommentInSection(rec, section) {
    if (!section) return true;
    const el = findCommentAnchorElement(rec);
    return !!(el && section.contains(el));
  }

  function getActiveComments() {
    const list = (COMMENTS_DB[pageKey()] || []);
    const slug = getCurrentChapterSlug();
    if (!slug) return list.slice();
    const activeSection = getActiveChapterSection();
    const result = [];
    let mutated = false;
    list.forEach(rec => {
      if (!rec) return;
      if (!rec.slug) {
        const detected = detectCommentSlug(rec);
        if (detected) {
          rec.slug = detected;
          mutated = true;
        }
      }
      if (rec.slug) {
        if (rec.slug === slug) result.push(rec);
      } else if (isCommentInSection(rec, activeSection)) {
        result.push(rec);
      }
    });
    if (mutated) saveComments();
    return result;
  }

  function gatherActiveCommentsWithElements() {
    return getActiveComments()
      .map(rec => {
        const el = findCommentAnchorElement(rec);
        return el ? { rec, el } : null;
      })
      .filter(Boolean);
  }

  function gatherActiveFootnotes() {
    const active = getActiveChapterSection();
    const refSelector = 'a[role="doc-noteref"], a.footnote-ref';
    const refMap = new Map();
    const scope = active || document;
    Array.from(scope.querySelectorAll(refSelector)).forEach(ref => {
      if (active && !active.contains(ref)) return;
      const href = ref.getAttribute('href') || ref.getAttribute('data-footnote-href');
      if (!href || !href.startsWith('#')) return;
      const id = href.slice(1);
      const top = ref.getBoundingClientRect().top + window.scrollY;
      const label = (() => {
        const sup = ref.querySelector('sup');
        const raw = (sup ? sup.textContent : ref.textContent) || '';
        return raw.replace(/\s+/g, ' ').trim();
      })();
      const existing = refMap.get(id);
      if (!existing || top < existing.pos) {
        refMap.set(id, { id, ref, pos: top, number: label });
      }
    });
    const items = [];
    refMap.forEach(entry => {
      let def = document.getElementById(entry.id);
      if (!def) return;
      if (!(def instanceof HTMLElement)) def = def.parentElement;
      if (!def) return;
      let li = def;
      if (li.tagName && li.tagName.toLowerCase() !== 'li') {
        const nearestLi = li.closest('li');
        if (nearestLi) li = nearestLi;
      }
      if (!(li instanceof HTMLElement)) return;
      if (active) {
        const parentSection = li.closest('section.chapter-page');
        if (parentSection && parentSection !== active) return;
      }
      const fallbackLabel = entry.number || entry.id.replace(/[^0-9]+/g, '').trim();
      items.push({ id: entry.id, li, ref: entry.ref, pos: entry.pos, number: fallbackLabel });
    });
    return items;
  }

  function initUI() {
    try {
      setupHeaderControls();
      setupLeftPanelTabs();
      setupRightSidebar();
      setupMarkerFunctionality();
      setupMobileFootnoteToggle();
      disableDefaultQuartoSearch();
      setupSidebarSearch();
      setupGlobalSearch();
      setupKeyboardShortcuts();
      setupScrollPosition();
      
      // ç‹¬è‡ªTOCã‚·ã‚¹ãƒ†ãƒ ã‚’åˆæœŸåŒ–ï¼ˆDOMæ§‹ç¯‰å¾Œï¼‰
      setTimeout(() => {
        CustomTOC.initializeCustomTOC();
      }, 100);
      
      console.log('UI initialized');
      setTimeout(refreshRightPanels, 80);
    } catch (e) {
      console.error('UI init failed:', e);
    }
  }
  const queueInit = () => window.setTimeout(initUI, 0);
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', queueInit, { once: true });
  } else {
    queueInit();
  }

  function setupHeaderControls() {
    const tocMobileBtn = document.getElementById('toc-mobile-btn');
    const settingsToggleBtn = document.getElementById('settings-toggle-btn');
    const settingsMenu = document.getElementById('settings-menu');
    const settingsMenuClose = document.getElementById('settings-menu-close');
    const settingsMenuOverlay = document.getElementById('settings-menu-overlay');
    const themeSelect = document.getElementById('theme-select');
    const fontSizeSelect = document.getElementById('font-size-select');
    const commentsExportPage = document.getElementById('comments-export-page');
    const commentsExportAll = document.getElementById('comments-export-all');
    const commentsImport = document.getElementById('comments-import');
    const commentsImportButton = document.getElementById('comments-import-button');

    // ãƒãƒ³ãƒãƒ¼ã‚¬ãƒ¼ãƒ¡ãƒ‹ãƒ¥ãƒ¼æ©Ÿèƒ½
    const hamburgerBtn = document.getElementById('hamburger-menu-btn');
    const hamburgerPanel = document.getElementById('hamburger-menu-panel');
    const hamburgerOverlay = document.getElementById('hamburger-menu-overlay');
    const hamburgerContent = hamburgerPanel.querySelector('.hamburger-menu-content');
    
    if (hamburgerBtn && hamburgerPanel && hamburgerOverlay) {
      const menuItems = [
        {
          label: "ç›®æ¬¡ã‚’è¡¨ç¤º",
          action: "show-toc",
          icon: "ğŸ“‹"
        },
        {
          label: "æ–‡å­—ã‚µã‚¤ã‚º",
          action: "font-size",
          icon: "ğŸ”¤"
        },
        {
          label: "ãƒ†ãƒ¼ãƒåˆ‡ã‚Šæ›¿ãˆ",
          action: "theme",
          icon: "ğŸ¨"
        },
        {
          label: "ã‚³ãƒ¡ãƒ³ãƒˆå‡ºåŠ›(ã“ã®ãƒšãƒ¼ã‚¸)",
          action: "export-comments-page",
          icon: "ğŸ“„"
        },
        {
          label: "å…¨ã‚³ãƒ¡ãƒ³ãƒˆå‡ºåŠ›",
          action: "export-comments-all", 
          icon: "ğŸ“š"
        },
        {
          label: "ã‚³ãƒ¡ãƒ³ãƒˆèª­è¾¼",
          action: "import-comments",
          icon: "ğŸ“¥"
        },
        {
          label: "PDFãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰",
          action: "download-pdf",
          icon: "ğŸ“‘"
        }
      ];

      // ãƒ¡ãƒ‹ãƒ¥ãƒ¼é …ç›®ã‚’ç”Ÿæˆ
      const menuList = document.createElement('ul');
      menuList.className = 'hamburger-menu-list';
      
      menuItems.forEach(item => {
        const menuItem = document.createElement('li');
        menuItem.className = 'hamburger-menu-item';
        const menuLink = document.createElement('a');
        menuLink.className = 'hamburger-menu-link';
        menuLink.href = '#';
        menuLink.innerHTML = `${item.icon} ${item.label}`;
        menuLink.setAttribute('role', 'menuitem');
        menuLink.setAttribute('aria-label', item.label);
        
        menuLink.addEventListener('click', (e) => {
          e.preventDefault();
          handleHamburgerMenuAction(item.action);
          closeHamburgerMenu();
        });
        
        menuItem.appendChild(menuLink);
        menuList.appendChild(menuItem);
      });
      
      hamburgerContent.innerHTML = '';
      hamburgerContent.appendChild(menuList);

      // ãƒ¡ãƒ‹ãƒ¥ãƒ¼é–‹é–‰æ©Ÿèƒ½
      const openHamburgerMenu = () => {
        hamburgerBtn.setAttribute('aria-expanded', 'true');
        hamburgerBtn.setAttribute('aria-label', 'ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚’é–‰ã˜ã‚‹');
        hamburgerPanel.classList.add('open');
        hamburgerOverlay.classList.add('open');
        
        // æœ€åˆã®é …ç›®ã«ãƒ•ã‚©ãƒ¼ã‚«ã‚¹
        const firstLink = hamburgerPanel.querySelector('.hamburger-menu-link');
        if (firstLink) {
          firstLink.focus();
        }
      };

      const closeHamburgerMenu = () => {
        hamburgerBtn.setAttribute('aria-expanded', 'false');
        hamburgerBtn.setAttribute('aria-label', 'ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚’é–‹ã');
        hamburgerPanel.classList.remove('open');
        hamburgerOverlay.classList.remove('open');
        hamburgerBtn.focus();
      };

      hamburgerBtn.addEventListener('click', openHamburgerMenu);
      hamburgerOverlay.addEventListener('click', closeHamburgerMenu);
      
      // ESCã‚­ãƒ¼ã§é–‰ã˜ã‚‹
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && hamburgerPanel.classList.contains('open')) {
          closeHamburgerMenu();
        }
      });

      // ã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£ã®ãŸã‚ã€ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ã‚µãƒãƒ¼ãƒˆ
      hamburgerBtn.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' || e.key === ' ') {
          e.preventDefault();
          openHamburgerMenu();
        }
      });

      // ã‚¢ã‚¯ãƒ†ã‚£ãƒ™ãƒ¼ã‚·ãƒ§ãƒ³ãƒ„ã‚­ãƒƒãƒ—ã§ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ã‚’æœ‰åŠ¹åŒ–
      let currentFocusIndex = -1;
      const focusableElements = () => hamburgerPanel.querySelectorAll('.hamburger-menu-link');

      hamburgerPanel.addEventListener('keydown', (e) => {
        if (!hamburgerPanel.classList.contains('open')) return;
        
        const elements = focusableElements();
        if (elements.length === 0) return;

        switch (e.key) {
          case 'ArrowDown':
            e.preventDefault();
            currentFocusIndex = (currentFocusIndex + 1) % elements.length;
            elements[currentFocusIndex].focus();
            break;
          case 'ArrowUp':
            e.preventDefault();
            currentFocusIndex = currentFocusIndex <= 0 ? elements.length - 1 : currentFocusIndex - 1;
            elements[currentFocusIndex].focus();
            break;
          case 'Home':
            e.preventDefault();
            currentFocusIndex = 0;
            elements[currentFocusIndex].focus();
            break;
          case 'End':
            e.preventDefault();
            currentFocusIndex = elements.length - 1;
            elements[currentFocusIndex].focus();
            break;
        }
      });
    }

    // ãƒãƒ³ãƒãƒ¼ã‚¬ãƒ¼ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³å‡¦ç†
    function handleHamburgerMenuAction(action) {
      switch (action) {
        case 'show-toc':
          // ç›®æ¬¡ã‚’è¡¨ç¤º
          const tocMobileBtn = document.getElementById('toc-mobile-btn');
          if (tocMobileBtn) tocMobileBtn.click();
          break;
        case 'font-size':
          // æ–‡å­—ã‚µã‚¤ã‚ºãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚’é–‹ã
          if (settingsMenu) {
            settingsMenu.classList.add('open');
            settingsMenuOverlay.classList.add('open');
          }
          break;
        case 'theme':
          // ãƒ†ãƒ¼ãƒãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚’é–‹ã
          if (settingsMenu) {
            settingsMenu.classList.add('open');
            settingsMenuOverlay.classList.add('open');
          }
          break;
        case 'export-comments-page':
          exportComments(true);
          break;
        case 'export-comments-all':
          exportComments(false);
          break;
        case 'import-comments':
          if (commentsImport) commentsImport.click();
          break;
        case 'download-pdf':
          window.print();
          break;
      }
    }

    // è¨­å®šãƒ¡ãƒ‹ãƒ¥ãƒ¼é–‹é–‰æ©Ÿèƒ½
    if (settingsToggleBtn && settingsMenu && settingsMenuOverlay) {
      const openSettingsMenu = () => {
        settingsMenu.classList.add('open');
        settingsMenuOverlay.classList.add('open');
      };

      const closeSettingsMenu = () => {
        settingsMenu.classList.remove('open');
        settingsMenuOverlay.classList.remove('open');
      };

      settingsToggleBtn.addEventListener('click', openSettingsMenu);
      settingsMenuClose.addEventListener('click', closeSettingsMenu);
      settingsMenuOverlay.addEventListener('click', closeSettingsMenu);

      // ESCã‚­ãƒ¼ã§ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚’é–‰ã˜ã‚‹
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && settingsMenu.classList.contains('open')) {
          closeSettingsMenu();
        }
      });
    }

    // ãƒ†ãƒ¼ãƒåˆ‡æ›¿æ©Ÿèƒ½
    if (themeSelect) {
      const mq = window.matchMedia('(prefers-color-scheme: dark)');
      function applyTheme(mode) {
        if (mode === 'auto') {
          document.body.setAttribute('data-theme', mq.matches ? 'dark' : 'light');
        } else {
          document.body.setAttribute('data-theme', mode);
        }
      }
      const saved = localStorage.getItem(STORAGE_KEYS.theme) || 'auto';
      themeSelect.value = saved;
      applyTheme(saved);
      mq.addEventListener('change', () => { if ((localStorage.getItem(STORAGE_KEYS.theme) || 'auto') === 'auto') applyTheme('auto'); });
      themeSelect.addEventListener('change', (e) => {
        const theme = e.target.value;
        localStorage.setItem(STORAGE_KEYS.theme, theme);
        applyTheme(theme);
      });
    }

    // æ–‡å­—ã‚µã‚¤ã‚ºå¤‰æ›´æ©Ÿèƒ½
    if (fontSizeSelect) {
      const currentSize = localStorage.getItem(STORAGE_KEYS.fontSize) || 'M';
      fontSizeSelect.value = currentSize;
      document.body.setAttribute('data-font-size', currentSize);
      fontSizeSelect.addEventListener('change', (e) => {
        const size = e.target.value;
        document.body.setAttribute('data-font-size', size);
        localStorage.setItem(STORAGE_KEYS.fontSize, size);
      });
    }

    // ãƒ¢ãƒã‚¤ãƒ«ç”¨ç›®æ¬¡ãƒœã‚¿ãƒ³
    if (tocMobileBtn) {
      tocMobileBtn.addEventListener('click', () => {
        const tocPanel = document.getElementById('quarto-sidebar');
        if (tocPanel) tocPanel.classList.toggle('mobile-open');
      });
    }

    // ã‚³ãƒ¡ãƒ³ãƒˆå‡ºåŠ›æ©Ÿèƒ½
    if (commentsExportPage) {
      commentsExportPage.addEventListener('click', () => exportComments(true));
    }
    if (commentsExportAll) {
      commentsExportAll.addEventListener('click', () => exportComments(false));
    }

    // ã‚³ãƒ¡ãƒ³ãƒˆã‚¤ãƒ³ãƒãƒ¼ãƒˆæ©Ÿèƒ½
    if (commentsImport && commentsImportButton) {
      commentsImport.addEventListener('change', (e) => importCommentsFromFile(e.target.files[0]));
      commentsImportButton.addEventListener('click', () => commentsImport.click());
    }
  }

  function setupLeftPanelTabs() {
    const sidebar = document.getElementById('quarto-sidebar');
    if (!sidebar) return;
    const menuContainer = sidebar.querySelector('.sidebar-menu-container');
    if (!menuContainer) return;
    const tabWrapper = document.createElement('div');
    tabWrapper.className = 'toc-switcher';
    tabWrapper.innerHTML = `
<div class="toc-tabs">
        <button type="button" class="toc-tab active" data-tab="site">å„ç« </button>
        <button type="button" class="toc-tab" data-tab="page">ç« å†…</button>
        <button type="button" class="toc-tab" data-tab="all">å…¨ä½“</button>
      </div>
      <div class="toc-panel toc-site-content"></div>
      <div class="toc-panel toc-page-content hidden"></div>
      <div class="toc-panel toc-all-content hidden"></div>
    `;

    const menuCloneForAll = menuContainer.cloneNode(true);
    const parent = menuContainer.parentNode;
    parent.replaceChild(tabWrapper, menuContainer);
    const sitePanel = tabWrapper.querySelector('.toc-site-content');
    sitePanel.appendChild(menuContainer);
    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: å„ç« ã‚¿ãƒ–ã¯ç¬¬2éšå±¤ã¾ã§å±•é–‹
    try { setSidebarDepth(menuContainer, 2); } catch (e) { console.warn('setSidebarDepth failed for site', e); }

    const pagePanel = tabWrapper.querySelector('.toc-page-content');

    const allPanel = tabWrapper.querySelector('.toc-all-content');
    if (menuCloneForAll) {
      // å„ç« ã‚¿ãƒ–: ç¬¬2éšå±¤ã¾ã§å±•é–‹ï¼ˆå¾“æ¥ã®ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰
      setSidebarDepth(menuCloneForAll, 2);
      allPanel.appendChild(menuCloneForAll);
    } else {
      allPanel.innerHTML = '<p class="toc-empty">ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚’èª­ã¿è¾¼ã‚ã¾ã›ã‚“ã§ã—ãŸã€‚</p>';
    }

    const tabButtons = tabWrapper.querySelectorAll('.toc-tab');
    const panels = { site: sitePanel, page: pagePanel, all: allPanel };
    tabButtons.forEach(button => {
      button.addEventListener('click', () => {
        const target = button.dataset.tab;
        tabButtons.forEach(btn => btn.classList.remove('active'));
        button.classList.add('active');
        Object.values(panels).forEach(p => p.classList.add('hidden'));
        if (panels[target]) panels[target].classList.remove('hidden');
      });
    });
  }

  function setupRightSidebar() {
    ensureRightTabs();
    refreshRightPanels();
    const onResize = debounce(() => {
      ensureRightTabs();
      refreshRightPanels();
    }, 200);
    window.addEventListener('resize', onResize);
    window.addEventListener('orientationchange', onResize);
    window.addEventListener('hashchange', () => { setTimeout(refreshRightPanels, 60); });
  }

  function refreshRightPanels() {
    applyFootnoteLayout();
    renderCommentsPanel();
    if (SIDENOTES_ON) {
      renderSidenotes(currentRightTab());
    } else {
      activateRightTab(currentRightTab(), { skipSave: true });
    }
  }

  function ensureRightTabs() {
    const marginSidebar = document.getElementById('quarto-margin-sidebar');
    if (!marginSidebar) return;
    let wrapper = marginSidebar.querySelector('.right-switcher');
    if (!wrapper) {
      wrapper = document.createElement('div');
      wrapper.className = 'right-switcher';
      wrapper.innerHTML = `
        <div class="toc-tabs">
          <button type="button" class="toc-tab" data-tab="footnotes">è„šæ³¨</button>
          <button type="button" class="toc-tab" data-tab="comments">ã‚³ãƒ¡ãƒ³ãƒˆ</button>
          <button type="button" class="toc-tab" data-tab="both">ä¸¡æ–¹</button>
        </div>
        <div class="sidenotes-toolbar">
          <label class="sidenotes-toggle"><input type="checkbox" id="sidenotes-toggle"> å‚æ³¨è¡¨ç¤º</label>
        </div>
        <div class="toc-panel right-footnotes"></div>
        <div class="toc-panel right-comments" style="display:none"></div>
        <div class="toc-panel right-both" style="display:none"></div>
      `;
      marginSidebar.innerHTML = '';
      marginSidebar.appendChild(wrapper);

      const tabs = wrapper.querySelectorAll('.toc-tab');
      tabs.forEach(btn => {
        btn.addEventListener('click', () => {
          activateRightTab(btn.dataset.tab || 'footnotes');
        });
      });

      const sidenotesToggle = wrapper.querySelector('#sidenotes-toggle');
      if (sidenotesToggle) {
        sidenotesToggle.addEventListener('change', (e) => setSidenotesMode(e.target.checked));
      }
      const savedTab = getSavedRightTab();
      activateRightTab(savedTab, { skipSave: true });
      if (sidenotesToggle) {
        sidenotesToggle.checked = true;
        setSidenotesMode(true);
      } else {
        setSidenotesMode(false);
      }
    } else {
      const toggle = wrapper.querySelector('#sidenotes-toggle');
      if (toggle) toggle.checked = SIDENOTES_ON;
      activateRightTab(getSavedRightTab(), { skipSave: true });
    }
  }

  let SIDENOTES_ON = false;
  let SIDENOTES_ITEMS = [];

  function activateRightTab(tab, opts = {}) {
    const marginSidebar = document.getElementById('quarto-margin-sidebar');
    if (!marginSidebar) return;
    const wrapper = marginSidebar.querySelector('.right-switcher');
    if (!wrapper) return;
    const tabs = Array.from(wrapper.querySelectorAll('.toc-tab'));
    const normalized = ['footnotes', 'comments', 'both'].includes(tab) ? tab : 'footnotes';
    tabs.forEach(btn => btn.classList.toggle('active', btn.dataset.tab === normalized));
    const footPanel = wrapper.querySelector('.right-footnotes');
    const commPanel = wrapper.querySelector('.right-comments');
    const bothPanel = wrapper.querySelector('.right-both');
    if (SIDENOTES_ON) {
      if (footPanel) footPanel.style.display = 'none';
      if (commPanel) commPanel.style.display = 'none';
      if (bothPanel) bothPanel.style.display = 'none';
      renderSidenotes(normalized);
    } else {
      if (footPanel) footPanel.style.display = normalized === 'footnotes' ? '' : 'none';
      if (commPanel) commPanel.style.display = normalized === 'comments' ? '' : 'none';
      if (bothPanel) bothPanel.style.display = normalized === 'both' ? '' : 'none';
    }
    if (!opts.skipSave) saveRightTab(normalized);
  }

  function currentRightTab() {
    const active = document.querySelector('#quarto-margin-sidebar .toc-tab.active');
    if (active) return active.getAttribute('data-tab') || 'footnotes';
    return getSavedRightTab();
  }

  function setSidenotesMode(on) {
    const ms = document.getElementById('quarto-margin-sidebar');
    if (!ms) return;
    const foot = ms.querySelector('.right-footnotes');
    const comm = ms.querySelector('.right-comments');
    const both = ms.querySelector('.right-both');
    SIDENOTES_ON = !!on;
    if (SIDENOTES_ON) {
      ms.classList.add('sidenotes-on');
      if (foot) foot.style.display = 'none';
      if (comm) comm.style.display = 'none';
      if (both) both.style.display = 'none';
      renderSidenotes(currentRightTab());
      window.addEventListener('scroll', updateSidenotesPositions, { passive: true });
      window.addEventListener('resize', updateSidenotesPositions);
    } else {
      ms.classList.remove('sidenotes-on');
      clearSidenotes();
      window.removeEventListener('scroll', updateSidenotesPositions);
      window.removeEventListener('resize', updateSidenotesPositions);
      activateRightTab(currentRightTab(), { skipSave: true });
    }
  }

  function clearSidenotes() {
    const ms = document.getElementById('quarto-margin-sidebar');
    ms.querySelectorAll('.margin-note').forEach(n => n.remove());
    SIDENOTES_ITEMS = [];
  }

  function renderSidenotes(mode) {
    clearSidenotes();
    const ms = document.getElementById('quarto-margin-sidebar');
    if (!ms) return;
    const makeNote = (opts) => {
      const note = document.createElement('div');
      note.className = 'margin-note' + (opts.kind==='comment' ? ' comment' : '');
      note.innerHTML = `
        <div class=\"meta\"><span>${opts.time||''}</span>${opts.moveHtml||''}${opts.showMenu ? '<button class="menu" title="ãƒ¡ãƒ‹ãƒ¥ãƒ¼" style="margin-left:auto;background:none;border:none;cursor:pointer;font-size:16px;line-height:1;">â‹¯</button>' : ''}</div>
        ${opts.targetHtml||''}
        <div class=\"body\">${opts.bodyHtml||''}</div>
      `;
      ms.appendChild(note);
      return note;
    };

    const footnotes = gatherActiveFootnotes();
    const comments = gatherActiveCommentsWithElements();

    const entries = [];
    if (mode !== 'comments') {
      footnotes.forEach(fn => {
        if (!fn.ref) return;
        entries.push({ kind: 'foot', el: fn.ref, def: fn.li });
      });
    }
    if (mode !== 'footnotes') {
      comments.forEach(item => {
        if (!item.el) return;
        entries.push({ kind: 'comment', el: item.el, rec: item.rec });
      });
    }

    SIDENOTES_ITEMS = entries.map(entry => {
      if (entry.kind === 'comment') {
        const rec = entry.rec;
        const note = makeNote({
          kind: 'comment',
          time: fmtMMDDHHmm(rec.t),
          moveHtml: `<a href="#" class="mv">ç§»å‹•</a>`,
          targetHtml: `<div class="target">${escapeHtml((rec.text||'').slice(0,80))}</div>`,
          bodyHtml: escapeHtml(rec.body||''),
          showMenu: true
        });
        note.querySelector('.mv')?.addEventListener('click', (e)=>{ e.preventDefault(); scrollToComment(rec); });
        note.querySelector('.menu')?.addEventListener('click', (e)=>{ e.stopPropagation(); openCommentMenu(note, rec, { x: e.clientX, y: e.clientY }); });
        return { kind: 'comment', el: entry.el, node: note };
      } else {
        const txt = entry.def ? entry.def.innerText || entry.def.textContent || '' : '';
        const note = makeNote({
          kind: 'foot',
          bodyHtml: escapeHtml(txt),
          moveHtml: '',
          showMenu: false
        });
        note.querySelector('.menu')?.remove();
        return { kind: 'foot', el: entry.el, node: note };
      }
    });

    updateSidenotesPositions();
  }

  function rightSidebarBaseOffset() {
    const ms = document.getElementById('quarto-margin-sidebar');
    if (!ms) return 0;
    const switcher = ms.querySelector('.right-switcher');
    return switcher ? switcher.offsetHeight + 12 : 0;
  }

  function updateSidenotesPositions() {
    if (!SIDENOTES_ON) return;
    const ms = document.getElementById('quarto-margin-sidebar');
    if (!ms) return;
    const msTop = ms.getBoundingClientRect().top;
    const viewH = window.innerHeight || document.documentElement.clientHeight;
    const baseOffset = rightSidebarBaseOffset();

    SIDENOTES_ITEMS.forEach(item => { if (item.node) item.node.style.display = 'none'; });

    const desired = SIDENOTES_ITEMS
      .filter(item => item.el && item.node && item.el.getClientRects().length)
      .map(item => {
        const rect = item.el.getBoundingClientRect();
        return { item, rect, desiredTop: rect.top - msTop };
      })
      .sort((a,b)=>a.desiredTop-b.desiredTop);

    const gap = 8;
    let cursor = baseOffset;
    desired.forEach(({item, rect, desiredTop}) => {
      const node = item.node;
      if (!node) return;
      const visible = !(rect.bottom < 0 || rect.top > viewH);
      if (!visible) {
        node.style.display = 'none';
        return;
      }
      const targetTop = Math.max(cursor, desiredTop + baseOffset);
      node.style.display = 'block';
      node.style.top = targetTop + 'px';
      cursor = targetTop + node.offsetHeight + gap;
    });
  }

  function applyFootnoteLayout() {
    const isPortrait = window.matchMedia('(orientation: portrait)').matches || (window.innerHeight > window.innerWidth);
    if (isPortrait) {
      renderInlineFootnotes();
    } else {
      renderSidebarFootnotes();
    }
  }

  function renderSidebarFootnotes() {
    document.querySelectorAll('.footnote-inline').forEach(n => n.remove());
    const marginSidebar = document.getElementById('quarto-margin-sidebar');
    if (!marginSidebar) return;
    const footHost = marginSidebar.querySelector('.right-footnotes') || marginSidebar;
    const bothHost = marginSidebar.querySelector('.right-both');
    footHost.innerHTML = '';
    if (bothHost) bothHost.innerHTML = '';

    const headerRow = document.createElement('div');
    headerRow.style.cssText = 'display:flex;align-items:center;justify-content:space-between;margin-bottom:6px;';
    const header = document.createElement('h2');
    header.className = 'footnotes-title';
    header.textContent = 'è„šæ³¨';
    const sort = document.createElement('select');
    sort.innerHTML = '<option value="pos">æœ¬æ–‡ä½ç½®é †</option><option value="num">ç•ªå·é †</option>';
    sort.value = localStorage.getItem('footnotes-sort') || 'pos';
    sort.addEventListener('change', () => { localStorage.setItem('footnotes-sort', sort.value); renderSidebarFootnotes(); });
    headerRow.appendChild(header); headerRow.appendChild(sort);
    footHost.appendChild(headerRow);

    const footnotes = gatherActiveFootnotes();
    if (!footnotes.length) {
      footHost.insertAdjacentHTML('beforeend','<p class="footnotes-empty">ã“ã®ãƒšãƒ¼ã‚¸ã«ã¯è„šæ³¨ãŒã‚ã‚Šã¾ã›ã‚“ã€‚</p>');
      if (bothHost) bothHost.insertAdjacentHTML('beforeend','<p class="footnotes-empty">ã“ã®ãƒšãƒ¼ã‚¸ã«ã¯è„šæ³¨/ã‚³ãƒ¡ãƒ³ãƒˆãŒã‚ã‚Šã¾ã›ã‚“ã€‚</p>');
      return;
    }

    const items = footnotes.slice();
    const mode = sort.value;
    const getSortableNumber = (item) => {
      const primary = Number(item.number);
      if (!Number.isNaN(primary)) return primary;
      const fallbackFromId = Number(String(item.id || '').replace(/[^0-9]+/g, ''));
      if (!Number.isNaN(fallbackFromId)) return fallbackFromId;
      return Number.POSITIVE_INFINITY;
    };
    if (mode === 'pos') {
      items.sort((a,b)=>a.pos-b.pos);
    } else {
      items.sort((a,b)=> {
        const numA = getSortableNumber(a);
        const numB = getSortableNumber(b);
        if (numA !== numB) return numA - numB;
        const labelA = (a.number || '').toString();
        const labelB = (b.number || '').toString();
        const cmpLabel = labelA.localeCompare(labelB, undefined, { numeric: true, sensitivity: 'base' });
        if (cmpLabel !== 0) return cmpLabel;
        return (a.id || '').localeCompare(b.id || '');
      });
    }

    const wrapper = document.createElement('div');
    wrapper.className = 'margin-footnotes';
    const ol = document.createElement('ol');
    items.forEach((it, idx) => {
      const clone = it.li.cloneNode(true);
      const displayLabel = (it.number && String(it.number).trim().length) ? String(it.number).trim() : String(idx + 1);
      if (!clone.querySelector('.footnote-num')) {
        const num = document.createElement('span');
        num.className = 'footnote-num';
        num.textContent = displayLabel + '. ';
        clone.insertBefore(num, clone.firstChild);
      }
      it.number = displayLabel;
      it.displayIndex = displayLabel;
      it.clone = clone;
      ol.appendChild(clone);
    });
    wrapper.appendChild(ol);
    footHost.appendChild(wrapper);

    // ä¸¡æ–¹ã‚¿ãƒ–: ã‚³ãƒ¡ãƒ³ãƒˆã¨è„šæ³¨ã‚’æœ¬æ–‡ä½ç½®ã§æ··åœ¨
    if (bothHost) renderBothPanel(bothHost, items);

    setupScrollSyncForFootnotes(footHost, items);
  }

  function renderBothPanel(host, footItems) {
    const commentAnchors = gatherActiveCommentsWithElements();
    const commItems = commentAnchors.map(({ rec, el }) => {
      const rect = el ? el.getBoundingClientRect() : null;
      const top = rect ? (rect.top + window.scrollY) : Infinity;
      return { type: 'comment', top, rec };
    });
    const footMixed = (footItems || []).map((f) => ({
      type: 'foot',
      top: f.pos,
      id: f.id,
      displayIndex: f.displayIndex,
      number: f.number,
      clone: f.li.cloneNode(true)
    }));
    const merged = commItems.concat(footMixed).sort((a, b) => a.top - b.top);

    host.innerHTML = '';
    const header = document.createElement('h2');
    header.className = 'footnotes-title';
    header.textContent = 'ä¸¡æ–¹';
    host.appendChild(header);

    const list = document.createElement('div');
    list.className = 'both-mixed-list';
    list.style.cssText = 'display:flex; flex-direction:column; gap:8px;';

    merged.forEach(item => {
      if (item.type === 'comment') {
        const rec = item.rec;
        const card = document.createElement('div');
        card.className = 'comment-card';
        card.style.cssText = 'padding:10px;background:#fff;border-radius:6px;border-left:3px solid #ff9800;box-shadow:0 1px 3px rgba(0,0,0,0.08);';
        const meta = document.createElement('div');
        meta.className = 'comment-meta';
        meta.style.cssText = 'font-size:12px;color:#6c757d;margin-bottom:6px;display:flex;gap:8px;align-items:center;';
        const t = document.createElement('span');
        t.textContent = fmtMMDDHHmm(rec.t);
        const move = document.createElement('a');
        move.href = '#';
        move.textContent = 'ç§»å‹•';
        move.addEventListener('click', (e) => { e.preventDefault(); scrollToComment(rec); });
        meta.appendChild(t);
        meta.appendChild(move);
        const target = document.createElement('div');
        target.className = 'comment-snippet';
        target.style.cssText = 'font-size:13px;color:#495057;background:#fff3e0;padding:6px 8px;border-radius:4px;margin-bottom:6px;';
        target.textContent = rec.text || '';
        const body = document.createElement('div');
        body.className = 'comment-body';
        body.style.cssText = 'white-space:pre-wrap; line-height:1.5;';
        body.textContent = rec.body || '';
        card.appendChild(meta);
        card.appendChild(target);
        card.appendChild(body);
        list.appendChild(card);
      } else {
        const wrapper = document.createElement('div');
        wrapper.className = 'both-footnote-card';
        wrapper.style.cssText = 'padding:10px;background:#fff;border-radius:6px;border-left:3px solid #6c757d;box-shadow:0 1px 3px rgba(0,0,0,0.06);';
        const clone = item.clone;
        if (!clone.querySelector('.footnote-num')) {
          const num = document.createElement('span');
          num.className = 'footnote-num';
          const label = (item.displayIndex && String(item.displayIndex).trim().length)
            ? String(item.displayIndex).trim()
            : (item.number && String(item.number).trim().length)
              ? String(item.number).trim()
              : String(footMixed.indexOf(item) + 1);
          num.textContent = label + '. ';
          clone.insertBefore(num, clone.firstChild);
        }
        wrapper.appendChild(clone);
        list.appendChild(wrapper);
      }
    });
    host.appendChild(list);
    setupScrollSyncForBoth(host, merged);
  }

  function setupScrollSyncForFootnotes(host, items) {
    const mode = localStorage.getItem('footnotes-sort') || 'pos';
    if (mode !== 'pos') return;
    const onScroll = () => {
      const center = window.scrollY + window.innerHeight/2;
      let best = null, bestD = Infinity;
      items.forEach(it => {
        const d = Math.abs((it.pos ?? Infinity) - center);
        if (d < bestD) { best = it; bestD = d; }
      });
      if (best) {
        const nodes = host.querySelectorAll('ol > li');
        const idx = items.indexOf(best);
        const li = nodes[idx];
        const container = document.getElementById('quarto-margin-sidebar') || host;
        if (li && container) {
          const targetTop = li.offsetTop - (container.clientHeight/2 - li.clientHeight/2);
          container.scrollTo({ top: Math.max(0, targetTop), behavior: 'smooth' });
        }
      }
    };
    window.addEventListener('scroll', onScroll, { passive: true });
  }

  function setupScrollSyncForBoth(host, items) {
    const onScroll = () => {
      const center = window.scrollY + window.innerHeight/2;
      let bestIndex = -1, bestD = Infinity;
      items.forEach((it, i) => {
        const d = Math.abs((it.top ?? Infinity) - center);
        if (d < bestD) { bestD = d; bestIndex = i; }
      });
      if (bestIndex >= 0) {
        const list = host.lastElementChild; // list container
        const card = list && list.children[bestIndex];
        const container = document.getElementById('quarto-margin-sidebar') || host;
        if (card && container) {
          const targetTop = card.offsetTop - (container.clientHeight/2 - card.clientHeight/2);
          container.scrollTo({ top: Math.max(0, targetTop), behavior: 'smooth' });
        }
      }
    };
    window.addEventListener('scroll', onScroll, { passive: true });
  }

  function renderCommentsPanel() {
    const marginSidebar = document.getElementById('quarto-margin-sidebar');
    if (!marginSidebar) return;
    const commHost = marginSidebar.querySelector('.right-comments');
    if (!commHost) return;
    const list = getActiveComments();
    commHost.innerHTML = '';

    const header = document.createElement('div');
    header.style.cssText = 'display:flex;align-items:center;justify-content:space-between;margin-bottom:6px;';
    const title = document.createElement('h2');
    title.className = 'footnotes-title';
    title.textContent = 'ã‚³ãƒ¡ãƒ³ãƒˆ';
    const sort = document.createElement('select');
    sort.innerHTML = '<option value="new">æ–°ã—ã„é †</option><option value="pos">æœ¬æ–‡ä½ç½®é †</option><option value="old">å¤ã„é †</option>';
    sort.value = localStorage.getItem('comments-sort') || 'new';
    sort.addEventListener('change', () => { localStorage.setItem('comments-sort', sort.value); renderCommentsPanel(); });
    header.appendChild(title); header.appendChild(sort);
    commHost.appendChild(header);

    if (!list.length) { commHost.insertAdjacentHTML('beforeend','<p class="footnotes-empty">ã‚³ãƒ¡ãƒ³ãƒˆã¯ã‚ã‚Šã¾ã›ã‚“ã€‚</p>'); return; }

    const computePos = (rec) => {
      const el = findCommentAnchorElement(rec);
      const top = el ? (el.getBoundingClientRect().top + window.scrollY) : Infinity;
      return top;
    };

    let arr = list.slice();
    const mode = sort.value;
    if (mode === 'new') arr.sort((a,b)=>b.t-a.t);
    else if (mode === 'old') arr.sort((a,b)=>a.t-b.t);
    else if (mode === 'pos') arr.sort((a,b)=>computePos(a)-computePos(b));

    const ul = document.createElement('ul');
    ul.className = 'comment-list';
    ul.style.listStyle = 'none'; ul.style.padding = '0'; ul.style.margin = '0';

    arr.forEach(rec => {
      const li = document.createElement('li');
      li.dataset.id = rec.id;
      li.className = 'comment-item';
      li.style.cssText = 'margin:12px 0; padding:10px; background:#fff; border-radius:6px; border-left:3px solid #6c757d; box-shadow:0 1px 3px rgba(0,0,0,0.08); position:relative;';
      const meta = document.createElement('div');
      meta.className = 'comment-meta';
      meta.style.cssText = 'font-size:12px; color:#6c757d; margin-bottom:6px; display:flex; gap:8px; align-items:center;';
      const time = fmtMMDDHHmm(rec.t);
      const move = document.createElement('a');
      move.href = '#'; move.textContent = 'ç§»å‹•';
      move.addEventListener('click', (e) => { e.preventDefault(); scrollToComment(rec); });
      const menuBtn = document.createElement('button');
      menuBtn.textContent = 'â‹¯';
      menuBtn.setAttribute('aria-label','ãƒ¡ãƒ‹ãƒ¥ãƒ¼');
      menuBtn.style.cssText = 'margin-left:auto;background:none;border:none;cursor:pointer;font-size:18px;line-height:1;';
      menuBtn.addEventListener('click', (e) => { e.stopPropagation(); openCommentMenu(li, rec, {x:e.clientX,y:e.clientY}); });
      meta.innerHTML = `<span>${time}</span>`;
      meta.appendChild(move);
      meta.appendChild(menuBtn);

      const target = document.createElement('div');
      target.className = 'comment-snippet';
      target.style.cssText = 'font-size:13px; color:#495057; background:#f8f9fa; padding:6px 8px; border-radius:4px; margin-bottom:6px;';
      target.textContent = rec.text || '';
      const body = document.createElement('div');
      body.className = 'comment-body';
      body.style.cssText = 'white-space:pre-wrap; line-height:1.5;';
      body.textContent = rec.body || '';
      li.appendChild(meta); li.appendChild(target); li.appendChild(body);
      ul.appendChild(li);
    });

    commHost.appendChild(ul);

    setupScrollSyncForComments(commHost, arr);
  }

  function openCommentMenu(li, rec, pt) {
    closeAnyInlineMenu();
    const menu = document.createElement('div');
    menu.className = 'comment-menu-popup';
    menu.style.cssText = 'position:fixed; background:#fff; border:1px solid #e1e5eb; box-shadow:0 4px 12px rgba(0,0,0,0.12); border-radius:6px; z-index:10001; padding:6px;';
    menu.innerHTML = '<button type="button" data-act="edit" style="display:block;width:100%;text-align:left;padding:6px 10px;background:none;border:none;cursor:pointer;">ç·¨é›†</button>\n<button type="button" data-act="del" style="display:block;width:100%;text-align:left;padding:6px 10px;background:none;border:none;cursor:pointer;">å‰Šé™¤</button>';
    document.body.appendChild(menu);
    const x = pt?.x || (li.getBoundingClientRect().right - 10);
    const y = pt?.y || (li.getBoundingClientRect().top + 20);
    menu.style.left = x + 'px';
    menu.style.top = y + 'px';
    const onDoc = (e)=>{ if (!menu.contains(e.target)) { closeAnyInlineMenu(); document.removeEventListener('mousedown', onDoc, true);} };
    document.addEventListener('mousedown', onDoc, true);
    menu.addEventListener('click', (e) => {
      const act = e.target?.getAttribute('data-act');
      if (act === 'edit') editComment(rec);
      if (act === 'del') deleteComment(rec);
      closeAnyInlineMenu();
    });
  }

  function closeAnyInlineMenu(){ document.querySelectorAll('.comment-menu-popup').forEach(n=>n.remove()); }

  function editComment(rec) {
    const overlay = document.createElement('div');
    overlay.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.4);z-index:10000;display:flex;align-items:center;justify-content:center;';
    const dialog = document.createElement('div');
    dialog.style.cssText = 'background:#fff;color:#222;max-width:600px;width:92%;padding:16px;border-radius:8px;box-shadow:0 10px 30px rgba(0,0,0,0.25);';
    dialog.innerHTML = `
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
        <h3 style="margin:0;font-size:16px;">ã‚³ãƒ¡ãƒ³ãƒˆç·¨é›†</h3>
        <button type=\"button\" aria-label=\"é–‰ã˜ã‚‹\" style=\"background:none;border:none;font-size:18px;cursor:pointer;\">Ã—</button>
      </div>
      <div style="font-size:13px;color:#555;background:#f8f9fa;border:1px solid #e9ecef;padding:8px;border-radius:4px;margin-bottom:8px;">å¯¾è±¡: ${(rec.text||'').slice(0,140)}</div>
      <textarea id="comment-edit-area" rows="6" style="width:100%;font-size:14px;padding:8px;border-radius:6px;border:1px solid #ced4da;resize:vertical;">${(rec.body||'')}</textarea>
      <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:10px;">
        <button type="button" id="comment-edit-cancel" style="padding:6px 12px;border:1px solid #dee2e6;border-radius:4px;background:#f8f9fa;cursor:pointer;">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
        <button type="button" id="comment-edit-save" style="padding:6px 12px;border:1px solid #0d6efd;border-radius:4px;background:#0d6efd;color:#fff;cursor:pointer;">ä¿å­˜</button>
      </div>
    `;
    overlay.appendChild(dialog);
    document.body.appendChild(overlay);
    const close = ()=>overlay.remove();
    dialog.querySelector('[aria-label="é–‰ã˜ã‚‹"]').addEventListener('click', close);
    dialog.querySelector('#comment-edit-cancel').addEventListener('click', close);
    dialog.querySelector('#comment-edit-save').addEventListener('click', () => {
      const v = (dialog.querySelector('#comment-edit-area').value||'').trim();
      if (!v) return;
      const key = pageKey();
      const arr = COMMENTS_DB[key]||[];
      const idx = arr.findIndex(x=>x.id===rec.id);
      if (idx>=0) {
        arr[idx].body = v;
        arr[idx].t = Date.now();
        COMMENTS_DB[key]=arr;
        saveComments();
        refreshRightPanels();
      }
      close();
    });
  }

  function deleteComment(rec) {
    if (!confirm('ã“ã®ã‚³ãƒ¡ãƒ³ãƒˆã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ')) return;
    const key = pageKey();
    const arr = COMMENTS_DB[key]||[];
    COMMENTS_DB[key] = arr.filter(x=>x.id!==rec.id);
    saveComments();
    // ãƒãƒ¼ã‚«ãƒ¼ã‚‚å‰Šé™¤
    document.querySelectorAll(`.text-marker[data-comment-id="${rec.id}"]`).forEach(el => {
      const p = el.parentNode; while (el.firstChild) p.insertBefore(el.firstChild, el); p.removeChild(el);
    });
    refreshRightPanels();
  }

  function setupScrollSyncForComments(host, items) {
    const mode = localStorage.getItem('comments-sort') || 'new';
    if (mode !== 'pos') return;
    const onScroll = () => {
      const center = window.scrollY + window.innerHeight/2;
      let best = null, bestD = Infinity;
      items.forEach(rec => {
        const el = findCommentAnchorElement(rec);
        const top = el ? (el.getBoundingClientRect().top + window.scrollY) : Infinity;
        const d = Math.abs(top - center);
        if (d < bestD) { best = rec; bestD = d; }
      });
      if (best) {
        const li = host.querySelector(`li[data-id="${best.id}"]`);
        const container = document.getElementById('quarto-margin-sidebar') || host;
        if (li && container) {
          const targetTop = li.offsetTop - (container.clientHeight/2 - li.clientHeight/2);
          container.scrollTo({ top: Math.max(0, targetTop), behavior: 'smooth' });
        }
      }
    };
    window.addEventListener('scroll', onScroll, { passive: true });
  }

  function scrollToComment(rec) {
    try {
      const first = (rec.ranges && rec.ranges[0]);
      if (!first) return;
      const node = getNodeByPathSafe(first.s);
      if (!node) return;
      let el = node.nodeType === Node.ELEMENT_NODE ? node : node.parentElement;
      while (el && el !== document.body && !(el instanceof HTMLElement)) el = el.parentElement;
      if (!el) return;
      el.scrollIntoView({ behavior: 'smooth', block: 'center' });
      const prev = el.style.boxShadow;
      el.style.transition = 'box-shadow 0.3s ease';
      el.style.boxShadow = '0 0 0 3px rgba(26,115,232,0.5)';
      setTimeout(() => { el.style.boxShadow = prev || ''; }, 1600);
    } catch (e) { console.warn('scrollToComment failed', e); }
  }

  function getNodeByPathSafe(path) {
    try { let n=document.body; for (const idx of path||[]) { if (!n || !n.childNodes[idx]) return null; n = n.childNodes[idx]; } return n; } catch { return null; }
  }

  function renderInlineFootnotes() {
    const marginSidebar = document.getElementById('quarto-margin-sidebar');
    if (marginSidebar) marginSidebar.innerHTML = '';
    document.querySelectorAll('.footnote-inline').forEach(n => n.remove());
    const active = getActiveChapterSection();
    const scope = active || document;
    const refSelector = 'a[role="doc-noteref"], a.footnote-ref';
    const refs = Array.from(scope.querySelectorAll(refSelector)).filter(ref => !active || active.contains(ref));
    if (!refs.length) return;
    refs.forEach(ref => {
      const href = ref.getAttribute('href') || ref.getAttribute('data-footnote-href');
      if (!href || !href.startsWith('#')) return;
      const id = href.slice(1);
      const target = document.getElementById(id);
      if (!target) return;
      if (active) {
        const section = target.closest('section.chapter-page');
        if (section && section !== active) return;
      }
      const numberText = (ref.textContent || '').replace(/[^0-9]/g, '') || '';
      const host = findHostParagraph(ref);
      if (!host) return;
      const clone = target.cloneNode(true);
      clone.querySelectorAll('.footnote-back, .footnote-backref, [role="doc-backlink"]').forEach(a => a.remove());
      const container = document.createElement('div');
      container.className = 'footnote-inline';
      const numSpan = document.createElement('span');
      numSpan.className = 'footnote-num';
      numSpan.textContent = (numberText ? numberText : '') + '. ';
      container.appendChild(numSpan);
      while (clone.firstChild) container.appendChild(clone.firstChild);
      host.insertAdjacentElement('afterend', container);
    });
  }

  function findHostParagraph(el) {
    let p = el;
    while (p && p !== document.body) {
      if (p.tagName === 'P' || p.tagName === 'LI') return p;
      p = p.parentElement;
    }
    return null;
  }

  function debounce(fn, ms) {
    let t;
    return (...args) => { clearTimeout(t); t = setTimeout(() => fn.apply(this, args), ms); };
  }

  function setupMarkerFunctionality() {
    let markersDB = JSON.parse(localStorage.getItem(STORAGE_KEYS.markers) || '{}');
    let pendingSerializedRange = null;

    // æ—¢å­˜ãƒãƒ¼ã‚«ãƒ¼ã‚’å¾©å…ƒ
    restoreMarkers();
    restoreCommentMarkers();

    // ãƒ†ã‚­ã‚¹ãƒˆé¸æŠã§ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ã‚’è¡¨ç¤ºï¼ˆUIè¦ç´ ä¸Šã¯ç„¡åŠ¹ï¼‰
    document.addEventListener('mouseup', (e) => {
      if (closestInteractive(e.target)) return;
      const sel = window.getSelection();
      if (!sel || sel.rangeCount === 0) {
        hideMarkerToolbar();
        pendingSerializedRange = null;
        return;
      }
      const text = sel.toString().trim();
      if (text) {
        const rect = getSelectionRect(sel);
        const fallbackPoint = { x: e.clientX, y: e.clientY };
        try {
          pendingSerializedRange = serializeRange(sel.getRangeAt(0));
        } catch {
          pendingSerializedRange = null;
        }
        showMarkerToolbar(rect, fallbackPoint);
      } else {
        hideMarkerToolbar();
        pendingSerializedRange = null;
      }
    });

    function closestInteractive(el){
      return el.closest('.marker-toolbar, .js-header, .global-search-dialog, #quarto-sidebar');
    }

    function getSelectionRect(selection) {
      if (!selection || selection.rangeCount === 0) return null;
      try {
        const range = selection.getRangeAt(0).cloneRange();
        const rect = range.getBoundingClientRect();
        if (rect && (rect.width || rect.height)) return rect;
        const rects = range.getClientRects();
        for (const r of rects) {
          if (r.width || r.height) return r;
        }
      } catch (err) {
        console.warn('getSelectionRect failed', err);
      }
      const focusContainer = selection.focusNode instanceof Element ? selection.focusNode : selection.focusNode?.parentElement;
      return focusContainer ? focusContainer.getBoundingClientRect() : null;
    }

    function showMarkerToolbar(rect, fallbackPoint) {
      let toolbar = document.querySelector('.marker-toolbar');
      if (!toolbar) {
        toolbar = createMarkerToolbar();
        document.body.appendChild(toolbar);
      }
      toolbar.classList.add('show');
      toolbar.style.display = 'flex';
      toolbar.style.flexDirection = 'column';
      toolbar.style.gap = '6px';
      toolbar.style.position = 'absolute';
      toolbar.style.removeProperty('right');
      toolbar.style.removeProperty('bottom');
      positionMarkerToolbar(toolbar, rect, fallbackPoint);
    }

    function positionMarkerToolbar(toolbar, rect, fallbackPoint) {
      requestAnimationFrame(() => {
        if (!toolbar.classList.contains('show')) return;
        let targetRect = rect;
        if (!targetRect || (!(targetRect.width || targetRect.height))) {
          if (fallbackPoint && typeof fallbackPoint.x === 'number' && typeof fallbackPoint.y === 'number') {
            targetRect = {
              top: fallbackPoint.y,
              bottom: fallbackPoint.y,
              left: fallbackPoint.x,
              right: fallbackPoint.x,
              width: 0,
              height: 0
            };
          } else {
            const vw = window.innerWidth || document.documentElement.clientWidth || 0;
            const vh = window.innerHeight || document.documentElement.clientHeight || 0;
            targetRect = {
              top: vh / 2,
              bottom: vh / 2,
              left: vw / 2,
              right: vw / 2,
              width: 0,
              height: 0
            };
          }
        }
        const scrollX = window.scrollX ?? window.pageXOffset ?? document.documentElement.scrollLeft ?? 0;
        const scrollY = window.scrollY ?? window.pageYOffset ?? document.documentElement.scrollTop ?? 0;
        const toolbarWidth = toolbar.offsetWidth;
        const toolbarHeight = toolbar.offsetHeight;
        const margin = 12;
        const viewportWidth = document.documentElement.clientWidth || window.innerWidth || toolbarWidth;
        const rectWidth = targetRect.width ?? (targetRect.right - targetRect.left) ?? 0;
        const rectCenterX = targetRect.left + rectWidth / 2;
        let left = scrollX + rectCenterX - toolbarWidth / 2;
        left = Math.max(scrollX + 8, Math.min(left, scrollX + viewportWidth - toolbarWidth - 8));
        const rectBottom = targetRect.bottom ?? (targetRect.top + targetRect.height) ?? targetRect.top;
        let top = scrollY + targetRect.top - toolbarHeight - margin;
        if (top < scrollY + 8) {
          top = scrollY + rectBottom + margin;
        }
        const viewportHeight = document.documentElement.clientHeight || window.innerHeight || toolbarHeight;
        const maxTop = scrollY + viewportHeight - toolbarHeight - 8;
        top = Math.min(top, maxTop);
        toolbar.style.left = `${Math.round(left)}px`;
        toolbar.style.top = `${Math.round(top)}px`;
      });
    }

    function createMarkerToolbar() {
      const toolbar = document.createElement('div');
      toolbar.className = 'marker-toolbar';
      toolbar.innerHTML = `
        <div class="marker-controls" role="toolbar" aria-label="ãƒã‚¤ãƒ©ã‚¤ãƒˆè‰²é¸æŠ">
          <div class="marker-colors">
            <button type="button" class="marker-color-btn" data-color="yellow" title="é»„"></button>
            <button type="button" class="marker-color-btn" data-color="green" title="ç·‘"></button>
            <button type="button" class="marker-color-btn" data-color="blue" title="é’"></button>
            <button type="button" class="marker-color-btn" data-color="pink" title="ãƒ”ãƒ³ã‚¯"></button>
          </div>
          <button type="button" class="marker-comment-btn" title="é¸æŠç¯„å›²ã«ã‚³ãƒ¡ãƒ³ãƒˆ" aria-label="é¸æŠç¯„å›²ã«ã‚³ãƒ¡ãƒ³ãƒˆ"></button>
        </div>
      `;
      toolbar.querySelectorAll('.marker-color-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          applyMarker(btn.dataset.color);
          hideMarkerToolbar();
        });
      });
      const commentBtn = toolbar.querySelector('.marker-comment-btn');
      if (commentBtn) {
        commentBtn.addEventListener('click', () => {
          openCommentDialog();
        });
      }
      return toolbar;
    }

    function openCommentDialog() {
      const selection = window.getSelection();
      let baseRange = null;
      if (selection && selection.rangeCount > 0 && selection.toString().trim()) {
        baseRange = selection.getRangeAt(0);
      } else if (pendingSerializedRange) {
        baseRange = deserializeRange(pendingSerializedRange);
      }
      if (!baseRange || baseRange.collapsed) return;

      const overlay = document.createElement('div');
      overlay.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.4);z-index:10000;display:flex;align-items:center;justify-content:center;';
      const dialog = document.createElement('div');
      dialog.style.cssText = 'background:#fff;color:#222;max-width:600px;width:92%;padding:16px;border-radius:8px;box-shadow:0 10px 30px rgba(0,0,0,0.25);';
      dialog.innerHTML = `
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
          <h3 style="margin:0;font-size:16px;">ã‚³ãƒ¡ãƒ³ãƒˆã‚’è¿½åŠ </h3>
          <button type="button" aria-label="é–‰ã˜ã‚‹" style="background:none;border:none;font-size:18px;cursor:pointer;">Ã—</button>
        </div>
        <div style="font-size:13px;color:#555;background:#f8f9fa;border:1px solid #e9ecef;padding:8px;border-radius:4px;margin-bottom:8px;" id="comment-snippet"></div>
        <textarea id="comment-textarea" rows="6" style="width:100%;font-size:14px;padding:8px;border-radius:6px;border:1px solid #ced4da;resize:vertical;" placeholder="ã“ã“ã«ã‚³ãƒ¡ãƒ³ãƒˆã‚’å…¥åŠ›ï¼ˆé•·æ–‡å¯ï¼‰"></textarea>
        <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:10px;">
          <button type="button" id="comment-cancel" style="padding:6px 12px;border:1px solid #dee2e6;border-radius:4px;background:#f8f9fa;cursor:pointer;">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
          <button type="button" id="comment-save" style="padding:6px 12px;border:1px solid #0d6efd;border-radius:4px;background:#0d6efd;color:#fff;cursor:pointer;">ä¿å­˜</button>
        </div>
      `;
      overlay.appendChild(dialog);
      document.body.appendChild(overlay);

      const close = () => overlay.remove();
      dialog.querySelector('button[aria-label="é–‰ã˜ã‚‹"]').addEventListener('click', close);
      dialog.querySelector('#comment-cancel').addEventListener('click', close);

      // é¸æŠã‚¹ãƒ‹ãƒšãƒƒãƒˆè¡¨ç¤º
      const snippet = baseRange.cloneContents().textContent || window.getSelection().toString();
      dialog.querySelector('#comment-snippet').textContent = `å¯¾è±¡: ${snippet?.slice(0,140) || ''}`;

      dialog.querySelector('#comment-save').addEventListener('click', () => {
        const body = (dialog.querySelector('#comment-textarea').value || '').trim();
        if (!body) { dialog.querySelector('#comment-textarea').focus(); return; }
        const segs = getTextSegments(baseRange);
        if (!segs.length) { close(); return; }
        const serializedRanges = segs.map(seg => ({ s: getPath(seg.node), so: seg.start, e: getPath(seg.node), eo: seg.end }));
        const rec = { id: `comment-${Date.now()}-${Math.floor(Math.random()*1000)}`, ranges: serializedRanges, text: snippet, body, t: Date.now(), slug: getCurrentChapterSlug() || null };
        const key = pageKey();
        if (!COMMENTS_DB[key]) COMMENTS_DB[key] = [];
        COMMENTS_DB[key].push(rec);
        saveComments();
        // æ©™è‰²ãƒãƒ¼ã‚«ãƒ¼é©ç”¨
        segs.forEach(seg => {
          const span = document.createElement('span');
          span.className = 'text-marker marker-orange';
          span.setAttribute('data-comment-id', rec.id);
          applyColorStyles(span, 'orange');
          wrapBySplitText(seg.node, seg.start, seg.end, span);
        });
        refreshRightPanels();
        close();
      });
    }

    function applyMarker(color) {
      const selection = window.getSelection();
      let baseRange = null;
      if (selection && selection.rangeCount > 0 && selection.toString().trim()) {
        baseRange = selection.getRangeAt(0);
      } else if (pendingSerializedRange) {
        baseRange = deserializeRange(pendingSerializedRange);
      }
      if (!baseRange || baseRange.collapsed) return;

      const markerId = `marker-${Date.now()}-${Math.floor(Math.random()*1000)}`;
      const segments = getTextSegments(baseRange);
      if (!segments.length) return;

      const serializedRanges = [];
      segments.forEach(seg => {
        // åˆ†å‰²æ¸ˆã¿ã‚µãƒ–ãƒ¬ãƒ³ã‚¸ã‚’ã‚¹ã‚¿ã‚¤ãƒ«ä»˜ä¸
        const span = document.createElement('span');
        span.className = `text-marker marker-${color}`;
        span.setAttribute('data-marker-id', markerId);
        applyColorStyles(span, color);
        span.addEventListener('dblclick', () => removeMarkerGroup(markerId));
        span.addEventListener('contextmenu', (e) => { e.preventDefault(); cycleMarkerColorGroup(markerId); });

        // ä¿¡é ¼æ€§ã®é«˜ã„splitTextãƒ™ãƒ¼ã‚¹ã®ãƒ©ãƒƒãƒ—ï¼ˆfile://ã§ã‚‚å®‰å®šï¼‰
        const serialized = { s: getPath(seg.node), so: seg.start, e: getPath(seg.node), eo: seg.end };
        wrapBySplitText(seg.node, seg.start, seg.end, span);
        serializedRanges.push(serialized);
      });

      selection.removeAllRanges();

      const page = window.location.pathname;
      if (!markersDB[page]) markersDB[page] = [];
      markersDB[page].push({ id: markerId, color, ranges: serializedRanges, t: Date.now() });
      saveMarkers();
      pendingSerializedRange = null;
    }

    // é¸æŠç¯„å›²ã«äº¤å·®ã™ã‚‹ãƒ†ã‚­ã‚¹ãƒˆãƒãƒ¼ãƒ‰ã‚’ã‚µãƒ–ãƒ¬ãƒ³ã‚¸ã«åˆ†å‰²
    function getTextSegments(range) {
      const segments = [];

      // ãƒ«ãƒ¼ãƒˆãŒãƒ†ã‚­ã‚¹ãƒˆãƒãƒ¼ãƒ‰ã®å ´åˆã‚’è€ƒæ…®
      if (range.commonAncestorContainer && range.commonAncestorContainer.nodeType === Node.TEXT_NODE) {
        const node = range.commonAncestorContainer;
        const start = (node === range.startContainer) ? range.startOffset : 0;
        const end = (node === range.endContainer) ? range.endOffset : (node.nodeValue || '').length;
        if (start !== end) segments.push({ node, start, end });
        return segments;
      }

      const walker = document.createTreeWalker(
        range.commonAncestorContainer,
        NodeFilter.SHOW_TEXT,
        {
          acceptNode: (node) => {
            try {
              return range.intersectsNode(node) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;
            } catch (e) {
              // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: compareBoundaryPoints
              if (!node.nodeValue) return NodeFilter.FILTER_REJECT;
              const r = document.createRange();
              r.selectNodeContents(node);
              const endVsStart = range.compareBoundaryPoints(Range.END_TO_START, r);
              if (endVsStart <= 0) return NodeFilter.FILTER_REJECT;
              const startVsEnd = range.compareBoundaryPoints(Range.START_TO_END, r);
              if (startVsEnd >= 0) return NodeFilter.FILTER_REJECT;
              return NodeFilter.FILTER_ACCEPT;
            }
          }
        }
      );

      let node;
      while ((node = walker.nextNode())) {
        let start = 0;
        let end = node.nodeValue.length;
        if (node === range.startContainer && range.startContainer.nodeType === Node.TEXT_NODE) start = range.startOffset;
        if (node === range.endContainer && range.endContainer.nodeType === Node.TEXT_NODE) end = range.endOffset;
        if (start !== end) segments.push({ node, start, end });
      }
      return segments;
    }

    function hideMarkerToolbar() {
      const toolbar = document.querySelector('.marker-toolbar');
      if (toolbar) {
        toolbar.classList.remove('show');
        toolbar.style.display = 'none';
      }
    }

    function removeMarkerGroup(markerId) {
      document.querySelectorAll(`.text-marker[data-marker-id="${markerId}"]`).forEach(el => {
        const parent = el.parentNode;
        while (el.firstChild) parent.insertBefore(el.firstChild, el);
        parent.removeChild(el);
      });
      const page = window.location.pathname;
      if (markersDB[page]) {
        markersDB[page] = markersDB[page].filter(m => m.id !== markerId);
        if (!markersDB[page].length) delete markersDB[page];
        saveMarkers();
      }
    }

    function clearAllMarkers() {
      document.querySelectorAll('.text-marker').forEach(n => {
        const parent = n.parentNode;
        while (n.firstChild) parent.insertBefore(n.firstChild, n);
        parent.removeChild(n);
      });
      delete markersDB[window.location.pathname];
      saveMarkers();
    }

    function cycleMarkerColorGroup(markerId) {
      const order = ['yellow','green','blue','pink'];
      const els = Array.from(document.querySelectorAll(`.text-marker[data-marker-id="${markerId}"]`));
      if (!els.length) return;
      const el = els[0];
      const current = order.find(c => el.classList.contains(`marker-${c}`)) || 'yellow';
      const next = order[(order.indexOf(current)+1)%order.length];
      els.forEach(e => { order.forEach(c => e.classList.remove(`marker-${c}`)); e.classList.add(`marker-${next}`); applyColorStyles(e, next); });
      const page = window.location.pathname;
      const rec = (markersDB[page]||[]).find(m => m.id === markerId);
      if (rec) { rec.color = next; saveMarkers(); }
    }

    function saveMarkers(){ localStorage.setItem(STORAGE_KEYS.markers, JSON.stringify(markersDB)); }

    function restoreMarkers() {
      const page = window.location.pathname;
      const list = (markersDB[page] || []);
      list.forEach(m => {
        // äº’æ›æ€§: å¤ã„å½¢å¼ {range} ã‚’ {ranges:[range]} ã«å¤‰æ›
        const ranges = m.ranges || (m.range ? [m.range] : []);
        ranges.forEach(rSerialized => {
        const tn = getNodeByPath(rSerialized.s);
        if (!tn || tn.nodeType !== Node.TEXT_NODE) return;
        const span = document.createElement('span');
        span.className = `text-marker marker-${m.color}`;
        span.setAttribute('data-marker-id', m.id);
        applyColorStyles(span, m.color);
        span.addEventListener('dblclick', () => removeMarkerGroup(m.id));
        span.addEventListener('contextmenu', (e) => { e.preventDefault(); cycleMarkerColorGroup(m.id); });
        wrapBySplitText(tn, rSerialized.so, rSerialized.eo, span);
        });
      });
    }

    function restoreCommentMarkers() {
      try {
        const list = (COMMENTS_DB[pageKey()] || []);
        list.forEach(rec => {
          (rec.ranges || []).forEach(r => {
            if (!r || typeof r.so !== 'number' || typeof r.eo !== 'number' || r.so === r.eo) return;
            const tn = getNodeByPath(r.s);
            if (!tn || tn.nodeType !== Node.TEXT_NODE) return;
            const span = document.createElement('span');
            span.className = 'text-marker marker-orange';
            span.setAttribute('data-comment-id', rec.id);
            applyColorStyles(span, 'orange');
            wrapBySplitText(tn, r.so, r.eo, span);
          });
        });
      } catch (e) {
        console.warn('restoreCommentMarkers failed', e);
      }
    }

    // ç¯„å›²ã®ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚º/ãƒ‡ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚º
    function serializeRange(range) {
      return {
        s: getPath(range.startContainer), so: range.startOffset,
        e: getPath(range.endContainer), eo: range.endOffset
      };
    }
    function deserializeRange(obj) {
      try {
        const sc = getNodeByPath(obj.s);
        const ec = getNodeByPath(obj.e);
        if (!sc || !ec) return null;
        const r = document.createRange();
        r.setStart(sc, Math.min(obj.so, nodeMaxOffset(sc)));
        r.setEnd(ec, Math.min(obj.eo, nodeMaxOffset(ec)));
        return r;
      } catch { return null; }
    }
    function nodeIndex(node){ let i=0; while(node && node.previousSibling){ node = node.previousSibling; i++; } return i; }
    function getPath(node){ const p=[]; let n=node; while(n && n !== document.body){ p.push(nodeIndex(n)); n = n.parentNode; } return p.reverse(); }
    function getNodeByPath(path){ let n=document.body; for(const idx of path){ if(!n || !n.childNodes[idx]) return null; n = n.childNodes[idx]; } return n; }
    function nodeMaxOffset(n){ return n.nodeType===Node.TEXT_NODE ? (n.nodeValue||'').length : (n.childNodes?n.childNodes.length:0); }

    function wrapBySplitText(textNode, start, end, wrapper) {
      try {
        let mid = textNode;
        if (start > 0) mid = textNode.splitText(start);
        let tail = mid;
        const len = end - start;
        if (len < mid.nodeValue.length) tail = mid.splitText(len);
        const parent = mid.parentNode;
        parent.insertBefore(wrapper, mid);
        wrapper.appendChild(mid);
      } catch (e) {
        console.warn('wrapBySplitText failed', e);
      }
    }

    function applyColorStyles(el, color) {
      // ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ã‚¹ã‚¿ã‚¤ãƒ«ã§ç¢ºå®Ÿã«å¯è¦–åŒ–ï¼ˆCSSãŒèª­ã¿è¾¼ã‚ãªã„file://æ™‚ã®ä¿é™ºï¼‰
      const map = {
        yellow: 'rgba(255, 235, 59, 0.6)',
        green:  'rgba(129, 199, 132, 0.5)',
        blue:   'rgba(100, 181, 246, 0.5)',
        pink:   'rgba(244, 143, 177, 0.5)',
        orange: 'rgba(255, 152, 0, 0.45)'
      };
      el.style.backgroundColor = map[color] || 'rgba(255, 235, 59, 0.6)';
      el.style.boxShadow = 'inset 0 -0.15em 0 rgba(0,0,0,0.08)';
    }
  }

  function setupMobileFootnoteToggle() {
    document.querySelectorAll('.footnote-ref').forEach(footnote => {
      footnote.addEventListener('click', (e) => {
        e.preventDefault();
        const footnoteId = footnote.getAttribute('href');
        const footnoteDef = document.querySelector(footnoteId);
        if (footnoteDef) footnoteDef.classList.toggle('expanded');
      });
    });
  }

  function disableDefaultQuartoSearch() {
    try {
      const defaultBtn = document.getElementById('quarto-search');
      if (defaultBtn) defaultBtn.remove();
      const defaultPanel = document.getElementById('quarto-search-results');
      if (defaultPanel) defaultPanel.remove();
      const defaultOptions = document.getElementById('quarto-search-options');
      if (defaultOptions) defaultOptions.remove();
      if (window.Quarto && typeof window.Quarto.doc === 'object') {
        window.Quarto.doc.disableSearch = true;
      }
    } catch (e) {
      console.warn('Failed to disable default Quarto search', e);
    }
  }

  function setupSidebarSearch() {
    const sidebarSearch = document.querySelector('#quarto-sidebar .sidebar-search');
    if (!sidebarSearch) return;

    sidebarSearch.innerHTML = '';

    const form = document.createElement('form');
    form.className = 'sidebar-search-form';
    form.setAttribute('role', 'search');
    form.setAttribute('aria-label', 'ã‚µã‚¤ãƒˆå†…æ¤œç´¢ãƒ•ã‚©ãƒ¼ãƒ ');

    const input = document.createElement('input');
    input.type = 'search';
    input.id = 'sidebar-search-input';
    input.placeholder = 'ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’æ¤œç´¢...';
    input.setAttribute('aria-label', 'ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’æ¤œç´¢');
    input.autocomplete = 'off';

    form.appendChild(input);
    sidebarSearch.appendChild(form);

    const resultsWrapper = document.createElement('div');
    resultsWrapper.className = 'sidebar-search-results hidden';
    resultsWrapper.innerHTML = `
      <div class="sidebar-search-header">
        <span class="sidebar-search-query"></span>
        <button type="button" class="sidebar-search-clear" aria-label="æ¤œç´¢çµæœã‚’é–‰ã˜ã‚‹">Ã—</button>
      </div>
      <div class="sidebar-search-summary"></div>
      <div class="sidebar-search-items"></div>
      <div class="sidebar-search-empty">æ¤œç´¢çµæœã¯ã“ã“ã«è¡¨ç¤ºã•ã‚Œã¾ã™ã€‚</div>
    `;
    sidebarSearch.appendChild(resultsWrapper);

    SEARCH_RESULTS_VIEW.sidebarContainer = resultsWrapper;
    SEARCH_RESULTS_VIEW.sidebarSummary = resultsWrapper.querySelector('.sidebar-search-summary');
    SEARCH_RESULTS_VIEW.sidebarList = resultsWrapper.querySelector('.sidebar-search-items');
    SEARCH_RESULTS_VIEW.sidebarQuery = resultsWrapper.querySelector('.sidebar-search-query');
    SEARCH_RESULTS_VIEW.sidebarClearBtn = resultsWrapper.querySelector('.sidebar-search-clear');

    if (SEARCH_RESULTS_VIEW.sidebarClearBtn) {
      SEARCH_RESULTS_VIEW.sidebarClearBtn.addEventListener('click', (event) => {
        event.preventDefault();
        clearSidebarSearchResults();
      });
    }

    const openOverlayWithQuery = (raw) => {
      const query = (typeof raw === 'string' ? raw : '').trim();
      const handle = openSearchOverlay(query);
      if (handle && handle.input) {
        const end = handle.input.value.length;
        handle.input.focus();
        handle.input.setSelectionRange(end, end);
      }
    };

    form.addEventListener('submit', (event) => {
      event.preventDefault();
      openOverlayWithQuery(input.value);
    });

    input.addEventListener('keydown', (event) => {
      if (event.key === 'Enter') {
        event.preventDefault();
        openOverlayWithQuery(input.value);
      }
    });

    input.addEventListener('input', (event) => {
      const value = event.target.value;
      const overlay = document.querySelector('.global-search-overlay');
      if (!overlay) {
        if (value.trim().length >= 1) {
          openOverlayWithQuery(value);
        }
        return;
      }
      const overlayInput = overlay.querySelector('#global-search-input');
      if (overlayInput && overlayInput.value !== value) {
        overlayInput.value = value;
        overlayInput.dispatchEvent(new Event('input', { bubbles: true }));
      }
    });

    restoreSearchSession();
  }

  const SEARCH_SESSION_KEY = 'quarto-search-session';

  function saveSearchSession(session) {
    try {
      sessionStorage.setItem(SEARCH_SESSION_KEY, JSON.stringify(session));
    } catch (error) {
      console.warn('Search session save failed', error);
    }
  }

  function loadSearchSession() {
    try {
      const raw = sessionStorage.getItem(SEARCH_SESSION_KEY);
      if (!raw) return null;
      return JSON.parse(raw);
    } catch (error) {
      console.warn('Search session load failed', error);
      return null;
    }
  }

  function restoreSearchSession() {
    const session = loadSearchSession();
    if (!session || !Array.isArray(session.results) || !session.results.length) {
      clearSidebarSearchResults();
      return;
    }

    SEARCH_RESULTS_VIEW.sidebarData = session;
    renderSidebarSearchResults(session);

    const currentUrl = new URL(window.location.href, window.location.origin);
    if (session.active) {
      const target = new URL(session.active.url, window.location.href);
      if (target.origin === currentUrl.origin && target.pathname === currentUrl.pathname) {
        requestAnimationFrame(() => {
          clearSearchHighlights();
          scrollToMatchOnPage(session.query, session.active.matchIndex || 0);
        });
      }
    }
  }

  function clearSidebarSearchResults() {
    if (SEARCH_RESULTS_VIEW.sidebarContainer) {
      SEARCH_RESULTS_VIEW.sidebarContainer.classList.add('hidden');
      const empty = SEARCH_RESULTS_VIEW.sidebarContainer.querySelector('.sidebar-search-empty');
      if (empty) empty.classList.remove('hidden');
    }
    if (SEARCH_RESULTS_VIEW.sidebarSummary) {
      SEARCH_RESULTS_VIEW.sidebarSummary.innerHTML = '';
    }
    if (SEARCH_RESULTS_VIEW.sidebarList) {
      SEARCH_RESULTS_VIEW.sidebarList.innerHTML = '';
    }
    if (SEARCH_RESULTS_VIEW.sidebarQuery) {
      SEARCH_RESULTS_VIEW.sidebarQuery.textContent = '';
    }
    SEARCH_RESULTS_VIEW.sidebarData = null;
    clearSearchHighlights();
    try {
      sessionStorage.removeItem(SEARCH_SESSION_KEY);
    } catch (error) {
      console.warn('Failed to clear search session', error);
    }
  }

  function renderSidebarSearchResults(session) {
    const container = SEARCH_RESULTS_VIEW.sidebarContainer;
    if (!container) return;

    SEARCH_RESULTS_VIEW.sidebarData = session;

    const empty = container.querySelector('.sidebar-search-empty');
    const summary = SEARCH_RESULTS_VIEW.sidebarSummary;
    const list = SEARCH_RESULTS_VIEW.sidebarList;
    const queryLabel = SEARCH_RESULTS_VIEW.sidebarQuery;

    if (!session || !Array.isArray(session.results) || !session.results.length) {
      clearSidebarSearchResults();
      return;
    }

    container.classList.remove('hidden');
    if (empty) empty.classList.add('hidden');
    if (queryLabel) {
      queryLabel.textContent = `ã€Œ${session.query}ã€`;
    }
    if (summary) {
      const hiddenCount = session.results.reduce((sum, item) => sum + (item.remainingMatches || 0), 0);
      const totalMatches = session.results.length + hiddenCount;
      summary.innerHTML = `<p><strong>${totalMatches}</strong>ä»¶ã®çµæœï¼ˆã€Œ${escapeHtml(session.query)}ã€ï¼‰</p>`;
    }
    if (list) {
      list.innerHTML = '';
      session.results.forEach((result, index) => {
        const itemBtn = document.createElement('button');
        itemBtn.type = 'button';
        itemBtn.className = 'sidebar-search-item';
        if (session.active &&
            session.active.url === result.url &&
            session.active.matchIndex === result.matchIndex) {
          itemBtn.classList.add('active');
        }

        itemBtn.innerHTML = `
          <span class="sidebar-search-item-title">${escapeHtml(result.title || result.url)}</span>
          <span class="sidebar-search-item-order">${result.matchIndex + 1}/${result.totalMatches || result.matchCount || 1}</span>
          <span class="sidebar-search-item-count">${result.totalMatches || result.matchCount || 1}ä»¶</span>
          <div class="sidebar-search-item-context">${result.context}</div>
        `;

        itemBtn.addEventListener('click', () => {
          handleSidebarResultSelection(result, index);
        });
        list.appendChild(itemBtn);
      });
    }
  }

  function handleSidebarResultSelection(result, index) {
    if (!SEARCH_RESULTS_VIEW.sidebarData) return;
    const session = SEARCH_RESULTS_VIEW.sidebarData;
    session.active = {
      url: result.url,
      matchIndex: result.matchIndex,
      index
    };
    session.timestamp = Date.now();
    saveSearchSession(session);
    renderSidebarSearchResults(session);
    navigateToSearchResult(result, session.query);
  }

  function handleOverlayResultSelection(result) {
    if (!result) return;
    const activePayload = convertResultToSession(result);
    const session = {
      query: SEARCH_RESULTS_VIEW.query,
      results: convertOverlayResultsForSession(SEARCH_RESULTS_VIEW.results),
      active: {
        url: activePayload.url,
        matchIndex: activePayload.matchIndex || 0
      },
      timestamp: Date.now()
    };
    SEARCH_RESULTS_VIEW.sidebarData = session;
    saveSearchSession(session);
    renderSidebarSearchResults(session);
    if (typeof SEARCH_RESULTS_VIEW.closeOverlay === 'function') {
      SEARCH_RESULTS_VIEW.closeOverlay();
    }
    navigateToSearchResult(activePayload, session.query);
  }

  function resolveResultUrl(url) {
    try {
      const resolved = new URL(url, window.location.href);
      return resolved.href;
    } catch {
      return url;
    }
  }

  function convertOverlayResultsForSession(results) {
    return results.map(convertResultToSession);
  }

  function convertResultToSession(result) {
    const page = result.page || {};
    return {
      url: resolveResultUrl(page.url || result.url || window.location.href),
      title: page.title || result.title || (page.url || 'ãƒšãƒ¼ã‚¸'),
      chapter: page.chapter || result.chapter || '',
      context: result.context || '',
      matchCount: result.matchCount || 1,
      totalMatches: result.totalMatches || result.matchCount || 1,
      remainingMatches: result.remainingMatches || 0,
      matchIndex: result.matchIndex || 0
    };
  }

  function navigateToSearchResult(result, query) {
    if (!result) return;
    const targetUrl = new URL(result.url, window.location.href);
    const currentUrl = new URL(window.location.href);
    const sameDocument = targetUrl.origin === currentUrl.origin && targetUrl.pathname === currentUrl.pathname;

    if (sameDocument) {
      if (targetUrl.hash && targetUrl.hash !== window.location.hash) {
        window.location.hash = targetUrl.hash;
      }
      requestAnimationFrame(() => {
        if (!scrollToMatchOnPage(query, result.matchIndex || 0) && targetUrl.hash) {
          const targetEl = document.querySelector(targetUrl.hash);
          if (targetEl && typeof targetEl.scrollIntoView === 'function') {
            targetEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
          }
        }
      });
    } else {
      window.location.href = targetUrl.href;
    }
  }

  let activeSearchHighlights = [];

  function clearSearchHighlights() {
    if (!activeSearchHighlights.length) return;
    activeSearchHighlights.forEach(span => {
      try {
        if (!span || !span.parentNode) return;
        const parent = span.parentNode;
        while (span.firstChild) {
          parent.insertBefore(span.firstChild, span);
        }
        parent.removeChild(span);
      } catch (error) {
        console.warn('Failed clearing highlight', error);
      }
    });
    activeSearchHighlights = [];
  }

  function highlightRange(range) {
    if (!range) return;
    const mark = document.createElement('mark');
    mark.className = 'search-hit-highlight';
    try {
      range.surroundContents(mark);
      activeSearchHighlights.push(mark);
      mark.scrollIntoView({ behavior: 'smooth', block: 'center' });
      setTimeout(() => {
        mark.classList.add('search-hit-fade');
      }, 100);
    } catch (error) {
      console.warn('Failed to highlight range', error);
    }
  }

  function scrollToMatchOnPage(query, matchIndex) {
    if (!query) return false;
    clearSearchHighlights();
    const walker = document.createTreeWalker(document.body, NodeFilter.SHOW_TEXT, null);
    const target = query.toLowerCase();
    let occurrence = -1;
    let node = walker.nextNode();
    while (node) {
      if (!(node.parentElement && node.parentElement.closest('.global-search-overlay'))) {
        const text = node.textContent || '';
        const lower = text.toLowerCase();
        let pos = 0;
        while (true) {
          const found = lower.indexOf(target, pos);
          if (found === -1) break;
          occurrence += 1;
          if (occurrence === matchIndex) {
            const range = document.createRange();
            range.setStart(node, found);
            range.setEnd(node, found + query.length);
            highlightRange(range);
            return true;
          }
          pos = found + query.length;
        }
      }
      node = walker.nextNode();
    }
    return false;
  }
  function setupGlobalSearch() {
    const openBtn = document.getElementById('search-open-btn');
    if (openBtn) openBtn.addEventListener('click', (e) => { e.preventDefault(); openSearchOverlay(); });

    window.quartoOpenSearch = (initialQuery = '') => {
      if (typeof initialQuery !== 'string') initialQuery = '';
      openSearchOverlay(initialQuery);
    };

    document.addEventListener('keydown', (e) => {
      if ((e.ctrlKey || e.metaKey) && (e.key === 'k' || e.key === 'K')) {
        e.preventDefault();
        openSearchOverlay();
      }
    }, true);
  }

  const SEARCH_STATE = {
    pages: [],
    index: {},
    loading: false,
    loaded: false,
    localSections: []
  };

  const SEARCH_RESULTS_VIEW = {
    results: [],
    query: '',
    rendered: 0,
    chunkSize: 20,
    totalCount: 0,
    summaryEl: null,
    listEl: null,
    loadMoreWrapper: null,
    loadMoreBtn: null,
    lastChapter: '',
    lastPage: '',
    closeOverlay: null,
    overlayKeyHandler: null,
    overlayClickHandler: null,
    sidebarContainer: null,
    sidebarSummary: null,
    sidebarList: null,
    sidebarQuery: null,
    sidebarClearBtn: null,
    sidebarData: null
  };

  const MAX_SNIPPETS_PER_PAGE = 20;
  const MAX_MATCHES_SCAN = 400;

  function collectBookPages() {
    if (SEARCH_STATE.pages.length) return SEARCH_STATE.pages;
    // file:// ã§ã¯ä»–ãƒšãƒ¼ã‚¸fetchãŒãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œã‚‹ãŸã‚ç¾åœ¨ãƒšãƒ¼ã‚¸ã®ã¿
    if (location.protocol === 'file:') {
      const sections = Array.from(document.querySelectorAll('section.chapter-page'));
      const baseUrl = window.location.href.split('#')[0];
      if (!sections.length) {
        SEARCH_STATE.localSections = [];
        SEARCH_STATE.pages = [baseUrl];
        return SEARCH_STATE.pages;
      }
      SEARCH_STATE.localSections = sections.map(section => {
        const id = section.id || '';
        const url = id ? `${baseUrl}#${id}` : baseUrl;
        return { id, url, element: section };
      });
      SEARCH_STATE.pages = SEARCH_STATE.localSections.map(entry => entry.url);
      return SEARCH_STATE.pages;
    }
    const sidebar = document.querySelector('#quarto-sidebar .sidebar-menu-container');
    const hrefs = new Set();
    if (sidebar) {
      sidebar.querySelectorAll('a[href]')?.forEach(a => {
        const href = a.getAttribute('href');
        if (!href) return;
        if (href.startsWith('http')) return;
        if (href.startsWith('#')) return;
        hrefs.add(new URL(href, window.location.href).href);
      });
    }
    // Also add current page
    hrefs.add(window.location.href);
    SEARCH_STATE.pages = Array.from(hrefs);
    SEARCH_STATE.localSections = [];
    return SEARCH_STATE.pages;
  }

  function normalizeWhitespace(text) {
    return (text || '').replace(/\s+/g, ' ').trim();
  }

  function deriveSectionTitle(section, fallback) {
    if (!section) return fallback || 'ã“ã®ãƒšãƒ¼ã‚¸';
    const selectors = ['h1 .chapter-title', 'h1', '.chapter-title', 'header .title', 'h2', 'h3'];
    for (const sel of selectors) {
      const el = section.querySelector(sel);
      if (el) {
        const txt = normalizeWhitespace(el.textContent);
        if (txt) return txt;
      }
    }
    const heading = Array.from(section.querySelectorAll('h1, h2, h3, h4, h5')).find(h => normalizeWhitespace(h.textContent));
    if (heading) return normalizeWhitespace(heading.textContent);
    const id = section.id || '';
    if (id) return normalizeWhitespace(id.replace(/^page-/, '').replace(/[-_]+/g, ' ')) || (fallback || 'ã“ã®ãƒšãƒ¼ã‚¸');
    return fallback || 'ã“ã®ãƒšãƒ¼ã‚¸';
  }

  function extractSectionText(section) {
    if (!section) return '';
    const clone = section.cloneNode(true);
    const removable = [
      'script',
      'style',
      'nav',
      '.single-pager',
      '.margin-note',
      '.right-footnotes',
      '.right-comments',
      '.right-both',
      '.comment-menu-popup',
      '.global-search-overlay',
      '.global-search-dialog',
      '.marker-toolbar'
    ];
    removable.forEach(sel => clone.querySelectorAll(sel).forEach(el => el.remove()));
    return normalizeWhitespace(clone.textContent || '');
  }

  async function buildSearchIndex() {
    if (SEARCH_STATE.loaded || SEARCH_STATE.loading) return;
    SEARCH_STATE.loading = true;
    SEARCH_STATE.index = {};
    const pages = collectBookPages();

    if (location.protocol === 'file:') {
      const baseUrl = window.location.href.split('#')[0];
      if (!SEARCH_STATE.localSections || !SEARCH_STATE.localSections.length) {
        collectBookPages();
      }
      const docTitle = normalizeWhitespace(document.querySelector('header .title')?.textContent || document.title || '');
      const sections = (SEARCH_STATE.localSections && SEARCH_STATE.localSections.length)
        ? SEARCH_STATE.localSections
        : [];
      const seen = new Set();
      if (sections.length) {
        sections.forEach(entry => {
          const section = entry.element;
          const url = entry.url || (entry.id ? `${baseUrl}#${entry.id}` : baseUrl);
          const title = deriveSectionTitle(section, docTitle || baseUrl);
          const text = extractSectionText(section);
          SEARCH_STATE.index[url] = { url, title, text, slug: entry.id };
          seen.add(url);
        });
        const hasIndex = sections.some(entry => (entry.id || '').toLowerCase() === 'page-index');
        if (!hasIndex) {
          const main = document.querySelector('main#quarto-document-content') || document.querySelector('main') || document.body;
          if (main) {
            const text = extractSectionText(main);
            const url = baseUrl;
            if (!seen.has(url)) {
              const title = deriveSectionTitle(main, docTitle || baseUrl);
              SEARCH_STATE.index[url] = { url, title, text };
            }
          }
        }
      } else {
        const main = document.querySelector('main#quarto-document-content') || document.querySelector('main') || document.body;
        const text = extractSectionText(main);
        SEARCH_STATE.index[baseUrl] = { url: baseUrl, title: docTitle || baseUrl, text };
      }
      SEARCH_STATE.loaded = true;
      SEARCH_STATE.loading = false;
      return;
    }

    const fetchPage = async (url) => {
      try {
        const res = await fetch(url);
        const html = await res.text();
        const doc = new DOMParser().parseFromString(html, 'text/html');
        const title = (doc.querySelector('header .title')?.textContent || doc.querySelector('title')?.textContent || '').trim();
        const main = doc.querySelector('main') || doc.querySelector('#quarto-document-content') || doc.body;
        const text = (main.textContent || '').replace(/\s+/g, ' ').trim();
        return { url, title, text };
      } catch (e) {
        console.warn('Search: failed to fetch', url, e);
        return { url, title: url, text: '' };
      }
    };

    const results = await Promise.all(pages.map(fetchPage));
    results.forEach(r => { SEARCH_STATE.index[r.url] = r; });
    SEARCH_STATE.loaded = true;
    SEARCH_STATE.loading = false;
  }

  function openSearchOverlay(initialQuery = '') {
    const startQuery = (typeof initialQuery === 'string') ? initialQuery.trim() : '';
    let overlay = document.querySelector('.global-search-overlay');
    if (overlay) overlay.remove();

    overlay = document.createElement('div');
    overlay.className = 'global-search-overlay';
    overlay.innerHTML = `
      <div class="global-search-dialog" role="dialog" aria-modal="true" aria-label="å…¨ãƒšãƒ¼ã‚¸æ¤œç´¢">
        <div class="global-search-header">
          <h3>æ¤œç´¢</h3>
          <button class="global-search-close" aria-label="é–‰ã˜ã‚‹">Ã—</button>
        </div>
        <div class="global-search-input-wrapper">
          <input id="global-search-input" type="text" placeholder="ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’å…¥åŠ› (Ctrl/Cmd + K)" autocomplete="off" />
          <button id="global-search-btn">æ¤œç´¢</button>
        </div>
        <div class="global-search-results">
          <div class="search-help">æ¤œç´¢èªã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚</div>
        </div>
      </div>
    `;
    document.body.appendChild(overlay);
    overlay.style.display = 'block';
    document.body.classList.add('search-overlay-active');

    const close = () => {
      if (overlay && overlay.parentNode) {
        overlay.parentNode.removeChild(overlay);
      }
      document.body.classList.remove('search-overlay-active');
      if (SEARCH_RESULTS_VIEW.overlayKeyHandler) {
        document.removeEventListener('keydown', SEARCH_RESULTS_VIEW.overlayKeyHandler, true);
        SEARCH_RESULTS_VIEW.overlayKeyHandler = null;
      }
      if (SEARCH_RESULTS_VIEW.overlayClickHandler) {
        document.removeEventListener('click', SEARCH_RESULTS_VIEW.overlayClickHandler, true);
        SEARCH_RESULTS_VIEW.overlayClickHandler = null;
      }
      resetSearchResultsView();
      SEARCH_RESULTS_VIEW.closeOverlay = null;
    };
    overlay.addEventListener('click', (e) => { if (e.target === overlay) close(); });
    overlay.querySelector('.global-search-close')?.addEventListener('click', close);

    const input = overlay.querySelector('#global-search-input');
    const btn = overlay.querySelector('#global-search-btn');
    const syncSidebarInput = (value) => {
      const sidebarInput = document.getElementById('sidebar-search-input');
      if (!sidebarInput || sidebarInput === document.activeElement) return;
      if (sidebarInput.value !== value) sidebarInput.value = value;
    };
    input.value = startQuery;
    input.focus();

    const ensureIndex = async () => {
      if (!SEARCH_STATE.loaded) {
        const results = overlay.querySelector('.global-search-results');
        results.innerHTML = '<div class="search-loading">ç´¢å¼•ã‚’ä½œæˆä¸­...</div>';
        await buildSearchIndex();
      }
    };

    const doSearch = async () => {
      const q = (input.value || '').trim();
      syncSidebarInput(q);
      const resultsEl = overlay.querySelector('.global-search-results');
      if (!q) {
        resultsEl.innerHTML = '<div class="search-help">æ¤œç´¢èªã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚</div>';
        resetSearchResultsView();
        return;
      }
      await ensureIndex();
      const results = [];
      for (const url of Object.keys(SEARCH_STATE.index)) {
        const item = SEARCH_STATE.index[url];
        if (!item || !item.text) continue;
        const page = {
          url,
          title: item.title || url,
          chapter: item.title || ''
        };
        const matches = findMatches(item.text, q, MAX_SNIPPETS_PER_PAGE);
        matches.forEach(match => {
          results.push({
            page,
            context: match.context,
            matchCount: match.totalMatches,
            totalMatches: match.totalMatches,
            matchIndex: match.matchIndex,
            remainingMatches: match.remainingMatches
          });
        });
      }
      renderResults(resultsEl, results, q);
    };

    const debouncedSearch = debounce(doSearch, 200);

    const dialog = overlay.querySelector('.global-search-dialog');
    const keyHandler = (event) => {
      if (event.key === 'Escape') {
        event.preventDefault();
        close();
      }
    };
    const clickHandler = (event) => {
      if (dialog && !dialog.contains(event.target)) {
        close();
      }
    };
    document.addEventListener('keydown', keyHandler, true);
    document.addEventListener('click', clickHandler, true);
    SEARCH_RESULTS_VIEW.overlayKeyHandler = keyHandler;
    SEARCH_RESULTS_VIEW.overlayClickHandler = clickHandler;
    SEARCH_RESULTS_VIEW.closeOverlay = close;

    input.addEventListener('input', () => { debouncedSearch(); });
    input.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') { e.preventDefault(); doSearch(); }
      if (e.key === 'Escape') { e.preventDefault(); close(); }
    });
    btn.addEventListener('click', () => { doSearch(); });

    if (startQuery.length) {
      doSearch();
      const end = input.value.length;
      input.setSelectionRange(end, end);
    }

    return { overlay, input, close };
  }

  function findMatches(text, query, limit) {
    if (!text || !query) return [];
    const sanitized = text.replace(/\s+/g, ' ');
    const hay = sanitized.toLowerCase();
    const needle = query.toLowerCase();
    const indices = [];
    let pos = 0;
    let safety = 0;
    while (pos < hay.length) {
      const idx = hay.indexOf(needle, pos);
      if (idx === -1) break;
      indices.push(idx);
      pos = idx + needle.length;
      safety += 1;
      if (safety >= MAX_MATCHES_SCAN) break;
    }
    const total = indices.length;
    if (!total) return [];
    const clamp = Math.min(total, limit || MAX_SNIPPETS_PER_PAGE);
    const results = [];
    for (let i = 0; i < clamp; i += 1) {
      const start = Math.max(0, indices[i] - 80);
      const end = Math.min(sanitized.length, indices[i] + query.length + 80);
      let snippet = sanitized.slice(start, end);
      snippet = highlight(snippet, query);
      if (start > 0) snippet = 'â€¦' + snippet;
      if (end < sanitized.length) snippet = snippet + 'â€¦';
      const remainingMatches = (total > clamp && i === clamp - 1) ? total - clamp : 0;
      if (remainingMatches > 0) {
        snippet += `<span class="search-result-more">ä»–${remainingMatches}ä»¶ã®ä¸€è‡´</span>`;
      }
      results.push({
        context: snippet,
        matchIndex: i,
        totalMatches: total,
        remainingMatches
      });
    }
    return results;
  }

  function escapeHtml(s) {
    return (s || '').replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[c]));
  }

  function highlight(text, query) {
    const escQ = query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    return text.replace(new RegExp(escQ, 'gi'), m => `<mark>${escapeHtml(m)}</mark>`);
  }

  function fmtMMDDHHmm(t){
    const d = new Date(t); const pad = (n)=>String(n).padStart(2,'0');
    return `${pad(d.getMonth()+1)}/${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}`;
  }

  function renderResults(container, results, query) {
    if (!container) return;

    if (!results.length) {
      container.innerHTML = `<div class="search-no-results"><p>ä¸€è‡´ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚</p><ul><li>èªå¥ã‚’çŸ­ãã™ã‚‹</li><li>åˆ¥ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’è©¦ã™</li></ul></div>`;
      resetSearchResultsView();
      return;
    }

    resetSearchResultsView();
    clearSearchHighlights();
    SEARCH_RESULTS_VIEW.results = results;
    SEARCH_RESULTS_VIEW.query = query;
    SEARCH_RESULTS_VIEW.totalCount = results.length + results.reduce((sum, r) => sum + (r.remainingMatches || 0), 0);

    container.innerHTML = '';

    const summary = document.createElement('div');
    summary.className = 'search-results-summary';
    container.appendChild(summary);
    SEARCH_RESULTS_VIEW.summaryEl = summary;

    const listWrap = document.createElement('div');
    listWrap.className = 'search-results-items';
    container.appendChild(listWrap);
    SEARCH_RESULTS_VIEW.listEl = listWrap;

    const loadMoreWrapper = document.createElement('div');
    loadMoreWrapper.className = 'search-load-more-wrapper';
    const loadMoreBtn = document.createElement('button');
    loadMoreBtn.type = 'button';
    loadMoreBtn.className = 'search-load-more-btn';
    loadMoreBtn.textContent = 'ã•ã‚‰ã«è¡¨ç¤º';
    loadMoreWrapper.appendChild(loadMoreBtn);
    container.appendChild(loadMoreWrapper);
    SEARCH_RESULTS_VIEW.loadMoreWrapper = loadMoreWrapper;
    SEARCH_RESULTS_VIEW.loadMoreBtn = loadMoreBtn;
    loadMoreBtn.addEventListener('click', () => renderOverlayResultsChunk());

    renderOverlayResultsChunk(true);
  }

  function renderOverlayResultsChunk(reset = false) {
    const state = SEARCH_RESULTS_VIEW;
    if (!state.listEl) return;

    if (reset) {
      state.listEl.innerHTML = '';
      state.rendered = 0;
      state.lastChapter = '';
      state.lastPage = '';
    }

    const total = state.results.length;
    if (state.rendered >= total) {
      updateOverlayResultsSummary();
      if (state.loadMoreWrapper) state.loadMoreWrapper.style.display = 'none';
      return;
    }

    const limit = Math.min(total, state.rendered + state.chunkSize);
    for (let i = state.rendered; i < limit; i += 1) {
      const result = state.results[i];
      const chapter = result.page?.chapter || '';
      const pageUrl = result.page?.url || '';

      if (chapter && (chapter !== state.lastChapter || pageUrl !== state.lastPage)) {
        const section = document.createElement('section');
        section.className = 'search-chapter-section';
        const heading = document.createElement('h4');
        heading.className = 'search-chapter-title';
        heading.textContent = chapter;
        section.appendChild(heading);
        state.listEl.appendChild(section);
        state.lastChapter = chapter;
        state.lastPage = pageUrl;
      }

      const item = document.createElement('div');
      item.className = 'search-result-item';

      const titleRow = document.createElement('div');
      titleRow.className = 'search-result-title';

      const link = document.createElement('a');
      link.className = 'search-result-link';
      link.href = result.page?.url || '#';
      link.textContent = result.page?.title || result.page?.url || 'ãƒšãƒ¼ã‚¸';
      link.addEventListener('click', (event) => {
        event.preventDefault();
        handleOverlayResultSelection(result);
      });

      const order = document.createElement('span');
      order.className = 'search-snippet-order';
      order.textContent = `${(result.matchIndex || 0) + 1}/${result.totalMatches || result.matchCount || 1}`;

      const badge = document.createElement('span');
      badge.className = 'search-match-count';
      badge.textContent = `${result.totalMatches || result.matchCount || 1}ä»¶`;

      titleRow.appendChild(link);
      titleRow.appendChild(order);
      titleRow.appendChild(badge);
      item.appendChild(titleRow);

      const ctx = document.createElement('div');
      ctx.className = 'search-result-context';
      ctx.innerHTML = result.context;
      item.appendChild(ctx);

      state.listEl.appendChild(item);
    }

    state.rendered = limit;
    updateOverlayResultsSummary();

    if (state.loadMoreWrapper) {
      state.loadMoreWrapper.style.display = state.rendered >= total ? 'none' : '';
    }
  }

  function updateOverlayResultsSummary() {
    const state = SEARCH_RESULTS_VIEW;
    if (!state.summaryEl) return;
    const hiddenCount = state.results.reduce((sum, item) => sum + (item.remainingMatches || 0), 0);
    const totalMatches = state.results.length + hiddenCount;
    const shownMatches = Math.min(state.rendered, state.results.length);
    const escapedQuery = escapeHtml(state.query);
    state.summaryEl.innerHTML = `
      <p><strong>${totalMatches}</strong>ä»¶ã®çµæœï¼ˆã€Œ${escapedQuery}ã€ï¼‰</p>
      <p class="search-results-muted">${shownMatches}ä»¶ã‚’è¡¨ç¤ºä¸­${hiddenCount > 0 ? `ï¼ˆä»–${hiddenCount}ä»¶ï¼‰` : ''}</p>
    `;
  }

  function resetSearchResultsView() {
    SEARCH_RESULTS_VIEW.results = [];
    SEARCH_RESULTS_VIEW.query = '';
    SEARCH_RESULTS_VIEW.rendered = 0;
    SEARCH_RESULTS_VIEW.totalCount = 0;
    SEARCH_RESULTS_VIEW.summaryEl = null;
    SEARCH_RESULTS_VIEW.listEl = null;
    SEARCH_RESULTS_VIEW.loadMoreWrapper = null;
    SEARCH_RESULTS_VIEW.loadMoreBtn = null;
    SEARCH_RESULTS_VIEW.lastChapter = '';
    SEARCH_RESULTS_VIEW.lastPage = '';
  }

  function setupKeyboardShortcuts() {
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        const dialogs = document.querySelectorAll('.global-search-dialog');
        dialogs.forEach(dialog => dialog.remove());
      }
    });
  }

  function setupScrollPosition() {
    const scrollY = sessionStorage.getItem(STORAGE_KEYS.scrollPosition);
    if (scrollY) window.scrollTo(0, parseInt(scrollY));
    window.addEventListener('beforeunload', () => {
      sessionStorage.setItem(STORAGE_KEYS.scrollPosition, window.scrollY);
    });
  }

  function expandAllInMenu(root) {
    try {
      root.querySelectorAll('.collapse').forEach(el => {
        el.classList.add('show');
        el.style.height = 'auto';
      });
      root.querySelectorAll('[data-bs-toggle="collapse"]').forEach(tg => {
        tg.setAttribute('aria-expanded', 'true');
      });
      root.querySelectorAll('[data-bs-toggle="collapse"]').forEach(tg => {
        tg.removeAttribute('data-bs-toggle');
        tg.removeAttribute('data-bs-target');
      });
    } catch (e) {
      console.warn('Failed to expand all menu levels:', e);
    }
  }

  // Quartoå·¦ã‚µã‚¤ãƒ‰ãƒãƒ¼ï¼ˆå„ç« /å…¨ä½“ï¼‰: æŒ‡å®šéšå±¤ã¾ã§å±•é–‹ã€ãã‚Œä»¥é™ã‚’æŠ˜ã‚ŠãŸãŸã¿
  function setSidebarDepth(root, maxDepth) {
    try {
      const togglers = root.querySelectorAll('[data-bs-toggle="collapse"][data-bs-target]');
      const getDepthForTarget = (target) => {
        let d = 1; let n = target;
        while (n && n !== root) { if (n.tagName === 'UL') d++; n = n.parentElement; }
        return d;
      };
      togglers.forEach(tg => {
        const sel = tg.getAttribute('data-bs-target');
        if (!sel || sel[0] !== '#') return;
        const target = root.querySelector(sel);
        if (!target) return;
        const depth = getDepthForTarget(target);
        const open = (maxDepth === Infinity) || (depth <= maxDepth);
        target.classList.toggle('show', !!open);
        target.style.height = open ? 'auto' : '';
        tg.setAttribute('aria-expanded', open ? 'true' : 'false');
      });
    } catch (e) {
      console.warn('setSidebarDepth error:', e);
    }
  }

  // ãƒšãƒ¼ã‚¸å†…ç›®æ¬¡: ãƒ„ãƒªãƒ¼åŒ– + å±•é–‹/æ ¼ç´ãƒˆã‚°ãƒ«ã‚’ä»˜ä¸ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆéšå±¤ã¾ã§å±•é–‹ï¼‰
  // éšå±¤åˆ¤å®šã¯å¿…ãšMarkdownã®#æ•°ï¼ˆ= è¦‹å‡ºã—ã‚¿ã‚°H1..H6ã®ãƒ¬ãƒ™ãƒ«ï¼‰ã«å¾“ã†
  function enhancePageToc(panel, defaultDepth) {
    const nav = panel.querySelector('nav#TOC');
    if (!nav) return;
    const getHeadingLevelFromLink = (a) => {
      try {
        if (!a) return null;
        const href = a.getAttribute('href') || '';
        if (!href.startsWith('#')) return null;
        const id = href.slice(1);
        const h = document.getElementById(id);
        if (!h) return null;
        const tag = (h.tagName || '').toUpperCase();
        if (/^H[1-6]$/.test(tag)) return parseInt(tag.slice(1), 10);
        return null;
      } catch { return null; }
    };

    nav.querySelectorAll('li').forEach(li => {
      const childUl = li.querySelector(':scope > ul');
      const link = li.querySelector(':scope > a');
      const level = getHeadingLevelFromLink(link);

      if (childUl) {
        li.classList.add('has-children');
        const toggle = document.createElement('span');
        toggle.className = 'toc-toggle';
        toggle.textContent = 'â–¾';
        if (link && link.parentNode === li) {
          const row = document.createElement('div');
          row.className = 'li-row';
          li.insertBefore(row, link);
          row.appendChild(toggle);
          row.appendChild(link);
        } else {
          li.insertBefore(toggle, li.firstChild);
        }
        toggle.addEventListener('click', () => {
          li.classList.toggle('collapsed');
          toggle.textContent = li.classList.contains('collapsed') ? 'â–¸' : 'â–¾';
        });
      }

      // åˆæœŸå±•é–‹çŠ¶æ…‹ã¯ # ã®ãƒ¬ãƒ™ãƒ«ã§åˆ¤å®š
      if (level != null) {
        const open = (defaultDepth === Infinity) || (level <= defaultDepth);
        if (open) {
          li.classList.remove('collapsed');
          const t = li.querySelector(':scope > .toc-toggle');
          if (t) t.textContent = 'â–¾';
        } else {
          li.classList.add('collapsed');
          const t = li.querySelector(':scope > .toc-toggle');
          if (t) t.textContent = 'â–¸';
        }
      }
    });
  }

  // ç‹¬è‡ªTOCã‚·ã‚¹ãƒ†ãƒ 
  const CustomTOC = {
    // ç¾åœ¨ã®ãƒšãƒ¼ã‚¸ã®è¦‹å‡ºã—ã‚’å–å¾—
    getPageHeadings: function() {
      const headmap = new Map();
      let maxDepth = 0;
      
      // ãƒ¡ã‚¤ãƒ³ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‹ã‚‰è¦‹å‡ºã—ã‚’å–å¾—
      const allHeadings = document.querySelectorAll('main h1, main h2, main h3, main h4, main h5, main h6');
      
      allHeadings.forEach(heading => {
        const text = heading.textContent || heading.innerText || '';
        if (!text.trim()) return;
        
        const level = parseInt(heading.tagName.slice(1), 10);
        const id = heading.id || this.generateIdFromText(text);
        
        headmap.set(id, {
          id: id,
          text: text,
          level: level,
          element: heading,
          children: []
        });
        maxDepth = Math.max(maxDepth, level);
      });
      
      return { headings: headmap, maxDepth: maxDepth };
    },
    
    // ãƒ†ã‚­ã‚¹ãƒˆã‹ã‚‰IDã‚’ç”Ÿæˆï¼ˆQuartoäº’æ›ï¼‰
    generateIdFromText: function(text) {
      return text
        .replace(/\s+/g, ' ')
        .trim()
        .toLowerCase()
        .replace(/[^\w\s-]/g, '')
        .replace(/\s+/g, '-');
    },
    
    // ãƒšãƒ¼ã‚¸å¤–TOCï¼šã™ã¹ã¦ã®ãƒšãƒ¼ã‚¸æƒ…å ±ï¼ˆé™çš„ãƒ‡ãƒ¼ã‚¿ï¼‰
    getAllPagesTOC: function() {
      // ãƒšãƒ¼ã‚¸æ§‹æˆã‚’é™çš„ã«å®šç¾©ã™ã‚‹
      return [
        {
          title: "AJMUN 37th å¹³å’Œã¸ã®èª²é¡Œï¼šè£œéº",
          url: "../index.html",
          type: "cover"
        },
        {
          title: "ãƒ•ãƒ­ãƒ³ãƒˆæŒ¨æ‹¶",
          url: "../content/00_front.html",
          type: "front"
        },
        {
          title: "ç¬¬1ç«  ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®æ¦‚è¦",
          url: "../content/01_ch01.html",
          type: "chapter",
          sections: [
            "1.1 ã¯ã˜ã‚ã«",
            "1.2 ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®ç›®çš„",
            "1.2.1 èª²é¡Œèªè­˜",
            "1.2.2 è§£æ±ºæ–¹é‡",
            "1.3 æŠ€è¡“é¸å®š",
            "1.3.1 Quarto + Pandoc",
            "1.3.2 UDPæ˜æœãƒ•ã‚©ãƒ³ãƒˆ",
            "1.4 ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ§‹æˆ",
            "1.4.1 ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ§‹é€ ",
            "1.4.2 ãƒ•ã‚¡ã‚¤ãƒ«é…ç½®æˆ¦ç•¥",
            "1.5 é–‹ç™ºã‚¢ãƒ—ãƒ­ãƒ¼ãƒ",
            "1.5.1 ãƒ—ãƒ­ã‚°ãƒ¬ãƒƒã‚·ãƒ–ã‚¨ãƒ³ãƒãƒ³ã‚¹ãƒ¡ãƒ³ãƒˆ",
            "1.5.2 ã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£å„ªå…ˆ"
          ]
        },
        {
          title: "ç¬¬2ç«  æŠ€è¡“çš„èª²é¡Œã¨è§£æ±ºç­–",
          url: "../content/02_ch02.html",
          type: "chapter",
          sections: [
            "2.1 æ—¥æœ¬èªçµ„ç‰ˆã®èª²é¡Œ",
            "2.1.1 æ–‡å­—ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°",
            "2.1.2 ãƒ•ã‚©ãƒ³ãƒˆã®æ‰±ã„",
            "2.2 ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–ãƒ‡ã‚¶ã‚¤ãƒ³",
            "2.2.1 æ¨™é•·ç”»é¢ã®åˆ¶ç´„",
            "2.2.2 ãƒ¢ãƒã‚¤ãƒ«ã¸ã®å¯¾å¿œ",
            "2.3 ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã®æœ€é©åŒ–",
            "2.3.1 èª­ã¿è¾¼ã¿æ™‚é–“ã®çŸ­ç¸®",
            "2.3.2 ã‚¹ãƒ ãƒ¼ã‚ºãªæ“ä½œæ„Ÿ"
          ]
        },
        {
          title: "ç¬¬3ç«  å®Ÿè£…æ–¹é‡",
          url: "../content/03_ch03.html",
          type: "chapter",
          sections: [
            "3.1 é–‹ç™ºã‚¢ãƒ—ãƒ­ãƒ¼ãƒ",
            "3.1.1 ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ§‹é€ ",
            "3.1.2 ãƒ“ãƒ«ãƒ‰ã‚·ã‚¹ãƒ†ãƒ ",
            "3.2 æŠ€è¡“é¸æŠ",
            "3.3 å“è³ªä¿è¨¼"
          ]
        },
        {
          title: "ã‚³ãƒ©ãƒ 1ï¼šWebãƒ•ã‚©ãƒ³ãƒˆã®æ­´å²",
          url: "../content/20_col01.html",
          type: "column",
          sections: [
            "ãƒ‡ã‚¸ã‚¿ãƒ«ã‚¿ã‚¤ãƒã‚°ãƒ©ãƒ•ã‚£ã®ç™ºå±•",
            "ç”»åƒãƒ•ã‚©ãƒ³ãƒˆã®æ™‚ä»£",
            "Webãƒ•ã‚©ãƒ³ãƒˆã®ç™»å ´",
            "æ—¥æœ¬èªå¯¾å¿œã®èª²é¡Œ",
            "ã‚µãƒ–ã‚»ãƒƒãƒˆåŒ–ã®é‡è¦æ€§"
          ]
        },
        {
          title: "ã‚³ãƒ©ãƒ 2ï¼šã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£ã®é‡è¦æ€§",
          url: "../content/21_col02.html",
          type: "column",
          sections: [
            "ãƒªãƒ†ãƒ©ã‚·ãƒ¼ã®å¤šæ§˜æ€§",
            "è¦–è¦šçš„é…æ…®",
            "è´è¦šçš„é…æ…®",
            "èº«ä½“çš„é…æ…®",
            "æŠ€è¡“çš„ãªå®Ÿè£…"
          ]
        },
        {
          title: "ç¬¬4ç«  UI/UXè¨­è¨ˆ",
          url: "../content/04_ch04.html",
          type: "chapter",
          sections: [
            "4.1 åŸºæœ¬åŸå‰‡",
            "4.2 ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆè¨­è¨ˆ",
            "4.3 ã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£"
          ]
        },
        {
          title: "ç¬¬5ç«  ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–",
          url: "../content/05_ch05.html",
          type: "chapter",
          sections: [
            "5.1 èª­ã¿è¾¼ã¿é€Ÿåº¦",
            "5.2 ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã®åŠ¹ç‡åŒ–",
            "5.3 ã‚­ãƒ£ãƒƒã‚·ãƒ¥æˆ¦ç•¥"
          ]
        },
        {
          title: "ç¬¬6ç«  å›½é€£ã®åˆ¶åº¦",
          url: "./06_ch06.html",
          type: "chapter",
          sections: [
            "ã¯ã˜ã‚ã«",
            "ç¬¬1ç¯€ å›½é€£ã¨ã„ã†çµ„ç¹”",
            "ç¬¬1é … æ¦‚è¦ãƒ»çµ„ç¹”æ§‹é€ ",
            "ç¬¬2é … å®‰å…¨ä¿éšœç†äº‹ä¼š",
            "ç¬¬3é … å›½é€£ã®ç´›äº‰å¯¾å‡¦",
            "ç¬¬4é … å®‰ä¿ç†æ±ºè­°ã«åŸºã¥ãç¾©å‹™",
            "ã‚³ãƒ©ãƒ  å®‰ä¿ç†æ±ºè­°ã®æ‹˜æŸåŠ›",
            "ç¬¬2ç¯€ å›½é€£è²¡æ”¿",
            "ç¬¬2é … PKOäºˆç®—",
            "ç¬¬3ç¯€ å›½é€£ã«ã‚ˆã‚‹çµŒæ¸ˆåˆ¶è£",
            "ç¬¬1é … å›½éš›é€£åˆæ†²ç« ã«ãŠã‘ã‚‹çµŒæ¸ˆåˆ¶è£æªç½®",
            "ç¬¬2é … å†·æˆ¦ä¸‹ã®çµŒæ¸ˆåˆ¶è£",
            "ç¬¬3é … å†·æˆ¦å¾Œã®çµŒæ¸ˆåˆ¶è£",
            "ç¬¬3é … çµŒæ¸ˆåˆ¶è£ã«ä¼´ã†å•é¡Œã¨ãã®å¾Œ",
            "ç¬¬4é … å›½é€£æ†²ç« ç¬¬50æ¡ã®æ³¨è§£",
            "ç¬¬4ç¯€ å›½é€£å¹³å’Œç¶­æŒæ´»å‹•(PKO)",
            "å‚è€ƒæ–‡çŒ®"
          ]
        },
        {
          title: "ç¬¬7ç«  ã¾ã¨ã‚ã¨å±•æœ›",
          url: "../content/07_ch07.html",
          type: "chapter",
          sections: [
            "7.1 ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®æˆæœ",
            "7.2 æŠ€è¡“çš„è²¢çŒ®",
            "7.3 ä»Šå¾Œã®ç™ºå±•",
            "ã¾ã¨ã‚"
          ]
        },
        {
          title: "ã‚³ãƒ©ãƒ 3ï¼šä»Šå¾Œã®æŠ€è¡“å‹•å‘",
          url: "../content/22_col03.html",
          type: "column",
          sections: [
            "æ–°ã—ã„æŠ€è¡“ã®ç™»å ´",
            "Variable Fonts",
            "Container Queries",
            "Web Components",
            "ç™ºå±•ã®å¯èƒ½æ€§",
            "PWAåŒ–",
            "ã‚ªãƒ•ãƒ©ã‚¤ãƒ³å¯¾å¿œ",
            "ãƒãƒ«ãƒãƒ‡ãƒã‚¤ã‚¹åŒæœŸ"
          ]
        },
        {
          title: "ç·¨é›†å¾Œè¨˜",
          url: "../content/90_afterword.html",
          type: "appendix",
          sections: [
            "åŸ·ç­†ã®çµŒç·¯",
            "æŠ€è¡“çš„ãªæŒ‘æˆ¦",
            "ãƒ•ã‚©ãƒ³ãƒˆåŸ‹è¾¼",
            "ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–è¨­è¨ˆ",
            "è„šæ³¨å‡¦ç†",
            "èª­è€…ã®çš†æ§˜ã¸",
            "ä»Šå¾Œã®å±•æœ›",
            "çµã³ã«"
          ]
        },
        {
          title: "å‚è€ƒæ–‡çŒ®",
          url: "../content/95_references.html",
          type: "appendix"
        },
        {
          title: "ç´¢å¼•",
          url: "../content/96_index.html",
          type: "appendix",
          sections: [
            "ã‚", "ã†", "ã‹", "ã“", "ã—", "ãŸ", "ã¯", "ã‚"
          ]
        }
      ];
    },
    
    // ãƒšãƒ¼ã‚¸å†…TOCã‚’ç”Ÿæˆï¼ˆç« å†…ã‚¿ãƒ–ç”¨ï¼‰
    generatePageTOC: function(maxDepth) {
      const { headings } = this.getPageHeadings();
      
      if (headings.size === 0) {
        return '<p class="toc-empty">ã“ã®ãƒšãƒ¼ã‚¸ã«ã¯è¦‹å‡ºã—ãŒã‚ã‚Šã¾ã›ã‚“ã€‚</p>';
      }
      
      const items = [];
      headings.forEach((heading, id) => {
        const level = Math.min(Math.max(heading.level, 1), 6);
        if (level > maxDepth) return;
        const levelClass = `page-toc-level-${level}`;
        const liClasses = ['page-toc-item', levelClass].join(' ');
        items.push(`<li class="${liClasses}"><a class="page-toc-link" href="#${id}">${heading.text}</a></li>`);
      });

      if (!items.length) {
        return '<p class="toc-empty">ã“ã®ãƒšãƒ¼ã‚¸ã«ã¯è¦‹å‡ºã—ãŒã‚ã‚Šã¾ã›ã‚“ã€‚</p>';
      }

      return `<ul class="page-toc-list">${items.join('')}</ul>`;
    },
    
    // å…¨ä½“TOCã‚’ç”Ÿæˆï¼ˆå…¨ä½“ã‚¿ãƒ–ç”¨ï¼‰
    generateAllPagesTOC: function() {
      const pages = this.getAllPagesTOC();
      const currentPath = (window.location.pathname || '').split('/').pop() || 'index.html';
      
      let html = '<ul class="all-toc-list">';
      
      pages.forEach(page => {
        const normalizedPage = (page.url || '').replace(/^\.\//, '').split('/').pop() || '';
        const isActive = normalizedPage === currentPath;
        const itemClasses = ['all-toc-item', `all-toc-item--${page.type || 'other'}`];
        if (isActive) itemClasses.push('active');
        
        html += `<li class="${itemClasses.join(' ')}">`;
        html += `<a href="${page.url}" class="all-toc-link">${page.title}</a>`;
        
        if (Array.isArray(page.sections) && page.sections.length) {
          html += '<ul class="all-toc-sublist">';
          page.sections.forEach(sectionName => {
            const sectionId = this.generateIdFromText(sectionName);
            const link = `${page.url}#${sectionId}`;
            html += `<li class="all-toc-subitem"><a href="${link}" class="all-toc-sublink">${sectionName}</a></li>`;
          });
          html += '</ul>';
        }
        
        html += '</li>';
      });
      
      html += '</ul>';
      return html;
    },
    
    // TOCæ§‹é€ ã‚’HTMLã«å¤‰æ›
    renderTOCStructure: function(structure, maxDepth = Infinity, options = {}) {
      const {
        listClass = 'custom-toc-list',
        childListClass = 'custom-toc-child-list',
        itemClass = (item, active) => `custom-toc-item level-${item.level} ${active}`,
        linkClass = (item, active) => `custom-toc-link ${active}`
      } = options;

      const normalizeClass = (value) => (value || '').trim().replace(/\s+/g, ' ');

      const renderItems = (items, currentDepth = 1) => {
        let resultHtml = '';

        items.forEach(item => {
          if (Array.isArray(item)) {
            if (currentDepth <= maxDepth) {
              resultHtml += `<ul class="${normalizeClass(childListClass)}">`;
              item.forEach(childItem => {
                resultHtml += renderItems([childItem], currentDepth + 1);
              });
              resultHtml += '</ul>';
            }
          } else if (item && item.id) {
            const isActive = document.getElementById(item.id)?.classList.contains('active');
            const activeClass = isActive ? 'active' : '';
            const liClass = typeof itemClass === 'function' ? itemClass(item, activeClass) : itemClass;
            const linkClassName = typeof linkClass === 'function' ? linkClass(item, activeClass) : linkClass;

            resultHtml += `<li class="${normalizeClass(liClass)}">`;
            resultHtml += `<a href="#${item.id}" class="${normalizeClass(linkClassName)}">${item.text}</a>`;

            if (item.children && item.children.length > 0 && currentDepth < maxDepth) {
              resultHtml += `<ul class="${normalizeClass(childListClass)}">`;
              item.children.forEach(child => {
                resultHtml += renderItems([child], currentDepth + 1);
              });
              resultHtml += '</ul>';
            }

            resultHtml += '</li>';
          }
        });

        return resultHtml;
      };

      let html = `<ul class="${normalizeClass(listClass)}">`;
      structure.forEach(item => {
        html += renderItems([item], 1);
      });
      html += '</ul>';
      return html;
    },
    
    // TOCã‚’åˆæœŸåŒ–
    initializeCustomTOC: function() {
      // ç« å†…ã‚¿ãƒ–ç”¨TOC
      const pageTOCPanel = document.querySelector('.toc-page-content');
      if (pageTOCPanel) {
        const pageTOC = this.generatePageTOC(Infinity);
        pageTOCPanel.innerHTML = pageTOC;
      }
      
      // å…¨ä½“ã‚¿ãƒ–ç”¨TOC
      const allTOCPanel = document.querySelector('.toc-all-content');
      if (allTOCPanel) {
        const allTOC = this.generateAllPagesTOC();
        allTOCPanel.innerHTML = allTOC;
        
        // éšå±¤æŠ˜ã‚ŠãŸãŸã¿æ©Ÿèƒ½
        this.setupTOCToggling(allTOCPanel);
      }
    },
    
    // TOCã®éšå±¤å±•é–‹/æŠ˜ã‚ŠãŸãŸã¿æ©Ÿèƒ½
    setupTOCToggling: function(container) {
      const toggleButtons = container.querySelectorAll('.custom-toc-item > .custom-toc-link');
      
      toggleButtons.forEach(link => {
        const listItem = link.closest('.custom-toc-item');
        const childList = listItem.querySelector('.custom-toc-child-list');
        
        if (childList) {
          // é–‹é–‰ãƒœã‚¿ãƒ³ã‚’è¿½åŠ 
          const toggleBtn = document.createElement('span');
          toggleBtn.className = 'custom-toc-toggle';
          toggleBtn.textContent = 'â–¾';
          
          link.parentNode.insertBefore(toggleBtn, link);
          link.style.paddingLeft = '20px';
          
          // ç¬¬4éšå±¤ä»¥ä¸‹ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§æŠ˜ã‚ŠãŸãŸã‚€
          const level = parseInt(listItem.className.match(/level-(\d+)/)?.[1] || 1, 10);
          const collapsed = level >= 4;
          
          if (collapsed) {
            childList.style.display = 'none';
            toggleBtn.textContent = 'â–¸';
          }
          
          toggleBtn.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            
            const isCollapsed = childList.style.display === 'none';
            childList.style.display = isCollapsed ? '' : 'none';
            toggleBtn.textContent = isCollapsed ? 'â–¾' : 'â–¸';
          });
          
          // è¦ªãƒªãƒ³ã‚¯ã®ã‚¯ãƒªãƒƒã‚¯å‹•ä½œ
          link.addEventListener('click', (e) => {
            e.stopPropagation();
          });
        }
      });
    }
  };

  // ã‚³ãƒ¡ãƒ³ãƒˆã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ/ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
  function exportComments(pageOnly) {
    try {
      const data = pageOnly ? { [pageKey()]: COMMENTS_DB[pageKey()]||[] } : COMMENTS_DB;
      const blob = new Blob([JSON.stringify({ version:'1.0', exportedAt: new Date().toISOString(), data }, null, 2)], { type:'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      const base = pageOnly ? (pageKey().split('/').pop()||'page') : 'all';
      a.download = `comments_${base}_${new Date().toISOString().slice(0,10)}.json`;
      document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
    } catch (e) { alert('ã‚³ãƒ¡ãƒ³ãƒˆå‡ºåŠ›ã«å¤±æ•—ã—ã¾ã—ãŸ'); }
  }
  function importCommentsFromFile(file) {
    if (!file) return;
    const reader = new FileReader();
    reader.onload = () => {
      try {
        const json = JSON.parse(reader.result);
        const incoming = json.data || {};
        // ãƒãƒ¼ã‚¸
        Object.keys(incoming).forEach(k => {
          if (!Array.isArray(incoming[k])) return;
          if (!COMMENTS_DB[k]) COMMENTS_DB[k] = [];
          const existingIds = new Set(COMMENTS_DB[k].map(r=>r.id));
          incoming[k].forEach(rec => { if (!existingIds.has(rec.id)) COMMENTS_DB[k].push(rec); });
        });
        saveComments();
        refreshRightPanels();
        alert('ã‚³ãƒ¡ãƒ³ãƒˆã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¾ã—ãŸ');
      } catch (e) {
        alert('ã‚³ãƒ¡ãƒ³ãƒˆèª­è¾¼ã«å¤±æ•—ã—ã¾ã—ãŸ');
      }
    };
    reader.readAsText(file, 'utf-8');
  }

})();
</script>




</body></html>