<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ja" xml:lang="ja"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.25">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>第2章　集団安全保障体制の系譜 – 平和への課題：補遺</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../content/03_ch03.html" rel="next">
<link href="../content/01_ch01.html" rel="prev">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-d2604bcb90b21ac6bc3164282300c13a.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "一致なし",
    "search-matching-documents-text": "一致した文書",
    "search-copy-link-title": "検索へのリンクをコピー",
    "search-hide-matches-text": "追加の検索結果を非表示",
    "search-more-match-text": "追加の検索結果",
    "search-more-matches-text": "追加の検索結果",
    "search-clear-button-title": "消去",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "取消",
    "search-submit-button-title": "検索",
    "search-label": "サーチ"
  }
}</script>
<style>
  :root {
    --sidebar-width: 280px;
    --margin-width: 150px;
    --gutter-width: 12px;
  }
</style>
<style>
  :root {
    --sidebar-width: 280px;
    --margin-width: 150px;
    --gutter-width: 12px;
  }
</style>
<link rel="preload" href="../fonts/BIZUDPMincho-Regular.woff2" as="font" type="font/woff2" crossorigin="">
<link rel="preload" href="../fonts/BIZUDPMincho-Bold.woff2" as="font" type="font/woff2" crossorigin="">
<link rel="preload" href="../fonts/BIZUDPGothic-Regular.woff2" as="font" type="font/woff2" crossorigin="">
<link rel="preload" href="../fonts/BIZUDPGothic-Bold.woff2" as="font" type="font/woff2" crossorigin="">


<link rel="stylesheet" href="../src/css/font-udpmincho.css">
<link rel="stylesheet" href="../src/css/base.css">
<link rel="stylesheet" href="../src/css/simple-theme.css">
<link rel="stylesheet" href="../src/css/right-panel.css">
</head>

<body class="nav-sidebar floating quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="サイドバーを切り替える" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../content/02_ch02.html"><span class="chapter-title">第2章　集団安全保障体制の系譜</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="サイドバーを切り替える" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="サーチ" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header sidebar-header-stacked">
      <a href="../index.html" class="sidebar-logo-link">
      </a>
    <div class="sidebar-title mb-0 py-0">
      <a href="../">平和への課題：補遺</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="サーチ"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../index.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">AJMUN 37th 平和への課題：補遺</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/00_front.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">フロント挨拶</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/01_ch01.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">第1章 プロジェクトの概要</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/02_ch02.html" class="sidebar-item-text sidebar-link active"><span class="chapter-title">第2章　集団安全保障体制の系譜</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/03_ch03.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">第3章　争点・論点解説</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/04_ch04.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">第4章 国連による紛争処理</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/05_ch05.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">第5章　国連の制度</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/06_ch06.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">第1節　国際法法原論</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Appendices</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="セクションを切り替え">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/90_afterword.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">編集後記</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/95_references.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">参考文献</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../content/96_index.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">索引</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">目次</h2>
   
  <ul>
  <li><a href="#第1節-はじめに" id="toc-第1節-はじめに" class="nav-link active" data-scroll-target="#第1節-はじめに">第1節　はじめに</a></li>
  <li><a href="#第2節-集団安全保障体制の創設から国際連合の設立まで" id="toc-第2節-集団安全保障体制の創設から国際連合の設立まで" class="nav-link" data-scroll-target="#第2節-集団安全保障体制の創設から国際連合の設立まで">第2節　集団安全保障体制の創設から国際連合の設立まで</a>
  <ul class="collapse">
  <li><a href="#第1項-集団安全保障の誕生" id="toc-第1項-集団安全保障の誕生" class="nav-link" data-scroll-target="#第1項-集団安全保障の誕生">第1項　集団安全保障の誕生</a></li>
  <li><a href="#第2項-国際連合での集団安全保障" id="toc-第2項-国際連合での集団安全保障" class="nav-link" data-scroll-target="#第2項-国際連合での集団安全保障">第2項　国際連合での集団安全保障</a></li>
  </ul></li>
  <li><a href="#第3節-冷戦期における国連の集団安全保障体制" id="toc-第3節-冷戦期における国連の集団安全保障体制" class="nav-link" data-scroll-target="#第3節-冷戦期における国連の集団安全保障体制">第3節　冷戦期における国連の集団安全保障体制</a>
  <ul class="collapse">
  <li><a href="#コラム-用語の整理まだ" id="toc-コラム-用語の整理まだ" class="nav-link" data-scroll-target="#コラム-用語の整理まだ">＜コラム　用語の整理＞(まだ)</a></li>
  <li><a href="#第1項-安保理の問題点" id="toc-第1項-安保理の問題点" class="nav-link" data-scroll-target="#第1項-安保理の問題点">第1項　安保理の問題点</a></li>
  <li><a href="#第2項-国連憲章における強制措置の特色と弱点上の項と統合してもいいかも" id="toc-第2項-国連憲章における強制措置の特色と弱点上の項と統合してもいいかも" class="nav-link" data-scroll-target="#第2項-国連憲章における強制措置の特色と弱点上の項と統合してもいいかも">第2項　国連憲章における強制措置の特色と弱点（上の項と統合してもいいかも）</a></li>
  <li><a href="#第3項-朝鮮戦争まだ" id="toc-第3項-朝鮮戦争まだ" class="nav-link" data-scroll-target="#第3項-朝鮮戦争まだ">第3項　朝鮮戦争（まだ）</a></li>
  <li><a href="#第4項-アジアアフリカ諸国の外交努力" id="toc-第4項-アジアアフリカ諸国の外交努力" class="nav-link" data-scroll-target="#第4項-アジアアフリカ諸国の外交努力">第4項　アジア・アフリカ諸国の外交努力</a></li>
  <li><a href="#第5項-平和維持活動の登場" id="toc-第5項-平和維持活動の登場" class="nav-link" data-scroll-target="#第5項-平和維持活動の登場">第5項　平和維持活動の登場</a></li>
  <li><a href="#第6項-スエズ危機と国連軍unef" id="toc-第6項-スエズ危機と国連軍unef" class="nav-link" data-scroll-target="#第6項-スエズ危機と国連軍unef">第6項　スエズ危機と国連軍（UNEF）</a></li>
  <li><a href="#第7項-コンゴ動乱と国連軍onuc" id="toc-第7項-コンゴ動乱と国連軍onuc" class="nav-link" data-scroll-target="#第7項-コンゴ動乱と国連軍onuc">第7項　コンゴ動乱と国連軍（ONUC）</a></li>
  <li><a href="#第8項-平和維持活動の動揺と同意原則の再検討" id="toc-第8項-平和維持活動の動揺と同意原則の再検討" class="nav-link" data-scroll-target="#第8項-平和維持活動の動揺と同意原則の再検討">第8項　平和維持活動の動揺と同意原則の再検討</a></li>
  <li><a href="#第9項-中東における平和維持活動の復活書くか未定" id="toc-第9項-中東における平和維持活動の復活書くか未定" class="nav-link" data-scroll-target="#第9項-中東における平和維持活動の復活書くか未定">第9項　中東における平和維持活動の復活（書くか未定）</a></li>
  <li><a href="#第10項-平和維持活動の基本的課題と特別委員会の議論" id="toc-第10項-平和維持活動の基本的課題と特別委員会の議論" class="nav-link" data-scroll-target="#第10項-平和維持活動の基本的課題と特別委員会の議論">第10項　平和維持活動の基本的課題と特別委員会の議論</a></li>
  <li><a href="#第11項-冷戦期における国連待機軍の議論" id="toc-第11項-冷戦期における国連待機軍の議論" class="nav-link" data-scroll-target="#第11項-冷戦期における国連待機軍の議論">第11項　冷戦期における「国連待機軍」の議論</a></li>
  <li><a href="#第12項-第3節のむすびに" id="toc-第12項-第3節のむすびに" class="nav-link" data-scroll-target="#第12項-第3節のむすびに">第12項　第3節のむすびに</a></li>
  </ul></li>
  <li><a href="#第4節-ポスト冷戦期の国連の集団安全保障体制" id="toc-第4節-ポスト冷戦期の国連の集団安全保障体制" class="nav-link" data-scroll-target="#第4節-ポスト冷戦期の国連の集団安全保障体制">第4節　ポスト冷戦期の国連の集団安全保障体制</a>
  <ul class="collapse">
  <li><a href="#第1項-湾岸戦争一次資料残し" id="toc-第1項-湾岸戦争一次資料残し" class="nav-link" data-scroll-target="#第1項-湾岸戦争一次資料残し">第1項　湾岸戦争（一次資料残し）</a></li>
  <li><a href="#第2項-ポスト冷戦期の始まりと安保理サミット文は完成一次資料をこれから追加予定" id="toc-第2項-ポスト冷戦期の始まりと安保理サミット文は完成一次資料をこれから追加予定" class="nav-link" data-scroll-target="#第2項-ポスト冷戦期の始まりと安保理サミット文は完成一次資料をこれから追加予定">第2項　ポスト冷戦期の始まりと安保理サミット（文は完成／一次資料をこれから追加予定）</a></li>
  <li><a href="#第3項-平和への課題文はおおよそ完成一次資料を追加予定" id="toc-第3項-平和への課題文はおおよそ完成一次資料を追加予定" class="nav-link" data-scroll-target="#第3項-平和への課題文はおおよそ完成一次資料を追加予定">第3項　「平和への課題」（文はおおよそ完成／一次資料を追加予定）</a></li>
  <li><a href="#第4項-その後のイラク" id="toc-第4項-その後のイラク" class="nav-link" data-scroll-target="#第4項-その後のイラク">第4項　その後のイラク</a></li>
  <li><a href="#第5項-リビアへの経済制裁" id="toc-第5項-リビアへの経済制裁" class="nav-link" data-scroll-target="#第5項-リビアへの経済制裁">第5項　リビアへの経済制裁</a></li>
  <li><a href="#第6項-ソマリア内戦" id="toc-第6項-ソマリア内戦" class="nav-link" data-scroll-target="#第6項-ソマリア内戦">第6項　ソマリア内戦</a></li>
  <li><a href="#第7項-旧ユーゴ内戦" id="toc-第7項-旧ユーゴ内戦" class="nav-link" data-scroll-target="#第7項-旧ユーゴ内戦">第7項　旧ユーゴ内戦</a></li>
  <li><a href="#第8項-ルワンダ内戦" id="toc-第8項-ルワンダ内戦" class="nav-link" data-scroll-target="#第8項-ルワンダ内戦">第8項　ルワンダ内戦</a></li>
  <li><a href="#第9項-ハイチ情勢" id="toc-第9項-ハイチ情勢" class="nav-link" data-scroll-target="#第9項-ハイチ情勢">第9項　ハイチ情勢</a></li>
  <li><a href="#第10項-強制措置発動の適否とその実施方法の適否消すかも" id="toc-第10項-強制措置発動の適否とその実施方法の適否消すかも" class="nav-link" data-scroll-target="#第10項-強制措置発動の適否とその実施方法の適否消すかも">第10項　強制措置発動の適否とその実施方法の適否（消すかも）</a></li>
  <li><a href="#第11項-ガリが残した平和への課題補遺要素は入れた最後に組み直し" id="toc-第11項-ガリが残した平和への課題補遺要素は入れた最後に組み直し" class="nav-link" data-scroll-target="#第11項-ガリが残した平和への課題補遺要素は入れた最後に組み直し">第11項　ガリが残した「平和への課題：補遺」（要素は入れた／最後に組み直し）</a></li>
  </ul></li>
  <li><a href="#参考文献" id="toc-参考文献" class="nav-link" data-scroll-target="#参考文献">参考文献</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">
<div class="header-ui">
  <div id="js-header" class="js-header">
    <div class="js-header__inner">
      <div class="js-header__left">
        <div class="js-header__logo">
          <span class="js-header__title"><span class="title-main">平和への課題：補遺</span><span class="title-sub">Background Guide</span></span>
        </div>
      </div>
      <div class="js-header__right">
        <div class="js-header__controls">
          <!-- 設定メニューボタン -->
          <button class="js-settings-toggle-btn" id="settings-toggle-btn" aria-label="設定メニューを開く">
            <img src="" data-asset="assets/setting.png" alt="" aria-hidden="true" class="settings-toggle-icon">
          </button>
        </div>
      </div>
    </div>
  </div>
  
  <!-- 格納型設定メニュー -->
  <div class="settings-menu" id="settings-menu">
    <div class="settings-menu__inner">
      <div class="settings-menu__header">
        <h3 class="anchored">表示設定</h3>
        <button class="settings-menu__close" id="settings-menu-close">×</button>
      </div>
      <div class="settings-menu__content">
        <!-- 文字サイズ -->
        <div class="settings-item">
          <label for="font-size-select">文字サイズ：</label>
          <select class="js-font-size-select" id="font-size-select" aria-label="文字サイズ">
            <option value="3XS">3XS</option>
            <option value="2XS">2XS</option>
            <option value="XS">XS</option>
            <option value="S">S</option>
            <option value="M" selected="">M</option>
            <option value="L">L</option>
            <option value="XL">XL</option>
          </select>
        </div>
        
        <!-- テーマ切替 -->
        <div class="settings-item">
          <label for="theme-select">テーマ：</label>
          <select class="js-theme-select" id="theme-select" aria-label="テーマ">
            <option value="light">ライト</option>
            <option value="dark">ダーク</option>
            <option value="auto">自動</option>
          </select>
        </div>
        
        <!-- コメント機能 -->
        <div class="settings-divider"></div>
        <div class="settings-section-title">コメント機能</div>
        <div class="settings-item">
          <button class="js-comments-export-page" id="comments-export-page">コメント出力(このページ)</button>
        </div>
        <div class="settings-item">
          <button class="js-comments-export-all" id="comments-export-all">全コメント出力</button>
        </div>
        <div class="settings-item">
          <label for="comments-import" class="js-comments-import-label">コメント読込：</label>
          <input type="file" id="comments-import" class="js-comments-import" accept="application/json" style="display:none;">
          <button class="js-comments-import-button" id="comments-import-button">ファイル選択</button>
        </div>
        
        <!-- プレビューのトースト表示数 -->
        <div class="settings-item">
          <label for="gdoc-toast-max">プレビューのトースト数：</label>
          <input type="range" id="gdoc-toast-max" min="0" max="9" value="3" aria-label="プレビューのトースト数">
          <span id="gdoc-toast-max-value">3</span>
        </div>

        <!-- 各種設定リセット -->
        <div class="settings-divider"></div>
        <div class="settings-section-title">リセット</div>
        <div class="settings-item settings-item--reset-buttons">
          <button type="button" id="reset-ui-settings">UI系をリセット</button>
          <button type="button" id="reset-memo-settings">メモ系をリセット</button>
          <button type="button" id="reset-preview-settings">プレビューをリセット</button>
          <button type="button" id="reset-all-settings">すべてをリセット</button>
        </div>
      </div>
    </div>
  </div>
  <div class="settings-menu-overlay" id="settings-menu-overlay"></div>
</div>

<div class="toc-overlay">
  <div class="toc-overlay__backdrop"></div>
  <div class="toc-sheet">
    <div class="toc-sheet__header">
      <h3 class="anchored">ナビゲーション</h3>
      <button class="toc-sheet__close">×</button>
    </div>
    <div class="toc-sheet__content">
      <!-- 左パネル相当の内容はJavaScriptで生成 -->
    </div>
  </div>
</div>

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-title">第2章　集団安全保障体制の系譜</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>文責：島村 海里</p>
<section id="第1節-はじめに" class="level2">
<h2 class="anchored" data-anchor-id="第1節-はじめに">第1節　はじめに</h2>
<p>　1989年に訪れた冷戦の終結。これは国際政治の構造に多大な変化をもたらした。世界平和機構としての国際連合の存在が脚光を浴びるようになったのも必然であった。米ソを中心とする大国の協力体制が整った安全保障理事会はもはや「拒否権」に悩まされることなく、国際の平和と安全の維持に関わる要の組織として、多くの決議を採択できるようになった。その中でも、イラクに対する一連の制裁決議がほとんど全会一致で採択されたことは、安保理の回復を象徴する出来事であった。また、国連は多発する地域紛争に意欲的な介入を続け、世界各地にPKOを展開させることに成功した。しかしこうした国連への期待の高揚は束の間に終わってしまった。ソマリアや旧ユーゴをはじめとする国連活動がことごとくつまずいたからであった。それに伴い、米国をはじめ国際世論は一転して国連離れの様相を帯び始めた。<br>
　95年時点の国連は、国際の平和と安全の維持を司る機関としての在り方をめぐって試行錯誤の段階にある。就任後まもなくブトロス・ブトロス＝ガリ事務総長は「平和への課題（An Agenda for Peace）」と題する報告書の中で大胆な国連改革の提言を行い国際的反響を呼んだ。それからわずか2年半後に出された「平和への課題：補遺（Supplement to an Agenda for Peace）」では前回の提言を大きく軌道修正する内容となった。<br>
　21世紀を間近に控え、国連はなおも世界平和実現への進路を求めあぐねている。この章では、国際連盟発足時に誕生した集団安全保障体制の解説に始まり、95年にガリが「平和への課題：補遺」を発表するまでの歴史を振り返る。国連が本来志向する集団安全保障体制の形とその実現方法について解説したのち、1945年の国連発足からの半世紀にも及ぶ国連の歴史を踏まえて、国連が本質的に抱えている問題およびガリが「平和への課題：補遺」で残した問題意識とその本質に迫りたい。</p>
</section>
<section id="第2節-集団安全保障体制の創設から国際連合の設立まで" class="level2">
<h2 class="anchored" data-anchor-id="第2節-集団安全保障体制の創設から国際連合の設立まで">第2節　集団安全保障体制の創設から国際連合の設立まで</h2>
<section id="第1項-集団安全保障の誕生" class="level3">
<h3 class="anchored" data-anchor-id="第1項-集団安全保障の誕生">第1項　集団安全保障の誕生</h3>
<p>　集団安全保障。これは、複数の国家が平和の維持を予め約し、もしその中の一国が、これに違反して戦争に訴えた場合には、他のすべての国が、武力の使用を含めて抑制のための行動をとることを予定したものである。この方針は、第一次世界大戦の終結とともに国際連盟が作り上げた体制であり、第一次世界大戦を引き起こした原因とされた勢力均衡政策への強い反省が反映されたものである。勢力均衡政策は、対立する国家間の力の均衡の維持を目的とし、元来、仮想敵国の存在を前提として成立するものであるが、集団安全保障は、対立する国家を包含して平和の維持を計り、相互の協力に国際関係の安全を達成しようとするものである。そこには仮想敵国は存在せず、平和の維持という共通の目的に向かっての諸国の協力が要求される。この体制が完成すれば、勢力均衡政策の致命的欠点である「絶えざる力の不均衡」は消滅し、国際社会には安定した平和が得られるはずであった。同時に、勢力均衡政策の立脚する「自国の利益の維持」という利己的政策は廃れ、「国際平和の維持」というより高度な目的への協力体制が完成するはずであった。<br>
　集団安全保障体制を創設した国際連盟の連盟規約第12条では、連盟国は相互間に国交断絶に至る恐れのある紛争が発生した時には、これを仲裁裁判又は司法的解決に付託するか、連盟理事会の審査に付するものとされ、仲裁裁判又は司法的解決の判決後又は理事会の報告後3ヶ月を経過するまでは戦争に訴えることは禁止された。また、連盟規約第13条及び第15条により、判決に服する国、及び当事国を除く理事国全部の同意による報告書に従う国に対して戦争に訴えることは禁じられた。これらの規定に違反して戦争に訴えた国は、他のすべての連盟国に対して戦争に訴えたものとみなされ、他のすべての連盟国は、この国と一切の経済関係を断絶することが約束され、この経済断行のため兵力が必要な時は、連盟理事会その分担程度を関係各国政府に提案するものとされた（第16条）。ただし、ここに予定されている経済措置は、経済断行のみであり、連盟国からの兵力提供も、この経済断行を実効性のあるものとするための措置に用いられるものにすぎず、直接戦闘行為を行なった違反国に制裁を加えるものではなかった。<br>
　集団安全保障における制裁措置を規定した連盟規約16条は、結果的には功を奏することはなかった。これは連盟創設当時から、連盟国が制裁参加に対するフリーハンドを欲しがったからであった。1921年、連盟総会は、規約第16条の適用の方針についての決議を採択したが、この決議は、規約に違反して戦争に訴えた国があっても、他の連盟国は各々の判断によって適当な処理を行うことを認めたものであった。この決議により、第16条の経済制裁に参加するか否かは全く各国の自由となり、ただ一度発動された対イタリア制裁も、実効性の極めて乏しいものとなってしまったのである。<br>
　国際連盟は他の部分においてもいくつか問題を抱えていた。全会一致という表決制度や戦争違法化の不安定さ、制裁体制の不備などの制度的・技術的欠陥のほか、加盟国がヨーロッパ中心で英仏以外の大国が連盟に結集していなかったことや、加盟国に集団安全保障の原則を守り抜こうという強固な決意がなかったことなど、さまざまな問題が挙げられる。ただ、国連憲章の起草者たちが連盟の失敗の最大の原因と考えたのは、制裁体制の不備であり、弱体かつ分権的な制裁体制こそが、ファシズム諸国の侵略戦争を許してしまった最大の原因と考えたのである。連盟の集団安全保障体制は、結果的に第二次世界大戦の勃発をもって完全に崩壊してしまうこととなってしまった。</p>
</section>
<section id="第2項-国際連合での集団安全保障" class="level3">
<h3 class="anchored" data-anchor-id="第2項-国際連合での集団安全保障">第2項　国際連合での集団安全保障</h3>
<p>　第二次世界大戦の終結をもって結成された国際連合では、国連連盟時代の教訓を踏まえた、より徹底した方式を備えた集団安全保障体制を採用した。国際連合憲章（以下、憲章）は第2条3項において紛争の平和的解決を加盟国に対して義務付けると同時に、第2条4項では国際関係における武力による威嚇または武力の行使を禁止した。国連による強制措置においては、第39条により、安全保障理事会（以下、安保理）が平和への脅威、平和の破壊、侵略行為の存在を認定し、国際の平和及び安全を維持しまたは回復するために、勧告をし、または第41条及び第42条にしたがって取るべき措置を決定することとされている。第41条では、兵力を伴わない非軍事的措置に関するもので、経済関係、及び交通、通信手段の全部または一部の中断、外交関係の断絶を含む。第42条では、第41条の措置では不十分な時において、陸海空軍の行動をとることができるとする軍事的措置を定めている。また、その効果的な実施のために、第43条では国連の軍事的行動が迅速に行われるよう、国連軍編成の即応体制をさだめ、そのために必要な特別協定の締結や軍事参謀委員会の設置などが周到に整備された。連盟時代の制裁措置が、経済措置に限られていたのに対して、国連憲章では、非軍事的措置、軍事的措置の両方が定められており、遥かに充実した内容となっている。さらに、憲章第25条により、加盟国は安保理の決定を、国連憲章にしたがって受諾し、かつ履行することに同意するとされており、安保理の決定は加盟国を拘束することとなっている。さらに第48条によって、国際の平和及び安全の維持のための安保理の決定を履行するのに必要な措置は、安保理の定めるところに従って加盟国の全部または一部によって取られることになっており、安全保障のために、加盟国が安保理の決定により行動することが定められている。<br>
　以上のような国連憲章の規定については一般に、集団安全保障体制を安保理に集権化し、連盟期の集団安全保障体制から格段に強化されたものとして評価されている。だが当時からこのシステムで本当に世界の平和と安全が保障されるかどうかについては、いくつかの疑問が出されていた。第一に、安保理常任理事国による拒否権の行使によって、侵略が行われても強制措置を発動できない事態が予想された。こうした懸念は冷戦がはじまったことにより現実となった。第二に、制裁体制の強化が本当に平和と安全の確保につながるのかどうかという点についても、批判や疑問、警戒感があった。大国に対する強制措置が世界戦争を招きうるために、小国に対してしか行われないとして、その小国は安保理による侵略行為の認定や強制措置発動の決定が公正に行われるかどうかに疑問を持っていたのである。サンフランシスコ会議でエジプトやニュージーランドは、安保理による強制措置発動の決定を総会の審査または同意にふくさせる修正案を提出し、ノルウェーは、安保理が国連の目的と原則だけでなく「憲章の規定及び将来の安全と福利に対する国家の信頼を損なうような性質の解決を押し付けてはならないとの考慮」に従っても行動するよう義務付ける修正案を出していたのである。これらは全て安保理の裁量権を枠にはめて、その暴走に歯止めをかけようとするものであった。この懸念について、冷戦の終焉とともに露呈することとなるのは、まだ先の話である。</p>
<p>　国際連合憲章は、その第7章において集団安全保障の機能を強化するために、かなり詳しい規定を置いている。国際連盟規約と比較して注目されるのは、強制措置を発動する手続きが組織化されていることである。連盟規約では違法な戦争を行なったかどうかの認定、および制裁措置の発動は連盟国がひとつひとつ総会で行なう建て前がとられ、連盟の機関の役割は制裁の実施にあたって、その協調体制について勧告するにすぎなかった。これに対し、国際連合では安全保障理事会の権限が強化され、制裁の発動は理事会の決議に基づいて行なわれ、各加盟国がこれに協力する体制がとられている。まず安全保障理事会は、平和に対する脅威、平和の破壊、侵略行為の存在を認定し、国際の平和と安全の維持または回復のために勧告することができ(第39条)、ついで理事会はとりあえず、事態の悪化を防ぐための暫定措置に従うよう関係国に要請することができ(第40条)、さらに理事会は、集団安全保障の中核をなす軍事的および非軍事的強制措置を決定し、加盟国にその履行を命じることができる(第41条、42条)。このように、強制措置を開始する時期や各加盟国のとる具体的措置を決定する権限を安全保障理事会に委ね、加盟国はこれに従う義務のあるものとすることにより(第25条)、安全保障理事会の中央集権的な統制よって制裁の効果を発揮できるようにしたことが、連盟規約と異なる第一の特色であった。</p>
</section>
</section>
<section id="第3節-冷戦期における国連の集団安全保障体制" class="level2">
<h2 class="anchored" data-anchor-id="第3節-冷戦期における国連の集団安全保障体制">第3節　冷戦期における国連の集団安全保障体制</h2>
<section id="コラム-用語の整理まだ" class="level3">
<h3 class="anchored" data-anchor-id="コラム-用語の整理まだ">＜コラム　用語の整理＞(まだ)</h3>
<p>　具体的な事例の解説に入る前に、平和を実現するための国連の諸機能を表す用語について、用語の整理を行おうと思う。用語の意味内容についてかなりの混乱が予想されるからである。国連の実践過程において、平和維持に関するキーワードが登場し、盛んに用いられるようになったのは以下の4つである。それぞれ “preventive diplomacy” “peace-keeping” “peace-making” 及び “peace-enforcement”である。<br>
　“preventive diplomacy”（「予防外交」や「防止外交」と訳される）という言葉を最初に用いたのは、ハマーショルド第2代国連事務総長である。彼は朝鮮戦争後の東西間の冷戦の雪解けにより、地域紛争解決のために国連の果たす役割への期待が高まった50年代後半に、国連による紛争への平和的介入や積極外交の必要祭を説き、「予防外交」の理論を展開したのである。この理論は、対立する東西陣営の接点の外で生じる武力紛争に対し国連がいち早く介入し、その中立的なUNプレゼンスにより紛争の収拾を図り、地域紛争が大国間の抗争に発展するのを予防するのを防止する国連の積極政策を指す。<br>
　“peace-making”（「平和創造」や「平和の創出」と訳される）は、国連憲章第6章における「紛争の平和的解決（pacific settlement of dispute）」に相当する用語であり、紛争当事者に対する仲介や調停といった平和的手段により紛争を解決する国連の外交努力を指す。これに対して “peace-enforcement”（「平和強制」）という言葉は、憲章第7章に定める集団安全保障体制の要をなす国連の強制機能を指すものとして用いられてきた。国連創設者が国連の平和維持機能の中で最も重視したのが、この「平和強制」、つまり強制力に支えられた平和維持システムであり、今回の会議で我々が議論の対象とするものもこの領域である。<br>
　以上の二つの用語については、国連憲章が紛争処理の硬軟両用のアプローチとしてそれぞれ詳しい規定を置いているのに対し、“peace-keeping”（「平和維持」とよく訳される）は、これに対応する明文の規定を欠いている。よく「6章半」の活動という表現が用いられるのはこのためである。先にも述べたようにこの語は、国連の実践過程で生み出され、発展した平和維持の新しい方式を指し、60年代の初めごろから一般に用いられるようになった慣用語である（なお、こうした活動をPKOと呼称するのは日本においてのみで、諸外国においては “peace-keeping” が用いられる）。特に56年のスエズ動乱の収集のために派遣された国連緊急軍（UNEF）が初めて用いてからである。三番所がこの表現を用いたのは、この新しい方の活動の持つ「非強制的」な性格を強調するためであり、国連の強制機能（「平和の強制」）と対比する概念として使われたのである。PKOは「予防外交」と密接な関係があり、その一翼を担うものとして現地介在した軍事組織がPKOと呼ばれるようになったのである。軍隊類似の組織による現地活動ではあるものの、その使用目的は「平和の強制」の軍隊とは対照的であり、その性格は憲章第6章の平和的解決機能と軌を一にする。PKOは武力紛争の軍事的側面を収拾するためのものであり、戦闘を目的としたものではない。現地での駐留や活動は、もっぱら紛争当事者からの協力が得られることと中立であることを前提とし、交戦者間の合意を得た停戦や兵力撤退の実施の監視や考察といった警察的な活動が行われるのである。事態の平穏化を図ったのちに、紛争そのものが政治的最終解決へ向かう素地を創るのであり、紛争の政治的側面の解消に向けられたものでは本来ないことは勘違いしてはならない。紛争そのものの最終的・政治的決着は「平和創造」の役割であるはずである。しかし、この「平和維持」と「平和創造」は不可分な関係として発展していくこととなる。</p>
</section>
<section id="第1項-安保理の問題点" class="level3">
<h3 class="anchored" data-anchor-id="第1項-安保理の問題点">第1項　安保理の問題点</h3>
<p>　結果的に第二次世界大戦の勃発を防ぐことができなかった国際連盟の反省をもとに設立された国際連合では、少なくともその規定上においては、強力な集団安全保障体制を安保理の設立によって作り上げることに成功したかと思われた。しかしその実態として、憲章のとった安全保障の制度は不完全なものであった。集団安全保障は軍事同盟とは異なり、制裁の対象となる国があらかじめ特定されない点に特色がある。したがって、いかなる国による平和への脅威、平和の破壊、侵略行為に対しても、制裁の発動は普遍的かつ規則的に一貫性を持ったものでなければならない。しかし国連の下では安保理の常任理事国に拒否権制度が与えられた。この手続きは、常任理事国の一国でも反対すれば、安保理の決議は成立しないことを意味する。常任理事国のいずれかの国が欲しないときは、第41条及び第42条の強制措置の発動は全く不可能であるのだ。もともと、国連の安全保障体制は第二次世界大戦中の連合国間の軍事協力体制を戦後にも維持しようとする発想に基づくもので、将来の国連の分解を予防する措置としても強制行動を五大国の一つに向けることは初めから想定されなかったのである。五大国の拒否権はこれを制度的に保証したものである。その結果、集団安全保障の発動の範囲は自ら限定され、五大国に向けたもの、および大国の支援する他の国に対しての制裁は適用できないこととなった。<br>
　大戦終結後、米ソ間が激しく対立した冷戦を通した拒否権の濫用により安保理は機能不全に陥った。仔細に語るのであれば、冷戦期を通して米ソ間には核戦略上の変化や、軍縮の進展などがあり、この期間の全てが一律の対立構造で説明できるものではない。ただ、安保理の審議で米ソが対立し妥協できない場合には、拒否権行使によって決着された。総会においてももともとの権限上の限界に加え、多数を占める途上国の側にソ連をはじめとする共産圏がつき、これに西側先進国が対立することで具体的な決定ができないという基本図式が完成していたのである。先にも述べたように、国連憲章は第7章で特に軍事的強制行動の組織化や、国連による指揮・統轄について詳しい規定を置いている。しかし軍事強制行動に使用する兵力提供の取極めや国連軍の組織化の企ても放棄され、第7章の構想は無に帰した。国連の歴史を通じて、国連軍の名のもとにまがりなりにも軍事的強制行動がとられた唯一の事例は50年の朝鮮戦争の時のみとなった。</p>
</section>
<section id="第2項-国連憲章における強制措置の特色と弱点上の項と統合してもいいかも" class="level3">
<h3 class="anchored" data-anchor-id="第2項-国連憲章における強制措置の特色と弱点上の項と統合してもいいかも">第2項　国連憲章における強制措置の特色と弱点（上の項と統合してもいいかも）</h3>
<p>　国連憲章が予定した集団安全保障の特色は、制裁手段としての軍事的強制措置を定め、それに使用する兵力の準備編成・指揮などについて多くの規定を設け、軍事制裁の組織化を図っている点である。すなわち、憲章は国連軍の迅速・能率的な編成と使用が可能なように、平素の準備体制について定めており、そのために、安全保障理事会は各加盟国との間に特別協定を締結し、国連の要請に応じて加盟国が提供すべき兵力の数や種類、軍事的便宜や援助の内容について、あらかじめ約束することになっており(第43条、45条)、したがってこのような特別協定が成立すれば、理事会はいつでも、直ちに国連軍を組織して強制行動に移れる仕組みになっている。さらに、憲章は、安全保障理事会の補助機関として、軍事参謀委員会を設けることを定めている(第46条、47条)。この委員会は、安全保障理事会の常任理事国の参謀総長などの軍事代表で構成し、理事会の使用する兵力につき、計画案の策定や戦略的指揮にあたるものである。<br>
　ところで、国連憲章第7章には、第42条から47条にかけて、「空、海、陸の軍隊 (air, sea, or land force)」、および「兵力 (armed forces, force(s))」 という言葉が用いられており、これが憲章上の「国連軍」と通称されるものである。では、この憲章が想定した国連軍はどのような性格のものとして考えられていたのであろうか。国連憲章第7章の規定自身によって、さらにそれを補うものとして、憲章の起草過程、および国連の発足直後の1947年に軍事参謀委員会が安全保障理事会に提出した国連軍の編成に関する一般原則を定めた「中間報告書」によって、その基本的性格を窺うことができる。<br>
　（1）まず、国連軍の任務は、安全保障理事会が第39条で認定した平和に対する脅威、平和の破壊、侵略行為に対して、第42条に従ってとる軍事強制行動のためのものであり、平和破壊や侵略を阻止、鎮圧するための、強制的軍事制裁の兵力と考えられていたことは疑いない。第7章の中で「強制行動 (enforcement action)」という言葉が用いられているのは、第45条と50条だけであり、その他は「措置(measures)」や「行動 (action)」という一般的な表現が使われているにすぎない。 しかし、第41条以下の「措置」や「行動」は、サンフランシスコの憲章起草会議の議事録に照らしても、「強制行動」という狭い意味に用いられており、この点は、軍事参謀委員会の「中間報告」でも、第7章に定める軍隊の使用目的が、第42条に規定された強制行動であることを前提にした規定を置いている。<br>
　（2）次に、憲章第7条が予定した国連軍は、常設的な軍隊か、それとも、その都度編成されるアドホックなものかという問題がある。憲章上の国連軍については、しばしば「常設化」ないし国連軍の「創設」という言葉が用いられる。しかし、これら「常設化」や「創設」とはどのような意味のものであろうか。<br>
　第二次大戦中、国際連盟に代わる戦後の平和機構の作成にとりかかった米国国務省の専門家達は、連盟では軽視された軍事的強制措置に対して強い関心を示したが、それに使用する兵力の型が問題となった。兵力による強制措置の可能性としては、①加盟各国の軍隊によるアドホックな共同の軍事行動、②加盟国があらかじめ定められた兵力分担計画に従い提供した軍隊で国際軍を組織し、これを国際機構の使用に委ねる制度、③国際機構が独自に保有する常設的な国際軍(国連常備軍)の使用、の3つが考えられた。このうち、第1の方法は、国際連盟規約第16条が採用した方式であり、効果的ではないと退けられた。一方、第3の国際機構による常時国際化された軍隊を保有する方式は、軍事的強制措置としては最も効果的と考えられ、国務省はとくに機動性に富んだ空軍部隊について常設的な国際空軍を設ける可能性を検討した。しかし、平時から加盟国の統制を離れた独自の国際化された軍隊(internationalized force)を設けることは国家主権の観念と相容れ難いと考えられ、とくに米国議会の承認を得ることが困難視されたので、常設国際空軍の構想は結局放棄されることになった。そこで残された方法、すなわち国際機構が独自の常備軍をもつのではないが、有事に備えた事前の準備体制(待機体制)をとる点で第1のものよりは一歩進めた、第2の方法を提案することに落ち着いたのである。<br>
　1944年のダンバートン・オークス会議では、中国とソ連の代表がそれぞれ「国際空軍」の創設に関する提案を行なったが、いかなる種類の国際常備軍の設置にも反対であるとする米、英代表の態度の前にこれらの提案は撤回され、結局上記の第2の構想を織り込んだ米国案が、ダンバートン・オークス提案の中で採用されたのであり(第8章B節5項、6項)、この案はサンフランシスコ会議でもほとんど修正なしに採択されて、憲章第7章の第43条および第45条の規定となった。憲章第45条は、「空軍割当部隊」について規定しているが、これは第43条の兵力と性格を異にするものではなく、特別協定に基づき関係国が自国空軍部隊の一部を国連用に待機させるものであって、国連の常時国際化された空軍というものではない。結局この規定は採用されなかった中ソ両国の提案の名残りである。<br>
　（3）憲章第7章の強制行動に参加する兵力は、はたして「国連軍」の名に値する国際的性格を備えたものか、それとも加盟国の軍隊 (national force, contingents)としての性格を残すとみるべきであろうか。多くの学者は、加盟各国の提供する兵力で編成される国連軍は、加盟各国の国内軍隊であると説く。たしかに国連は、自ら超国家的な軍隊を保有するわけではなく、国連の強制行動に提供された軍隊は依然本国に所属するのであり、その意味では「国別部隊」としての国家軍的性格を失わない。このことは「国際連合加盟国の空軍、海軍、又は陸軍」(第42条)、「国内空軍割当部隊」(第45条)という憲章の文面からも窺える上、軍事参謀委員会の報告もこのことを認めている。この意味においては、国連の強制行動に参加する各国の兵力は依然として、派遣国の国別軍隊としての性格を残しているといわねばならない。</p>
<table class="caption-top table">
<colgroup>
<col style="width: 100%">
</colgroup>
<thead>
<tr class="header">
<th>軍事参謀委員会が安保理に提出した1947年4月30日付けの「国連加盟国が安保理の利用に供する兵力の組織」に関する報告書　（S/336）</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>第X章 軍隊の戦略的指揮及び命令 36　特別協定に規定される軍隊は、それぞれの貢献国の排他的な指揮下に留まるものとする。ただし、安全保障理事会の要請に応じて提供された場合、その権限の下で作戦する場合を除く。 37　これらの部隊が憲章第42条に規定する措置の履行のために要請された場合、それらは安全保障理事会の管理下に入るものとする。 39　国別派遣部隊の指揮は、それぞれの加盟国が任命する指揮官によって行使されるものとする。これらの派遣部隊は、その国家的性格を保持し、常に自国の国軍で施行されている規律及び規則に従うものとする。 41　(中国、ソビエト社会主義共和国連邦、アメリカ合衆国代表団が受諾した条文：) 安全保障理事会に提供された軍隊の総司令官は、これらの部隊が安全保障理事会によって使用される期間、軍事参謀委員会の助言に基づき、安全保障理事会によって任命され得る。 (フランス及び英国代表団が受諾した条文：) 安全保障理事会に提供された軍隊の最高司令官は、これらの部隊が安全保障理事会によって使用される期間、軍事参謀委員会の助言に基づき、安全保障理事会によって任命され得る。 上記の最高司令官の下で行動する陸、海、空の部隊の司令官は、軍事参謀委員会の助言に基づき、安全保障理事会によって任命され得る。 フロント和訳</td>
</tr>
</tbody>
</table>
<p>　（4）最後に、憲章第7章が規定した国連軍の主要部分は、まず、「安全保障理事会の常任理事国が提供し、その他の加盟国による兵力の提供は、これを補充するために行なわれる」ものとされた。憲章第7章の下での国連軍の編成が五大国の兵力を中心に行なわれることになったのは、その目的が侵略行為などの撃退、制圧であるから、国連軍は近代的な装備をもつ強大な兵力でなければならず、兵力の分担も主として大国の軍事力に依存しなければならない。したがって、国連軍の編成が五大国を中心に行なわれるよう了解されたのは当然であった。</p>
<table class="caption-top table">
<colgroup>
<col style="width: 100%">
</colgroup>
<thead>
<tr class="header">
<th>軍事参謀委員会が安保理に提出した1947年4月30日付けの「国連加盟国が安保理の利用に供する兵力の組織」に関する報告書　（S/336）</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>第IV章 加盟国による軍隊の提供 10　特別協定に従い、安全保障理事会の要請に応じて提供されるべき軍隊の早期設立を容易にするため、安全保障理事会の常任理事国は、当初、これらの軍隊の主要部分を拠出するものとする。国際連合の他の加盟国の拠出が利用可能になるにつれて、それらは既に拠出された軍隊に追加されるものとする。 フロント和訳</td>
</tr>
</tbody>
</table>
<p>　以上にみたように、国連憲章は一見して集団安全保障の機能を一層強化する規定を備えたといわれた。しかしながら、憲章の規定の方が規約のそれよりも強化されているとは必ずしもいえない。というのは、国連では、強制措置の発動は安全保障理事会の決議を媒介として、かつその統制の下においてのみ可能とする強制措置の集権化がはかられている。しかしその安全保障理事会での決議の採択は、常任理事国の全会一致が前提とされており、大国の不一致の結果、理事会での決議の採択が不可能であれば国連はまったく動きがとれなくなる。冷戦を背景とした大国間の対立の激化によって、安全保障理事会での決議の採択は極めて困難となり、国連の安全保障の機能は麻痺したのである。<br>
　国連憲章のもう1つの特色である、軍事的強制措置の制度的強化についても、それが現実となるには国連軍編成のための待機体制の成立が前提となるが、これは今日も実現をみていない。国連が、いかにして即応体制の確立に失敗したのか、については下のコラムに掲載している。</p>
<table class="caption-top table">
<colgroup>
<col style="width: 100%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">軍事制裁の組織化の失敗</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">　　安全保障理事会が国連軍を編成し使用するための即応体制ないし待機体制を整えるには、憲章第43条によって、兵力提供の約束が得られねばならないが、その特別協定を安全保障理事会が加盟国との間に締結するためには、その前提として、まず国連軍の全体の規模や分担、編成や指揮についての一般原則を策定しなければならない（憲章第47条）。そこで、五大国の代表で構成する軍事参謀委員会は、安全保障理事会の要請により1946年以来その作業に着手し、47年4月30日、安保理事会に中間報告書を提出した。この報告書は、「国連加盟国により安全保障理事会の利用に供される兵力の組織に関する一般原則」を、4ヵ条の条文のかたちで列挙している。そのうち、25カ条は委員会の全会一致で採択されたものであるが、残る16ヵ条については、完全な合意が得られず、これらの条文については対立する複数の案を並記するにとどまった。軍事参謀委員会で意見が対立した重要な点は次の通りである。 　①国連軍の総兵力量について、最も大規模な兵力を主張する米国の案と、比較的小規模で足りるとするソ連の案が対立し、英国、フランス、中国の三国はソ連案に同調した。 この兵力の規模に関する米ソ両案の相違は相対的なものではあったが、これは国連軍の使用目的についての両国の見解の対立を反映したものであった。ソ連は、国連の強制行動は五大国に向けて発動されないという前提から、国連軍の総兵力は比較的小規模で足りると主張した。 これに対し米国が、国連軍は世界のあらゆる部分での侵略行為に対処できる程度の最強の兵力である必要を強調した。国連の強制行動が五大国に向けられえないことは、米国自身、憲章の起草過程では認めていたのであり、国連の発足後に日を経ずして米国がこの前提を覆すかにみえる提案を行なったことは、米国の反ソ感情の表明としてソ連の疑惑を深めるに十分であった。他の3ヵ国がソ連案に同調したのは、自国の兵力分担能力の限界を考慮した結果であろうとされる。 Yearbook of the United Nations, 1947-48, p493-496 　②国連軍は五大国の提供する兵力を中心に編成されることに合意をみたが、この五大国間の兵力分担をめぐってソ連と他の西側4ヵ国との主張が対立した。ソ連は厳格な平等原則を掲げて、五大国がそれぞれ提供する兵力は、兵員、船舶、航空機の内訳につき数量、種類ともに同一内容であることを原則とし、特に例外を認めるには、安全保障理事会の許可を必要とすると主張した。 これに対し、米、英、仏、中の4ヵ国は、五大国の各々は総兵力においてほほ匹敵する軍隊を提供すればよく、その内訳は、陸、海、空軍につき、それぞれの国の現有兵力の相違を反映した異なる内容のもので足り、五大国は陸、海、空軍のうち最も提供に適した兵力を提供すべきであるという、一種の分業制度を認めようとするものであった。 　この対立は、国連軍全体の規模についての上述の対立とも関連をもつ。米国が主張するような大規模な国連軍を想定すれば分業の制度によらざるをえないし、反対にソ連の主張する平等原則を貫けば、必然として国連軍の規模は縮小する。しかしソ連が厳格な平等原則に固執したのは、より深い理由に根ざすものであった。国連軍の構成が西側の主張するような分業方式をとれば、海軍や空軍は、当時の五大国の兵力構成からみて主として西側の兵力で占められることになり、その結果国連軍は西側諸国がその重要な部分を牛耳ることになり、西側の政治的、軍事目的に国連軍が利用される恐れがあると危惧したのである。ソ連の西側に対するこのような懐疑的な姿勢はその他の点でも共通するものであった。 　③平時、国連に使用されていない間の各国軍隊の配置について、西側4ヵ国は、法的に認められるかぎりすべての国の領域に駐留できるとし、逆にソ連は、国連提供用の各国部隊は自国領域内にのみ留まるべきことを主張した。ソ連によれば、国連提供用の軍隊が平時において外国基地に駐留することを認められれば、それが対ソ戦略に利用される恐れがあったからである。 　④兵站面での分担について、米、英、中の3ヵ国は、国連に提供する部隊の装備、弾薬その他の軍需物資の調達につき、他国の援助を受けることを認めたのに対し、ソ連とフランスは、このような必要が生じた場合はその都度安全保障理事会の許可を必要とすると主張した(第29条)。 ある国が軍事面で外国へ依存することは、すなわちその国の政治的独立を害するという基本的立場からである。 　⑤国連軍の任務終了後の撤退の時期についても、西側4ヵ国は、撤退は可及的速やかに行なわれるべきものとして期限を特定しなかったのに対し、ソ連は国連軍部隊は任務終了後、安全保障理事会の別段の決定がないかぎり、30日ないし90日以内に自国の領域内に撤退しなければならないと厳格な条件をつけた(第20条)。これも外国軍隊の長期駐留はその国の独立を侵す恐れがあるとの危惧を表わしたものである。 軍事参謀委員会が安保理に提出した1947年4月30日付けの「国連加盟国が安保理の利用に供する兵力の組織」に関する報告書　（S/336） 第IV章 加盟国による軍隊の提供 11　　安全保障理事会の5つの常任理事国は、それぞれ、国際連合加盟国が安全保障理事会に提供する軍隊に対して、同等の初期の全体的貢献を行うものとする。各常任理事国の国軍の規模及び構成の違いを考慮し、また、作戦のために均衡のとれた効果的な戦闘部隊を構成する安全保障理事会の能力をさらに高めるため、これらの貢献は、陸、海、空の個別構成要素の兵力に関して大きく異なることがある。 (中、仏、英、米代表団が受諾した条文) 　安全保障理事会の常任理事国は、陸、海、空の軍隊を、これらの軍隊の総兵力及び構成に関する平等の原則に基づいて提供するものとする。個別の場合において、安全保障理事会の常任理事国がかかる希望を表明した場合には、安全保障理事会の特別の決定により、この原則からの逸脱が許される。 (ソ連代表団が受諾した条文) 第V章 軍隊の雇用 20　安全保障理事会に提供された軍隊（通信線部隊を含む）が、憲章第42条に基づき安全保障理事会から委託された任務を遂行した後、それらは、憲章第43条に規定する特別協定によって定められる全般的な配置場所に、できるだけ速やかに撤退するものとする。撤退の開始及び完了の時期は、安全保障理事会が定めるものとする。 （中、仏、英、米代表団が受諾した条文） 　軍隊は、憲章第42条に規定する措置を履行した後、安全保障理事会が別段の決定をしない限り、30日から90日以内の期限内に自国の領域及び領水に撤退するものとする。この期限は、憲章第43条に基づき締結される協定に規定されるべきである。 （ソ連代表団が受諾した条文） 21　何らかの理由で、これらの軍隊が、安全保障理事会と他の国際連合加盟国との間の協定に基づき、これらの軍隊の通過、駐留又は行動のために使用が許可された領域又は領水に留まる場合、それらは、安全保障理事会が別段の決定をしない限り、第20条に示された期間の満了後30日以内に、自国の領域又は領水に撤退すべきである。この期限は、憲章第43条に基づき締結される協定に規定されるべきである。 （中、仏、英、米代表団が受諾せず、ソ連代表団が受諾した条文） 第VIII章 軍隊の後方支援 29　特別協定に従い、憲章第42条に規定する措置の実施のため、安全保障理事会の要請に応じて軍隊をその自由に利用させた国際連合加盟国は、それぞれの人員及び装備におけるすべての必要な補充、並びにすべての必要な補給及び輸送を、各自の部隊に提供するものとする。 31　加盟国は、上記第29条に基づく責任を完全に履行できない場合、安全保障理事会の援助を求めることができ、安全保障理事会は、軍事参謀委員会の助言に基づき、必要と認める援助の提供について、他の適切な加盟国と交渉するものとする。ある加盟国の貢献における不足分を他の加盟国の貢献からの移転によって補う前に、関係加盟国の同意を安全保障理事会が得なければならない。 （中、英、米代表団が受諾した条文） 　上記第29条に述べられた原則からの逸脱は、加盟国の要請により、軍事参謀委員会の助言に基づき、安全保障理事会の特別の決定によって、個別の場合に許されるものとする。ただし、この加盟国が、この加盟国によって安全保障理事会の自由に利用させられた軍隊の適切な供給のために、補給及び輸送を自国に提供させることを希望する場合に限る。 （仏、ソ連代表団が受諾した条文） 第IX章 軍隊の配置 32　加盟国が安全保障理事会に提供した軍隊は、安全保障理事会によって使用されない場合、憲章第43条にいう特別協定の条項の範囲内で、加盟国が法的なアクセス権を有するいかなる領域又は水域においても、加盟国の裁量で基地を置くものとする。 （中、英、米代表団が受諾した条文） 　安全保障理事会によって使用されない場合、加盟国が安全保障理事会の要請に応じて提供することを約束する軍隊は、憲章第43条に基づき安全保障理事会と加盟国との間で締結された特別協定によって定められる全般的な場所に駐留する。 加盟国の国境内、又はその管轄下にある領域若しくは水域内。 又は、憲章第107条に基づき、若しくは平和条約の条項に基づき、旧敵国の領域又は水域内。 又は、国際連合事務局に登録され、憲章第102条に従って公表された国際協定に基づき軍隊がアクセス権を有する他の国の領域又は水域内。 又は、安全保障理事会によって指定され、憲章第82条及び第83条に基づき安全保障理事会と加盟国との間の特定の協定の対象となった特定の戦略地域内。 （仏代表団が受諾した条文） 　国際連合加盟国が安全保障理事会に提供する軍隊は、憲章第107条に規定する場合を除き、貢献する加盟国自身の領域又は領水の国境内に駐屯するものとする。 （ソ連代表団が受諾した条文） 　以上の対立点は、米ソの冷戦を背景とする大国間の不信感に根ざすものであったから、この不信感が除去されない限りにおいて妥協の余地はなかった。こうして冷戦の進行とともに、国連による軍事行動の組織化への努力は完全に行き詰まり、憲章第43条の特別協定の締結は不可能となった。1948年8月、軍事参謀委員会はこのことを確認する報告を安全保障理事会に行ない、委員会の審議そのものまで打ち切られることになった。その後、国連総会は安保理に対して、第43条の規定を実施する努力を払うよう要請する決議を採択した（「平和のための結集」決議）こともあったものの、行き詰まりは打開されず、特別協定は今なお締結されていない。こうして、国連は集団安全保障の中核をなす強制行動のための「国連軍」をもつことに失敗し、憲章第43条は死文と化したのである。</td>
</tr>
</tbody>
</table>
</section>
<section id="第3項-朝鮮戦争まだ" class="level3">
<h3 class="anchored" data-anchor-id="第3項-朝鮮戦争まだ">第3項　朝鮮戦争（まだ）</h3>
<p>　冷戦時代を通じて、ベトナム戦争を始めとする多くの武力紛争が、国連の外で処理され、憲章第七章の規定はほとんど援用されることがなかった。 経済制裁に関する第四一条が援用されたわずかのケースは、皮肉にも、加盟国による違法な武力行使に対してでなく、南アフリカ共和国やローデシアに対する制裁のように、一国の人種政策に向けられたものであった。<br>
　冷戦時代に、国連が平和の破壊行為に対する軍事強制措置を適用した唯一の例は、1950年6月に始まった朝鮮戦争であった。このとき、米国がただちに安保理事会を招集し、朝鮮民主主義人民共和国(北朝鮮) 当局を平和破壊者と認定し、大韓民国への武力攻撃を撃退する軍事行動を加盟国に勧告する決議を矢継ぎ早に採択できたのは、ソ連がたまたま理事会を欠席していたという偶然が幸いしたからである。安保理決議を受けて、米国を中心に編成された多国籍軍(15ヵ国で編成)は、「国連軍」と呼ばれ、国連旗を使用したが、軍事行動の統轄指揮は米国政府に委ねられ、作戦の指揮権は米国政府が任命した司令官が行使し、「国連軍」は国連の直接のコントロールに服さなかったのである。朝鮮戦争は、国連決議に基づく軍事行動であったが、事実上は米国を中心とする西側の軍隊と、ソ連の支援を受けた北朝鮮・中国軍との軍事対決であった。朝鮮戦争は、双方の側に厖大な犠牲をもたらし、一九五三年の休戦協定によりようやく終結をみた。</p>
<p>　拒否権が乱発された冷戦期を通して国際連合、とりわけ安保理が紛争解決に介在し得たのは、拒否権の行使が控えられるような比較的小規模な衝突、内乱などに起因したものに限られた。ただ、多くの場合において大紛争に発展する可能性やその時に大国の利害が強く関わる可能性を孕んでいたことから、安保理が強制的措置まで踏み込むことに成功した事例は多くは存在しない。<br>
　冷戦期において安保理決議に基づいた軍事行動が取られた例は、1950年の朝鮮戦争の際のたった一度のみである。1950年6月25日に朝鮮戦争が勃発すると、安保理はソ連が中国代表権問題をめぐって安保理をボイコットしているのをいいことに、直ちに「韓国に対する北朝鮮の武力攻撃が平和の破壊を構成する」と認定し（第39条が援用されているわけではない）、「武力攻撃を排除し、この地域内の国際平和及び安全を回復するために必要な援助を与えるよう加盟国に勧告」した。加盟国がこの決議に従って行動するか否かは各国の自由とされた。その結果、朝鮮に派兵した国は15カ国（いずれもアメリカの同盟国）にとどまり、兵力の90％以上はアメリカ軍と韓国軍となった。この決議に応じて提供され、統一司令部の下に置かれた支援の兵力に国連期の使用を許可したものの、統一司令部の司令官の任命もアメリカ大統領に一任され、国連による統制などは全く用意されていなかった。朝鮮戦争が明らかにしたことは、安保理は結局アメリカの軍事行動ないし西側の同盟行動に国際社会の共同行動という普遍性の外皮を与えただけだった、ということである。</p>
<table class="caption-top table">
<colgroup>
<col style="width: 100%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">「平和のための結集」決議</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">　朝鮮戦争に際して国連のとった行動は集団安全保障が理想的な形で発動したとはいいがたいものであったものの、まがいなりにも国連の旗の下に軍事的強制措置が行われたことは、集団安全保障に対する諸国家の期待をにわかに高めることになった。 　しかし偶然が重なったが故にこうした軍事的強制措置が叶ったことに疑いはなく、将来もこうした措置が繰り返される保証はなかった。そこで、朝鮮の場合にはいわば変則的に行われた強制行動を、規則的に発動できるように制度化する企てがなされた。1950年の秋、国連総会が採択したいわゆる「平和のための結集」決議（“Uniting for Peace” Resolution）（Res.377 (V)）がそれである。この決議は11月3日、米国のイニシアチブによって総会に提出され、賛成52カ国、反対5カ国、棄権2カ国（反対派ソ連圏諸国）に多数で採択された。総会決議377（V）の内容は多岐にわたるが、当面の軍事強制措置の発動についての制度化は次の3つの面でなされた。 　①安全保障理事会の機能が大国の拒否権により妨げられた場合、安保理から審議を総会に移し、総会が兵力の使用を含む集団的措置を直ちに勧告しうることを明確にする。 　②加盟国は安保理や総会による勧告があったとき、軍事強制措置のために直ちに提供できるよう、あらかじめ訓練され、組織され、かつ装備された舞台を自国軍隊内に維持するように要請する。 　③憲章第7章の軍事参謀委員会に代わる総会の補助機関として「集団的措置委員会」を設ける。 「平和のための結集」決議　（Res.377(V)) 前文（一部） 　安全保障理事会による国際の平和及び安全の維持のための第一義的責任の遂行の重要性と常任理事国が全員一致を希求し且つ拒否権の使用に当たって抑制を行う義務のあることを再確認し、 　憲章第43条に規定した軍隊のための協定を交渉する発意が、安全保障理事会に属することを再確認し、また、この協定の締結に至るまで国際連合が、国際の平和及び安全を維持する手段を任意に使用し得ることを確保することを希望し、 　安全保障理事会がその責任、特に前記2項に掲げられた責任を全ての加盟国に代わって遂行することに失敗することが、加盟国から自己の義務を解除せず、又、国際連合から国際の平和及び安全を維持するという憲章に基づくその責任を解除しないことを認識し、 　このような失敗が、総会からその権利を奪わないこと、また、憲章に基づく国際の平和及び安全の維持に関するその責任を総会から解除しないことを特に承認し、 　総会がこれらの点に関してその責任を遂行するためには、事実を確認し且つ侵略者を発見する観察の可能性と、集団的に使用し得る軍隊の存在と、総会が国際連合加盟国に対して効果的であるために迅速な集団的行動を時を移さず勧告できることが必要であることを承認し、 本文（一部） C節 7　国際連合の各加盟国に対して、国際の平和及び安全の回復のための安全保障理事会又は総会のいずれかの勧告を支持して行うことができる援助の性質及び範囲を決定するために自国の資源を調査するように勧誘する。 8　国際連合加盟国に対して、安全保障理事会又は総会の勧告があったときに国際連合部隊として勤務するように、各国の憲法上の手続に従ってすみやかに提供することができるように訓練され組織され且つ装備された部隊を各加盟国がその自国軍隊内に維持することを勧告する。この部隊は憲章第51条に認められた個別的又は集団的自衛権の行使に当って使用することを妨げない。 9　国際連合加盟国に対して、前項の実施に当って執った措置をできる限りすみやかに集団的措置委員会に通報することを勧誘する。 10　事務総長に対して、第8項に定めた部隊の国際連合部隊としての迅速な服務のための組織、訓練及び装備に関する技術的勧告を得ることを望む加盟国の要請に応じて提供することができるような軍事専門家の一隊を、第11項に定めた委員会の承認を得て、任命することを要請する。 D節 11　14加盟国、即ち、オーストラリア、ベルギー、ブラジル、ビルマ、カナダ、エジプト、フランス、メキシコ、フィリピン、トルコ、連合王国、アメリカ合衆国、ベネズエラ及びウルグアイの代表者から構成する集団的措置委員会を設立し、且つ、この委員会に対して、事務総長及び委員会が適当と認める加盟国と協議して、集団的自衛権及び地域的取極(憲章第51条及び第52条)を考慮に入れ憲章の目的及び原則に従って国際の平和及び安全を維持し強化するために使用されるこの決議のC節の方法を含む方法について研究し、且つ安全保障理事会及び総会に対して1951年9月1日以前に報告すべきことを命ずる。 12　全ての加盟国に対して、この委員会と協力し、且つこの委員会の任務の遂行に当たってこれを援助することを勧告する。 13　事務総長に対して、この決議のC及びD節に定めた目的を効果的に達成するための必要な職員及び便宜を提供するように要請する。 　とりわけ第2の点については、憲章第7章の下で企てられた国連軍編成の即応体制ないし復活の試みに他ならない。ただ異なる点としては、軍事強制措置の勧告が安保理のみならず総会によってもなされること、そして強制措置の即応体制が特別協定の締結という法的措置によるものではなく、加盟国がそれぞれ待機軍を設けることである。 　しかしながら、総会の大多数の賛成を得て採択されたこの決議は、その後の実行において、総会の下での集団安全保障機能の強化に導くには至らなかった。この決議の実施に任務を帯びて設置された集団的措置委員会が、加盟60ヵ国に対して決議C節8項の規定を具体化する措置について回答を求めたものの、国連に提供するための待機軍を自国内に維持することに積極的な回答を行ったのは、若干の小国に過ぎず、大部分の加盟国は明確な回答を避けたのである。決議の提案者であるアメリカも同様の態度であり、将来の国連のとる集団措置にアメリカの兵力を使用するかはその都度決定するとし、自国軍隊の一部を国連に留保する用意のない旨を婉曲に伝えたのである。 　そうして、その後の国連の実践においても「平和のための結集」決議の本来の狙いが活かされることはなかった。この決議が後の国家慣行で援用されたのは、安保理で大国の拒否権行使により決議の成立が妨げられたときに、直ちに緊急特別総会を招集するという手続き的な面に限られたのであり、総会が強制措置を発動するという実質的な側面は活用されることはなかった。</td>
</tr>
</tbody>
</table>
</section>
<section id="第4項-アジアアフリカ諸国の外交努力" class="level3">
<h3 class="anchored" data-anchor-id="第4項-アジアアフリカ諸国の外交努力">第4項　アジア・アフリカ諸国の外交努力</h3>
<p>　朝鮮戦争における国連の経験も踏まえ、冷戦期において国連が本来目指していたはずの集団安全保障システムが有効に機能しないことが明らかになったことから、1950年代後半以降、国連では平和を維持する為の新しいアプローチが模索される事となった。その担い手となったのが植民地支配を脱して続々と国連に加盟したアジア・アフリカ諸国であった。これらの諸国の多くはいずれの同盟にも属しない非同盟政策を取り、差し当たり東西陣営間の緊張緩和に努めながら、植民地支配や搾取、抑圧、貧困、差別など紛争の原因となるさまざまな不公正を解消することによって、公平な平和を実現しようとしたのである。武力の行使は良かれ悪しかれ一つの状態を力によって変更しようとする行為であるから、武力行使の禁止や集団安全保障システムは、場合によっては不公正に現状を温存することになる危険性を持っている。だが、植民地支配やその遺制、不平等な国際政治・経済体制に苦しむアジア・アフリカ諸国ないし発展途上国にとっては、現状を維持することではなくこうした不公正を解消することが平和の名に値するものであった。言い換えれば、平和とは維持するものではなく積極的に創造するものであって、紛争原因の除去によって平和を実現しようというこの新しいアプローチは、集団安全保障システムが機能しないための代替案という以上に、平和観念そのものの発展・進化という積極的な意味を持っていたのである。<br>
　民族自決権といったような権利が国際社会の認める原則として確立されるにしたがって、その権利行使としての武力行使が正当なものとして認めざるを得ない状況が生まれたことは、政治的価値規範の変化が戦争の違法性という一般原則に対する新たな例外事項を生み出したといえる。これは国際社会における正義が単に国家主権原則に沿ってのみ決定されるのではなく、国際社会全体の総意として正義が打ち立てられるからこそ可能になった事態である。正義観念の発展というのは冷戦期の国際社会において特徴的であり、これは民族自決権に限らず人権規範や人道規範の発展などにも代表される。国家主権の原則が国際社会の秩序を表現する原理だとしても、それが民族自決や人権規範のような正義の原理との関係で柔軟に理解されるように変化してきたことは、集団安全保障体制内に大きな変革がもたらされたことも意味したのである。<br>
　こうした平和観念の発展・進化を象徴する出来事として挙げられるのは、冷戦下においても成功した南ローデシアと南アフリカに対する強制措置の発動であった。1966年6月、安保理は南ローデシアにおける白人少数政権が一方的に独立を宣言した事態を平和に対する脅威と認定し、南ローデシアに対して非軍事的強制措置を発動した。1977年11月には、安保理はアパルトヘイト政策を行う南アフリカに対しても非軍事的措置を発動した。これらの例にあるように、一国内での組織的な人権侵害や自決権の否定を「平和に対する脅威」と認定することは、明らかに憲章起草時の想定を超えるものであった。こうした決議の採択の背景に国連総会決議に示された圧倒的な国際世論があったことを踏まえれば、これらの例は単なる例外ではなく国際社会における平和観念が発展したことの反映として扱うのが妥当であろう。</p>
</section>
<section id="第5項-平和維持活動の登場" class="level3">
<h3 class="anchored" data-anchor-id="第5項-平和維持活動の登場">第5項　平和維持活動の登場</h3>
<p>　平和の内実を問題とするこのアプローチはまた、強制措置の発動だけでなく、紛争の予防やその平和的解決を重視するアプローチでもあった。国際紛争の多くは、さまざまな政治的・経済的あるいは歴史的・民族的な文脈の中で発生し、従って紛争当事者の双方に何らかの責任があるのが通例であった。この点で大いに活用されるようになったのが、平和維持活動（以下、PKO）である。武力紛争の当事国間で停戦が合意されたのち、紛争地域に小規模・軽装備の国連軍を派遣して停戦の監視や武力衝突の再発防止にあたらせ、その間に当事国自身の手による紛争の平和的解決を促すというこの方式は、確かに集団安全保障体制が機能しないために急遽考案されたものであって、それ自身は紛争の平和的解決を保証するものでもなかったが、他方でそれは、当事者の主体性を尊重することによって、多様で複雑な国際紛争や国内紛争に対処しうる柔軟性を持っていたのである。かくしてこの方式は、スエズ動乱（第二次中東戦争）に続いてコンゴ、キプロスなど各地の紛争で活用され、武力紛争に対処するための主要な方策の一つと位置付けられるようになっていったのである。<br>
　国連の発足後、集団安全保障の制度が挫折したのと裏腹に、国連は多発する武力紛争に柔軟に対処するため、PKOと呼ばれる方式を編み出し、活用してきた。これは憲章の起草者が予期しなかった紛争処理方法であり、国連が実践面で適応能力を示した実例として、評価されている。<br>
　PKOとは、地域紛争の平和的収拾を図るために、国連が関係国の同意の下に一定の軍事組織を現地に派遣し、その中立的役割を通じて事態の悪化を防止し、紛争の平和的解決への素地を作る活動を言う。国連による軍事組織の現地プレゼンスの初期の例は、1948年のインドネシア独立戦争やパレスチナ戦争、カシミール紛争の際設置された停戦監視団に遡るが、これは小規模の組織にすぎなかった。これらの停戦監視団はもともと国連の補助機関として設立されたものではなく、停戦の実現や住民投票、調停活動のための各種委員会の補佐として派遣されたものであり、それが次第に増員されてまとまった規模として組織化されたことで停戦監視団という集団を形成するようになった。しかし依然として国連の軍隊というには規模が小さく、それ自体特に注目を惹く存在ではなかった。</p>
<table class="caption-top table">
<colgroup>
<col style="width: 100%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">リー事務総長による「国家警備隊（UN Guard Force）」の構想</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">　初期における国連の実践とならんで、結局は実現をみなかったが、リー (Trigve Lie) 初代国連事務総長が総会で行なった「国連警備隊」の提案も、先駆的な構想として言及するに値する。 　インドネシア、パレスチナ、カシミールの経験を通じて、たとえ小規模の軍隊類似の組織でも、国連の平和維持に役立ちうるとの認識が生まれた。そこでリー事務総長は、国連総会への年次報告(1947-48年度)の序文において、小規模な国連警備隊 (U.N. Guard Force) の創設に関する次のような見解を表明した。 　「私は、目下、小規模の『国連警備隊』の創設の提案について検討中である。この警備隊は、事務総長が採用し、安全保障理事会および総会の使用に委ねることができる。これは憲章第42条、43条に定める兵力の代用として使うものではない。それは戦争のための軍隊ではなく、純然たる警備隊であり、国連の監督下に実施される住民投票にさいして、また停戦条項の実施にさいして、国連から派遣された使節の警護にあたるために使用できる。またエルサレムやトリエステのような都市が国際制度の下に置かれるさいには、安全保障理事会と信託統治理事会の下で警察的任務に使用できる。さらに、安全保障理事会が平和を脅かす事態の悪化を防止するための暫定措置を定める憲章第40条の下でも要請されよう。」 　その後間もなく、パレスチナで国連調停官のベルナドッテ伯が殺害されるという不祥事が発生したため、事務総長は、1947年9月、国連総会において正式の提案を行なった。 　この提案によると、警備隊の規模は最終的には数千名となるが、当面は800名とし、その内300名は現役とし国連本部に常駐せしめて訓練をほどこし、残る500名を予備隊員として平素は本国に留めるというものであった。警備隊員は、総会の予算の承認を得て、国連憲章第97、98条、および第100、101条の下で、国連機関のために提供される事務局職員の一部とされた。 　警備隊の機能について、事務総長の説明によれば、警備隊は「完全に非軍事的」な性格をもち、「領域主権者の同意(明示または黙示)を得てのみ」 一国の領域内で使用されるものである。その装備は、護身用の武器、輸送、通信機器に限られる。 逮捕や暴動の鎮圧などの警察権はもたず、攻撃的にせよ、防衛的にせよ、軍事目的のために使用する武器も備えないというものであった。 　しかし、この提案に対する各国の反応は一様でなかった。ソ連圏諸国は、これが憲章違反であり、たとえ小規模でも、やがて兵員や戦力を増強されて帝国主義的目的に利用されることになる。憲章第43条以外の方法では、安全保障理事会は軍隊を保持できない、と主張して反対した。他の代表は、この種の警備隊の合憲性を争わなかったが、財政上の理由や、現地の軍隊との衝突の可能性などを問題にして、否定的であった。米国は、提案の内容については自らの立場を留保しながら、 特別委員会を設置して問題の検討を行なわせるという、多くの国の立場に与した。 　総会での各国の消極的ないし否定的な態度にかんがみ、事務総長は翌年、原案を大幅に修正した提案を再び総会に提出し、これが採択された。しかし、その結果採用されたものは、当初の構想から大きく後退した、小規模の現地勤務要員 (U.N. Field Service) および現地勤務予備要員名簿 (Field Reserve Panel) の制度となった。前者の現地勤務要員は、武器をもたず(護身用のものも含めて)、ニューヨークの国連本部警備員と同様な機能を果たすものである。すなわち、その任務は、現地派遣使節に輸送上、通信上の便宜をはかる純技術的役割と使節の身辺の警護に限られた。また後者は、各国政府が指名する現地勤務要員の名簿にすぎず、これは安全保障理事会と総会が現地の住民投票や停戦の監視にあたらせるために使用することを意図されたものであるが、実際に活用されることになったのは、前者のみであった。</td>
</tr>
</tbody>
</table>
<p>　PKOが独自の紛争処理方式として脚光を浴びるきっかけとなったのは、1956年のスエズ動乱に際して、「国連緊急軍」 (UNEF) という規模のより大きな軍事組織が派遣されてからである。スエズ動乱を平和的に収拾し、停戦の実現と外国軍隊のスエズからの撤退を確保するために、国連総会は国連軍の派遣を決め、事務総長にその計画案の作成を委ねたのである。</p>
<p>　スエズ動乱に際してハマーショルド事務総長が総会に提出した報告書において、後に「平和維持活動」と呼ばれるようになった、国連活動の基本原則の骨格が形成されたのである。このときハマーショルドが提出した報告書には、冷戦状況に変化が生じていたという背景があった。米ソ間の軍拡競争の行き過ぎに対する協調姿勢と、53年のスターリンの死後にソ連が打ち出した「平和共存」の理論によって、両国間の話し合いの雰囲気が醸成されていたのである。そして冷戦緩和の動きを背景に、国連が積極政策を打ち出す余裕が生まれていたのだ。国連はこの機会をとらえて、ハマーショルドが名付けた「防止外交（preventive diplomacy）」という新しい政策によって、平和維持機能回復に活路を見出した。それは「冷戦の雪解けの時代に国連は何をしうるのか」という問いに対する回答でもあった。対立する勢力陣営の接点に対し、冷戦の主要舞台として大国の利害が直接絡む地域での紛争に対しては、国連は効果的な役割を果たすことが期待できない。しかし大国の利害の接点を離れた周辺地域での局地的武力衝突や内戦も少なくなく、この地域では国連は紛争の拡大防止のためにイニシアチブをとることができると考えた。すなわち国連は「いずれかの勢力陣営に対しても中立的に立つ」国際機関を現地に介在させることにより、紛争を局地化させ、大国間の抗争に発展するのを防止できる、といったものが「防止外交」の目的であった。こうした防止外交の一環として現地に介入した国連軍や軍事監視団の諸活動がやがて「平和維持活動」の名で呼ばれるようになった。この用語が初めて国連の登場したのは、1960年の初頭、スエズや今後での国連軍活動がともに実施中の時期にあたり、この2つの活動を念頭に用いられた。スエズの国連緊急軍（UNEF）は、のちの平和維持活動と呼ばれるものの原型となった活動であり、コンゴでの国連活動（ONUC）はこのUNEFをモデルとして実施されたものであった。しかし両者は同じ平和維持活動とはいえど、多くの点において対照的であり、紛争の性格や国際環境も異なるために、一方で採用された基本原則を他方にそのまま適用することの困難さが実証されたのであり、また、両者それぞれに対する評価も著しく分かれた。UNEFが国連の可能性と適用能力という積極面を浮き彫りにしたのに対し、ONUCは逆に国連活動の限界を露呈したのである。</p>
<p>　それは、①国連軍を特定国家の政策から完全に独立させること(指揮系統の国際的性格)、②同様の趣旨から、また国連活動の中立性のために、派遣部隊の選定は、安保理常任理事国以外の加盟国から行なうこと、③国連軍の活動は関係国の同意を前提とすること、④国連軍の性格は特定の当事国に対する強制的なものではない。ハマーショルド事務総長が示しこのような構想は、朝鮮戦争に派遣された「国連軍」とは基本的に異なる、非強制・中立の性格を国連緊急軍に与えようとするものであった。<br>
　UNEFの創設がスエズ動乱を平和裏に収拾したことが、国連の可能性と適応能力という積極面を浮き彫りにしたのに対し、同じくPKOの創成期におけるコンゴでの国連活動は、逆に国連活動の限界を露呈したのである。1960年、ベルギーから独立したコンゴで発生した暴動に端を発する動乱に対して、国連はUNEF に倣った平和維持軍を導入したが、国連軍の任務には、ベルギー軍の撤退という国際的側面のほかに、混乱したコンゴの秩序回復という国内的側面があった。<br>
　中央政府の解体や外人傭兵に支えられたカタンガ州の分離問題に直面した国連軍は、内戦の渦中に巻き込まれ、やがて中立・非強制というUNEF の基本原則を棄て、自衛の範囲を超えて武力を行使するようになった。<br>
　しかし、コンゴにおける国連軍(ONUC)の行動は、大きな論議を呼び、各方面からの批判にさらされた。この苦い経験を経て、その後のPKOは、内戦への対応をも含めて、再びUNEFの基本原則に立ち返ることになった。こうして、冷戦時代の幾多の試練を経て、UNEF 原則はその重要性が確認され、PKOの伝統的基本原則として定着したのである。</p>
</section>
<section id="第6項-スエズ危機と国連軍unef" class="level3">
<h3 class="anchored" data-anchor-id="第6項-スエズ危機と国連軍unef">第6項　スエズ危機と国連軍（UNEF）</h3>
<p>　スエズ危機は1956年7月にエジプト政府が行ったスエズ運河会社の国有化措置に端を発する。スエズ運河の国有化宣言は国際的反響を呼び、運河の経営がエジプト当局の手に移ることは、運河を世界戦略の要としていた英仏両国にとって死活的な重大事となった。運河の経営が英仏に渡れば、自由通行は保証されず、エジプトが将来ソ連に接近することも考えられた。そうなれば西側世界にとっても打撃になると思われたのである。英米仏の三カ国はコンスタンティノープル条約で保障された運河の継続的運営を確保するための国際会議や10月13日の安保理での議論を経て、紛争解決に向けて明るい見通しが開かれたようであった。しかし英・仏・イスラエルの3国は同年10月23日に勃発していたハンガリー動乱に世界の耳目が注がれたのをチャンスとして、同日3国の首脳がひそかにフランスのセーブルに集まり共同軍事作戦計画の最後の詰めがなされた。<br>
　10月29日、イスラエル軍がシナイ半島への侵攻を開始したことで、戦争の火蓋が切られた。戦争計画を知らされていなかった米国は、すぐさま安保理の開催を要求し、イスラエルに対して撤退するよう要求する決議案を提出したが英仏による拒否権の行使によって葬られた。同様のソ連案決議も英仏によって葬られている。一方英仏は、エジプト・イスラエルに対して最後通牒を行ったことを安保理に報告した。その内容は、エジプト・イスラエルの両国に対し12時間以内に戦闘を停止して両国の軍隊をスエズ運河から10マイルの地点まで撤退することを求め、さもなければ英仏軍は運河地帯内に入り運河を占領するというものであった。<br>
　10月30日、英仏軍の爆撃機がエジプトの拠点に攻撃を開始、 空挺部隊がスエズ地帯に進攻し、3国は国連の介入前に既成事実を固めるための共同作戦を展開した。翌31日に再開された安全保障理事会では、スエズ紛争の審理総会に移す動きが現われた。理事会は、ユーゴスラビアの提案により、1950年11月3日に採択された「平和のための結集」決議377に定める手続きに従い、緊急特別総会を招集し、必要な勧告を行なわせる決議を採択した。11月1日に開催された第1回緊急特別総会では、3国のエジプトへの軍事介入を糾弾する発言が相つぎ、 米国も3国の行動を非難した。これに対し英国代表は、自国の措置はあくまで「警察行動」であり、朝鮮戦争の際に米国が安全保障理事会の決議に先立って米軍の出動を命じたのと同様の措置であるとする弁明をした。11月2日、総会は米国提案の停戦勧告決議案を採択した。 この決議997は、交戦当事者に対して、即時停戦と交戦地域への兵力導入の停止、1949年の休戦協定の遵守、および停戦成立後の運河の再開を勧告し、事務総長に対し決議の実施情況の報告を求めたものである。<br>
　ところで、総会での審議にさいして、決議を実効的なものとするには、ある種の国連プレゼンス(国連機関による現地介在)が必要であるという考えが浮上したのである。この種のプレゼンスとしては、UNTSOの監視体制の強化も考えられたが、これまでの経緯から、監視員の派遣は当面の紛争解決のためには期待薄であった。もう一つは、朝鮮戦争の経験に倣った国連軍編成の方法で、いち早く軍事行動をとった加盟国の軍隊に国連軍としての地位を与える考えである。この考えを最初に打ち出したのは、英国代表であった。英国のディクソン(Sir Pierson Dixson)代表は、11月1日の総会での演説で、要旨次のような発言を行なった。すなわち、英国代表によれば、スエズ危機で英仏両国の果たした役割は、朝鮮動乱の際にいち早く軍事介入した米国のそれに相当するのであって、国連は、英仏が果たした敵対兵力の引き離し、停戦、平和維持の任務を引き継げばよいのである。しかし、国連軍の設置、派遣には時間がかかる。それまでの間、スエズ運河地帯に駐留中の英仏軍に対して、国連軍の一翼として行動する権限を与えればよい。スエズ運河問題の解決までの間、国連の軍隊が運河地帯に駐留し、管理する考えは、戦争の敗者であるエジプト政府にとっても魅力的であろう。<br>
　このような立場から、英仏両国政府は、11月3日の国連事務総長宛の書簡で、スエズ地帯の軍事行動を停止する条件として次の3点をあげたのである。①エジプト・イスラエルの両国は、平和維持のために国連軍 (A United Nations Force) の受入れに同意すること、②国連は、国連軍の設立を決議し、アラブ、イスラエル間の和平が達成され、スエズ運河に関する満足の行く取極めにつき合意が得られるまで、現地に駐留させること、③国連軍の創設に至るまでの間、交戦者の双方は、限られた兵力の英仏軍部隊が直ちに交戦兵力の間に駐留することを認めること。このように、英仏の提案は、英仏の軍隊による現地での「警察行動」を国連軍に引き継がせるという内容のものであった。<br>
　一方、カナダは、英仏提案に呼応するかのように、国連平和軍の構想を独自に打ち出したのである。ピアソン(L. Peason) カナダ外相は、11月2日の総会決議997の採決の直後、同国がこの決議に棄権した理由説明のために発言し、この決議には、停戦や兵力の撤退を当事者に呼びかけるだけで、国連が中東和平の達成のためにとる具体的措置が欠けていると不満を述べ、そのような措置として、「紛争の政治的解決が達成されるまでの間、休戦境界線の平穏化をもたらすに十分な規模の国連軍の派遣方について、加盟国と取極めを開始する権限を事務総長に与える」趣旨の条項が、この決議に含まれるのが望ましく、カナダも、この種の「真に国際的な平和警察軍 (a truly international peace and police force)」 への参加の用意があると述べた。<br>
　ピアソン外相から、国連軍創設の構想について打診をうけたハマーショルド事務総長の反応は、はじめは消極的であった。しかし、ピアソン代表は事務総長を説得し、11月3日の夜、総会に次のような決議案を提出した。<br>
　「総会は、1956年11月2日の決議遵守の促進が緊急に必要であることを認識し、優先事項として、事務総長に対し、前記決議に述べられた停戦を確保し監督するために、緊急の国際国連軍 (an Emergency international United Nations Force) を設立する計画を、48時間以内に提出するよう要請する。」<br>
　カナダ案は、57対0、棄権19で可決され、決議998(ESII)となった。この間、スエズではイスラエル軍が運河の東岸を制圧、英仏の空艇部隊が運河地帯でエジプト軍と交戦し、これに対して、ソ連はエジプト支援のための軍事介入を示唆し、米国に対し対英仏の共同軍事行動への参加を呼びかけて、これがかえって米国の対ソ警戒心を誘い、事態は一刻の猶予も許されぬ情況となった。こうした緊迫した情勢の中で、事務総長は総会決議で要請された国連緊急軍設置計画の策定に着手し、翌5日に再開された総会に第一次報告書 (A/3289) を提出、 若干国と協議の結果、停戦監督の任にあたる緊急国際軍の編成のための国連軍司令部 (United Nations Comand) を直ちに設置すること、国連軍の将兵は五大国(安全保障理事会の常任理事国)以外の国から選ばれることが望ましい旨を報告した。<br>
　右の事務総長報告をうけて、11月5日の総会決議1000(ESII)は、国連軍司令部を設置し、軍司令官に国連停戦監視機関(UNTSO)の本部長バーンズ (E.Burns) 中将 (カナダ)を任命し、軍司令官に、国連司令部付き将校として、UNTSOの監視員若干名 (但し安全保障理事会の五常任理事国出身者を除く)を採用し、さらに事務総長と協議の上、五大国を除く加盟国からの将校を追加採用する権限を委ねた。<br>
　右の国連軍司令部設置の承認を、総会からひとまずとりつけた後、ハマーショルド事務総長は国連軍の性格や編成、機能に関する青写真の作成を、事務局のコーディエ (A. Cordier)、バンチ (R. Bunche) 両氏、および関係国と協議しながら行ない、翌6日には、国連緊急軍に関する第二次・最終報告書 (A/3302) が総会に提出され、総会は7日、この報告を承認する決議1001(ESII)を採択した。<br>
　事務総長の最終報告書は、総会決議から48時間以内という短時間に作成されたものであったが、そこには、後に「平和維持軍」と呼ばれるようになった国連軍の骨格を形成する重要な諸原則が、すでに示されている。以下にその骨子を列挙すると、<br>
　①国連軍司令部と軍司令官を総会が直接設置・任命することにより、国連軍は、指揮系統を通じて、総会または安全保障理事会の直接の統制の下に置かれることになった。この方式は、国連軍を特定国家の政策から完全に独立させるために望ましいことである。これにより、在韓国連軍のように、国連が特定の国家に統一指揮権を委ねる方式や、特定国の軍隊が担った役割を国連が引き継ぐ方式(英仏がさきに提案したもの)は、国連軍が特定の国家の政策に左右されることになるとして、いずれも排除されたのである。<br>
　②同様の趣旨から、国連軍の編成にあたり、軍司令部の構成員、および派遣部隊の選定は、安全保障理事会の常任理事国以外の加盟国の中から行なうことが、特定国の政策からの独立性ないし中立性の保持のために必要である。国際軍の派遣は、当面の紛争の軍事的バランスや紛争解決の政治的バランスに影響を与えることがあってはならない。<br>
　③国連軍の活動は、関係国の同意を前提としてのみ可能である。すなわち、その編成にあたっては、軍隊提供国の同意が必要であるだけでなく、その駐留と活動には、派遣先の国(受入れ国)の同意が得られなければならない。国連軍は特定の加盟国に向けられた強制行動の一環として機能するものではない。それはUNTSOの監視員以上のものであり、軍隊類似 (paramilitary) の性格をもつが、駐留地域を一時的に支配する軍隊ではない。<br>
　④国連軍の任務は、総会決議に基づく停戦が実施される間に、エジプト政府の同意を得てエジプト領内に駐留し、外国軍隊の撤退の間、およびその後の地域の平穏を保つことにあり、その活動地域は、スエズ運河地帯から休戦境界線に及ぶ。<br>
　⑤財政措置については、さらに検討を要するが、当面採用すべき方法は、派遣部隊の装備や隊員の給与は提供国が負担し、そのほかの一切の経費は、国連が通常予算の枠外で賄うことにする。<br>
　このように、スエズ危機にさいして国連総会で突如浮上した国連軍創設の構想は、英仏提案がそのきっかけとなったものではあったが、その後事務総長が策定し、総会が承認した国連軍設置計画は、英仏案とは根本的に異なる内容のものとなった。それは、スエズに介入した英仏軍の任務を国連が引き継ぐものではなく、また、国連活動が冷戦を背景とした米ソ超大国の政策からも完全に切り離された中立的、非強制的性格が強調されているのである。この点では事務総長の計画案は、カナダのピアソン外相が提案した国連軍の構想とも若干ニュアンスを異にし、UNEFの基本的性格は事務総長の独創性に負うところが大きいのである。<br>
　11月7日の総会決議1001は、国連緊急軍の編成、機能に関する事務総長提案に盛られた始動原則を承認するとともに、事務局長に対して、国連軍の編成作業を関係国及び国連軍司令官と協議して進めること、及び事務総長に国連軍規則を策定することを受験し、さらに諮問委員会を設置することを決定した。<br>
　総会からのこの幅広い授権に基づき、事務総長は軍の編成作業に着手した。国連軍司令官は、UNEFが任務を遂行するためには、全体の規模は二個旅団すなわち約6000名が必要であり、三カ国の提供する兵員の規模は大隊単位が望ましく、これに小規模の空軍部隊や支援部隊を含めることが必要と考えた。また、国連軍の国別、地域別構成がバランスを失わないよう配慮された。<br>
　総会決議に対して、国連軍に舞台の提供を申し出た国は24ヵ国にのぼったが、選定基準に基づき、結局受諾されたのは、ブラジル、カナダ、コロンビア、デンマーク、フィンランド、インド、インドネシア、ノルウェー、スウェーデン、ユーゴスラビアの10ヵ国であり、このうちカナダとインドが技術面での支援部隊を担当することとなった。<br>
　1956年11月4日から5日にかけて、交戦当事者により国連停戦決議の相次ぐ受諾により、スエズ運河地帯での停戦は11月7日に実現をみた。事務総長はUNEFの心中条件についてエジプト政府と交渉を重ねた結果、11月14日に正式の合意が得られ、翌日UNEFの第一陣が現地に到着、スエズ運河地域で英仏軍とエジプト軍の間に心中して緩衝的役割を果たした。英仏軍のスエズ地域からの撤退計画は円滑かつ平穏に行われ、12月22日に同軍は撤退を完了したが、尾之間UNEFは現地の警察当局と協力して治安維持に当たるほか、地雷原の撤去、停戦違反事件の調査、捕虜の交換、住民の生命と財産の保護などの役割を果たした。<br>
　一方、イスラエル軍のシナイ半島およびガザ地区からの撤退は順調には進まなかったものの、事務総長による粘り強い交渉を経て、57年の3月には完全撤退し、即時にUNEFが展開され、同様の任務に就いた。こうしてUNEFは1956年3月以降、エジプト・イスラエル間の休戦ラインの西側、およびシナイ半島のコック再国境線沿いのエジプト側（イスラエルはUNEFの自国領内への立ち入りを認めなかった）に展開し、監視所での監視及びパトロールを通じて、休戦協定順守の確保にあたり、67年5月にエジプト政府からの要請に基づいて撤退するまで、10年以上にわたり中東地域の安定と平穏化に大きな貢献を行ったのである。<br>
　1958年の10月9日、ハマーショルド事務総長は、「UNEFの設置及び活動に基づく経験の研究摘要（Summary study of the experience derived from the establishment and operation of the force）」と題する報告書を、第13回総会に提出した。のちに「研究摘要（Summary Study）」の略称で一般に知られるようになったこの事務総長の報告書は、7つの章から構成されている。その中でも特に肝要な部分が、「結論及び基本原則」と題する最後の章である。ここではUNEFについて採用された構造上、および機能上の諸原則で、将来も同様の活動が実施された場合に採用するに値すると思われるものが掲げられており、のちに「平和維持活動」と呼ばれるようになった国連活動の一般原則を列挙することが意図されていた。<br>
　ハマーショルド事務総長は、この種の国連活動の一般原則を示すことにより、将来において迅速かつ能率的に実施を可能にし、同時に加盟国がUNEF型の国連活動への参加に備えた待機態勢の国内法制化を行うことを期待して、これらの基本原則をそのための指針として役立てることを志向したのである。実際、「研究摘要」の中で掲げられた諸原則の多くは、その後の国連軍活動の実践において踏襲されることとなった。<br>
　なお、この報告書が対象としたのはＵＮＥＦだけではなく、58年からレバノンへ展開が行われていた国連監視団（ＵＮＯＧＩＬ）に関連して興味深い言及があった。それは、レバノンのような内戦の状況に対して国連がＵＮＥＦ型の国連軍を派遣すれば、国連軍は内戦に巻き込まれ、紛争の当事者となる恐れがあると警告し、国連の紛争への介入方法はそれぞれの状況に応じて、適宜判断しなければならないと述べているのである。こうした教訓とジレンマは、今後の国連を悩ませることとなる。</p>
<table class="caption-top table">
<colgroup>
<col style="width: 100%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">レバノン内戦</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">　1958年のレバノン内戦に対する国連の介入は、同年5月22日、レバノン政府が安保理の開催を要請し、「アラブ連合共和国のレバノン内政への干渉から生じる事態の審理」を求めたことに始まる。当時レバノンでは、シャムーン政権が大統領の再選を可能にするため憲法改正を企てたため、反政府運動が全土に波及し内戦状態に陥っていた。こうした中、レバノン政府はアラブ連合共和国を構成するシリアから反政府勢力に対して援助があり、国境を越えて大量の武器や武装兵力が導入されていると訴えたのである。 　レバノン問題を審理した安保理は、6月11日、決議128を採択し、「レバノンに対し国境を越えて兵力や武器その他の軍事資材の違法な導入が行われないことを確保するために、レバノンへ監視団を緊急に派遣することを決定し、事務総長に対して、監視団の派遣につき必要な措置をとる権限を与え、安保理に適宜報告することを要請」したのである。事務総長は安保理決議に基づき直ちに国連監視団（UNOGIL）の設置、派遣の実施に着手し、また自ら現地に赴き陣頭指揮にあたった。「監視団」自身は3名の少将から構成され、またこれらを補佐する軍事監視員としてUNTSOから将校若干名が配属され、ついで加盟国21カ国から軍事監視員として約100名が提供された。こうしてUNOGILはレバノン、シリア間の国境地帯での兵員、軍用資材の違法な越境の有無を確かめるため、地上でのパトロール及び監視所での監視活動に加え、偵察機及びヘリコプターによる空からの監視を行い、さらに本部（ベイルート）での情報収集活動と、審判の訴えに対する現地での査察・検証の任務に従事した。 　その後レバノンの要請に基づいて米国がレバノンへ派兵を行い、それをソ連が内政干渉だとして非難を行い、安保理は決議を採択できる状況ではなくなってしまった。その後事務総長のリーダーシップの発揮により、ＵＮＯＧＩＬは増強され活動を継続したものの、シャムーン大統領が再選を断念したことから事態は収束し、最終的には12月9日には撤退したのである。</td>
</tr>
</tbody>
</table>
<table class="caption-top table">
<thead>
<tr class="header">
<th style="text-align: left;">「研究摘要」の最後の章「結論及び基本原則」　Ａ/3943</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">151、154-192</td>
</tr>
</tbody>
</table>
<p>　</p>
</section>
<section id="第7項-コンゴ動乱と国連軍onuc" class="level3">
<h3 class="anchored" data-anchor-id="第7項-コンゴ動乱と国連軍onuc">第7項　コンゴ動乱と国連軍（ONUC）</h3>
<p>　1960年7月、独立を達成したばかりのコンゴ共和国（旧ベルギー領コンゴ）で暴動が発生し、ベルギー軍は自国民保護と現地の治安回復のために今後へ軍事介入を開始した。これがコンゴでの国連軍活動のきっかけとなった。1960年の反植民地運動の高まりの中、アフリカに16の新国家が誕生し、一挙に国連へ加盟するなか、ベルギー領コンゴにおいても独立が達成された。しかしその内実としては、とても独立の準備が整った状態とは言えず、ベルギー議会によって制定されたコンゴ憲法の下での独立とはいえ、内政が安定している状況ではなかった。<br>
　ハマーショルド事務総長は、アジア、アフリカにおける植民地制度の清算は、彼の唱える「防止外交」を適用する絶好の機会ととらえ、大国の介入およびそれに伴う抗争に巻き込まれる前に国連による独立後の国作りに国連の役割を求めたのである。事務総長は1959年12月から60年1月にかけてアフリカ24ヵ国を歴訪、とりわけベルギー領コンゴでは、事前の準備を欠くコンゴの独立がもたらす困難さをつぶさに見聞した。その結果、コンゴに対しては独立式典に派遣したバンチ事務総長特使を現地にとどめ、国連が今後に提供する各種の援助計画についてコンゴ政府との協議を行わせ、「国連プレゼンス」を通じて今後の危機に備えさせたのである。<br>
　ベルギー政府は、1960年6月29日にコンゴ政府との間に結んだ友好援助協力条約に基づき、コンゴ国内に駐留するベルギー軍を、法と秩序の維持のため出動する権利を認められていた。7月5日、コンゴ国軍内で兵士の将校への昇格要求に端を発する反乱が発生すると、ベルギー政府はコンゴ政府の要請なしに自国民の保護の名目でコンゴへ派兵を行った。一方で、コンゴ国内のカタンガ州では、7月11日、チョンベ暫定政府大統領がベルギー支援の下にカタンガ州の独立を宣言した。こうした情勢の中でコンゴ政府は、7月12日に国連事務総長へ電報を送り、ベルギー軍の侵略からコンゴの領土保全と独立を守るための軍事援助の要請を行ったのである。<br>
　コンゴ政府の要請に対し、事務総長は憲章第99条の権限に基づき安保理を収集し、安保理決議143を賛成8、反対0、棄権3で採択した。その内容は、ベルギー軍の撤退を求めるとともに、「コンゴ政府と協力しながら、同政府の努力と国連の技術援助を通じて、今後の保安部隊が充分に任務を遂行できるようになったど同政府が考えるまで、必要な軍事援助を与える権限を事務総長に与える」というものであった。これがコンゴでの国連活動を承認する安保理の基本決議であるが、UNEFの場合と異なるのは決議そのものは国連軍（ＯＮＵＣ）の設置、派遣について言及せず、「軍事援助」という抽象的な表現を用い、援助の内容を事務総長に一任する形をとったことである。そしてこの決議の一般・抽象的な授権内容は、のちにＯＮＵＣのマンデートをめぐる争いを生む原因となったのである。<br>
　ＯＮＵＣの任務は、コンゴでの国連活動を通じてベルギー軍隊の撤退を促進するというコンゴ機器の国際的側面では、ＵＮＥＦの役割と同様であり、実際事務総長は「研究摘要」に掲げられた原則を適用していた。安保理決議に基づくベルギー軍の撤退は晨朝に進められ、撤退後は国連部隊がこれにとって代わった。ただＯＮＵＣのマンデートには国内的側面も含まれていた。内戦下での今後国内法秩序の維持、回復というＵＮＥＦとは根本から異なる状況があったのである。こうした国内的要因ゆえに、ＯＮＵＣはＵＮＥＦの原則の適用を困難たらしめる状況に直面し、多くの試練にさらされることになったのである。こうした要因には、①憲政の危機と呼ばれるコンゴの中央政府内部での分裂と対立、②カタンガをはじめとするコンゴ諸州の分離独立運動が惹起した中央政府対地方政府間の対立、③コンゴ国民を構成する種族間の対立抗争などの各種の分裂的要素、などがあり、さらには国際的側面においても、これらの国内抗争の各派と結びついた外国勢力の対立抗争が顕在化し、これが安保理での大国の不一致をもたらし決議の執行したとしての事務総長を苦境に立たせたのである。<br>
　中央政府の崩壊および対立する国内政治勢力の内戦という混乱した状況に対する国連の基本方針は、1960年9月20日の緊急特別総会決議1474において示された。同決議はコンゴ国民に対し、憲政の危機の解消のために平和的手段による内戦の停止を呼びかけ、その努力を援助する協力機関として「調整委員会」の任命をコンゴ諮問委員会に要請するものであった。国連の立場としては、内政の危機は純然たるコンゴの国内問題であり、国連としては内政不介入・中立的立場を遵守し、その解決は武力の行使によらずあくまで仲介者、調停者としての役割に徹することにより、紛争の当事者となることを極力回避することにあった。<br>
　ＯＮＵＣは対立する国内の武装勢力の衝突を回避するための防止措置として緊張した地域に中立地帯を設置し、説得による内戦防止に努め、自衛以外の武力行使を極力避けるよう要請したのである。しかしながら、ＯＮＵＣが国内治安の維持回復という任務を武力の不行使と今後の国内問題への不介入義務、及び中立性の原則と矛盾することなく遂行することがいかに至難の業であるかは、すぐに明らかとなった。特に象徴的であった事件は、ＯＮＵＣが安全確保のために警備にあたっていたルムンバ前首相（国内の政治勢力のひとつの指導者）の保護に失敗し、他勢力に殺害されてしまったことであった。ルムンバの死は国際的に大きな反響を呼び、同氏を支持する諸国からは国連の消極的ないし傍観的態度に対する批判が高まり、一部のONUC参加国は派遣部隊を引き上げる措置をとった。またソ連は以降ハマーショルド氏の事務総長の地位を否認するという強硬な態度を打ち出したほどであった。<br>
　ルムンバ殺害という緊迫した状況の中で開催された安保理会議は61年2月21日、決議162を採択し、ONUCに対して内戦防止のための最後の手段として武力の行使を含む措置をとることを認め、さらに国連の統轄下にない外国軍事要員のコンゴからの撤退を求めた。この決議で認められた武力行使の範囲が、従来の自衛のための枠を超えるものであるのかどうかについて議論を呼んだ。コンゴ国内の対立する政治勢力は、この決議を国連による内戦の武力鎮圧の承認とみなし、ONUCに対する敵対的態度をとるにいたった。コンゴ国軍のONUCに対する敵対行動に対して、ONUCは限定的な武力の行使に踏み切らざるを得ず、期せずして内戦に巻き込まれてしまったのである。<br>
　なお、こうした内乱の中においてもコンゴの憲政の危機を解決するために設けられた国連調停委員会の努力により、政治的解決が促進され、61年7月22日に召集されたコンゴ議会による承認ももって、内政における危機は解決されたのであった。しかしそれでもカタンガ州の分離問題は残されていた。この問題には、単なる国内問題としてはすまされない外的要因が結びついていた。そして分離運動を推進する外的要素として、ベルギー系の鉱山会社がカタンガ州に君臨し、分離運動を財政面及び軍事面で支援しており、多くのベルギーの職業軍人や公務員がカタンガ当局の傭兵や政治顧問となって私的権益の擁護のためにカタンガに介入し分離運動の担い手となっていたのである。<br>
　そこでこれらの外的要素をカタンガから排除することが国連にとっての緊急の課題となった。1961年2月21日の安保理決議161は、「国連軍司令部の統轄下にない全てのベルギー人その他の外国国籍の軍人・準軍事要員や政治顧問、及び傭兵のコンゴからの即時撤退、退去のための措置」が急務であることを挙げた。これは今後問題に対する外部からの民間レベルでの排除を求めたものである。<br>
　カタンガ当局はこの安保理決議に強く反発し、その後も外国人傭兵の募集を続けるなど、一向に成果を上げることはなく、コンゴ政府は国連に対し援助を要請することとなった。この要請に基づき、ONUCはヨーロッパ人将校、傭兵の逮捕に乗り出し、同時に予防措置としてカタンガの警察隊の本部や放送局、郵便局などの拠点をＯＮＵＣの管理下に置いた。しかしこうした作戦の継続がカタンガ側の反抗を呼び、武力を伴う事態へと発展してしまったのである。最終的にこの作戦は失敗に終わり、ＯＮＵＣはカタンガ警察隊の攻撃にさらされ、防戦のやむなきに至ったのである。ＯＮＵＣのとった行動は、英、仏、ソ連の信頼を失わせ、その他の国連加盟国もカタンガ、および中央政府をそれぞれ支持する立場から国連非難を行ったほどであった。<br>
　国連はカタンガ問題について新たな手を打つ必要に迫られ、安保理は11月24日に決議169を採択した。この決議は、①カタンガ州当局が外部からの援助を受け、外人傭兵の力を借りて行う違法な分離活動を強く非難し、②国連軍やその隊員に向けられた武力攻撃を非難し、直ちに中止するよう求め、③事務総長に対して、安保理決議161に定める外国軍人、準軍事要員、傭兵、政治顧問の即時逮捕、抑留、移送のため、必要とあれば力の行使を含む積極的行動をとること、および外人要員のコンゴへの帰還と、武器とその他の軍用資材の搬入を阻止する行動をとることを認め、④加盟国に対し、武器その他の軍用資材の供給の停止を要請し、⑤コンゴ共和国に対する一切の分離行動は、コンゴ基本法と安保理決議に違反することを宣言し、カタンガの分離行動の即時中止を要請し、⑥中央政府を断固支持する、というものとなった。この決議に現れたカタンガ問題に関する国連の態度の変化は、大きなものであった。従来の国連はこの問題に対して中立、不介入の立場をとっており、それは同問題が今後の純然たる国内問題であるという理解によるものであったが、これを改め、カタンガ当局は実は外国分子の傀儡に過ぎず、この分離運動はこれらの外国分子による違法な介入によって実施されている、という理解になったことで、ＯＮＵＣの目的がこの外的要素の積極的な除去となったのである。<br>
　しかしこの決議はカタンガ側にとっては、国連からの新たな「宣戦布告」に他ならなかった。そしてカタンガ警察隊は国連側に攻撃を仕掛け、衝突が相次いだものの、ＯＮＵＣによる制圧が功を奏し、最終的にはカタンガ側が最終的に分離を断念したことで事態は収束をみたのである。<br>
　外国の軍事・準軍事要員と傭兵がカタンガから排除され、今後の独立と領土保全に対する外部からの脅威が存在しなくなったことをもって、コンゴ全土の法と秩序の維持・回復は一様の目的を達成し、64年6月30日にＯＮＵＣはコンゴからの撤退を完了した。</p>
<table class="caption-top table">
<colgroup>
<col style="width: 100%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">「ある種の経費事件」</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">　ここで取り上げるのは、スエズおよびコンゴにおける国連の平和維持活動の経費に関する、1962年の国際司法裁判所の勧告的意見である。UNEFおよびONUCは、国連の平和維持において画期的な企てとして注目されたが、その活動経費についてはいわゆる共同責任の原則に基づき、国連総会が数次にわたって加盟国に割り当てる決議を行ったにもかかわらず、分担金を滞納する国が続出し、国連の財政危機を招いた。これらの滞納国がその理由として挙げるところは、経済的、政治的あるいは国内憲法上の理由など様々であったものの、中には問題の経費につき、分担金の支払い義務を法的に否認する議論も少なくなかった。そこで第15回総会は1961年に15か国の作業委員会を設けて問題解決を図ったが結論に至らなかったため、ついに総会は12月20日、裁判所に勧告的意見を求める決議を採択し、「コンゴおよび中東における国連活動の財政に関して、加盟国が国連憲章の下で負う義務につき、権威ある法的指針を得る」ことにしたのである。この勧告的意見は、憲章17条2項の解釈のみならず、総会と安保理の権限関係、平和維持軍の憲章上の根拠、事務総長の権限の法的根拠を検討した点で注目される。 　裁判所が検討した同問題につき、とりわけ注目されるのは、UNEFとONUCの活動についての財政措置が合憲になされたのかどうかという点における勧告的意見である。国連の財政権は、総会の専属的権限に属するか、あるいは平和維持の機能分野ではこの権限は安保理に属するのか、という点が第一に問題とされた。UNEFとONUCの国連軍活動に対する財政措置はいずれも総会によってとられた。このことから、主としてソ連圏諸国は次のようにその合憲性を争った。ONUCやUNEFといった国連の平和維持に関する行動の経費に対する財政措置を決定する機関は、総会ではなく安保理である。憲章第7章は、43条において国連の軍事行動への参加方法および手段についての取極めを規定しており、この取極めの中には当然財政面での援助も含まれる。そしてこの問題の決定は安保理によってなされることになっている。これ故、2つの国連活動の経費の支出、割り当ての決議が総会によってなされたことは違法である、と主張したのである。 こうした主張に対して裁判所の多数意見は、①まず総会に対して一般的に財政権を与えている憲章第17条の規定は、第7章の規定によって制限を受けているか。換言すれば第43条の規定は、第17条の一般規定に対する特則を構成するか、②次にこの問題が当面の二つの国連軍活動とどのように関連するか、の2つの面から回答している。裁判所はまず②の点にふれ、2つの国連軍活動は、どちらも憲章第7章に基づく行動ではなかったことを明らかにし、したがって第43条の適用に関する問題は当面の国連軍活動とは関係がないと答えた後、①の回答を行った。ここにおいて裁判所は、2つの国連軍活動から離れて、一般論として第7章の強制行動の場合、はたしてその経費支払いのための財政的決定が総会ではなく安保理によってなされるのかの問題を、次のように回答した。 　①まず、ソ連圏諸国が援用する第43条をみると、この規定は安保理と各加盟国の間に結ばれる特別規定に関するもので、この規定において各加盟国が安保理に提供するそれぞれの「兵力、援助、便益」の内容を決めることになっているが、この中で安保理が将来とるべき国連の強制行動に参加することによって生じた費用の一部について、参加国が負担するという取極めがなされるとは限らず、場合によっては経費の一部についていわば共通経費の形で国連自身が負担することを佐々目ることもあり得るであろう。しかしこの場合、国連が負担することになった経費の部分は、とりもなおさず憲章17条2項にいう「この機構の経費」となるのであり、この経費を予算に計上し、加盟国に割り当てる期間は総会に他ならない。 　②もっとも、裁判所によれば第43条の特別協定の中で将来起こるべき国連の強制行動の費用の分担方法を事前に規定することは困難というよりお不可能に近く、実際にはこの種の問題はいざ強制行動がとられた際に初めて現実に生じるであろう。この場合を規定したのが憲章第50条の規定であって、この規定はある加盟国が強制的、帽子的措置への参加の結果、経済上財政上の困難な立場に立った時、この国に経済的、財政的な援助を与える趣旨の規定である。しかし、この規定についても結局のところ第43条と同じことが適用されるのであって、その救済方法としては、他の加盟国がここに財政的援助を行うほかに、国連自身が援助に乗り出すことを安保理が決定することも考えられる。しかしこの場合、国連の財政援助のための費用は、やはり「この機構の経費」として第17条の規定が適用され、加盟国に割り当てを行うのは総会である。要するに、たとえ第7章の下での強制措置がとられる場合を考えても、その経費については財政権を行使する国連の期間は総会であって安保理ではない。このように裁判所は結論付けたのである。 　総会の予算権が平和と安全の維持の分野にも及ぶことは、1950年に採択された「国連の財政規則」に基づき、事務総長が出した細則にも、「事務総長は、平和と安全のための緊急の必要のとき」総会に補正の経費見積もりを提出できる、と定めていることからも、以上の裁判所の意見は肯定できる。しかし、以上のことは“国連が負担することになった”経費についての話であり、これに先行して平和維持活動の費用の分担方法をどのようにするか、つまり国連の平和維持活動への参加国ないし特定の国家（利害関係国）が国連の枠外でここに負担することになるのか、あるいは国連自身が分担することになるのか、について決定する段階を含むものではない。ソ連による「第7章の下での国連行動の経費の分担方法は安保理が決定する」という主張は、まさにこの部分におけるものであった。そしてこの段階での決定については、裁判所は前述の第43条および第50条の規定の解釈に際して、少なくとも第7章の下でとられる強制行動の経費分担の決定は安保理によってなされることを認めたのである。平和維持活動における経費分担は、その決定を承認した機関がその基本決議の中で行えるのであって、安保理の下で実施される平和維持活動については、安保理が財政的決定を行うことができると解せる。</td>
</tr>
<tr class="even">
<td style="text-align: left;">　以上の財政措置の合憲性の問題とは別に、加盟国の分担義務を異なる角度から否定する議論として、憲章第17条の規定にいう「経費」、すなわち総会の割り当てによって分担義務の生じる経費の範囲を限定し、UNEFとONUCの経費は第17条2項にいう義務的な「経費」に該当せず、したがって総会のとった財政措置は加盟国を拘束する性格を持たないとする主張がある。こうした主張において、それに至る論拠を異にする2つの見解があるため、別個に取り扱う。 　①第7章の強制行動の経費は第17条の適用が排除される、という論拠。こうした主張は上記の合憲性の問題における議論と平行するものであり、ソ連圏諸国の立場である。第17条2項にいう経費とは、国連の通常予算に含まれる通常経費であり、平和と安全の維持のための国連行動に使用される経費はこれを性格を異にし、この経費の支払い方法は憲章7章の手続き方法によらねばならないと主張した。 　これに対する裁判所の意見は先に述べたとおりである。その趣旨としては、①UNEFとONUCの活動は第7章下での強制行動ではなく、したがって第43条などの規定は関係がないこと、②たとえ強制行動の場合であったとしても、第43条や第50条の下での経費分担の取極めのうち、国連が自ら負担することになった部分については第17条に基づいて国連の経費として計上される。これは加盟国に割り当てる経費であり、結局第7章の規定は第17条の適用を排除するものではない、というものであった。 　②第17条の義務的「経費」の範囲を狭く解釈する立場。この主張を最もはっきり打ち出しているのはフランスである。フランスが裁判所に提出した簡潔な陳述書の基本的な態度は、憲章規定の解釈にあたり、加盟国の主権の制限は推定されてはならない、というものである。加盟国は明治に規定された以上の義務を国際機構に対して負われず、財政面でも第17条の下で総会が加盟国を構想区する経費分担の決定を行いうる範囲は、行政経費に限られ、それ以外の活動経費は国連の発足以来特別の財政的扱いを受け、これらは自発的な拠出金によって賄われてきたとして、UNEFやONUCについても総会決議によってその経費支払い方法は通常予算外の特別会計によるものとして扱われた事実からも、これが第17条2項の経費の枠外のもので系譜分担は非拘束的かつ自発的な性格を持つことが明らかであると、主張したのである。 　さらにフランスは、もし第17条2項の義務的経費の範囲を拡大解釈した場合に、いかに不当な結果を招くかについて、次の点を指摘した。すなわち国連活動の基礎となった決議の大部分は勧告的なものであり加盟国はこれに参加する義務を負わない。ところがその国連活動から生じる経費を賄うための財政決議によって加盟国が拘束されるとすれば、加盟国はもともと参加義務のない決議から少なくとも財政面での参加の義務を負わされることになる。要するに、総会はどのような勧告的決議に対しても財政的意味付けを加えることにより、加盟国に義務を課すことが可能となり、このことは総会をして財政的なりっほう機関たらしめ、ひいては国連に超国家的性格を与えることになると、「経費」の範囲を大きく解釈することの危険性を訴えたのである。 　ただし、裁判所によれば、「この機構の経費」がすべて加盟国に必ずしも義務的に割り当てられるということはないという。経費をどのような方法で、どのような財源から充当させるかは別個の問題であり、これにはさまざまな方法が考えられるとする。総会は経費を通常予算の分担率にしたがって加盟国に割り当てることも可能であるし、特定の分担率によることも可能である。あるいは自発的拠出金によって賄われる特別会計を採用する方法も可能である上、これらの混合方式も考えられるが、このように国連の経費をどのような方法で賄うかは単なる会計上の便宜に過ぎず、この方法から何らかの法的意味を引き出すことはできない。総会が加盟国に対して経費の分担を割り当てる権限を所有していることに変わりはないとして、裁判所はUNEFとONUCの経費が特別会計によったことを盾にその拘束性を否定するフランスの立場を退けたのである。　最終的に裁判所は、UNEFとONUCの活動が、①国連の目的の範囲内での活動であること、②その経費分担に関わる総会決議も、これが第17条2項の意味での「経費」であることを認めていることから、結局両活動の経費は第17条2項のいう経費であるとの結論を導き出した。なお、経費の拘束性から導かれる、義務の強制を懸念としたフランスの提起による問題点については、裁判所は何ら分析を行わなかった。だが、UNEFおよびONUCの両者は総会および安保理の補助機関とされたことに鑑みれば、補助機関の設置に関する国連決議がいわゆる国連の内部組織行政に関し拘束力のある決定となることからして、両者の活動のために生じる経費について総会は加盟国に義務的な割り当てを行いうるとみることが妥当であろう。</td>
</tr>
</tbody>
</table>
</section>
<section id="第8項-平和維持活動の動揺と同意原則の再検討" class="level3">
<h3 class="anchored" data-anchor-id="第8項-平和維持活動の動揺と同意原則の再検討">第8項　平和維持活動の動揺と同意原則の再検討</h3>
<p>　ONUCはUNEFをモデルとしてこれをコンゴ紛争に適用することを企てたものの、国内問題とりわけカタンガ州問題でつまづき、ONUCの活動は各方面からの批判にさらされるとともに、UNEFの基本原則および「研究摘要」における原則をも重大な試練に突き付けたのである。さらにコンゴ紛争は国連に重大な財政危機をもたらし、国際司法裁判所に勧告的意見を仰いだにもかかわらず事態が改善することはなく、加盟国による平和維持活動の経費の滞納はついに第19回総会において憲章第19条の制裁規定の適用の問題に発展したのである。こうした混乱を経て、第19回総会は1965年2月18日の決議2006で問題打開のために33カ国からなる「平和維持活動特別委員会」（以下、PKO特別委員会）を設置し、「平和維持活動のあらゆる面の包括的再検討」を行うこととなった。PKO特別委員会の議論については、第10項にて解説している。</p>
</section>
<section id="第9項-中東における平和維持活動の復活書くか未定" class="level3">
<h3 class="anchored" data-anchor-id="第9項-中東における平和維持活動の復活書くか未定">第9項　中東における平和維持活動の復活（書くか未定）</h3>
</section>
<section id="第10項-平和維持活動の基本的課題と特別委員会の議論" class="level3">
<h3 class="anchored" data-anchor-id="第10項-平和維持活動の基本的課題と特別委員会の議論">第10項　平和維持活動の基本的課題と特別委員会の議論</h3>
<p>　国連の平和維持活動は、国連憲章上本来予定された制度ではなく、国連の実践上の必要から慣行上発展したものである。そのため、この種の国連活動のために「ガイドライン」を用意する必要性が、早くから指摘されてきた。<br>
　ここで「ガイドライン」(指針、指導原則と訳される)というのは、国連の内部機関の運用上の内部規範、または加盟国のための行動上の準則をいう。この種のガイドラインは、ふつう国連総会の決議のかたちで、あるいは事務総長の報告として採択されるのであって、その法的性質からみれば、国連憲章や、国連の下で締結される国際条約とは、次元を異にすることは当然である。にも関わらず、国際機構が採択する各種のガイドラインには、機構の運用上、また構成国の行動を律する規範として、無視することのできない重要性をもったものも少なくない。<br>
　平和維持活動においては、将来に備えてあらかじめ基本原則を用意することにより、国連の軍隊や監視団が迅速・ 能率的に創設、派遣できるようにして、国連活動に安定した基礎を与えることが目的とされた。たとえば、1974年に第29回国連総会が採択した決議が、「国連の平和維持活動を律する合意されたガイドラインを作ることにより、将来の平和維持活動が効果的に運用されるようにし、もって国連の平和維持機能の強化をはかることの必要性」を謳っている。<br>
　第2の目的として、ガイドラインの設定は、国連加盟国が将来の平和維持活動への参加の可能性に備えて、自国内にあらかじめ待機体制を整えるためにも、望ましいことであると考えられた。1958年にハマーショルド事務総長が総会に提出した報告書「研究摘要」の中で、国連緊急軍等の経験から引き出した諸原則を掲げているのは、とくにこのことを念頭に置いたもので、将来のこの型の国連活動のために加盟国が待機体制を整えるための指針として役立てることが、意図されたのである。<br>
　実際には、これまで国連の下での平和維持活動のガイドライン作りは、2つの面で行なわれてきたといえる。その第1は、1965年の国連総会決議に基づいて設置された「PKO特別委員会」が、付託された任務の一環として行なってきた「平和維持活動のための合意されたガイドライン」の策定作業である。もう1つは、いわば実践上のガイドラインであって、これまで現実に実施された、いくつかの平和維持活動を規律するガイドライン、ないしは指導原則として定められたものである。後者は、特定の平和維持活動のために個別的に作られた、アドホックな性格の基本原則であり、前者が将来の国連活動のために策定した一般的・恒久的ガイドラインである。もっとも、アドホックな指導原則も将来の先例となる可能性をもつことを考えると、決して無視することはできない。<br>
　PKO特別委員会は、1965年2月18日、第19回国連総会決議によって設置された。この委員会が設立される動機となったのは、スエズ(UNEF)およびコンゴ(ONUC)の両国連平和維持活動の経費支払いについて、若干の国連加盟国による分担金の支払い拒否または滞納によって生じた国連の財政危機、およびそれがもたらした国連憲章第19条の制裁規定の適用をめぐる第19回総会の混乱を収拾することであった。そのために、33カ国からなる特別委員会を設け、これに「平和維持活動の経費の支払方法を含め、平和維持活動のあらゆる分野におけるあらゆる問題を包括的に再検討する」任務を与えたのである。<br>
　PKO特別委員会は、総会から付託された任務を果たすため、1968年、安保理事会の4常任理事国を含む8カ国からなる作業部会 (Working Group)を設置した。この作業部会は、作業計画の第一段階として、まず「安全保障理事会の決議により設置または承認された国連の軍事監視員の研究」を「第一モデル」と決定し、 ①監視団の規模と装備、その採用と構成、便益と役務、財政問題、②監視員と受入れ国の関係、③監視員の地位、特権・免除、任務の期限と終了、の諸点について研究することとし、次の段階としてより大規模な平和維持活動を扱う「第二モデル」の作成を予定したのである。<br>
　平和維持活動の研究を2つの段階に分けて進めることにしたのは、まず比較的問題の少ない軍事監視団の研究から始め、次いで国別部隊で構成する平和維持軍の研究に移るのが良いと考えられたからであり、また研究対象を「安全保障理事会の決議に基づいて設置または承認された」平和維持活動に限定したのは、設置機関である総会と安全保障理事会との権限をめぐる基本的な対立を回避しようとする、妥協的な意図によるものであった。しかし、このような慎重な作業計画にも関わらずPKO特別委員会の仕事は第一段階で早くも行き詰まることになった。<br>
　1968年、作業部会は、事務総長に対して①安保理事会やPKO特別委員会で表明された軍事監視団に関する各国の見解の一覧、②軍事監視団の実例(設立・承認手続、組織、規模、機能、受入れ国との関係の諸項目を含む)に関する文献資料を作成、提出させ、これを参考にして「第一モデル」の研究草案の作成に着手した。同年9月にPKO特別委員会に提出した第1回報告書によると、第一モデルの内容は、第1章「設立の承認」、第2章 「構造(編成、規模、構成、指揮)」、第3章「法的取極め(国連と受入れ国、参加国間の協定を含む)」、第4章「財政的取極め」、第5章 「軍事監視団の組織、展開、機能」、第6章 「活動の手続き」、第7章 「装備、便益、役務」、第8章「行政事務」の8章からなり、このうち5つの章についてはテキストが完成したが、残る3つの章、すなわち構造、指揮、統轄に関する第2章、法的取極めに関する第3章、財政的取極めに関する第4章については、合意が得られずテキストは未完のままとなった。1970、71年の両年にわたり、第一モデルの完成のための努力が続けられたが、前述の3つの章につき進展はなく、とくに第2章の監視団の構造、指揮、統轄をめぐる基本的な対立が、作業の進展をはばむ最大の要因であった。　しかし、1970年代に入ってから、 PKO特別委員会には行き詰まり打開のための新たな動きが現われた。71年、第26回国連総会は「加盟国に対してPKO特別委員会の作業に有益と見られる意見や提案を委員会に提出することを求める」と同時に、「国連憲章に則り国連の平和維持活動の実効性を高めるための合意されたガイドラインを作成することの重要性を強調し、このためにPKO特別委員会が作業を促進することを要請」する決議を採択した。 これは、総会が、進展のみられない軍事監視団に関する第一モデルの作成作業に見切りをつけ、「平和維持活動の合意されたガイドラインの策定」に新たな活路を見出そうとする意思表示であった。<br>
　国連総会からの新たな要請をうけて、PKO特別委員会は「国連平和維持活動のための合意ガイドライン」の策定に着手した。73年秋の第4次中東戦争にさいして、第2次国連緊急軍(UNEFI)、国連兵力引離し監視軍(UNDOF)が相次いで設置され、中東に国連平和維持活動が復活したことがガイドライン策定の作業にはずみをかけることになった。作業部会(72年に13カ国に拡大)は、総会からの要請に応えて加盟国から提出された各種の提案や見解を踏まえて合意ガイドラインの作成を行ない、74年には、ガイドライン条項案 (draft formulae) を盛った第3次報告書をPKO特別委員会に提出した。 この条項案は、第29回総会に提出されたPKO特別委員会の報告書の付属文書として、総会で審議された。<br>
　「ガイドライン条項案」と呼ばれる作業文書の内容は、13ヵ条からなり、第1条は、平和維持活動に対して安保理事会が直接行使する権限の事項を列挙する。 第2条から第5条までは、平和維持活動に関する安保理事会の権限の委任に関するもので、理事会の補助機関の新設、軍事参謀委員会の討議への兵力提供国の参加の可能性を定める。 第6条は、事務総長の役割、第7条は、安保理事会に対する事務総長および補助機関からの報告義務を定める。 第8条は、軍司令官の任命手続について、第9条は、平和維持活動の前提となる諸原則(これはUNEFIの経験から採用したもの)が掲げられ、第10条では、平和維持軍の構成および衡平な地理的代表制の考慮に言及し、第11条は、平和維持活動の経費の支払方式、第12条は、即応体制のための安保理事会による兵力提供の協定や取極めについて、第13条は、国連軍の現地における特権免除について、それぞれ定めている。<br>
　もっとも、この作業文書のテキストは、確定した条項案とはほど遠く、合意が得られないままいくつかの対案を併記した、カギ弧つきの条文が多く含まれていた。この対立点を減らし、合意のはばをいかに広げるかが、その後の作業部会およびPKO特別委員会の課題となり、70年代を通じてそのための努力に傾注された。1977年末に作業部会が提出した第11次報告書は、その後に進展をみた合意ガイドライン条項案が含まれており、このテキストがPKO特別委員会の総会に提出した報告書に添付されている。第11次案の全文を訳出したものを、以下に掲げる。</p>
<table class="caption-top table">
<colgroup>
<col style="width: 100%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">国連平和維持活動のための合意ガイドラインの条項案　（A/32/394, AnnexⅡ Appendix Ⅰ, 2 Dec 1977）</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">12条は絶対</td>
</tr>
</tbody>
</table>
<p>　しかしこのテキストは、作業部会における歩み寄りの限界を示すものであった。軍事監視団に関する第一モデルの場合と同様、事務総長と安保理事会の役割の配分、財政支弁方式、即応体制の取極め等の基本問題について対立を打開することは困難であり、数次にわたる総会によるガイドラインの完成の要請にもかかわらず、その後のPKO特別委員会の活動は不活発となり、80年代に入ってからは、委員会ではほとんど実質的な討議も行なわれない情況となった。そして、一般的ガイドラインを作成する必要性を疑問視する見解も目立つようになったのである。<br>
　以上のような、PKO特別委員会による平和維持活動のガイドライン策定作業の経過は、かつて、国連の発足当初、軍事参謀委員会が企てた国連軍の組織に関する一般原則の作成計画がたどった運命を想い起こさせる。五大国の代表で構成する軍事参謀委員会は、安保理事会の要請により1946年以来そのための討議を重ね、47年に中間報告を理事会に提出したが、この報告書は、41カ条の条文中、一16カ条について一致が得られず、対立した対案が併記されていた。そして、この対立点を打開する努力も、48年には早くも放棄された。<br>
　軍事参謀委員会での審理を行き詰まらせた最大の理由は、憲章第7章に規定する強制行動のための国連軍が、大国間の冷戦の下で、敵対する陣営の政治目的のために利用されることへの警戒心、不信感に基づくものであった。同様の警戒心、不信感は、平和維持活動のガイドラインを策定する討議においても、一部の国によって表明された。そして軍事参謀委員会と同様、PKO特別委員会もこの不信感に基づく対立を打開することはできなかったのである。<br>
　このように、PKO特別委員会による平和維持活動のガイドライン作成作業も成功したわけではないものの、救いとなっているのはPKO特別委員会の手による一般的ガイドライン策定作業とは別に、実践面で平和維持活動の実績の積み重ねがあり、その中で指導原則が現実に採用されている点である。しかし、総じていえば、「ガイドライン条項案」の内容と、実践面で採用された指導原則とを比較すると、両者の間には、かなりのギャップが存在する。実践面で採用されたアドホックな指導原則の内容の変遷をたどると、「研究摘要」で掲げられた諸原則の基本的な部分は、今日もなお引き継がれ、定着していることが分かる。このことは、「研究摘要」に盛られたガイドラインの合理性とハマーショルド事務総長の洞察力を示すと同時に、アドホックな性格の指導原則も一度採用されれば先例としての重みをもち、将来に受け継がれる傾向が強いことを示している。<br>
　実践面で採用され、継承された諸原則をみると、それらはバラバラな内容のものではなく、相互に関連づけられ、平和維持活動の基本的な性格を表わす3本の柱を形成していることが分かる。その3つの柱とは、第1に非強制的性格、第2に中立的性格、第3に国際的性格である。<br>
　第1の非強制的性格を形成する指導原則として、国連軍の派遣・駐留・撤退の基礎をなす同意原則、現地活動を律する武器の使用の制限、内政干渉の諸原則があげられる。これらは、いずれも第7章の型の国連軍とは相容れない性格のものである。第2の中立性を支える指導原則には、国連軍構成国の選定基準としての利害関係国の排除、現地活動で紛争当事者に対する中立・公正な態度の要請がある。これらも、強制行動とは全く原理を異にする諸原則である。さらに第3の国際的性格に属するものとして、平和維持軍が国連の一機関とされ、指揮系統を通じて国連の直接の統制下に立つこと、軍の構成基準としての公平な地理的代表制の考慮の要請、国連軍構成員の国連への忠誠義務、各種の特権免除、経費支弁に関する共同責任の原則等があり、これらは、平和維持活動の国際性(国連機関的性格)の反映にほかならない。また国連事務総長に与えられた統轄面での重要な役割も、平和維持活動の中立性および国際性を高める要素となっている。<br>
　なお、PKO特別委員会の「ガイドライン条項案」をみると、実践面で形成された諸原則のうち、重要な地位を占める同意原則、武力行使の制限、中立性の諸原則については、「条項案」の中ではごく簡単に扱われるか、全く言及もされていない。「条項案」で最も大きな比重を占め、詳細に定められているのは、統轄と指揮に関する諸規定であり、13ヵ条の条項中、実に7カ条は、平和維持活動に対する国連機関の権限の配分に関するものである。このことは、委員会での最大の関心がどこにあったかを物語っている。<br>
　ただ、委員会での一般的ガイドライン策定段階でみられた非妥協的態度は、特定の平和維持活動を実施するにあたって、アドホックな指導原則の採用の妨げとはならなかった。 個別的な問題処理の段階では、各国は原則にとらわれず柔軟な姿勢をとり、事務総長の権限や経費支払方式などについて現実的な対応を行なったのである。このことは、たとえ一般的ガイドラインの成文化に失敗しても、実践面の指導原則はなお定着し将来に適用される可能性をもつことを示している。「ガイドライン」は、本来適用の柔軟性をもつ点に特色があり、その成文化がかえって原則の硬直化をもたらす危険性も考えられるのである。</p>
<table class="caption-top table">
<colgroup>
<col style="width: 100%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">平和維持活動の国連憲章上の根拠について</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">国連の平和維持活動は、国連憲章で本来予定されていたものではなく、国連の実践を通じて慣行上形成されてきた制度である。したがって、この慣行上の制度と国連憲章との関係が早くから問題にされてきた。 　平和維持活動の根拠を国連憲章の特定の条文に求める方法については、学者により、憲章中のさまざまな条文が採用されているものの、これらを仔細に調べると、国連が平和維持活動を組織するための根拠規定としては、いずれも十分とはいえない。その内容が一般的、抽象的であるか、適切でないもの、平和維持活動との関連が間接的にすぎないもの、規定の内容と平和維持活動の基本原則との不調和など、種々の問題があり、いずれも規定の弾力的ないし拡張的解釈なしには、平和維持活動と結びつけることが困難である。そこで、平和維持活動は、全体的にみて、憲章上これを予定した明文の規定を欠くとの結論に達せざるをえない。しかし、もともと平和維持活動は憲章の起草者が予想しなかった制度であるから、このような結論はむしろ当然であろう。 　しかし、憲章に明文の規定を欠くことは、決して、平和維持活動が憲章上の根拠をもたないという意味ではない。これを補完するために一般的理論を援用することが可能である。そのような解釈理論としては、「黙示的権能」の理論と、「後に生じた慣行」の理論があり、前者は、平和維持活動につき憲章に明文の規定を欠く場合でも、国連は目的達成に必要な権能を黙示的に与えられているという理論であり、後者は、本来的にそのような権能をもたずとも、国連は発足後の実行の積み重ねによって、平和維持活動を組織し使用する権能を取得するにいたったとする理論である。この二つの理論に共通するのは、国連機関によってとられる解釈は加盟国の「一般的な容認」を得なければ拘束性をもたないという要件を満たさねばならないことであるが、幸い今日においては平和維持活動そのものの合憲性を争う国は事実上存在せず、したがっていずれの理論をとっても、平和維持活動を組織する国連の権能を導くことが可能である。 　ちなみに、国連事務局が作成したPKOの解説書、The Blue Helmets, A Review of U. N. Peace-keeping(1985) (邦訳「ブルーヘルメット 国連軍・平和への闘い」)では、総論の部分で、平和維持活動の法的基礎は憲章の第六章と第七章の間に求められるとしながら、他方では、「第40条に基礎を置くと考えられる」と説明していた(同書7頁)。ところが、1990年の改訂版(この改訂は、とくに第44回国連総会決議 (A/44/49) の要請に基づいて事務総長の下で行なわれた)では、この総論の部分は全面的に書き改められている。すなわち、ここでは、もはや第40条への言及はみられず、平和維持活動の法的根拠を憲章の特定の条文によって十分説明することは困難であるとし、強制行動を定めた第7章の諸規定でなく、また第6章の外交的諸手段を越えたもの、すなわち第6章と第7章の中間(第6章半)に位置づけられるとした上で、「最近では、その法的根拠は、同意原則のほか、憲章が国連とくに安全保障理事会に付与した幅広い権能の中に求められることにコンセンサスに近いものが形成されている」と述べている(同書第2版5頁)。</td>
</tr>
</tbody>
</table>
</section>
<section id="第11項-冷戦期における国連待機軍の議論" class="level3">
<h3 class="anchored" data-anchor-id="第11項-冷戦期における国連待機軍の議論">第11項　冷戦期における「国連待機軍」の議論</h3>
<p>　平和維持活動についての議論において、その運用につき残されている根本的な問題が、平和維持活動への加盟国の参加の問題である。種々の原則を基礎とし、アド・ホックに編成、派遣されるという慣行が成立した冷戦期の平和維持活動が、能率的かつ迅速にその活動を実施するために、いかにすれば必要な兵員や各種の要員を確保できるのか、という問題であり、そのために特に注目されたのが、一部の加盟国で実施されている「国連待機軍」の制度である。<br>
　国連待機軍（U.N. stand-by force）とは、国連の平和維持活動への使用ために各国があらかじめ自国内に指定（earmark）し、国連からの要請があれば直ちに出動できるように準備した軍隊のことである。待機軍は一部の加盟国により実施されているもの、または計画されている国内制度自体を指すものとして広く用いられているが、こうした企てそのものは決して新しいものではない。<br>
　最初の企てとしては、安保理による軍事参謀委員会においての憲章第43条の特別協定の策定作業として行われた。憲章第7章の下で行う軍事的強制行動に使用するために予定された「国連軍」創設の構想は、待機軍の制度と同質的である。憲章起草の初期の段階では、より進んだ提案として「国連常備軍ないし常設軍 (a standing, permanent force)」 を設ける案が登場したことがある。これは国連自身が常にその指揮下に置く軍隊を保有しようとする考えであるが、しかし結局国連憲章の下で採用されたのは、必要あるごとに加盟国の提供する部隊で編成されるアドホック型の国連軍であった。ただそのかわり、憲章の起草者は、国連軍が有事の際にいつでも編成できるよう、事前の待機体制 (stand-by arrangement) を整えることを怠らなかった。憲章第43条の規定がそれであって、安全保障理事会は加盟国とあらかじめ協定を結んで、各国が提供する兵力、援助、便宜の内容を取り極め、とくに兵力の数や種類、出動準備程度や配置について定めることを規定した。 この制度の下で、加盟国は協定に定められた範囲で、自国内に国連用に指定した一種の待機軍を用意することになっていたのである。ところが軍事参謀委員会では、大国間の対立から見解が分かれ、間もなく特別協定締結の企ては放棄されて第43条の規定も空文と化したのであり、これは第1 or 2項でみたとおりである。<br>
　その後、第2の待機軍設置の企てが国連総会の下でなされた。1950年に採択した「平和のための結集」決議の中で、国連総会は、「加盟国が安全保障理事会または総会の勧告に基づき、憲法上の手続に従って、国連部隊として使用するために、直ちに間に合うよう、訓練、編成、装備をほどこした部隊を各国軍隊内に維持することを勧告」したのである。しかしこのたびも、総会の呼びかけは、加盟国一般の冷たい反応のために実を結ばず、やがてこの計画は沙汰やみとなってしまった。<br>
　このように、国連の歴史において、待機軍設置計画は、安全保障理事会と総会によってそれぞれ試みられ、いずれも失敗に終っている。ところが、1960年代に入ると、国連加盟国の中に、「国連待機軍」と称して自国内に国連用の部隊を指定する措置をとる国が次々に現われ、世の関心を集めるようになった。そこで最近では、「国連待機軍」という言葉は、これら一部の加盟国による自発的な国内措置をさすものとして、ひろく用いられている。<br>
　こうした国連の外でなされる待機軍設置の動きがきっかけとなって、国連の内部でもこの問題を取り上げて検討しようとする動きがようやく現われた。たとえば、ウ・タント事務総長は、1967年の国連総会に提出した年次報告の序文において、次のような提案を行なっている。<br>
　「…………こうした不安定な情勢の中で、一部の加盟国が国連の平和維持活動にそなえて、国連に使用できるよう、自国の軍隊を待機軍に指定する決定を行なったことは歓迎すべきことである。こうした前向きの行動がとられたのを機会に、せめて国連総会が次のような問題について検討を行なうよう加盟国の合意が得られれば幸いである。その問題というのは、待機軍の訓練や装備を規格化すること、待機軍を提供する国と国連との関係や、待機軍の使用によって生じる憲章上、および財政上の諸問題などである。この問題の検討は、特別に任命された委員会によって行なうこともできるし、あるいは事務総長自身が必要な授権を得て研究を行なうことも可能であろう･･････」。<br>
　また国連総会もこの問題の検討に関する決議を採択した。第5回特別総会は1967年5月23日の決議の中で、PKO特別委員会に対して「国連平和維持活動のために、憲章に従って、加盟国が自発的に提供する便益、役務、および人員」について研究を進めることを要請し、さらに第22回総会は、同年12月13日の決議において、PKO特別委員会が右の決議に掲げた問題の研究を行なうことが適当であると認め、研究の進捗情況を総会に報告するよう求めた。PKO特別委員会は、1968年の初めからこの問題の審理を開始し、同委員会には、国連待機軍を設置した諸国を含む関係国からの研究資料が提出された。<br>
　このようにして、国連は過去二度にわたって企てられ、いずれも実現をみなかった待機軍制度の問題を、三度取り上げることになったわけである。ただ、このたびの待機軍計画が過去の2つの例と異なる点は、計画のイニシャティブがまず加盟国によってとられたことである。このような、各国の制度設計を起点として構想される国連待機軍の起源は、1956年のスエズ動乱にまで遡る。この緊迫した世界的危機を乗り切るために、国連緊急総会がいわば応急的に編成、派遣した国連緊急軍(UNEF)が事態の収拾に成果をあげ、平和維持の新方式として一躍世界の脚光をあびるにいたった。その半面、いわば泥縄式に急設された国連軍をめぐって生じた種々の混乱や不便、不備が指摘され、これを克服して将来同種の国連活動を迅速・ 能率的に行なえるよう、事前の対策を講じる必要性が説かれるようになったのであった。<br>
　こうした動きの口火を切ったのは、カナダのピアソン外相である。UNEF創設の立役者と知られる彼は、早くも1957年にピアソン・プランと呼ばれる提案を行なった。彼は、関係国の同意を前提とする国連の諸活動がさらに恒常的な基礎の上に実施される必要があり、このために、UNEFの経験に学んで将来この種の事態に対処できるよう一層の準備を行なわなければならないと説き、国連用待機軍の考えを明らかにした。カナダはその後間もなく、カナダ軍の一部を国連用に指定する措置をとったのである。<br>
　一方、スカンジナビア諸国も、1958年のスウェーデン、デンマーク、ノルウェー三国の外相会議でこの問題を取り上げ、アドホックな軍隊にかわる、より常設的な国連軍設置の可能性についての検討を行なった。しかし、これら北欧諸国が待機軍創設に踏みきる決定的なきっかけを与えたのは、1958年の秋、ハマーショルド国連事務総長が第13回国連総会に提出した報告書「国連緊急軍の設置と活動に基づく経験の研究摘要」であった。<br>
　「研究摘要」の中で事務総長は国連軍の常設化の問題にも言及している。事務総長によれば、UNEF型の国連活動は、将来予想される多様な紛争や事態に即応して編成や規模を弾力的に決めねばならず、この意味で、国連が固定的な常設軍 (a permanent force) を設けることは賛成できないと述べ、むしろそれにかわる措置として、UNEFの経験から導き出した諸原則を前提として、各国が国連との間に待機のための取極め(stand-by arrangement) を行なうことが望ましいと述べている。<br>
　第13回総会は、結局この報告について特別の措置をとることなく終わったが、しかしハマーショルド事務総長はこの提案を具体化する望みを棄てなかった。 そして翌59年6月12日、彼はUNEFに軍隊を派遣した諸国に対し書簡を送り、「研究摘要」の中で彼が行なった提案について各国の意向を打診し、とくに北欧諸国に対してはこの問題について関係国の間で非公式な協議を行なうことを希望したのである。<br>
　そして1960年9月14日にストックホルムで開かれたスウェーデン、デンマーク、ノルウェーの3カ国による国防相会議で、この問題がはじめて議題にのぼり、将来国連の要請に応えて、北欧諸国が速やかに対処できるための事前の措置について討議した。 その後1961年から63年にかけての相次ぐ国防相会議を経て、北欧待機軍を創設する構想が次第にかたちを整えたのである。この間、設置されるべき北欧待機軍の内容について、国連事務局との連絡がとられた。1963年末、フィンランドもこの企てに参加し、準備段階を終えた北欧4カ国は、64年の春に国連待機軍設置のための国内法上の手続きをそれぞれ踏んだのである。<br>
　その後、北欧やカナダのとったイニシアチブに伴って、他のいくつかの国がこれに続いた。オーストリアやオランダが待機軍設置の措置をとり、また英国やニュージーランドなど待機軍設置計画を公表した国も少なくなかった。</p>
<table class="caption-top table">
<colgroup>
<col style="width: 50%">
<col style="width: 50%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">各国の待機軍制度</th>
<th style="text-align: left;">特色</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">北欧型 （北欧4国）</td>
<td style="text-align: left;">・待機軍はすべて志願制によって構成され、国防を目的とする国防軍と組織面や運用面、採用面で区別されている（待機軍への勤務を命ぜられた現役将校などを除く）。 ・隊員は書面で政府と契約を結び、正式に待機兵として採用される。契約期間中、隊員は訓練期間を除いて休みとなるが、数日の予告でいつでも国連のために勤務に就けるよう待機していなければならない。 ・隊員の訓練は義務的であり、国や要員によって異なるものの2週間〜5週間に及ぶ。 ・待機軍の設置はこれにより国連への利用が自動的になされるというわけではない。事務総長からの要請に応じて、その都度政府が諸般の事情を考慮したうえで態度を決定する。 ・デンマークには憲兵隊員のための北欧合同訓練コースが設置されており、北欧以外にもオーストリアやアイルランド、イギリスからの要員も受け入れている。 ・ノルウェーには移動管制員用の北欧合同訓練センターが、スウェーデンには本部将校や監視員用の訓練センターが設置されている。</td>
</tr>
<tr class="even">
<td style="text-align: left;">北欧型 （オーストリア）</td>
<td style="text-align: left;">・待機軍の隊員の採用は志願制となっており、連邦軍の現役の大隊が国連大隊として参加することは不可能となっている。隊員の採用にあたっては、連邦軍の兵力とくに幹部の削減を防ぐために、予備役出身の割合が半数近くなるようになっている。 ・隊員は訓練のために年間4日間召集され、出発の際の2週間は集結編成期間としてより具体的な教育を受ける。また若干名の将校がスウェーデンの合同訓練コースに参加しており、北欧待機軍との連携を図っている。 ・派遣の決定が、要請のたびに都度行われる点は他の諸国と変わらないが、その手続きとしては連邦議会の再興委員会との協議を経る必要がある。 ・オーストリアは永世中立国であり、実際の派遣にあたって国連と結ばれる協定においては永世中立の地位に合致させるための厳しい条件がつけられる。なおこの点については、スウェーデンとフィンランドも同様である。</td>
</tr>
<tr class="odd">
<td style="text-align: left;">カナダ型 （カナダ）</td>
<td style="text-align: left;">・カナダが平和維持活動への参加にあたり最も重視した点は、融通性と機動性であった。様々な形態を持つ平和維持活動に柔軟に対応できるよう、平素の準備に弾力性を持たせることと、緊急事態に迅速に対処して変員を現地に送ることである。したがって、カナダ待機軍は国連専用部隊を設けて隊員を志願性により採用する方法ではなく、カナダ国防軍の正規部隊の一部を国連用に指定し、特別の訓練を施す方式をとっている。 ・カナダが国連待機軍に指定しているのは陸軍に限られ、地上部隊をローテーション方式で選抜し、待機させている。待機大隊に指定された部隊は、2ヶ月から6ヶ月にわたり、空輸の面と平和維持活動の両面で集中的な訓練を行う。なお、空軍と海軍については、平和維持活動のための専用の訓練が必要ないとの考えから、待機させることはしていない。 ・カナダは国連からの要請があった際は、国防大臣と外務大臣がこの問題を閣議にかけ、閣議の決定に基づき政令が出される。その政令ではカナダ部隊の兵力の限度が定められ、10日以内の議会承認を求めるのが慣例となっている。</td>
</tr>
<tr class="even">
<td style="text-align: left;">カナダ型 （オランダ）</td>
<td style="text-align: left;">・オランダの待機軍は、カナダの例に倣って正規軍の一部を国連用に指定する方式になっている。その使用目的は平和維持活動であるものの、この部隊は正規軍の一部であるために、同時にオランダの国防目的にも使用可能であり、この点はカナダも共通している。 ・平和維持活動のために指定されるオランダの部隊は正規軍であり、志願制ではない（徴兵に際して待機軍に指定された舞台に編入される場合は、そのものの希望に沿うこと原則）。そしてその待機軍は通常の訓練のほかに、平和維持活動に備えた特別の訓練・教育を受ける。また、他の待機軍設置国との連携の姿勢をとっているが、北欧諸国よりもカナダとの協調を強めている。 ・国連からの要請がある時、オランダ政府は平和維持活動への参加の是非を独自に決定する。</td>
</tr>
</tbody>
</table>
<p>　一口に「国連待機軍」といっても、その内容は極めて多様である。国連事務局に設置計画を通告した諸国についてみても、単なる監視員のための将校若干名を指定し、待機せしめたもの(イタリアなど)、警察官のみの派遣を考慮している国(ニュージーランド)、あるいは大国としての立場から平和維持活動への兵站・補給の面での協力を内容とするもの(イギリス) なども含まれている。<br>
　これに対し、北欧やカナダを中心とする7つの国は、「待機軍」の名にふさわしい規模と編成内容をもち、歩兵大隊を中核とする点で共通している。しかしこれら7つの国についても、その内容を検討すると、そこには北欧型とカナダ型という2つの異なる種類のものがみられる。カナダやオランダでは、自国の国防軍の一部を待機軍に指定し、必要な装備や編成替えを行なうにすぎないのに対し、北欧4国やオーストリアでは、国防軍とは別個に隊員は志願制により採用される国連専用の待機軍が設けられている(もっとも、隊員の大部分は兵役義務の完了者または完了予定者であり、通常の軍事訓練の経験者である)。<br>
　これら2つの型の待機軍制度はそれぞれに特色がある。待機軍と国防軍との関係についてみると、カナダ型の場合には待機軍に指定された部隊は、国連待機軍であると同時に国防軍をも兼ねるという二重の性格をもち、それ故に待機部隊は国連の任務とともに国防目的にも使用することが可能である。<br>
　一方、待機軍制度の目的である国連平和維持活動への参加の迅速性と能率性という角度からみるとき、現役の国防軍であるカナダ型の待機軍は常時出動可能な体制にある。これに対し、北欧型の場合は待機軍といっても平素は訓練期間を除いて実在せぬ予備軍であり、これが編成されるのは現実に国連への派遣が決定されたのちである。この点、カナダ型の待機軍に比べて、待機軍の編成、派遣に若干の遅れが生じることが考えられる。<br>
　なお、経費の負担については各国は共通の立場である。待機軍の自国領土内での維持、訓練に関する経費はすべて自国の負担とし、平和維持活動への参加によって生じた特別の支出は国連に請求するという建て前をとっている。もっとも国連による兵力提供国に対する経費の償還は滞りがちであるが、この問題の処理は派遣国と国連との間に結ばれる協定の中でなされることになる。<br>
　もっとも、これら各国の制度はアドホックに行われる平和維持活動をより常設的な基礎の上に置き、将来の国連活動に一層の計画性と迅速性を与えようとする努力の一環として設けられたものである。したがって各国の制度は、平和維持活動の基本原則をそのまま前提として採用しているのであって、待機軍の制度は基本的に平和維持活動の諸原則の適用に何らの変更をも加えるものとして設計されていない。もともとは憲章第7章に定める武力行使を目的とすること、紛争当事国の同意を必要としないこと、中立の姿勢を崩すことは想定していないのである。<br>
　また、国連待機軍の制度に対しては、それが国連の平和維持機能の強化の方策としては最善のものでなく、さらに一歩進めて、国連常備軍の創設が望ましいとの主張もある。待機軍の制度は、加盟国の提供した国別部隊 (national contingents) を構成単位とするから、「国連軍」といってもそこには「国家」軍としての要素が含まれており、そのために国連軍の編成と使用にさいして種々の厄介な問題が生じることは避けられない。<br>
　国連軍の派遣に先立つ兵力提供国の選択の問題(大国や利害関係国の排除、地理的考慮等)、派遣後に生じる派遣国と国連との関係をめぐる問題(指揮、規律、裁判管轄権、軍隊引揚げ権、経費分担等の問題) などがそれであり、待機軍制度につきまとう面倒な問題は、国連が個人の志願者を隊員に採用して編成した国連常備軍の創設によって解決できるという考えも存在する。<br>
　国連が当面する課題は、現在一部の国によって採用されている「待機軍」の全てを一層促進するために、国連自身がどのようなかたちで取り上げ、その制度化をはかるかである。こうした国連待機制度に関連した議論は冷戦終焉後も続けられた。この続きは次節で引き続き参照されたい。</p>
</section>
<section id="第12項-第3節のむすびに" class="level3">
<h3 class="anchored" data-anchor-id="第12項-第3節のむすびに">第12項　第3節のむすびに</h3>
<p>　結果的に言えば、平和維持活動に代表されるような平和の内実を問題の対象とするアプローチは、冷戦時において紛争の終局的解決を実現する成果をほとんどあげることはなかった。だがそれにもかかわらず、冷戦という巨大構造の渦中に置かれた国連にとって、集団安全保障の限界や欠陥を補う貴重な視点と可能性を含むものではあったはずである。国際社会における保守的、あるいは消極的ともいえる秩序原理が、武力行使禁止原則に裏付けられた国家主権原則に依拠したものであるとすれば、冷戦期に発展した国際社会における革新的、あるいは積極的な秩序原理は、民族自決や人権規範、人道規範などの倫理価値規範に訴えた正義であろう。第2次世界大戦の経験を踏まえて作られた国連憲章が維持しようとした「平和」は、消極的なものであり、戦争の除去であった。戦争に対応する武力行使は認められるというのは、戦争の違法性に依拠する思考形態であり、憲章第7章はこうした秩序維持の観点から「（消極的な）平和」の名において定められた。しかし冷戦期を通して秩序維持の正義と倫理的正義は、国際的価値規範体系の中で並列的な関係へと変化したのであり、冷戦の終結がこうした「（積極的な）平和」概念を憲章第7章への挿入し、安保理が国際社会の秩序維持の要請と正義追求の要請の両立を行えるようになることが期待されたのである。<br>
　ところが、いわゆる冷戦終結後の国連は、こうした視点を引き継いだものの、実行レベルにおいて失敗をもたらすことが多かった。以下にあげるポスト冷戦期の国連の実行における強制行動の連発は、一見したところ集団安全保障システムの再生＝国連の平和維持機能の強化であるように見える。だが実際のところ、湾岸戦争では国連の介在が事実上拒否された多国籍軍を編成し、テロ活動を理由としてリビアに経済制裁を発動、ソマリアや旧ユーゴ、ルワンダでは難民・避難民の保護や人道援助活動の安全確保のために武力行使を認め、ハイチでは選挙で選ばれた民主的政権を復権させるために武力行使を許可するなどしたことで、かえって事態を悪化あるいは混乱させ、国連の権威を失墜させた例も少なくない。もちろん対照的にカンボジアなど比較的成功に終わったといえる国連の介入事例も存在する。<br>
　ポスト冷戦期の国連の実行が、憲章規定や集団安全保障の原理とその発展過程をどれほどまでに反映して実行されていたのか、そしてそれが紛争解決にどれほど寄与したのか、あるいはしなかったのか、について次節では振り返ることで、「平和への課題：補遺」に現れる問題意識とその本質により迫りたい。</p>
</section>
</section>
<section id="第4節-ポスト冷戦期の国連の集団安全保障体制" class="level2">
<h2 class="anchored" data-anchor-id="第4節-ポスト冷戦期の国連の集団安全保障体制">第4節　ポスト冷戦期の国連の集団安全保障体制</h2>
<section id="第1項-湾岸戦争一次資料残し" class="level3">
<h3 class="anchored" data-anchor-id="第1項-湾岸戦争一次資料残し">第1項　湾岸戦争（一次資料残し）</h3>
<p>　東西間の冷戦が終結し、大国間の協調体制により安保理事会の機能が回復すると、国連の集団安全保障への期待がにわかに高まった。そのなかで、湾岸危機に際して国連がとった対応は、安保理事会の下での平和強制機能の復活を印象づけるものであった。1990年8月のイラクによるクウェート進攻とともに、米国を中心とする諸国はいち早くサウジアラビアとその周辺の海域に多国籍軍を派遣したが、安保理事会は、イラクに対する第7章の下での平和破壊の認定 (39条)、経済制裁 (41条)などに関する一連の決議を矢継ぎ早に採択した。<br>
　安保理は憲章第39条に基づき、「イラクのクウェート侵攻に関し国際の平和及び安全の破壊が存在することを認定」し、第40条によりイラクに対して「全ての軍隊を90年8月1日に位置していた地点まで独自活無条件に撤退することを要求」したのである。[^02_ch02-1]そして追加で加盟国に対して、イラクとの経済関係を中断することを求めたのである[^02_ch02-2]。安保理が一国の侵略行為に対して経済制裁を発動したのは国連史上初の事態であった。この後、安保理はイラクのクウェート侵攻を無効と宣言する決議[^02_ch02-3]、クウェートからの第三国民の出国を要求する決議[^02_ch02-4]を採択した。8月25日には「国籍を問わず全ての船舶の停戦と集積及びその戦期の検査を実施することにより」、決議661による経済制裁のうち「海運に関する条項の厳格な実施を確保する」ため「クウェート政府と協力してこの水域に海軍部隊を展開している加盟国」に対して「個別の状況が必要とするかもしれない措置」をとることを要請する決議を採択した[^02_ch02-5]。そして安保理は経済制裁を決めた決議661が海上輸送に重点を置いていたところ、リビアとイエメンが空路でイラクに対して物資を送っていることが判明したため、9月25日には対イラク空域封鎖決議[^02_ch02-6]などを採択したのち、11月29日にこれらの決議の実効性を確保するため、湾岸地域に展開する多国籍軍に対し、憲章第7章の下での武力行使を含む「あらゆる必要な手段」をとる権限を授権 (authorise) する決議678を採択したのである[^02_ch02-7]。<br>
　しかし、安保理決議678による武力行使の許可は、イラクに対する経済制裁の効果を十分見極めることなしに採択された。しかも本決議採択後の安保理の主要メンバーは以後新たな措置や行動をとるつもりのないことを声明して自ら交渉による解決の道を閉ざし、強制的に軍事措置に移行したのである。湾岸戦争直前の事務総長やフランスによるイニシアチブは、戦争回避＝平和的解決の可能性を孕むものであったし、ソ連による仲介の努力やイラクからの安保理決議受諾のシグナルがあったにも関わらず、安保理はその可能性を生かすことなく、翌年1月17日に多国籍軍による対イラク地上戦が開始された。4月3日、安保理は正式な停戦のための決議687[^02_ch02-8]を採択、6日にイラクが受諾したことにより湾岸戦争は終結をみたのである。この決議では、イラク・クウェート国境地帯での停戦監視団（UNOKOM）の設置が決定された。<br>
　多国籍軍によるイラク地上戦の憲章上の根拠については、これを51条の集団的自衛権の行使とみるか、42条の国連行動で一部の国に権限を委ねるものとみるかについて、学者の間に議論が分かれたが、43条の特別協定に基づく国連軍を組織できない現状では、安保理事会は一部の加盟国に強制行動を「授権」するという変則的な手段に頼らざるをえなかったのである。<br>
　こうした学説の混乱の原因は、安保理決議678の文言の曖昧さにある。 この決議は、安保理が自ら主体性を発揮して強制行動を統轄する責任をとらず、米国を中心とする多国籍軍に「あらゆる措置をとる」白紙委任に近い権限を付与する内容のものであったからである。1950年の朝鮮戦争の場合は、安保理は軍事行動の統一指揮権を、韓国援助の主導的立場にあったアメリカ政府に委ねるという便法がとられた。このため、朝鮮での軍事行動は、国連の直接の統制下におかれなかったのである。しかし、それでも「国連軍」司令部を設置し、国連旗の使用を認めるなど、国連との結び付きをもつ工夫をこらしたのである。<br>
　これに対し、湾岸戦争での多国籍軍の軍事行動は、安保理の「容認」決議によって国連からの「お墨付き」をもらったあと、それ以上に国連と結びつける努力はなされなかったのである。監督・統制の手続きとしては定期的報告しか規定しておらず、多国籍軍の軍事行動を停止または制限するためには新たな決議の採択が必要であった。軍事作戦の主導権を握った米国は、多国籍軍を、自ら「同盟軍 (coalition forces)」 と称して国連旗は使用せず、軍事行動の指揮にあたり軍事参謀委員会を活用すべきであるとのソ連提案も拒否したのである。こうして、多国籍軍による軍事行動が開始された1月17日以降、2月28日の停戦までの間、デ・クエアル事務総長が、多国籍軍側の作戦に関する情報収集について 「蚊帳の外に置かれた」と不満を述べるほど、国連との絶縁状態は続いた。1991年2月後半ごろからは、イラクから安保理決議受諾のシグナルが発せられるようになり、安保理では和平強化を訴える発言が相次いだが、アメリカはソ連による仲介の努力も無視して地上戦に突入、撤退途上のイラク軍に猛烈な攻撃を加えたのである。<br>
　こうした米国を中心とする多国籍軍の行動の背景には、多国籍軍の行動が国連の統制に服することにより、作戦行動の自由を縛られたくないとのアメリカ政府の意向があった。振り返ってみれば、イラクがイランに戦争を仕掛けた際や、ゴラン高原・ヨルダン川西岸を占領あるいは併合しているイスラエルに対して安保理は何の措置も採ってこなかったことからも、そもそも安保理が米国による政治性を排除できていないことが明らかであったが、この点がより強調されたのが湾岸戦争であった。<br>
　国連の強制行動への参加が、国連の指揮の下で行なわれることへの米国をはじめとする各国の拒否反応ゆえに、ポスト冷戦期における国連の平和強制機能は、いずれも湾岸戦争型の変則的なものとなった。国連が第43条の下での国連軍を編成できない状況では、軍事強制行動は国連の統制に服しない一部の加盟国(多国籍軍)の手に委ねざるをえない。こうした集団安全保障上の国連が抱える構造上の問題を露呈させたのが湾岸戦争であった。</p>
</section>
<section id="第2項-ポスト冷戦期の始まりと安保理サミット文は完成一次資料をこれから追加予定" class="level3">
<h3 class="anchored" data-anchor-id="第2項-ポスト冷戦期の始まりと安保理サミット文は完成一次資料をこれから追加予定">第2項　ポスト冷戦期の始まりと安保理サミット（文は完成／一次資料をこれから追加予定）</h3>
<p>　1989年12月、アメリカ合衆国大統領ジョージ・ブッシュとソビエト連邦共産党書記長ミハイル・ゴルバチョフは地中海に浮かぶ小さな島マルタにいた。この両者による米ソ首脳会談で40年以上にわたり続いた東西冷戦の終結が宣言された。「冷戦の終焉」は、さらに90年10月のドイツ統一、91年4月のワルシャワ条約機構の解体、そして91年12月のソビエト社会主義共和国連邦の崩壊などにより、新たな歴史の潮流となった。「冷戦の終焉」とは単に東西関係における厳しい緊張イメージに終止符が打たれたということを意味するものではない。第二次世界大戦後の国際政治における力の体系、またイデオロギーや思想、外交の行動規範にいたるまで、これらを大きく変える力を発揮した。つまり「冷戦の終焉」は従来の国際体系の機能や役割を大きく変質ないし消失させることとなった。<br>
　冷戦の終焉とともに、世界平和機構としての本来の国連の機能回復に大きな期待が寄せられた。既述のように、冷戦時代には、国連による国際安全保障機能は米ソ及び東西両陣営の厳しい「不信の構造」と「敵対構造」によって、実質上機能不全に陥っていた。この事実に鑑みれば、「冷戦の終焉」が何よりもまず国連に対して、新たに国際安全保障の機能と役割を復活させ、再生させる好機を与えることになったことに疑問の余地はないだろう。実際のところ、デクエヤル前国連事務総長は、1991年の「国連の活動に関する事務総長報告」の冒頭部分で、「冷戦の終焉」は「国連にとっての長い沈滞の季節」が終わりを告げたことを意味するものであると指摘し、さらに、「国連憲章の諸原則が新たな国際秩序を支配するようになるとの関心」がこれから続くこととなって、国連は「機構上のルネッサンス」期を迎えることになったと手放しで喜びを表現したくらいであった[^02_ch02-9]。<br>
　同様にガリ事務総長も冷戦時代の敵対的国家関係が終止符を打って国連は検証の偉大な目標を達成できることに希望を抱いていた。1992年6月にガリが残した「平和への課題」においては、「国際平和と安全を維持し、正義と人権を確保し、より大きな自由の下に社会的進歩とより良き生活水準を推進する」ことが実際に可能となるとの確信が国連加盟諸国に生まれ、その結果「国連は、過去の時代と同じように再び不全となることは決してない」と残している[^02_ch02-10]。<br>
　1992年1月31日、ニューヨークの国連本部で国連安全保障理事会が開催された。安保理の15のメンバーの首脳が一堂に会し「国際平和と安全に関する安全保障理事会の役割」という一般的議題について論じたため「安保理サミット」と呼ばれた。このような安保理の首脳会議が初めて開催されることとなった直接のきっかけは、同月に新しい国連事務総長としてエジプト出身のブトロス・ブトロス＝ガリ氏が就任したことと安保理常任理事国であったソ連に代わりロシアがその地位を継承したことの2点であった。また、より基本的な背景としては、湾岸戦争後1年を迎える時期に当たり冷戦後の新世界秩序の中で国連の果たす役割を改めて問い直し、その将来を模索する必要が感じられたからであった[^02_ch02-11]。安保理サミットでの各国首脳の発言内容は「国際平和と安全」という一般的なテーマの枠内で様々な分野に及んだが、議論の中心をなしたのは国連が紛争処理のために取る諸方策、および軍備管理・軍縮の諸問題であった。ここからは国際紛争の解決のための国連の在り方に焦点をあて、その審議の内容を紹介する。<br>
　湾岸戦争後1周年に当たる時期に開催された安保理サミットでは、各国首脳から対イラク制裁への言及がなされ、侵略を打ち砕く国連加盟国の結束を擁護する発言がみられた。湾岸戦争時に行われた多国籍軍の軍事行動は、朝鮮戦争以来2回目の国連による軍事的強制行動であり、空文と化していた憲章第7章（「平和の強制」システム）の復活の兆しとして、各国の関心を呼んだのである。もっとも、湾岸戦争での米軍を中心とする多国籍軍の軍事行動がはたして国連による集団安全保障体制の発動といえるかどうか、といった問題があった（詳しいものは既述）。湾岸戦争での米軍を中心とする多国籍軍の行動は、憲章第7章との関連において、かなり変則的であったからである。対イラク軍事活動のイニシアチブをとった米軍は、安保理からその行動を「容認（authorize）」する決議を取り付けたものの、多国籍軍は自らを「同盟軍（coalition forces, allied forces）」と呼んで国連との間に一定の距離を保ち、その軍事作戦について国連の統制を受けることを極力回避したからである。<br>
　安保理サミットではこの点が問題とされ、将来の集団安全保障が憲章第7章に則った真の意味での「国連行動」たらしめる必要が説かれた。オーストリアやフランスなどは第47条の軍事参謀委員会の活用や、国連軍に関する第43条の規定に言及した[^02_ch02-12]。しかし湾岸戦争のリーダーであった米国からはそれらについて何らの肯定的反応はなかった。このため議長として会議の結果をとりまとめた英国は議長声明の中で「集団安全保障」についてごく簡単な抽象的言及をするにとどめ、第7章の規定の活用について具体的な提案は一切行わなかったのである[^02_ch02-13]。<br>
　のみならず、国連の集団安全保障体制そのものについても、一部の国から、その将来について消極的・否定的見解が述べられてもいる。アフリカのカーボベルデやジンバブエは「侵略に対抗するための国連の集団的強制行動が効果的であるためには、その適用に一貫性がなければならない。これが選択的、恣意的になされれば、国連行動は道義性と信用を失うことになる。しかし、安保理の拒否権が認められている現状ではその一貫性は期待できない」として、強制行動の将来に不信感を示し、むしろ「強制行動は武力を用いない経済制裁にとどめるべきである」とすら主張したのである[^02_ch02-14]。<br>
　このように「平和の強制」システムの将来についての強化策に具体性を欠いたのとは対照的に、紛争の平和的な解決の諸法策については各代表から一様に積極的な評価がなされ、その一層の強化と活用のための具体策が提案されたのである。まず各代表が押しなべて言及したのは、「予防外交」についてであり、紛争の初期の段階での国連の介入の必要性を強調した。すなわち、世界平和に対する潜在的脅威となる地域紛争や事態に対して国連がいち早く解決に乗り出し、これが武力紛争に発展するのを食い止め、紛争を目のうちに摘み取ることの必要性である。紛争の現地に代表を送り、情報収集や解決のための斡旋を行わせるなどの権限を、事務総長が与えられるよう提案したのである。<br>
　「予防外交」と並んで各国代表が盛んに言及したのが「平和創造」と「平和維持」の二つであり、その具体的な中身としては、国連事務総長をはじめとする国連の諸機関による交渉、斡旋、仲介、事実調査、調停などの諸手続に及ぶものであった。安保理サミットで多くの代表は、この「平和創造」面での国連介入方式に高い評価を与え、とくに事務総長を中心とする「平和創造」の努力について一層の強化・活用を提案した。また、「平和維持」についてもこれの貢献を高く評価する発言が相次ぎ、PKOへの自国の積極的な参加の意向も表明された。理事国の中でこれまでPKOへの参加の実績を持つ国（オーストリアなど）に加えて新たな人的貢献を公約した国として、フランス代表は約1000人の隊員を国連からの要請に応じて即時に派遣できる体制を整えていることを伝え、ロシア代表も将来のPKOについて特に兵站面での貢献を申し出た。またベルギー代表はPKOに備えた待機軍を自国内に用意する意向を明らかにし、日本代表も目下PKO協力法案が国会で審議中であることを伝えるとともに財政面ではPKOの当初の経費を賄うための協力体制について提言を行った[^02_ch02-15]。<br>
　以上の各国による積極的発言を受け、会議終了時の議長声明では「「予防外交」、「平和創造」および「平和維持」に関する国連の能力をより効果的にし強化する方法について、事務総長がその分析と提案を作成し、92年7月1日までに提出するよう」勧告する文言が挿入されたのである[^02_ch02-16]。<br>
　なお安保理サミットの議長声明は、とくにPKOについて言及し「「平和創造」がアジア、アフリカ、ラテンアメリカ、欧州の各地域で貴重な貢献を行っていることを歓迎」したのち、「ここ数年来、PKOの活動がその数を増し、その幅を広げている」事を指摘している。当時のPKOの特色として、その数が激増する傾向に加え、その任務や組織面で“多様化”する現象が注目されていた時代であった。ここでいう多様化とは、「平和創造」がそれ自体単独でなされるのではなく、「平和維持」と結合するかたちで実施される事例が増えていた事を指す。冷戦の終結が東西間の代理戦争を終焉させたものの、代わって登場したのが人種的・宗教的内紛であった。国連は多発した紛争を収束させる切り札としてPKOを大いに活用したことで、量的にも質的にも大きな展開を遂げることとなったのである。質的な変化に着目すると、PKOは軍事・文民部門を含む複雑な任務と組織を持つものが多くなった。武力紛争が国連の平和的解決の努力によって解決に向かう中で、紛争の当事者間に同意をみた包括的な和平計画の一翼を担うものとして、PKOが組み込まれているのである。<br>
　典型的な事例としては、国連ナミビア独立支援グループ（UNTAG）があげられる。ナミビアの独立移行に関する包括的和平計画には、南アと人民解放戦線（SWAPO）との停戦と兵力引き離し、武力解除・軍の解体に始まり、差別・抑圧的性格の法令の廃止と政治犯の釈放、亡命者・難民の帰国という準備期間を経て、国連管理下での自由選挙を実施し、新憲法を採択してナミビアを独立させるというプロセスが含まれ、これらがUNTAGの支援の下に実施に移されたのである。そこでは、和平達成への包括的な計画の一環として停戦や兵力引き渡しといった軍事的側面の収集過程が、自由選挙などの政治過程と不可分に結びついて施され、「平和創造」と「平和維持」の二つの機能有機的に連動する形で結合したのである。これに参加したUNTAGの要員は、軍事部門と文民部門を含め8000名に上った。同様の方式は、国連西サハラ住民投票監視団（MINURSO）の活動、国連エルサルバドル監視団（ONUSAL）の活動、さらには国連カンボジア暫定統治機構（UNTAC）の諸活動は、いづれもナミビアをモデルにした、包括的和平計画に従って実施される予定である。<br>
　このような、和平の実現に至る軍事的過程と政治的過程とが連動して一挙に実施されることは、これまでPKOに対してしばしば与えられた「PKO自体は武力紛争の軍事的側面を収集するだけで、紛争そのものの根本的解決をもたらさない」という批判に答えるものであり、当時は将来のPKOの在り方を示すものとして大きな注目を浴びていた。<br>
　また、当時のPKOにはもう一つの潮流も存在していた。それが「平和の強制」と結びついた平和維持活動の登場である。湾岸戦争の終結の際に設けられた、国連イラク・クウェート監視団（UNIKOM）がそれである。UNIKOMは、国連憲章第7章のもとでイラクに対してとられた軍事的強制措置をいわば引き継ぐ形で非武装地帯の監視のために派遣されたものであり、「平和の強制」の後始末のために「平和維持」が導入された例である。もっとも「平和維持」と「平和の強制」の機能は、もともと水と油のような関係に立つから、両者の結合が無理なく行われるには困難が伴った。UNIKOM設置の時点では、第7章の下での国連の経済制裁は依然継続中であり、現地では多国籍軍の駐留がなお続けられていた。したがって、このような特殊な状況下ではPKOの実施にあたり「同意原則」は適応上、若干の修正を受けることはやむを得ないことであった。<br>
　第1に、UNIKOMの設置は、イラクに対する軍事行動を終結するための安保理の包括的停戦決議の一環として提案され、イラクはこの提案を受け入れたが、そもそも敗戦国による「受諾」がUNIKOMの受け入れに対する「同意」と同じものなのか、といった問題点がある。第2に、UNIKOMの駐留継続の可否は6か月ごとに安保理のみが決定するという方式がとられたが、これもPKOの任務終了に関する従来の慣行からは若干ずれてしまっている。<br>
　しかしこれらの点を除き、UNIKOM の現地での活動そのものは、基本的性格に何ら変更を生じなかった。このPKOの設置が第7章の適用という特殊な状況下でなされたにもかかわらず、UNIKOMの非武装地帯での活動に関する限り、その非強制性と中立性は貫かれ、またその他に関しても従来の慣行通りであった。また、33カ国の国籍の将校からなるUNIKOM監視団の中に常任理事国の監視員が含まれていたとしても、これもまた異とするには足らない。個人単位で採用される監視団については「国籍」は重要性が低いのであって、すでにパレスチナ停戦監視団（UNTSO）をはじめ、他の監視団にも常任理事国の参加の先例がみられる。[^02_ch02-17]<br>
　なお、安保理サミットが国連事務総長に対して紛争解決の3機能についての検討をゆだねたことは、同年のPKO特別委員会の審議に少なからぬ影響を与えた。4月から5月にかけて開かれたこの総会の補助機関は、PKOの諸問題について包括的審議を行ったのであり、PKOの財政的側面の他、加盟国によるPKOへの人的・物的貢献の促進の問題や、憲章第8章に基づく地域機構とのPKO実施の協力体制など、幅広い検討がなされたが、特にガリ事務総長の蒸気の報告書に委員会の討議を反映させる趣旨から、PKOと「予防外交」および「和平努力」との関連について、突っ込んだ討議が交わされたのである。<br>
　なかでも論戦の焦点となったのは「平和維持」と「予防外交」との関連であり、PKOをこれまでの武力衝突発生後の事後的使用にとどめず、紛争前の予防的な活用への可能性をめぐる議論であった。一部の加盟国は、予防的外交への手段として事務総長の情報収集、事実調査団の派遣に加えて、PKOの予防的展開が望ましいと述べ、これに侵略の抑止の効果を期待した。さらに、PKOの展開には関係国の同意が不可欠であるが、当事者が協力を拒むときには国連が強制措置に移ることを考えるべきで、この「自動的拡大（automatic escalation）」について慎重に検討すべきであると述べた。<br>
　しかしこれには他の加盟国から反論も出された。すなわち、ある地域の危険な事態に対してPKOを予防的に展開するにはどの程度で、どのような基準に従ってそれを特定し、その期間の決定に基づいて実施に踏み切るかという困難な問題があり、特に侵略に対する抑止力として使用するには相当の慎重さが要求される。PKOの予防的展開に当たっても、PKOの伝統的ガイドラインにのっとるべきであり、領域国の主権、内政不干渉原則の尊重、関係同時者の事前の同意、武器の不使用および現地活動での中立・公正な態度など、これらの諸原則は堅持されなければならず、憲章第7章の強制行動とは明確に一線を画すべきであるとの主張がなされたのである。このように、6月4日のPKO特別委員会の報告書は、PKOの予防的使用の可否についての見解の対立を浮き彫りにしている[^02_ch02-18]。</p>
</section>
<section id="第3項-平和への課題文はおおよそ完成一次資料を追加予定" class="level3">
<h3 class="anchored" data-anchor-id="第3項-平和への課題文はおおよそ完成一次資料を追加予定">第3項　「平和への課題」（文はおおよそ完成／一次資料を追加予定）</h3>
<p>　ポスト冷戦期を迎えて、国連の平和維持機能への期待が高まる中で、1992年1月末に開催された安保理サミットは、事務総長に対して、「予防外交」「平和創造」「平和維持」の三機能について検討を行い、その機能強化について提言するよう要請する議長声明を採択した。安保理からの付託を受けた事務総長が92年6月17日に公表したものが「平和への課題」と題する報告書であった。「平和への課題」では、上記の三機能のほか、“post-conflict peace-building”（「平和建設」ないし「平和再建」と訳される）という戦後復興ないし紛争再発防止のための機能を加え、以上4つの機能について検討を行った。</p>
<table class="caption-top table">
<colgroup>
<col style="width: 100%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">「平和への課題」　A/47/277-S/24111　1992/6/17</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Ⅱ. 定義 20　予防外交(Priventive Diplomacy)、平和創造(Peace-making)、平和維持(Peace-keeping)などの用語は不可分の関係にあるが、本報告書では次のような意味で用いている。 ― 「予防外交」とは、当事者間の争いの発生や現に存在する争いの紛争への発展を防ぐとともに、紛争が発生した場合の拡大を防止するための行動である。 ― 「平和創造」とは、主として国連憲章第6章で想定されている平和的手段を通じて、敵対する当事者間に合意を取りつけることをいう。 ― 「平和維持」とは現地に国連の存在を確立することであり、これまでは全当事者の承諾をもとに、通常は国連の軍事・警察要員が、また、しばしば文民も参加して行われている。平和維持は、紛争の防止と平和創造の双方の可能性を拡大する技術である。 21　本報告書はさらに、これらと密接な関係を持つ、紛争後の「平和建設」という概念も取り上げる。これは、紛争の再開を防ぐため平和を強化、固定化するのに役立つ構造を確認、支援する行動である。予防外交は紛争を、暴力行為が発生する以前に解決することを目的とする。平和創造と平和維持は、紛争を停止させ、いったん回復された平和を保つために必要となる。その成功は紛争後の平和建設の機会を強化し、それが国家および民族の間の暴力行為の再発を防止する。 22　これらの四つの行動分野を単独ではなく合わせて、またすべての加盟国の支持のもとに実施すれば、憲章の精神に基づく平和の確保に一貫した貢献を果たすことができる。このような分野のみならず平和のための活動というより広大な領域においても、国連には多大な経験がある。たとえば非植民地、環境、持続可能な開発、人口、疾病の撲滅、軍縮、国際法の発展など多くの問題に関するイニシアチブが、平和な世界の基盤づくりに測り知れないほど貢献してきている。世界はこれまでしばしば紛争によって引き裂かれ、人類の大規模な苦しみや欠乏状態に悩まされてきた。しかし国連の継続的な努力がなければ、こうした惨状はさらに拡大していただろう。伝統的な意味だけではなく、これからの時代が必要とする新たな次元での国際の平和の維持に発揮しうる国連の潜在能力を評価するに当たっては、このような広範にわたる経験が考慮されねばならない。</td>
</tr>
</tbody>
</table>
<p>　まず「予防外交」は、国連の諸機関(安保理、総会、事務総長および補助機関)が地域機構や専門機関の協力の下に行なう信頼醸成の措置にほかならない。このために、危機管理としての情報収集に努めるほか、事実調査団の現地派遣を通じて紛争の発生や悪化防止をはかり、さらにすすめて、国連要員の予防的現地介入ないし駐留を行なう。国内紛争への介入にあたり則るべき基本原則は、関係当事者の要請や同意を得ること、領域主権の尊重、内政不干渉、当事者に対する公平・中立的態度の厳守などである。国際紛争ないし国際的危機の場合には、安保理が国連の予防的介入を必要と認め、かつ紛争当事国双方が同意するとき、国連は当事国双方の領域への駐留が可能である。さらに、隣国の武力攻撃の脅威を感じ、安保理が国連の介在を必要と認めれば、当該国家のみの要請でその領域への展開が可能となる。<br>
　報告書は、その際に駐留する国連要員の規模と任務の内容は状況により異なるとしており、そこには軍隊の駐留も含まれるであろう。加えて報告書は予防的介入の措置として「非武装地帯」の設置を挙げる。これは、従来、停戦実施のためPKOの一環として実施されてきたものを、「予防的展開」の一方式として活用する提案である。非武装地帯の設置も、紛争当事者双方の同意があれば、国境をはさんで両側に設けることができるが、一方の側のみの同意がある場合、国境線の同意国側に設けることができるとする[^02_ch02-19]。</p>
<table class="caption-top table">
<colgroup>
<col style="width: 100%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">「平和への課題」　A/47/277-S/24111　1992/6/17</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Ⅲ. 予防外交 23　外交の最も望ましくない有効な用い方は、紛争に発展する以前に緊張を緩和させること、またもしも紛争が発生した場合には、速やかに拡大を阻止し、根底にある原因を解決するために機能することである。予防外交は直接実施してもよいし、国連の高官、専門機関や各種の計画、安全保障理事会、総会、国連と協力する地域機関などが実施することもできる。予防外交には信頼を創り出す措置が要求され、また情報収集と公式もしくは非公式の事実調査に基づく早期警報が必要であるほか、予防展開、場合によっては非武装地帯の設置なども必要となる可能性がある。 予防展開 28　危機的地域における国連の活動はこれまでは概して、紛争の発生後に開始されてきた。だがいまや、国連要員の予防展開が正当化される状況についても検討すべき時である。それはさまざまな場合や方法でとりうる。たとえば国家的な危機が発生した場合には、その国の政府あるいは全当事者の要請ないしは承諾に基づく予防展開がありうる。国家間の紛争にさいしては、国境の両側に国連が存在することが敵対行為の阻止に役立つと双方が考えた場合に、また、ある国が脅威を受けたと感じて、その国の国境内部のみにおける国連の適切な存在を要請する場合にも、やはり実施されうる。国連の存在の使命と構成はいずれの場合も、慎重に工夫されるとともに、すべての関係者の理解を得る必要がある。 29　予防展開は、国内で危機が発生して政府が要請した場合、また全当事者が承諾した場合に、苦痛を緩和したり暴力行為を限定あるいは制御したりするのに、さまざまな方法で役立つ。公平な人道的援助は決定的な重要性を持ちうるし、安全維持への援助は、軍人か警察官あるいは文民の要員によるものかどうかを問わず、生命を救い、交渉が可能になるような安全の条件を創り出すのに役立つ。また当事者が望むならば、調停の努力に貢献することもできる。国連はまたある種の状況においては、国連システムのさまざまな部分が持つ専門技術と資源を活用する必要があるかもしれない。この種の活動ではさらに、時によっては、非政府機関の参加も必要となるかもしれない。 30　このような国内の危機においては、国連はその国の主権を尊重する必要がある。さもなければ、憲章の諸原則を受け入れるにさいして加盟国が示した理解にそむくことになる。国連はあくまで、1991年12月19日の総会決議46/182にもられた指導原則に示されている、交渉によって慎重に達成された均衡には配慮しなければならない。この指導原則はとりわけ、人道的援助は人道、中立、公平の原則に基づいて提供されねばならないこと、主権、領土保全および国家の統一は憲章に従って十分に尊重されねばならないこと、これに関連して、人道的援助は被災国の承諾のもとに、また原則としてその国の要請に基づいて提供されねばならないこと、などを強調していた。指導原則はまた、国家にはその領土内で発生した緊急事態の犠牲者の世話をする責任があること、人道的援助を必要とする人々に接触する必要があることなども強調していた。このような指導原則に照らせば、国連の介入を求める政府の要請あるいは承諾は、その国の主権を侵害するものはないし、本来はいずれかの国の国内管轄権に属する事項について述べている憲章第2条7項の規定に違反するものでもない。 非武装地帯 33　非武装地帯は過去においては、紛争の終結にさいする当事者の合意によって設置されてきた。だが非武装地帯についてはいまや、平和維持活動の一環として国連要員をこの種の地帯に展開することに加えて、交戦国となる可能性がある国々を切り離す手段として両当事者の合意のもとに国境の両側に、あるいは攻撃のいかなる口実も取り除く手段として当事者の一方の要請のもとに国境の片側に一種の予防展開を行う有用性についても検討が必要である。非武装地帯は、紛争は防止しなければならないという国際社会の関心を象徴する役割を果たす。</td>
</tr>
</tbody>
</table>
<p>　第2の「平和創造」は、紛争当事者に対する和平達成への国連の努力の具体策として、報告書は国連憲章第6章に掲げる紛争の平和的解決の諸手段を挙げる。 安保理や総会、事務総長による交渉、審査、仲介、調停、仲裁のほか、とくに国際司法裁判所（ICJ）の機能強化を訴えた。<br>
　ところが、「平和創造」の具体策としての事務総長の提言は、ここに至って突如第6章の枠を超え、第7章の領域に踏み込むのである。報告書は、国連の紛争努力にもかかわらず、平和的手段が功を奏しないときは、第42条の軍事的強制措置を選択する必要を説く。 ただ、第42条の適用には第43条の特別協定の締結が先決であることを事務総長も認めている。そこで第43条を活性化して、安保理が軍事参謀委員会の補佐を得て、国連軍創設のための特別協定の締結に向けて交渉を開始することを提案した。<br>
　もっとも、侵略に対抗するための第43条型の国連軍創設の可能性は近い将来期待できないとみる事務総長は、 その代案として、停戦合意が厳守されない場合、その実現、回復をはかるための「平和強制部隊 （peace-enforcement units, PEU）」創設を検討するよう提案する。 「平和強制部隊」の性格は、報告書によれば、加盟国から自発的に提供する部隊で編成され、あらかじめ限定された任務(PKOのそれを超えることをうる)のために国連の要請で派遣され、武器はPKOのよりも重装備であり、平素、加盟国の軍隊内でそれに備えた訓練を行なうとされる。 「平和強制部隊」の派遣は安保理の決議に基づき、PKOの場合と同様、事務総長の指揮・統轄下に置かれる。要するに、 「平和強制部隊」は、兵力や装備、任務の点で、第43条型の国連軍と、 PKOとの中間型のものと思われる。報告書も、「平和強制部隊」が、将来憲章第43条の下で創設される侵略に対抗する型の国連軍や、加盟国がPKOに備えて待機する型のものとは区別すべき第3の型の待機軍であると強調し、憲章上の根拠も、第40条の暫定措置の一環と位置づけている。事務総長の新提案は、突如浮上したものだけに世間の注目を集めたが、その性格は「平和強制部隊」の呼称が示す（enforcementが入っている）ように、憲章第7章の強制措置を目的とした軍隊であることは否定できない。</p>
<table class="caption-top table">
<colgroup>
<col style="width: 100%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">「平和への課題」　A/47/277-S/24111　1992/6/17</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Ⅳ. 平和創造 34　紛争防止と平和維持の二つの任務の間には、敵対する当事者間の合意を平和的な手段によって取りつけるために努力するという責任が存在する。憲章第6章は、紛争解決に役立つさまざまな手段を明示している。これらの手段は、総会が採択した1982年の「国際紛争の平和的解決に関するマニラ宣言」、1988年の「国際の平和と安全を脅かす紛争および情勢の防止と除去、およびこの分野における国連の役割に関する宣言」などを含む各種の宣言によって拡充されている。これはまた国連憲章に従い国際の平和と安全、国際協力をあらゆる側面で強化することをうたった1989年11月15日の決議44/21など、総会が採択したさまざまな決議でも取り上げられている。国連はこのような平和的手段の適用に広範な経験を積んできた。紛争が未解決のまま取り残されたことがあったとしても、それは平和的解決の手法が不明、あるいは不十分だったためではない。その原因の第一は、当事者に憲章第6章で提案されたような手段によって相違点の解決を求める政治的意志が欠如していたこと、第二は、これは第三者を通じる解決方式が選ばれていた場合であるが、その第三者に使用できる手段が欠如していたことにある。問題に対する国際社会の無関心、あるいはそれを無視することも、やはり解決の可能性を阻害することがありうる。国連の平和的解決能力の強化を望むのであれば、われわれはまず、これらの分野を重視しなければならない。 軍事力の行使 42　もしも平和的手段が失敗した場合には、「平和に対する脅威、平和の破壊または侵略行為」に対抗して国際の平和と安全を維持あるいは回復するため、安全保障理事会の決定に基づいて憲章第7章で規定された措置を取るということが、憲章に示された集団安全保障の概念の真髄である。安全保障理事会はこれまではまだ、そうした措置のなかでも最も強制的なもの、すなわち憲章第42条で想定されたような軍隊による行動は取っていない。安全保障理事会はイラク・クウェート両国間の紛争にさいしては、理事会に代わって措置を講じる権限を加盟諸国に与えるという方法を選んだ。しかし憲章は詳細にわたる取り組み方を規定しており、この点についてはいまやすべての加盟国が留意する必要がある。 43　安全保障理事会は憲章第42条に基づき、国際の平和と安全を維持または回復するために軍事行動を取る権限を持っている。この種の行動を取るのはあらゆる平和的手段が失敗した場合のみでなければならないが、国際の安全を保障する機構としての国連の信頼性にとっては、こうした行動も辞さないという選択権を持つことが肝要である。それには交渉を通じて、憲章第43条で規定されたように、加盟国が第42条に掲げられた目的のために安全保障理事会に対して特定の場合のみならず恒久的にも、兵力、援助および便益を利用させることを約束する特別協定を締結する必要がある。憲章が採択されて初めて存在する現在の政治状況においては、この種の特別協定の締結を長らく妨げてきた障害も、もはやその力を失ったはずである。安全保障理事会が自由に使える対応手段を持つことには侵略者も当然気づくはずであるから、常備軍をいつでも使用できる態勢が整うことは、それだけでも平和の破壊を抑止する手段として役立つ。第43条に基づく軍隊はおそらく絶対に、最新兵器を装備した大規模な軍隊からの脅威に対抗できるほどの規模や装備を整えることはあるまい。しかし小規模の軍隊による脅威であるならば、必ずや対処できるはずである。私は安全保障理事会が第43条に基づき、軍事参謀委員会によって支持された交渉を開始するよう勧告する。軍事参謀委員会は第47条第2項に基づき、必要とあれば他の加盟国の参加を求めて増強することができる。私は、軍事参謀委員会の役割は平和維持活動の立案あるいは実施の文脈においてではなく、憲章第7章の文脈において判断されるべきだと考えている。 平和強制部隊 44　第43条に基づく部隊の任務は、差し迫ったあるいは現実の、公然たる侵略に対応することにある。このような部隊はまだ当分の間、実現はしないことだろう。停戦が合意されても守られないことはしばしばであり、国連はこれまでも時折、停戦を回復、維持するために部隊を派遣するよう要請されてきた。この任務は折にふれ、平和維持軍の任務や、平和維持軍に兵力を提供する諸国の期待を上回ることがありうる。私は安全保障理事会が、明確に定義された状況においては、その委任事項を事前に明記したうえで、平和実施部隊の利用を考慮するよう勧告する。加盟国から提供されるこの部隊は常時出動可能な態勢をとり、この種の任務に志願した部隊で構成されるものとする。この部隊は平和維持軍よりも重装備のものでなければならず、各国の軍隊で広範囲な準備訓練を受ける必要がある。部隊の展開と活動は安全保障理事会の権限に属し、平和維持軍の場合と同様、事務総長の指揮下に入ることになる。このような平和実施部隊は、憲章第40条が定める暫定措置として正当化できると私は考えている。この平和実施部隊を、侵略行為に対処するために第43条に基づいていずれ設置されるかもしれない兵力や、平和維持活動に貢献できるよう各国が待機態勢に置くことに合意するかもしれない軍事要員と混同してはならない。 45　外交が本報告書で取り上げるすべての活動において継続的に行われているのと同様、平和創造と平和維持の間にも、境界線はやはり存在しないかもしれない。国連軍の現地への展開が紛争防止の可能性を拡大し、平和創造活動を促進し、平和建設の必要条件として役立つ場合が多いことでも明らかなように、平和創造は平和維持の前奏曲であることが少なくない。</td>
</tr>
</tbody>
</table>
<p>　第3の「平和維持」の項では、最近、PKOの役割がとくに高まった点を評価するとともに、その強化策についての事務総長提言は、もっぱらPKOに対する加盟国の人的、物的・資金的貢献をいかに確保するかの点に絞られている。具体的には、①PKOの困難な財政状況を緩和するために、加盟国の経費分担は、各国の国防予算から支出すべきこと、②人的貢献面では、とくに後方支援のロジスティック部隊の需要が大きいこと、③PKOの待機体制を確立すること、④PKO用の資材の備蓄体制の必要性、などである。</p>
<table class="caption-top table">
<colgroup>
<col style="width: 100%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">「平和への課題」　A/47/277-S/24111　1992/6/17</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Ⅴ. 平和維持 46　平和維持はまさしく、国連の発明といえる。平和維持はこれまで全世界の数多くの緊張地域に、かなりの安定をもたらしてきた。 要望の増大 49　平和維持と平和建設活動に関する国連への要望は、今後も事務局および加盟国の能力と政治的、財政的意思に対する挑戦となるであろう。安全保障理事会と同様に私も、平和維持活動の任務の増加と拡大を歓迎する。 平和維持の新段階 50　平和維持活動の性格は近年、急速な進化を遂げた。平和維持の既存の原則と慣行は近年の新たな要求に柔軟に対応し、成功に必要な基本条件も変わってはいない。その基本条件とは、任務が明確で実行可能なものであること、任務の実行に当事者の協力が得られること、安全保障理事会の支持が継続すること、加盟国が進んで専門家を含む必要な軍事、警察、文民要員を提供すること、本部および現地に効果的な国連軍司令部が存在すること、適切な財政・補給支援があること、などである。国際環境の変化につれ、また平和維持活動がますます、すでに調停者によって交渉された解決策の実施を助けるために展開されるようになるにつれ、その補給、装備、要員、財政に関して多くの新たな要求と問題が生じているが、もしも加盟国が望むならば、また必要な資源を提供する用意があるならば、これらの問題はすべて解決可能である。 要員 51　加盟国は平和維持活動への参加に熱意を示している。だが、軍事オブザーバーと歩兵部隊は必要数がいつでも提供されるものの、補給部隊を長期間にわたり割愛できる軍隊は少なく、これが大きな問題となっている。加盟国に対しては1990年、原則としてどのような軍事要員を提供する用意があるかを明らかにするよう要請したが、回答を寄せた国はほとんどなかった。私は全加盟国に対し、これらについて率直かつ速やかに回答するよう繰り返し要請する。予備的な取り決めは必要に応じ、新たな活動の必要が生じた場合に提供できる特殊技能を持つ要員の種類と数に関して事務局と加盟国が取り交わす書簡によって確認すべきである。 52　平和維持活動ではこれまでにも増して、文民の政務担当者、人権監視員、選挙担当員、難民・人道的援助専門家、警察官などが、軍事要員に劣らぬ中心的な役割を演じることが必要となっている。警察要員は、必要な数を集めるのがますます困難になっている。そこで、文民、警察官、軍事要員などの平和維持要員を加盟国および非政府機関、事務局の施設などが持つさまざまな能力を用いて訓練するための取り決めを再検討し、改善をはかるよう勧告する。要員提供国をさらに増やす努力は続くが、少なからぬ潜在能力を持つ諸国は、国連の活動に参加するかもしれない警察要員のための外国語の訓練に力を注いでほしい。国連自体に関しては、事務局職員が迅速に平和維持活動での任務に転任できるようにするため、報奨措置を含む特別の人事手続きを制定する必要がある。事務局に勤務する軍事スタッフの定員と能力も、新たな、しかもより重大な必要に対応できるよう拡大しなければならない。 補給 53　大部隊が海外で活動するのに必要な装備を、すべての国が提供できるとは限らない。装備の一部は部隊の提供国から提供されるとしても、その大部分については、装備が不十分な部隊を補うためのものを含め、国連が提供しなければならない。だが国連には、このような装備の備蓄はない。生産者に発注する必要が生じて、さまざまな問題を引き起こす。活動の開始と同時に少なくともいくらかの車両、通信器材、発電機その他が入手できるようにするためには、平和維持用の基本装備を事前に備蓄しておく必要がある。また各国政府が、必要が生じれば国連に直ちに売却、貸与、あるいは寄贈することができるよう、事務総長が定めた特定の備蓄を確約することが望ましい。</td>
</tr>
</tbody>
</table>
<p>　続く「平和の再建」と題する項目では、紛争後ないし戦後処理としての平和再建策が論じられる。 国連の和平合意やPKOの結果、恒久平和を確実なものとする諸措置を挙げる。具体的には、内戦の場合は、交戦者の武装解除、秩序の回復、兵器の処分、難民帰還の援助、選挙の管理、人権擁護の活動、政治対策等が挙げられ、国際紛争の場合は、経済的、社会的復興活動、紛争再発防止の信頼醸成を列挙する。これらは、従来「平和維持」や「平和創造」の諸措置に含めて説明されたものであるが、ガリ事務総長は、和平達成の最終段階をとくに切り離して「平和の再建」と名づけたものである。<br>
　ここまで、国連の下での紛争処理において、それを大きく二分するアプローチを紹介した。それぞれ、紛争の平和的解決機能と強制的解決機能である。これら硬軟両様の解決方式は、それぞれ長所とともに欠陥や限界を伴うものことは言うまでもないであろう。「平和創造」と「平和維持」の2機能にあたってはその共有する非強制・中立の性格が和平実現を促進する触媒的効果を持つ点が長所となっているが、紛争の当事者からの同意や協力が得られないときこれらの機能はその限界を露呈する。他方、「平和の強制」については、国際社会に法と秩序をもたらすために最後の手段として制裁ないしは軍事的強制措置に訴える必要はあるものの、力による平和維持の方式はそれ自体が大きな副作用を伴う。経済制裁については、～～軍事力による措置については、人的、物的破壊は避けられない。こうした硬軟両様の解決方式は、それぞれ異なる原理に服する別個の機能である。前の項からの繰り返しにはなるが、集団安全保障の適用には「一貫性」がなければならない。それが恣意的、選択的になされれば制度の信頼や正当性、そしてその実効性をも容易に失われてしまう恐れがあるのは既述のとおりである。<br>
　しかし、この両者を混同したような提案をガリ事務総長は「平和への課題」で行っていた。「平和創造」を「憲章第6章の平和的解決手段による和平努力」と定義しながら、この項目中に、唐突にも、第7章の強制機能に関する提案を挿入したのである。この論理的矛盾を避けるためには、「平和創造」を定義し直すか、あるいは「平和創造」という新たな項目を設け、そのなかで強制機能の提言を行なうべきであったかもしれない。 「平和強制部隊」創設の新提案については、それがどのような基本原則に基づいて派遣されるのか、停戦遵守を確保する任務に就くとき、すでに現地に展開中のPKOとの関係はどのようになるのか、 なんらの説明もなかったことは、「一貫性」の欠如に直結する可能性をはらんでいる。ここで想起されるのは、1983年のレバノン内戦に対して投入された米・英・仏・伊の4大国からなる「多国籍軍（MNF）」がたどった不幸な運命かもしれない。この大国の軍事力を背景とする “強化された” PKOは、結局はレバノン内戦に巻き込まれ無残な失敗に終わったのであった。<br>
　また、先の章において詳しく解説することとなるが、92年時点において経済制裁に関する問題意識は醸成されていなかった。事実、「平和への課題」における経済制裁に関する言及は、～～</p>
<table class="caption-top table">
<colgroup>
<col style="width: 100%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">「平和への課題」　A/47/277-S/24111　1992/6/17</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Ⅳ． 平和創造 制裁と特別の経済問題 41　平和創造が憲章第41条に基づく制裁の適用を必要とする場合には、特別の経済問題に直面する諸国が憲章第50条の規定に従い、これらの問題について安全保障理事会と協議する権利を持つばかりでなく、そうした窮状と取り組んでもらえるという現実的な可能性が存在することが重要である。私は安全保障理事会が、各国をこのような窮境から防ぐために利用することができる、国連機構の金融機関その他の機関を包含する一連の措置を考案するよう勧告する。このような措置は公正をはかるために必要であるばかりか、安全保障理事会の決定への協力を各国に促す手段ともなるであろう。</td>
</tr>
</tbody>
</table>
<p>　<br>
　なお、「平和への課題」では憲章第8章の地域的取極めや地域機構との協力体制、紛争地での国連要員の安全確保、財政措置等の問題も扱っているが、ここでは割愛する。</p>
</section>
<section id="第4項-その後のイラク" class="level3">
<h3 class="anchored" data-anchor-id="第4項-その後のイラク">第4項　その後のイラク</h3>
</section>
<section id="第5項-リビアへの経済制裁" class="level3">
<h3 class="anchored" data-anchor-id="第5項-リビアへの経済制裁">第5項　リビアへの経済制裁</h3>
<p>・リビアに対する強制措置の発動は、航空機爆破事件の被害者の引き渡しを主要な要求事項とするものであるが、3年も前の個別の刑事事件に関して、しかも条約によって紛争処理の方式が別途用意されているにも関わらず、経済措置を発動してそれとは異なった解決方法を強制することが許されるのかどうか、法的に見ても問題がある。<br>
・</p>
</section>
<section id="第6項-ソマリア内戦" class="level3">
<h3 class="anchored" data-anchor-id="第6項-ソマリア内戦">第6項　ソマリア内戦</h3>
<p>　ソマリアでは、米軍を主体とする多国籍軍（UNITAF）の撤収後、その任務を引き継いだ第二次ソマリア国連軍(UNOSOMI)に対して、安保理事会は、停戦監視、難民支援といった任務に加えて、武装集団に対する強制的武装解除や国連要員を攻撃した責任者の逮捕という武力行使を伴う新たな任務を与えた決議814)。これにより、第二次ソマリア活動は、もはや伝統的なPKOではなく、平和強制軍へと変質したのである。 コンゴの国連活動を想起させる一連の軍事作戦の結果は、国連とアイディード将軍派との抗争となり、国連は本来の中立性を離れて内戦の渦中に巻き込まれ、軍事作戦を主導した米軍などに多数の犠牲者が出るに及んで、ソマリアの強制行動は終結を余儀なくされたのである。</p>
<p>・ソマリアの指導者や族長に対するサヌーン事務総長特別代表の説得と根回しが成果を上げようとしていたにも関わらず、国連自身がそれを縁壊しにした上で、強制措置を発動したとの批判がある。<br>
・ソマリアでは、湾岸戦争の反省を踏まえ、定期的報告に加えて、統一的な指揮・統制を確保するための取り決めと調査メカニズムの確立、若干の安保理メンバーにより構成されるアド・ホック委員会による決議実施状況の報告、UNOSOM連絡将校の現地統一司令部への派遣が規定され、現実に事務総長レベル、事務局レベル、原理レベルでの厳密な連絡がとられたが、それらは統合軍（UNITAF）の行動の監視・監督というよりむしろ人道援助活動との調整や通常型PKOに復帰するための条件整備という性格の強いものであった。しかも、こうした連絡・調整さえ実際には統合軍の任務の範囲を巡って国連とアメリカの見解が対立したのちにうまく機能しなかった。<br>
・国連の指揮する兵力に武力行使権限が与えられたUNOSOMⅡは、1993年6月5日のパキスタン部隊襲撃事件をきっかけに、統一ソマリア会議アイディド派と全面的な交戦状態に突入、アメリカの兵力引き上げ方針決定によって通常型PKOへの復帰を余儀なくされた。国連自身の指揮する強制行動が、武力行使を授権した場合により一層惨めな失敗に終わったことはなんとも皮肉なことであった。ただし、この場合においても国連の指揮権が貫徹していたわけではない。UNOSOMⅡの展開にあたって、機構的にはUNOSOMⅡに属さないが必要な場合にはアメリカの緊急展開部隊がUNOSOMⅡの支援にあたることがアメリカ政府によって実施されたのである。失敗の原因を解明するために設置された国連の調査委員会はUNOSOMⅡがソマリアの国家再建という政治問題に関与したことを、アイディド派との敵対関係を生み出した根本原因としつつ、死傷者を増大させた原因の一つとして多くの作戦が国連の指揮・統制外で行われた事を指摘している。だが、国連の指揮が貫徹していれば、事態は一層泥沼化していた可能性は高い。UNOSOMⅡの経験は、国連による監視・監督だけでなく、国連とりわけ安保理に対する監視・監督もまた必要な事を示しているのかもしれない。<br>
・</p>
</section>
<section id="第7項-旧ユーゴ内戦" class="level3">
<h3 class="anchored" data-anchor-id="第7項-旧ユーゴ内戦">第7項　旧ユーゴ内戦</h3>
<p>　ユーゴでのPKOは、まず連邦制度の解体に伴い独立したクロアチア共和国の内戦に対して実施された。共和国内のクロアチア、セルビア両系住民の内戦に対し、まず欧州共同体（EC）が仲介を試みたあと、国連事務総長特使の調停が功を奏して、1991年11月23日、ジュネーブで紛争当事者間の停戦協定が成立した。この協定の中で紛争当事者はPKOの導入を要請した。これを受け92年2月21日の安保理決議743に基づきUNPROFORのクロアチアは県が実現した。UNPROFORの任務は、①クロアチア領内に「国連保護区」を設け、地区内での非武装化の状況を国連平和維持部隊が検証し、文民警察が人権保護の状況を確認すること、②避難民の期間をはじめとする人道的救済措置をとること、であった。<br>
　UNPROFORの設置にあたり、採用された基本原則は、事務総長報告「平和維持計画」によれば、以下の諸点であった。①平和維持活動は、すべての当事者による停戦合意の守と、協力を得ることが前提となる、②要員の提供は加盟国からの自発的協力に依存する、 ③ UNPROFORは事務総長の指揮監督の下におかれる、紛争当事者に対し、公平・中立性を厳守すること、⑤武器は自己防衛のため最小限度の使用のみが許される。これらは、伝統的なPKOの諸原則を踏襲したものである。<br>
　UNPROFORの活動により、クロアチアの情勢はひとまず鎮静化に向かった。ところが、四月に入り、ボスニア・ヘルツェゴビナが連邦から分離独立するに及んで、内戦はこの新共和国にも飛び火し、セルビア系、クロアチア系、およびモスレム系の三勢力の陣取り合戦の様相を呈し、大量の避難民を生んだ。安保理の停戦勧告決議にもかかわらず、事態は悪化の一途をたどり、人道的救援活動も妨害され、サラエボ空港も使用不可能となった。こうした事態を踏まえて、安保理は5月30日の決議で、新ユーゴスラビア連邦共和国(セルビアとモンテネグロ)とその国軍(JNA) によるボスニア介入を非難するとともに、同国に対する包括的経済制裁決議757を採択した。<br>
　一方、 UNPROFOR司令官の仲介の結果、6月5日にボスニアの紛争当事者間の停戦協定が成立し、人道的救援活動のため、サラエボ空港をUNPROFORの監督の下に再開することに合意した。これを受けて、安保理決議758により、クロアチアに展開しているUNPROFORの任務と規模を拡大することになった。 UNPROFORの新たな任務は、サラエボ空港の再開と安全確保の措置(空港地域の非武装化と出入国の安全確保)、サラエボへの人道的救援活動の監督、および安全区域の設置であった。<br>
　この決議を受けて、約1000人の歩兵部隊と60人の軍事監視団がサラエボ地区に派遣されたが、事態の改善がみられないため、安保理はさらに8月13日、ボスニア・ヘルツェゴビナにおける「人道的援助の実施を容易にするため、 加盟国にあらゆる必要な措置をとるよう要請」する決議770を採択した。 決議にいう「あらゆる必要な措置」とは武力行使の容認を意味するものと解された。しかし、この決議は、UNPROFORに対しては、その任務や性格に変更を加えるものではなかった。サラエボ地区に派遣されたUNPROFORは、クロアチアに展開中のそれと一体のものである。したがって、サラエボでのUNPROFORの活動も、設立当初に採用された基本原則に服するものというべきであろう。</p>
<p>　ボスニアでは、既述のように、UNPROFORの現地活動と併行して、安保理事会は憲章第七章を援用し、安全地帯からの兵員と重火器の撤収等の停戦協定の遵守を確保するため、セルビア人勢力に対する空爆の実施をNATOに授権した。この措置は、ソマリアの場合と異なり、 UNPROFOR自体の強制行動への変質を意味するものではなかった。 しかし、NATO軍による空爆開始は、セルビア人勢力の反発を呼び、その結果、 UNPROFOR が報復の標的となり、多数のPKO要員が拘束されることになった。このことは、国連のPKOの実施にあたり、これと併行する形で強制行動に訴えざるをえないとき、いかにして両者を切り離すことができるかという困難な問題を提起している。</p>
<p>・ボスニア・ヘルツェゴヴィナで、紛争当事者の全てが多かれ少なかれ残虐行為を行なっていたにも関わらず、もっぱらセルビア人勢力に対してのみ制裁措置を発動したことは、一種の二重基準と言える。<br>
・旧ユーゴ、とりわけボスニア・ヘルツェゴヴィナの場合には、集団殺害や暴行、強制移住などの非人道的行為が強制措置発動の根拠とされているが、各民族がモザイク用に混在している旧ユーゴで十分な準備なしに各共和国の独立を認め得れば、少数民族となる下位集団・地域が連鎖的に分離・独立を企て、領土の奪い合い＝異民族の追放・排除が起きることは当然に予想されたことであった。結果的に最悪の事態をもたらした責任の一部は、旧ユーゴ各共和国の独立をいち早く承認したドイツとEU諸国、国連加盟承認という形でそれを追認した国連自身にある。こうして、一連の非人道的行為が紛争の性格そのものに起因し、それ自身が紛争処理の一方法となっているとすれば、紛争原因やそれに対する責任を棚にあげ、非人道的行為のみを取り出して強制措置を発動することは、クリーンハンドの原則に反するものと思われる。<br>
・</p>
</section>
<section id="第8項-ルワンダ内戦" class="level3">
<h3 class="anchored" data-anchor-id="第8項-ルワンダ内戦">第8項　ルワンダ内戦</h3>
<p>・ルワンダではソマリアでの反省から、受検される任務や行動目的を明確に規定することや、任務が達成されたかどうかの認定権限を安保理に留保することに重点が置かれ、監視・監督の体制は大幅に後退してしまった。武力行使の授権に二ヶ月という期限がついていたものの、監視・監督体制としては、UNAMIRとの緊密な協力を実現するため「適当なメカニズムを設立するよう事務総長に要請」しているだけとなった。<br>
・授権される任務や行動目的を明確に規定することや任務が達成されたかどうかの認定権限を安保理に留保することに重点が置かれ、監視・監督の耐性は大幅に後退した。</p>
</section>
<section id="第9項-ハイチ情勢" class="level3">
<h3 class="anchored" data-anchor-id="第9項-ハイチ情勢">第9項　ハイチ情勢</h3>
<p>・ハイチの場合にもルワンダと同様にソマリアからの反省が活用される機運があったものの、多国籍軍からのスムースな意向を準備するために派遣されるUNMIH先遣隊の任務の一部として、多国籍軍の活動のモニターが挙げられているだけである。人道目的で強制措置が発動される場合には、通常型のPKOと並行して武力行使が授権されたり、多国籍軍の後を通常型PKOで引き継ぐことが予定されていたりしているが、このような場合のPKOは、自己の展開条件を多国籍軍の活動に依存しているという意味で第三者性を欠いていた。ここにおいて監視・監督の機能を委ねるのは不適当であっただろう。<br>
・授権される任務や行動目的を明確に規定することや任務が達成されたかどうかの認定権限を安保理に留保することに重点が置かれ、監視・監督の耐性は大幅に後退した。</p>
</section>
<section id="第10項-強制措置発動の適否とその実施方法の適否消すかも" class="level3">
<h3 class="anchored" data-anchor-id="第10項-強制措置発動の適否とその実施方法の適否消すかも">第10項　強制措置発動の適否とその実施方法の適否（消すかも）</h3>
<p>　</p>
</section>
<section id="第11項-ガリが残した平和への課題補遺要素は入れた最後に組み直し" class="level3">
<h3 class="anchored" data-anchor-id="第11項-ガリが残した平和への課題補遺要素は入れた最後に組み直し">第11項　ガリが残した「平和への課題：補遺」（要素は入れた／最後に組み直し）</h3>
<p>　ここまでポスト冷戦期の国連の諸活動について振り返ってきた。先にも述べたように、冷戦の終焉は国際政治の力の体系を大きく変容せしめたが、その冷戦の終焉が露見させた集団安全保障機能と役割をめぐる問題の本質はどこにあるのだろうか。この点について、国連事務次長（1945-1986）を長く経験したブライアン・ウルクハルトが興味深い分析を行っている。<br>
　ウルクハルトによれば、安保理は88年から90年ごろまでは集団安全保障機能を果たしていたという[^02_ch02-20]。88年8月にはイラン・イラク戦争を集結させ（安保理決議598号）、また国連事務総長による交渉のイニシアティブに従って88-89年にはソ連軍をアフガニスタンから撤退させることに成功し、さらにナミビアの独立が安保理決議435号の下に90年3月に実現し、またキューバ軍も89年にアンゴラから段階的撤退を始めた。ところが、国連の集団安全保障機能とその役割の順調な回復は90年を境としてむしろ深刻な壁にぶつかることとなった。ウルクハルトの見立てでは、その第一の主要な国際的事件は90年8月に勃発したイラクによるクウェート侵攻であり、第二に民族間対立の紛争を契機とした既成の国家内あるいは旧主権国家内に起こる深刻な武力闘争の多発であり、まさにソマリア、旧ユーゴスラビアやルワンダといった事例がこれにあたる。<br>
　95年の国連とくに安保理が問われている、集団安全保障機能に関わる問いは以下の2つに大別される。①国連の集団安全保障機能とその役割が、強制措置を司る憲章第7章の予定・期待する通りに果たして冷戦後作動しているかどうか。②国連は国家間（between states）の侵略行為や紛争を抑止および終結させるばかりではなく、国家国境の内部（within the borders of states）で発生する紛争とそれに伴って発生する人権抑圧などに介入するべきなのか、そしてそうなのであればこれらを解決するために、どのような対応が求められるのか。<br>
　まずは第1の問題についてから。イラクによるクウェート侵攻に対する国連の対応については既述のとおりなので軽く振り返るに留める。安保理はクウェート侵攻が始まった1990年8月2日から、計12もの安保理決議を採択したものの、11月29日の678号決議（「イラクが91年1月15日までに撤退しない場合、（中略）あらゆる必要な手段を講ずることを国連加盟諸国はクウェート政府と協力して行う」ことを認める）に至ると、憲章第7章の諸条件・諸規定からますます逸脱することとなった。91年1月になって派遣された多国籍軍は、名実ともに憲章第7章が定める国連軍ではなかった。当時の国連事務総長であったデクエヤルは、この多国籍軍が憲章第7章第42条の形式をとって作られた強制力の行使ではなかった事実を強調し、湾岸戦争は「集団的外交の驚くべき失敗」とまで述べた。この経験が、冷戦終焉後の国際政治および国際関係の中で国連の予定し期待する「国連軍」ないし常設される平和維持軍が創設されるべきではないか、との問題意識と再提案につながっているのである。また、（ここからちょこっと経済制裁の話）<br>
　そもそも集団安全保障とは、「いずれか特定の国家に対するいずれか特定の国家による侵略的かつ非合法的な武力行使は、すべての国々の連合した力によってこれを排除する」ものとの前提及び仮定に立っている。ここにおいて、普遍的な意味における集団安全保障は、歴史上の軍事同盟と異なるばかりでなく、力の均衡システムとも異なっている。力の均衡システムが不当なパワーに向けられた国々の共同行動であるのに対し、集団安全保障は明らかに侵略行為に対抗する共同行動として位置づけられているからである。安保理がその集団安全保障を効果的に機能させ、実効的な強制行動を行うためには、安保理の「民主性」と行動の「一貫性」が求められるのはこれまで繰り返したとおりである。だがその集団安全保障体制は、国連において創設当初から明らかに不十分な構造のまま放置され、理想的な強制行動の運用からほど遠い現実に置かれているのである。また、この本質的な問題点は国内紛争に対して行われた強制行動についても同様でなのであり、旧ユーゴに対して行われた経済措置については、〜〜であり、旧ユーゴに加えソマリアに対する軍事的な強制措置についても、〜〜であったのはすでに述べたとおりである。</p>
<table class="caption-top table">
<colgroup>
<col style="width: 100%">
</colgroup>
<thead>
<tr class="header">
<th>「平和への課題：補遺」　A/50/60-S/1995/1　1995/1/3</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Ⅲ. 平和と安全保障のための手段 E. 制裁 67　安全保障理事会によるこの措置の利用の大幅な増大は、特に制裁の目的、その適用と影響力とその意図せぬ影響の監視に関連した多数の困難に光を当てた。 68　　特定の制裁措置が課される目標は、必ずしも常に明確に定義されるわけではない。実際、それが時間とともに変化することもあるように思われる。その不明確性と可変性の組合せは、安全保障理事会がその目標がいつ達成したと見なされ、いつ制裁を解くかについて合意するのを難しくしている。理事会は司法機関ではなく、政治機関であることを認識しながら、制裁を課すと決定する場合に同時にその目的が達成されたことを決定するための客観的な基準を定めることが重要である。有効な手段としての制裁の利用への全般的支持が保たれるためには、制裁を課す目的が政治行動の是正でなく、懲罰であるという印象や、制裁を課す当初の決定の動機となった目的以外のものに資するために基準が変化するという印象を与えることを避けるよう配慮すべきである。 69　制裁と部分的地域機関の適用を監視する方法について国連が得た経験は、一部の事例ではこれに関して役割を演じうる。しかしながら、この任務は、主権や経済的利害による、自国やその国民によるいわゆる違反の国際的監視または国際的調査の展開を受け入れることに対する政府の抵抗によって複雑化される。制裁の影響を評価することは、そのような測定に固有の複雑さと対象国への進入に対する制限のゆえに、さらに難しい。 70　一般的に認識される制裁は妥協を許さない直裁的な手段である。それは対象国の弱者集団を苦しめることが、弱者集団の窮状によってその行動が影響されそうもない政治指導者に圧力をかける妥当な手段であるか否かという倫理問題を提起する。制裁はまた、意図せぬ望ましくない影響を常に伴う。それは人道的援助機関にある種の物資供給を拒んだり、必要な適用免除を得るための煩雑な手続きを強いることによって、これらの機関の活動を複雑化する。それは国連の開発目標と対立し、対象国の生産力を長期的に損なうこともある。また、対象国の近隣国や主な経済的パートナーに深刻な影響を与えうる。さらに、国連に象徴される国際社会に反発する愛国的対応を引き起こすことや、制裁がその行動を是正しようとする指導者の背後に人々を結集させることによって、それ自体の目的が挫折する場合もある。</td>
</tr>
<tr class="even">
<td>F. 実施行動 80　ここ数年間の経験は、安全保障理事会が実施任務を加盟国グループに委ねた場合に得られる価値と生じうる困難を明らかにしている。肯定的な面では、この取り決めは国連に対し、それ以外では得られない実施能力を与えるし、国連に無関係な加盟国による一方的な武力行使よりも望ましい。他方、この取り決めは国連の偉大さと信頼性に否定的影響を及ぼしうる。また、安全保障理事会が関連国に権限を付与するとき、実際には理事会が想定していなかった武力行動の承認と国際的合法性を関連国が主張する危険性もある。そのような権限を付与された加盟国は、最近の活動で、自らの活動に関して安全保障理事会に対しより十分かつより定期的に報告している。 国際連合広報センター訳（非公式訳）</td>
</tr>
</tbody>
</table>
<p>　そして第2の問題について移る。ポスト冷戦下における主要な変化の中でも象徴的なのが、人種や民族、また宗教を異にするエスニック紛争が国家国境の内部において多発したことであり、国連にとっての新たな困難なハードルとして現れたことである。国家間戦争の伝統的な紛争原因は資源や領土であったが、国家内紛争は自治権の要求にとどまらず、民族自決権行使による独立国家樹立まで視野に入れた泥沼の闘争に発展する事例も多く、国際的な調停や仲介による解決を困難にしている。冷戦の終焉は多くの弱小国家が自国の存続のために必要としてきた東西両陣営からの様々な支援を取り除き、これら多くの国で悲惨な戦争が開始された。経済的支援を失ったこれらの諸国は、国内経済の衰退がはじまり、通貨の崩壊、マーケットの喪失とともに失業者が急増し、これらすべてが社会的不安定の要因となる。こうした社会的不安定により、これまで共存していた国民が民族、部族、宗教などを核としたさらに小さい集団に分化するようになり、些細なことがきっかけとなって他の集団と武力抗争の状態をもたらすようになったのである。このような武力闘争では、組織的な重火器による戦闘が行われるのではなく、冷戦後の国際社会で安価に入手できる小火器、軽迫撃砲、地雷などの武器が使用されるのが一般的である。さらに民兵、軍閥、組織犯罪者、一般の犯罪者などによる武力闘争は軍事行動と犯罪行為の区別が困難であり、その責任範囲についても不明確となる。また被害者は圧倒的に一般住民の割合が高く、90年代には女性と子供を中心とした非戦闘員が被害者全体の過半数以上を占めたといわれる。また、紛争の激化とともに十院は自宅抗菌状態となり、伝染病、環境災害、飢饉などの人道的な緊急状態が発生する。そしてしばしば大量の住民が難民となって国外に流出するのである。<br>
　このような国内紛争が多発していることをまさに反映してPKOが90年代に入って増加している。ガリ事務総長は「平和への課題：補遺」において、PKOが92年1月以降の11の事例のうち、実に9個の事例（82％）が国内紛争に関わるものであること、しかもその中で近年はボスニア紛争に国連の対応の苦悩がみられるとしている。なぜ苦悩なのかという点においては、以下のようなエスニック紛争の問題点があげられる。①正規軍のみならず武装市民やゲリラが参加している事から多数の市民が攻撃の標的となって犠牲者となること。②その結果人道上の救援が緊急課題となるにもかかわらず、紛争当事国の法と秩序はほぼ崩壊している事から緊急事態に実効的な対応をできなくなっていること。③国連自体が人道上の救援目的といっても十分な軍事力を紛争地域に容易に派遣しがたくなっていること。の3つである。<br>
　旧ユーゴの場合では、国家そのものが複雑多様な民族・言語・宗教から構成されていた。長く「国家としてのアイデンティティー・クライシス」を内在させていた事に疑いはない。しかし92年以降のボスニア紛争の継続的な危機には、60年代以降の共産主義体制による集権化政策が結局失敗を余儀なくされたこと、また80年代終わりのソビエトの崩壊や東欧革命の発生が旧ユーゴの政治体制に影響を与えたことのみに帰すことはできない。その理由の中には、「最近になって自由独立を獲得したマイノリティーが今度は彼らの新たな共和国にある別のマイノリティー集団を差別し殺す」といった恐るべき事態、すなわち民族浄化のために少数民族を暴力で抹殺する民族的ナショナリズムが日常化している現実がある。</p>
<table class="caption-top table">
<colgroup>
<col style="width: 100%">
</colgroup>
<thead>
<tr class="header">
<th>「平和への課題：補遺」　A/50/60-S/1995/1　1995/1/3</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Ⅱ. 量的・質的な変化 9　活動の量の増大（PKOの増加）は、たとえ活動の性質が変化していなくても、国連に重圧を課していただろう。しかしながら、活動の性質が変化しなかったわけではない。量的変化よりもさらに大幅な質的変化が見られたのである。 10　一つは、今日の紛争のきわめて多くが国家間のものでなく、国家内のものであるという事実である。冷戦の終結は、旧ソ連や他の国々における紛争を抑えていた制約を取り除いた。その結果、新興独立諸国のなかで戦争が頻発しており、その多くは宗教的性格や民族的性格を帯び、例をみないほどの暴力や残虐さを伴っている。冷戦の終結はアフリカにおける同様の戦争の勃発にも寄与したように思われ、国内で冷戦によって煽られた代理戦争は依然として未解決である。対照的に、国家間の戦争は稀な出来事になっている。 11　1988年前半に存在した5つの平和維持活動のうち、4つは国家間の戦争に関するものであり、1つだけ（全体の20%）が国家内戦争に関するものであった。それ以降設けられた21の平和維持活動のうち、国家間戦争に関するものはわずか8つであったのに対し、国家内戦争に関するものは13（62%）であった。ただし、その一部は、特に旧ユーゴスラビアにおける活動は、国家間規模でもあった。1992年1月以降設けられた11の平和維持活動のうち、2つ以外はすべて（82%）が国家内戦争に関するものであった。 国際連合広報センター訳（非公式訳）</td>
</tr>
</tbody>
</table>
<p>　そして問題とされたのは、直近のPKO活動において強制力を導入する現象がみられることである。冷戦後のPKOには大国が積極的に参加するようになったが、これらの大国（とりわけ西側）の議論には、PKOがより効果的になるには強制力によって支えられねばならないという考えがあり、PKOの改善策として伝統的諸原則の見直しの必要性を説く傾向があった。ガリ事務総長も「平和への課題」における「平和強制部隊」の提案においてみられるように、いわゆる「拡大PKO（expanded peace-keeping）」の名の下にこのような考えを提唱したことがある（ニューヨーク大学での事務総長の演説にて）。そしてPKOと強制行動を結びつける考えは特に内戦型の紛争について主張され、また「人道的干渉」理論によって正当化されたことにより、ソマリアや旧ユーゴへの国連介入で現実に適用されたのである。<br>
　しかしポスト冷戦期に実施された強制行動には、民族や部族を当事者としたいわゆるエスニック紛争に対し、難民・避難民の保護や人道援助の安全確保などの人道的必要性を根拠として発動されたものが少なくなかった。非人道的手段による他集団の排除・壊滅が紛争の実体をなしてしまっている時、人道目的の強制行動といえども必然的に紛争そのものへの介入とならざるを得ず、また紛争そのものの解決なくして非人道的行為をやめさせることも困難である。国連自身が紛争当事者と見做されて攻撃の対象とされる一方、紛争そのものへの介入を授権されていないため、人権・人道保護の目的を達成し得ないというジレンマに陥ることとなる。</p>
<table class="caption-top table">
<colgroup>
<col style="width: 100%">
</colgroup>
<thead>
<tr class="header">
<th>「平和への課題：補遺」　A/50/60-S/1995/1　1995/1/3</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Ⅱ. 量的・質的な変化 18　第2の質的変化は、人道的援助活動を保護するための国連軍の利用である。人道的援助機関は、戦争の文民犠牲者が生じた場合にはつねに彼らに援助を提供するよう努めている。あまりにしばしば、交戦当事者が彼らの活動を困難にしたり、不可能にしたりする。これの理由は、戦争の必然性である場合もあるが、特定集団の援助はいずれかの当事者の戦争目的に反することが理由である場合のほうが多い。戦闘員が援助物資を自らのために流用する傾向も強まっている。戦争が国家内紛争なので、人道的援助機関はしばしば上述の混沌とした無法な状況において任務を遂行しなければならない。そのような事例の全部ではないが、一部では、結果的な惨事が世界中のテレビ画面に映し出され、国連が人道的援助活動を促進し、保護するために部隊を展開することを求める政治的圧力を生じさせる。そのようなイメージは人道的援助行動への支持を確立する一助となりうるが、また、効果的な意思決定をはるかに難しくする情緒的環境を創り出す。 19　これはボスニア・ヘルツェゴビナやソマリアにおける新たな種類の国連活動を生じさせた。たとえ武力行使が憲章第7章に基づき承認されても、国連は侵略者(確認されれば)に攻撃中止を命じたり、休戦を強要することなく、交戦当事者間で中立かつ公平な立場を保つ。これも従来の平和維持ではない。なぜなら、交戦状態は続行しており、平和維持使命が基礎としうる交戦当事者間の協定が存在しないことが多いからである。ボスニア・ヘルツェゴビナにおける「安全地帯」の概念は、同様の事例である。それは国連に対し、武力行使を承認させる人道的援助使命をもたらすが、それは限られた局所的な目的であり、戦争を終結させるものではない。 Ⅲ. 平和と安全保障のための手段 B. 平和維持 35　いずれの事例（ソマリアとボスニア・ヘルツェゴビナのこと）でも、既存の平和維持活動は武力行使を要求する追加使命を与えられており、したがって、当事者の同意、公正性および武力の非行使を要求する既存の使命と組み合わせることはできない。また、旧ユーゴスラビアの事例のように、利用可能であったよりもはるかに強い軍事能力なしでは、それは遂行が不可能であった。現実には、既存の構成、軍備、兵站支援および配備がそれを用いる可能性を否定する場合に武力を行使するよう要請すること以上に平和維持活動にとって危険なことはない。平和維持の論理は、実施についてとはまったく違う政治的・軍事的前提から発しており、後者の力学は平和維持が促進しようとする政治的過程とは相容れない。この二つの違いを曖昧にすることは、平和維持活動の実行可能性を損ない、その要員を危険にさらすことになる。 36　国際問題は速やかに限られた時間内で解決することができない。国連が解決するよう求められている紛争には通常、深い根があり、他者の平和創造努力を拒んできたものである。その決議は、辛抱強い外交と、信頼を築いて積年の差異への交渉された解決策を長期的に可能にする政治過程の確立を要求している。そのような過程はしばしば不満と後退に遭遇し、ほとんど必然的に希望したよりも長くかかる。それをスピードアップするために軍事力を行使したいという誘惑に耐える必要がある。平和維持と武力行使(自衛以外の)は、代替手法と見なされるべきで、あるものから別のものへの容易な移行を可能にする1つの連続体の隣接点と見なしてはならない。 国際連合広報センター訳（非公式訳）および一部改訳</td>
</tr>
</tbody>
</table>
<p>　このようにしてみてみると、ガリ事務総長が、奇しくもボスニア・ヘルツェゴビナ紛争やソマリア紛争が顕在化する時期に発表した1992年の「平和への課題」の一連の政策提案には、その後の国内型紛争の深刻さから、再検討すべき課題が少なくなかったことがわかる。第3項でも述べたように、「平和への課題」で問われるべき論点は、「平和創造」と「平和維持」の間に、軍事力の行使の「中間領域」を設定し、新たに「平和強制部隊」 の構想を打ち出したことの適否、ないし可否の点である。 別言すると、ガリ事務総長は、国連が憲章第43条に基づく部隊、すなわち国連軍は当分の間実現しないと予想した上で、国連が「停戦を回復、維持するために」現地に強制力を投入することが必要となる事例を考えて、平和維持軍よりも重装備の「平和強制部隊」の利用を国連加盟諸国に提案したわけであるが、この提案がポスト冷戦下の国連の新たな国際安全保障機能と役割の強化を目ざす上で、妥当であったのか否かであったのか、といった課題である。<br>
　事実、95年にガリ事務総長によって出された「平和への課題：補遺」では、以下のようにして「平和強制部隊」の構想ではなく、新たに「緊急対応部隊」という提案を行なっている。</p>
<table class="caption-top table">
<colgroup>
<col style="width: 100%">
</colgroup>
<thead>
<tr class="header">
<th>「平和への課題」　A/47/277-S/24111　1992/6/17</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Ⅳ. 平和創造 平和強制部隊 44　第43条に基づく部隊の任務は、差し迫ったあるいは現実の、公然たる侵略に対応することにある。このような部隊はまだ当分の間、実現はしないことだろう。停戦が合意されても守られないことはしばしばであり、国連はこれまでも時折、停戦を回復、維持するために部隊を派遣するよう要請されてきた。この任務は折にふれ、平和維持軍の任務や、平和維持軍に兵力を提供する諸国の期待を上回ることがありうる。私は安全保障理事会が、明確に定義された状況においては、その委任事項を事前に明記したうえで、平和強制部隊の利用を考慮するよう勧告する。加盟国から提供されるこの部隊は常時出動可能な態勢をとり、この種の任務に志願した部隊で構成されるものとする。この部隊は平和維持軍よりも重装備のものでなければならず、各国の軍隊で広範囲な準備訓練を受ける必要がある。部隊の展開と活動は安全保障理事会の権限に属し、平和維持軍の場合と同様、事務総長の指揮下に入ることになる。このような平和強制部隊は、憲章第40条が定める暫定措置として正当化できると私は考えている。この平和強制部隊を、侵略行為に対処するために第43条に基づいていずれ設置されるかもしれない兵力や、平和維持活動に貢献できるよう各国が待機態勢に置くことに合意するかもしれない軍事要員と混同してはならない。 45　外交が本報告書で取り上げるすべての活動において継続的に行われているのと同様、平和創造と平和維持の間にも、境界線はやはり存在しないかもしれない。国連軍の現地への展開が紛争防止の可能性を拡大し、平和創造活動を促進し、平和建設の必要条件として役立つ場合が多いことでも明らかなように、平和創造は平和維持の前奏曲であることが少なくない。</td>
</tr>
<tr class="even">
<td>「平和への課題：補遺」　A/50/60-S/1995/1　1995/1/3</td>
</tr>
<tr class="odd">
<td>Ⅲ. 平和と安全保障のための手段 B. 平和維持 44　このような状況下で、私は国連は迅速な緊急対応部隊というアイデアを真剣に考える必要があるという結論に達した。そのような武力は、平和維持部隊の緊急の必要性がある場合に、安全保障理事会の戦略的な展開予備部隊となるであろう。それは多数の国の兵から成る歩兵大隊規模のもので構成することもできる。これらの隊は、同一の基準で訓練され、同一の活動手続きを行い、統合された通信機器を備え、定期的な間隔で合同演習を行う。これらの隊は各母国に駐留するが、いつでも必要に応じられる水準に保たれる。この取り決めの価値は当然ながら。この武力が実際に緊急時に利用可能であるよう安全保障理事会ができるかどうかにかかっている。これは複雑で高費用の取り決めだが、私は時がそれを可能にすると信じている。 45　装備と十分な訓練は、懸念が強まっているもう一つの領域である。原則は、部隊提供国政府が自国の部隊が活動に必要な装備を十分にそなえて到着するようにすることである。しかしながら、加盟国はますます必要な装備と訓練を備えていない部隊を提供するようになっている。代替がなければ、逼迫する国連は市場で装備を調達するか、他の加盟国からの自発的拠出によって装備を入手しなければならない。当該部隊が装備の使用法を学ぶにはより一層時間がかかり、それは彼らが初めて遭遇する装備であることが多い。この問題への対処法は多数考えられており、例えば、しばしば提唱されているとおり、標準的な平和維持装備の予備ストックの国連による設置と、装備を必要とする政府とそれを提供する用意のある政府との協力である。 46　最近の経験から得られた別の教訓は、特に困難な状況下に置かれた平和維持活動は効果的な情報能力を要することである。これは平和維持活動の使命をその人民に説明できるようにし、信頼できる公平な情報源を提供することで、当事者自身によっても配布される誤った情報に対抗できるようにする。無線はこのために最も効果的な媒体である。無線を含め情報能力が提供されている活動では、たとえ夜遅くでも、活動の成功に計り知れないほど貴重な貢献をすることが認識されている。私は将来の活動の立案において、情報能力の必要性が初期段階で検討され、必要な資源が予算案に含められるべきであると指示した。 国際連合広報センター訳（非公式訳）および一部改訳</td>
</tr>
</tbody>
</table>
<p>　なお、最近のPKOは「包括的和平協定」の実施段階で活用されるものが多くなったことを忘れてはならないだろう。これは国連による平和実現の努力が実を結んで、当事者間に包括的和平協定が成立し、そこでは紛争の軍事的収拾のみならず政治的解決を含む紛争の最終的決着に至る過程について合意ができ、武力紛争の軍事的収拾段階（停戦、兵力引き離し、非武装化）のみならず、政治的解決への過程（難民、人権活動、治安維持、行政機構の債権、選挙の実施）までのレールが敷かれており、PKOはその過程の中に組み入れられ、その実施を円滑に促進する役割を担うのである。この種の複合化現象は、「第二世代のPKO」と呼ばれることがある。複合化したPKOの典型例として、ナミビア（UNTAG）やカンボジア（UNTAC）、規模が小さくはなるが西サハラ（MINURSO）、アンゴラ（UNAVEM）、エルサルバドル（ONUSAL）、モザンビーク（UNUMOZ）での国連活動を挙げることができ、これらの活動については成功を収めた。</p>
<table class="caption-top table">
<colgroup>
<col style="width: 100%">
</colgroup>
<thead>
<tr class="header">
<th>「平和への課題：補遺」　A/50/60-S/1995/1　1995/1/3</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Ⅱ. 量的・質的な変化 20　第3の変化は、現地での国連活動の性質におけるものである。冷戦時代、国連平和維持活動は主に軍事的な性質のもので、通常は停戦の後だが、当該紛争調停交渉の前の時期に展開された。実際、その主要目的の1つは、調停交渉が起こりうる状況を創り出すことであった。1980年代後半、新種の平和維持活動が現れた。それは交渉が成功したのちに設けられ、当事者が交渉した総合的解決を実施するのを手助けする使命を帯びている。そのような活動はナミビア、アンゴラ、エルサルバドル、カンボジア、モザンビークで展開された。ほとんどの事例で顕著な成功を収めている。 国際連合広報センター訳（非公式訳）</td>
</tr>
</tbody>
</table>
<p>（　事実、ガリ事務総長の「平和強制部隊」構想は、少なくとも、以下の3つの点で難点ないし問題をかかえていた。①このような「平和強制部隊」の構想が、民主的な意思の形成に基づいて提唱されているかどうかが担保されていないこと。②「平和強制部隊」が加盟諸国から提供される志願による重装備の部隊であるといっても、軍事力の規模や質について国連事務局が専権的に決められるかどうか、「平和強制部隊」が事務総長の指揮下に入る場合、とくに志願する国々の「軍事主権」との関係について、あらかじめ議論がないまま提案されていること。③ガリ事務総長は、この「平和強制部隊」について、「侵略行為に対処するために第43条に基づいていずれ設置されるかもしれない兵力や、平和維持活動に貢献できる各国が待機態勢に置くことに合意するかもしれない軍事要員と混同してはならない」と述べているが、「平和強制部隊」と「国連軍」との関係を具体的にはどのようにするのか、暫定的措置のみに議論が集中していること。 別言すると、第3の問題は、ガリ事務総長が、「安全保障理事会が憲章第43条に基づき、軍事参謀委員会によって指示された交渉を開始するよう勧告する」とし、次いで「軍事参謀委員会は憲章第47条第2項に基づき、必要とあれば他の加盟国の参加を求めて増強することができる」と述べたものの、「平和への課題」では、第43条に基づく部隊、「国連軍」は当分の間実現しないとの判断に立って、国連の「集団安全保障体制」の根幹にかかわる重要課題をむしろ後回しにしたことにある。ポスト冷戦期における国連の集団安全保障の性格及び体制の論点については、根本的な問題は触れずじまいのままである。）</p>
<p>　こうした90年代前半に国連が行った、目的や方法が不明瞭な強制措置に伴う失敗や、「平和への課題」に記された国連による平和維持方針の諸機能の概念が混乱を招いたことらの反省から、95年1月にガリ事務総長によって提出された事務総長報告書「平和への課題：補遺」では、平和と安全の諸手段について、概念の再構成が行われた。そこでは、国連がこれまで国際紛争処理のために編み出した諸手段を2つに大別している。<br>
　1つは、①防止外交と平和創出（preventive diplomacy and peace-making）、②平和維持（peace-keeping）、③紛争後の平和建設（post-conflict peace-building）の3つである。2つ目は、①制裁（sanction）、②平和強制（peace-enforcement）ないし強制措置（enforcement action）である。このうち最初の3つはいずれも紛争当事者の同意を得てのみ実施されるのに対し、後の2つは強制手段としての性格上、関係国の同意は不要であるとする。</p>
<table class="caption-top table">
<colgroup>
<col style="width: 100%">
</colgroup>
<thead>
<tr class="header">
<th>「平和への課題：補遺」　A/50/60-S/1995/1　1995/1/3</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Ⅲ. 平和と安全保障のための手段 23　国連は、国家間および国家内の紛争を管理し、解決するための一連の手段を設けている。そのうち最も重要なのは、予防外交と平和創造、平和維持、平和建設、軍縮、制裁、そして平和実施である。初めの三つは紛争当事者の同意が得られた場合に限って用いることができる。一方、制裁と平和強制（enforcement）は強制措置（coercive measures）であるので、定義により、関係当事者の同意を必要としない。軍縮は合意に基づき、もしくは憲章第7章に基づく強制的行動に関連して行うことができる。 国際連合広報センター訳（非公式訳）および一部改訳</td>
</tr>
</tbody>
</table>
<p>　以上の分類によって、諸概念が伝統的な定義に回帰し、「平和への課題」でみられた概念の混乱が回避された。それぞれ、①「予防外交」は「平和への課題」ではPKOの予防展開や非武装地帯の設置といった軍事的措置を含む広い概念であったが、「平和への課題：補遺」では「平和創造」の一貫をなす措置として位置づけられていること。②「平和創造」は、憲章第6章にある紛争の平和的解決のための外交的努力という伝統的概念に戻されていること。③「平和維持」は当事者の同意を前提とする活動であることが確認されたこと。④「平和強制」は憲章第7章の “enforcement action” （強制行動）と同じものであること。「平和への課題：補遺」では「平和の強制」と「強制措置」は互換的に用いられており、 enforcement は coercive measures と同義語であることが明確にされた。</p>
<table class="caption-top table">
<colgroup>
<col style="width: 100%">
</colgroup>
<thead>
<tr class="header">
<th>「平和への課題：補遺」　A/50/60-S/1995/1　1995/1/3</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Ⅲ. 平和と安全保障のための手段 A. 予防外交と平和創造 26　　早期警報、健全な外交、そして一部の事例では予防外交を通じて紛争を防止することのほうが、紛争が発生したのちにそれを解決するために大きな政治的・軍事的努力を引き受けなければならないことよりも明らかに好ましい。安全保障理事会の1992年1月31日の宣言 (国連文書S/23500)は、私に対し、予防および平和創造活動を優先するよう命じた。私はそれに従って、従来は事務局の様々な部局で行われていた一連の政治的機能を扱う政治問題局を設置した。同局はそれ以降、連続的に構造変革の経過をたどってきて、現在は世界中の政治的展開をフォローするようになっているので、差し迫った紛争の早期警報を発し、国連による予防行動の可能性と既存の紛争を解決するのに役立つ行動の可能性について分析することができる。 27　経験は、これらの努力における成功への最大の障壁が、広く認められているとおり、情報、分析能力、および国連のイニシアチブについてのアイデアの欠如ではないことを明らかにしている。成功はしばしば、いずれかの当事者が国連の助力を受け入れたがらないことで最初から遮られる。これは国家間紛争についても国家内紛争についても当てはまる。たとえ前者に対する国連の行動が憲章の範囲内であるのに対し、後者の事例は憲章第2条第7項でもって解決されなければならないとしても、そうである。</td>
</tr>
<tr class="even">
<td>B. 平和維持 33　国連は、冷戦の終結の結果生じた新たな政治環境に対応して平和維持が展開されたスピードを誇ることができるが、ここ数年、平和維持のいくつかの基本的原則の尊重がその成功に不可欠であることを確認している。三つの特に重要な原則は、当事者の同意、公平性、そして自衛以外の武力の非行使である。最近の成功と失敗についての分析は、成功した場合はみなこれらの原則が尊重されており、あまり成功しなかった活動では尊重されていないことを明らかにしている。 34　特に平和維持活動を率いてきた近年の使命の三つの側面があり、それは当事者の同意を失うこと、不公平だと思われるふうに振る舞うこと、および/または自衛以外に武力行使することである。これらは戦闘継続中に人道援助的活動を保護し、指定された安全地帯において文民を保護し、国民和解を受け入れ準備が整うよりも速いペースで達成するよう当事者に迫る任務であった。ソマリアとボスニア・ヘルツェゴビナの事例はこの点で教訓的である。 35　いずれの事例（ソマリアとボスニア・ヘルツェゴビナのこと）でも、既存の平和維持活動は武力行使を要求する追加使命を与えられており、したがって、当事者の同意、公正性および武力の非行使を要求する既存の使命と組み合わせることはできない。また、旧ユーゴスラビアの事例のように、利用可能であったよりもはるかに強い軍事能力なしでは、それは遂行が不可能であった。現実には、既存の構成、軍備、兵站支援および配備がそれを用いる可能性を否定する場合に武力を行使するよう要請すること以上に平和維持活動にとって危険なことはない。平和維持の論理は、実施についてとはまったく違う政治的・軍事的前提から発しており、後者の力学は平和維持が促進しようとする政治的過程とは相容れない。この二つの違いを曖昧にすることは、平和維持活動の実行可能性を損ない、その要員を危険にさらすことになる。 36　国際問題は速やかに限られた時間内で解決することができない。国連が解決するよう求められている紛争には通常、深い根があり、他者の平和創造努力を拒んできたものである。その決議は、辛抱強い外交と、信頼を築いて積年の差異への交渉された解決策を長期的に可能にする政治過程の確立を要求している。そのような過程はしばしば不満と後退に遭遇し、ほとんど必然的に希望したよりも長くかかる。それをスピードアップするために軍事力を行使したいという誘惑に耐える必要がある。平和維持と武力行使(自衛以外の)は、代替手法と見なされるべきで、あるものから別のものへの容易な移行を可能にする1つの連続体の隣接点と見なしてはならない。</td>
</tr>
<tr class="odd">
<td>F. 実施行動 77　国連憲章の達成の一つは、平和への脅威、平和の侵害、または侵略行為に責任を負う者に対する実施行動をとる権限を国連に与えたことである。しかしながら、安全保障理事会も事務総長も現在は、おそらく非常に限られたスケールのものを除いて、活動を展開し、指示し、指揮し、管理する能力を持たない。私は、国連がそのような能力を長期的に養成することが望ましいと考えているが、国連の資源が不足し、以前ほど求められていない平和創造および平和維持について委ねられた責任に取り組むよう強いられているこの時期にそれを試みるのは愚行であろう。 80　ここ数年間の経験は、安全保障理事会が実施任務を加盟国グループに委ねた場合に得られる価値と生じうる困難を明らかにしている。肯定的な面では、この取り決めは国連に対し、それ以外では得られない実施能力を与えるし、国連に無関係な加盟国による一方的な武力行使よりも望ましい。他方、この取り決めは国連の偉大さと信頼性に否定的影響を及ぼしうる。また、安全保障理事会が関連国に権限を付与するとき、実際には理事会が想定していなかった武力行動の承認と国際的合法性を関連国が主張する危険性もある。そのような権限を付与された加盟国は、最近の活動で、自らの活動に関して安全保障理事会に対しより十分かつより定期的に報告している。 国際連合広報センター訳（非公式訳）および一部改訳</td>
</tr>
</tbody>
</table>
<p>　冷戦の解消は、国連が平和維持の分野で陥った機能障害の真の理由を浮き彫りにした。機能不全の原因はこれまで広く語られてきたような「東西対立」だけに帰せられるものではなく、より根本的な原因の存在を知らしめたのである。世界平和実現のために国連の持つ諸手段は、いずれも「万能薬」ではない。それぞれに制度としての長所と短所があり、限界がある。問題はこれらの制度をいかに有効に働かせるかであり、それは関係国がこれらをいかに活用するかにかかっている。</p>
<p>（第二次国連ソマリア活動（UNOSOMⅡ）を除き、軍事的強制措置は全て加盟国に武力行使を授権するという形で実施されている。憲章43条にいう特別協定が締結されていない状況の中、加盟国の自発的に提供する兵力を使用することになっても、それ自身は必ずしも集団安全保障の原理に反するものではない。しかし、それが強制措置という公的な行動とみなされるためには、国連による指揮・監督・統制の下で実施されることが不可欠な条件である。ところがこの時代に行われた武力行使の授権では、国連に指揮権がないのはもちろん、監督・統制の体制も極めて不十分であった）</p>
</section>
</section>
<section id="参考文献" class="level2">
<h2 class="anchored" data-anchor-id="参考文献">参考文献</h2>
<p>香西 茂　『国連の平和維持活動』　有斐閣　1991年</p>
<p>西川 吉光　『紛争解決と国連・国際法』　晃洋書房　1996年</p>
<p>篠田 英朗　「国際規範の歴史的・理論的検討　——秩序・正義そして国家主権」</p>
<p>筒井 若水　「集団安全保障と安全保障理事会の役割」</p>
<p>香西 茂　「ポスト冷戦期における国連の役割」</p>
<p>香西 茂　「国際連合の紛争処理機能の動向」</p>
<p>香西 茂　「国連と世界平和の維持　——五〇年の変遷と課題」</p>
<p>鴨 武彦　「ポスト冷戦下の国際連合　——国際安全保障機能および役割の変化と改革構想」</p>
<p>鴨 武彦　「冷戦後の安全保障と国連　——理論的考察」</p>
<p>松田 竹男　「国際連合の集団安全保障　——その歴史、現状、課題」</p>
<p>酒井 啓亘　「国連平和維持活動の今日的展開と原則の動揺」</p>
<p>土屋 茂樹　「勢力均衡政策と集団安全保障」</p>
<p>松葉 真美　「国連平和維持活動(PKO)の発展と武力行使をめぐる原則の変化」</p>
<p>高井 晉　「紛争解決支援と軍事力の役割」</p>
<p>B. Boutros-Ghali, “An Agenda for Peace”, United Nations Doc., A/47/277, S/24111, 17 June 1992</p>
<p>B. Boutros-Ghali, “Supplement to an Agenda for Peace”, United Nation Docs., A/50/60, S/1995/1, 3 Jan 1995</p>
<p>Brian Urquhart, “The UN and international Security after the Cold War.” Adam Roberts and Benedict Kingbury (eds.). United Nations, Divided World, Clarendon Press, Oxford, 1994.</p>
<p>B. Boutros-Ghali, “The Papers of United Nations Secretary-General Boutros Boutros-Ghali”</p>
<p>「平和への課題 1995年 - 国際連合広報センター」<br>
<a href="https://www.unic.or.jp/files/peace.pdf">https://www.unic.or.jp/files/peace.pdf</a>　（2025年10月21日閲覧）</p>
<p>[^02_ch02-1] 決議660</p>
<p>[^02_ch02-2] 決議661</p>
<p>[^02_ch02-3] 決議662</p>
<p>[^02_ch02-4] 決議664</p>
<p>[^02_ch02-5] 決議665</p>
<p>[^02_ch02-6] 決議670</p>
<p>[^02_ch02-7] 決議678</p>
<p>[^02_ch02-8] 決議687</p>
<p>[^02_ch02-9] 要出典</p>
<p>[^02_ch02-10] 要出典</p>
<p>[^02_ch02-11] 結果から申し上げれば、新世界秩序の中で求められる国連の役割についてはっきりとした意思統一が国連内でなされることがないまま、95年でも同様の問題意識を抱えた状態で当会議を迎えている</p>
<p>[^02_ch02-12] 要出典</p>
<p>[^02_ch02-13] 要出典</p>
<p>[^02_ch02-14] 要出典</p>
<p>[^02_ch02-15] 要出典</p>
<p>[^02_ch02-16] 要出典</p>
<p>[^02_ch02-17] 「研究摘要」後の基本的に平和維持軍から常任理事国を除く方針は、一部の例外があるものの冷戦期には続けられてきた。しかしUNIKOMをはじめポスト冷戦期においては、各地のPKOに米英仏が積極的に参加するようになった。なお、ロシアは1992年のボスニア・ヘルツェゴビナにて最初のPKO派遣を行い、中国も同年のカンボジアにて最初のＰＫＯ派遣を行った。また、ＵＮＩＫＯＭには最終的に常任理事国のすべての国が参加した。</p>
<p>[^02_ch02-18] 要出典</p>
<p>[^02_ch02-19] 92年12月に安保理はマケドニアへの平和維持軍の展開を決定した。これはマケドニアにおいて武力衝突が発生する恐れがあることからマケドニアの大統領の要請に基づいて派遣されることになったPKOであり、予防展開のリーディングケースとなった。決議７９５。</p>
<p>[^02_ch02-20] ソ連の国連政策転換が大きく影響した。国連創設以来、ソ連は社会主義国が少数派であったことから国連に対しては常に不信感を抱き続け、平和維持活動についてもこれを憲章違反だとして財政的支援を拒否し続けてきた。しかし87年以降、ゴルバチョフの影響でこうした姿勢に変化が生じ、平和維持活動が活性化することとなった。</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "コピーしました");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "コピーしました");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../content/01_ch01.html" class="pagination-link" aria-label="第1章 プロジェクトの概要">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-title">第1章 プロジェクトの概要</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../content/03_ch03.html" class="pagination-link" aria-label="第3章　争点・論点解説">
        <span class="nav-page-text"><span class="chapter-title">第3章　争点・論点解説</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<script>
// Inlined UI script for offline file:// compatibility
// Source: src/js/ui-clean.js (inlined)
(function() {
  'use strict';

const STORAGE_KEYS = {
  tocLocation: 'quarto-toc-location',
  theme: 'quarto-theme',
  fontSize: 'quarto-font-size',
  markers: 'quarto-markers',
  comments: 'quarto-comments',
  scrollPosition: 'quarto-scroll-position',
  rightTab: 'quarto-right-tab',
  readingState: 'quarto-reading-state'
};

  const NAV_DATA_STATE = {
    promise: null,
    data: null,
    rootPrefix: null
  };

  function getRootPrefix() {
    if (NAV_DATA_STATE.rootPrefix != null) return NAV_DATA_STATE.rootPrefix;
    const meta = document.querySelector('meta[name="quarto:offset"]');
    let prefix = meta ? (meta.getAttribute('content') || '') : '';
    if (prefix && !prefix.endsWith('/')) prefix += '/';
    NAV_DATA_STATE.rootPrefix = prefix;
    return prefix;
  }

  function normalizePath(path) {
    const cleaned = (path || '').replace(/\\/g, '/');
    const decoded = decodeURIComponent(cleaned);
    return decoded.replace(/^\/+/, '');
  }

  // =============================
  // 設定リセット系ユーティリティ
  // =============================
  function resetUiSettings() {
    try {
      // 現行UIの表示系
      localStorage.removeItem(STORAGE_KEYS.theme);
      localStorage.removeItem(STORAGE_KEYS.fontSize);
      localStorage.removeItem(STORAGE_KEYS.rightTab);
      localStorage.removeItem('footnotes-sort');
      localStorage.removeItem('comments-sort');

      // 旧UI由来（残っている可能性があるもの）
      localStorage.removeItem('txtSize');
      localStorage.removeItem('theme');
      localStorage.removeItem('tocLocation');
      localStorage.removeItem('scrollPos');
    } catch (e) {
      console.warn('resetUiSettings failed', e);
    }
  }

  function resetMemoSettings() {
    try {
      // マーカー／コメント関連
      localStorage.removeItem(STORAGE_KEYS.markers);
      localStorage.removeItem(STORAGE_KEYS.comments);
    } catch (e) {
      console.warn('resetMemoSettings failed', e);
    }
  }

  function resetPreviewSettings() {
    try {
      // Docs/BG プレビュー関連
      localStorage.removeItem('gdocPreviewMaxToasts');
      localStorage.removeItem('gdocPreviewState_v2');
    } catch (e) {
      console.warn('resetPreviewSettings failed', e);
    }
  }

  function resetAllSettingsHard() {
    try {
      // localStorage 全消去（他サイトのデータは同一オリジン内なので注意が必要だが、
      // このBGビューア専用オリジン前提で、完全リセットとして実装）
      localStorage.clear();
    } catch (e) {
      console.warn('resetAllSettingsHard failed', e);
    }
    try {
      // 読書状態・スクロール状態など sessionStorage 由来のものもクリア
      sessionStorage.clear();
    } catch (e) {
      console.warn('sessionStorage clear failed', e);
    }
  }

  function computeCurrentOutputPath() {
    const currentUrl = new URL(window.location.href);
    let rel = decodeURIComponent(currentUrl.pathname);
    try {
      const rootUrl = new URL(getRootPrefix() || './', window.location.href);
      if (rel.startsWith(rootUrl.pathname)) {
        rel = rel.slice(rootUrl.pathname.length);
      }
    } catch (e) {
      console.warn('computeCurrentOutputPath root resolution failed:', e);
    }
    const outIdx = rel.indexOf('/out/');
    if (outIdx >= 0) rel = rel.slice(outIdx + 5);
    rel = rel.replace(/^\//, '');
    if (!rel) rel = 'index.html';
    if (rel.endsWith('/')) rel += 'index.html';
    return rel;
  }

  function isSamePage(pathA, pathB) {
    return normalizePath(pathA) === normalizePath(pathB);
  }

  function buildHref(pagePath, anchor) {
    const current = computeCurrentOutputPath();
    if (isSamePage(pagePath, current)) {
      return anchor ? `#${anchor}` : '#';
    }
    const prefix = getRootPrefix();
    const base = `${prefix || ''}${pagePath}`;
    return anchor ? `${base}#${anchor}` : base;
  }

  function updateIndexLinksForContext() {
    const currentPath = computeCurrentOutputPath();
    const inContentDir = typeof currentPath === 'string' && currentPath.startsWith('content/');
    const links = document.querySelectorAll('a[data-aj-index-root-href]');
    if (!links.length) return;
    links.forEach(link => {
      const rootHref = link.getAttribute('data-aj-index-root-href');
      const localHref = link.getAttribute('data-aj-index-local-href');
      const target = inContentDir && localHref ? localHref : rootHref;
      if (target) {
        link.setAttribute('href', target);
      }
    });
  }

  function reinforceAnchors(scope) {
    if (!scope || typeof scope.querySelectorAll !== 'function') return;
    const anchors = scope.querySelectorAll('a[href]');
    anchors.forEach(anchor => {
      if (anchor.dataset.ajLinkReinforced === 'true') return;
      anchor.dataset.ajLinkReinforced = 'true';
      const href = anchor.getAttribute('href') || '';
      if (/^https?:\/\//i.test(href)) {
        if (!anchor.getAttribute('target')) {
          anchor.setAttribute('target', '_blank');
        }
        const rel = anchor.getAttribute('rel') || '';
        if (!/noopener/i.test(rel)) {
          anchor.setAttribute('rel', (rel + ' noopener noreferrer').trim());
        }
      }
    });
  }

  function setInlineFootnoteMode(active) {
    const next = !!active;
    if (INLINE_FOOTNOTE_MODE === next) return;
    INLINE_FOOTNOTE_MODE = next;
    if (!INLINE_FOOTNOTE_MODE) {
      hideCommentPopover();
    }
  }

  function ensureCommentMarkerInteractions() {
    const markers = document.querySelectorAll('.text-marker[data-comment-id]');
    markers.forEach(marker => {
      if (marker.dataset.commentMarkerBound === 'true') return;
      marker.dataset.commentMarkerBound = 'true';
      marker.addEventListener('click', handleCommentMarkerClick);
      marker.addEventListener('pointerenter', handleCommentMarkerPointerEnter);
      marker.addEventListener('pointerleave', handleCommentMarkerPointerLeave);
    });
  }

  function handleCommentMarkerClick(event) {
    if (!INLINE_FOOTNOTE_MODE) return;
    event.preventDefault();
    event.stopPropagation();
    const marker = event.currentTarget;
    if (commentPopoverEl && commentPopoverMarker === marker && commentPopoverPersistent) {
      hideCommentPopover();
    } else {
      showCommentPopover(marker, { persistent: true });
    }
  }

  function handleCommentMarkerPointerEnter(event) {
    if (!INLINE_FOOTNOTE_MODE) return;
    if (event.pointerType && event.pointerType !== 'mouse') return;
    const marker = event.currentTarget;
    showCommentPopover(marker, { persistent: false });
    clearCommentPopoverHideTimer();
  }

  function handleCommentMarkerPointerLeave() {
    if (!INLINE_FOOTNOTE_MODE) return;
    scheduleCommentPopoverHide(200);
  }

  function showCommentPopover(marker, opts) {
    if (!marker) return;
    const rec = getCommentRecordById(marker.getAttribute('data-comment-id'));
    if (!rec) return;
    const persistent = !!(opts && opts.persistent);
    clearCommentPopoverHideTimer();
    commentPopoverPersistent = persistent;
    commentPopoverMarker = marker;
    if (commentPopoverEl) {
      commentPopoverEl.remove();
      commentPopoverEl = null;
    }
    commentPopoverEl = document.createElement('div');
    commentPopoverEl.className = 'comment-inline-popover';
    const snippetRaw = (rec.text || '').trim();
    const snippetHtml = snippetRaw ? `対象: ${escapeHtml(snippetRaw.slice(0, 160))}` : '';
    const bodyHtml = escapeHtml(rec.body || '').replace(/\n/g, '<br>');
    commentPopoverEl.innerHTML = `
      ${snippetHtml ? `<div class="comment-inline-popover__snippet">${snippetHtml}</div>` : ''}
      <div class="comment-inline-popover__body">${bodyHtml || '<em>コメント内容がありません。</em>'}</div>
    `;
    commentPopoverEl.addEventListener('pointerenter', clearCommentPopoverHideTimer);
    commentPopoverEl.addEventListener('pointerleave', () => scheduleCommentPopoverHide(200));
    document.body.appendChild(commentPopoverEl);
    positionCommentPopover(marker);
  }

  function hideCommentPopover() {
    clearCommentPopoverHideTimer();
    if (commentPopoverEl) {
      commentPopoverEl.remove();
      commentPopoverEl = null;
    }
    commentPopoverMarker = null;
    commentPopoverPersistent = false;
  }

  function scheduleCommentPopoverHide(delay) {
    if (commentPopoverPersistent || !commentPopoverEl) return;
    clearCommentPopoverHideTimer();
    commentPopoverHideTimer = window.setTimeout(() => {
      hideCommentPopover();
    }, delay || 0);
  }

  function clearCommentPopoverHideTimer() {
    if (commentPopoverHideTimer) {
      clearTimeout(commentPopoverHideTimer);
      commentPopoverHideTimer = null;
    }
  }

  function positionCommentPopover(marker) {
    if (!commentPopoverEl || !marker) return;
    const rect = marker.getBoundingClientRect();
    const popRect = commentPopoverEl.getBoundingClientRect();
    const scrollX = window.scrollX || document.documentElement.scrollLeft || 0;
    const scrollY = window.scrollY || document.documentElement.scrollTop || 0;
    const viewportWidth = document.documentElement.clientWidth || window.innerWidth || popRect.width;
    const viewportHeight = document.documentElement.clientHeight || window.innerHeight || popRect.height;
    let top = scrollY + rect.bottom + 10;
    let left = scrollX + rect.left + (rect.width / 2) - (popRect.width / 2);
    const minLeft = scrollX + 8;
    const maxLeft = scrollX + viewportWidth - popRect.width - 8;
    if (left < minLeft) left = minLeft;
    if (left > maxLeft) left = maxLeft;
    const maxTop = scrollY + viewportHeight - popRect.height - 8;
    if (top > maxTop) {
      top = scrollY + rect.top - popRect.height - 10;
    }
    if (top < scrollY + 8) {
      top = scrollY + 8;
    }
    commentPopoverEl.style.top = `${top}px`;
    commentPopoverEl.style.left = `${left}px`;
  }

  function updateCommentPopoverPosition() {
    if (!INLINE_FOOTNOTE_MODE || !commentPopoverEl || !commentPopoverMarker) return;
    positionCommentPopover(commentPopoverMarker);
  }

  function getCommentRecordById(id) {
    if (!id) return null;
    const list = COMMENTS_DB[pageKey()] || [];
    return list.find(rec => rec && rec.id === id) || null;
  }

  document.addEventListener('click', (event) => {
    if (!INLINE_FOOTNOTE_MODE) return;
    const marker = event.target.closest && event.target.closest('.text-marker[data-comment-id]');
    if (marker) return;
    if (commentPopoverEl && !event.target.closest('.comment-inline-popover')) {
      hideCommentPopover();
    }
  });

  window.addEventListener('scroll', () => updateCommentPopoverPosition(), { passive: true });
  window.addEventListener('resize', () => updateCommentPopoverPosition());

  function cloneTreeWithDepth(nodes, maxLevel) {
    if (!Array.isArray(nodes) || !nodes.length) return [];
    const walk = (list) => {
      const acc = [];
      list.forEach(node => {
        if (!node || typeof node !== 'object') return;
        if (typeof node.level !== 'number' || node.level > maxLevel) return;
        const copy = {
          title: node.title,
          level: node.level,
          anchor: node.anchor,
          children: []
        };
        if (Array.isArray(node.children) && node.children.length) {
          copy.children = walk(node.children);
        }
        acc.push(copy);
      });
      return acc;
    };
    return walk(nodes);
  }

  function resolveNavData(data) {
    if (data && typeof data === 'object' && Array.isArray(data.pages)) {
      NAV_DATA_STATE.data = data;
      return data;
    }
    throw new Error('Invalid navigation data payload');
  }

  function loadNavDataViaScript(prefix) {
    if (typeof document === 'undefined') {
      return Promise.reject(new Error('DOM unavailable for script loading'));
    }
    return new Promise((resolve, reject) => {
      const existing = document.querySelector('script[data-nav-data="true"]');
      if (existing && typeof window.__NAV_DATA__ === 'object' && window.__NAV_DATA__) {
        try {
          resolve(resolveNavData(window.__NAV_DATA__));
        } catch (err) {
          reject(err);
        }
        return;
      }
      const script = document.createElement('script');
      script.type = 'text/javascript';
      script.dataset.navData = 'true';
      script.src = `${prefix}assets/nav-data.js`;
      script.onload = () => {
        try {
          resolve(resolveNavData(window.__NAV_DATA__));
        } catch (err) {
          reject(err);
        }
      };
      script.onerror = () => reject(new Error('Failed to load nav-data.js'));
      document.head.appendChild(script);
    });
  }

  function loadNavData() {
    if (NAV_DATA_STATE.data) return Promise.resolve(NAV_DATA_STATE.data);
    if (typeof window.__NAV_DATA__ === 'object' && window.__NAV_DATA__) {
      try {
        return Promise.resolve(resolveNavData(window.__NAV_DATA__));
      } catch (err) {
        return Promise.reject(err);
      }
    }
    if (NAV_DATA_STATE.promise) return NAV_DATA_STATE.promise;
    const prefix = getRootPrefix() || '';
    if (location.protocol === 'file:') {
      NAV_DATA_STATE.promise = loadNavDataViaScript(prefix)
        .catch(err => {
          console.warn('Failed to load nav data via script:', err);
          NAV_DATA_STATE.data = null;
          return null;
        });
      return NAV_DATA_STATE.promise;
    }

    const url = new URL(`${prefix}assets/nav-data.json`, window.location.href);
    NAV_DATA_STATE.promise = fetch(url.href)
      .then(res => {
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        return res.json();
      })
      .then(json => resolveNavData(json))
      .catch(err => {
        console.warn('Failed to fetch nav data, retrying with script fallback:', err);
        return loadNavDataViaScript(prefix)
          .catch(scriptErr => {
            console.warn('Script fallback failed for nav data:', scriptErr);
            NAV_DATA_STATE.data = null;
            return null;
          });
      });
    return NAV_DATA_STATE.promise;
  }

  function canonicalPageKey(pathname) {
    try {
      let path = (pathname || '').split(/[?#]/)[0];
      path = path.replace(/\\/g, '/').replace(/\/+/g, '/');
      const segments = path.split('/').filter(Boolean);
      if (!segments.length) return 'index.html';
      const last = segments[segments.length - 1];
      if (!last || last.toLowerCase() === 'index.html') {
        const prev = segments.length > 1 ? segments[segments.length - 2] : '';
        return prev ? `${prev}/index.html` : 'index.html';
      }
      return last;
    } catch {
      return pathname || 'index.html';
    }
  }

  function pageKey() {
    return canonicalPageKey(window.location.pathname || '');
  }

  function canonicalizeCommentsDB(db) {
    const merged = {};
    const seenMap = {};
    if (!db || typeof db !== 'object') {
      return {};
    }
    Object.keys(db).forEach(oldKey => {
      const canonical = canonicalPageKey(oldKey);
      if (!merged[canonical]) {
        merged[canonical] = [];
        seenMap[canonical] = new Set();
      }
      const list = db[oldKey] || [];
      list.forEach(rec => {
        if (!rec || !rec.id || seenMap[canonical].has(rec.id)) return;
        merged[canonical].push(rec);
        seenMap[canonical].add(rec.id);
      });
    });
    return merged;
  }

  // コメントDB（ページキー毎に配列）
  let COMMENTS_DB = {};
  try {
    COMMENTS_DB = JSON.parse(localStorage.getItem(STORAGE_KEYS.comments) || '{}') || {};
  } catch {
    COMMENTS_DB = {};
  }
  COMMENTS_DB = canonicalizeCommentsDB(COMMENTS_DB);
  try { localStorage.setItem(STORAGE_KEYS.comments, JSON.stringify(COMMENTS_DB)); } catch {}
  function saveComments() {
    try { localStorage.setItem(STORAGE_KEYS.comments, JSON.stringify(COMMENTS_DB)); }
    catch (e) { console.warn('Save comments failed', e); }
  }

let INLINE_FOOTNOTE_MODE = false;
let commentPopoverEl = null;
let commentPopoverMarker = null;
let commentPopoverPersistent = false;
let commentPopoverHideTimer = null;
let cleanupCommentMarkersDom = () => {};
let refreshCommentMarkersFromDB = () => {};
let readingStateSaveTimer = null;

  function resolveAssetPath(relPath) {
    try {
      // Prefer Quarto's offset meta when available so paths work on index.html and content pages
      const offsetMeta = document.querySelector('meta[name="quarto:offset"]');
      if (offsetMeta) {
        let offset = offsetMeta.getAttribute('content') || '';
        if (offset && !offset.endsWith('/')) offset += '/';
        return offset + relPath;
      }

      // Fallback: derive base from simple-theme.css location if present
      const themeLink = document.querySelector('link[rel="stylesheet"][href*="src/css/simple-theme.css"]');
      if (themeLink) {
        const href = themeLink.getAttribute('href') || '';
        const parts = href.split('/');
        const srcIndex = parts.indexOf('src');
        if (srcIndex >= 0) {
          const prefix = parts.slice(0, srcIndex).join('/');
          const base = prefix ? prefix.replace(/\/*$/, '/') : '';
          return base + relPath;
        }
      }
    } catch (e) {
      console.warn('resolveAssetPath failed', e);
    }
    return relPath;
  }

  let readingMeterState = null;
  let scrollExtensionEl = null;
  let pendingScrollExtensionRaf = 0;
  const SCROLL_EXTENSION_BUFFER = 80;
  const FOOTNOTE_INLINE_BREAKPOINT = 1024;
  let currentFootnoteLayout = null;

  function formatReadingNumber(value) {
    if (!Number.isFinite(value)) return '0';
    try {
      return value.toLocaleString('ja-JP');
    } catch (error) {
      console.warn('Failed to format number:', error);
      return String(Math.trunc(value));
    }
  }

  function extractReadableText(root) {
    if (!root) return '';
    const clone = root.cloneNode(true);
    const selectorsToRemove = [
      '.header-ui',
      '.settings-menu',
      '.settings-menu-overlay',
      '.scroll-settings-header',
      '#scroll-settings-header',
      '.toc-overlay',
      '.global-search-overlay',
      '.marker-toolbar'
    ];
    selectorsToRemove.forEach((selector) => {
      clone.querySelectorAll(selector).forEach((node) => node.remove());
    });
    return (clone.textContent || '').replace(/\s+/g, '');
  }

  function ensureScrollExtensionElement() {
    if (scrollExtensionEl && document.body.contains(scrollExtensionEl)) {
      return scrollExtensionEl;
    }
    if (!document.body) return null;
    scrollExtensionEl = document.createElement('div');
    scrollExtensionEl.id = 'scroll-extension-anchor';
    scrollExtensionEl.setAttribute('aria-hidden', 'true');
    scrollExtensionEl.style.cssText = 'width:1px;height:0;margin:0;padding:0;';
    document.body.appendChild(scrollExtensionEl);
    return scrollExtensionEl;
  }

  function updateScrollExtensionNow() {
    const placeholder = ensureScrollExtensionElement();
    if (!placeholder) return;
    placeholder.style.height = '0px';
    const docElement = document.documentElement || document.body;
    const baseHeight = Math.max(
      document.body ? document.body.scrollHeight : 0,
      docElement ? docElement.scrollHeight : 0
    );
    let maxBottom = baseHeight;
    let hasTarget = false;
    const targets = [
      document.getElementById('quarto-document-content'),
      document.getElementById('quarto-sidebar'),
      document.getElementById('quarto-margin-sidebar')
    ];
    targets.forEach(el => {
      if (!el) return;
      const rect = el.getBoundingClientRect();
      if (!rect || !Number.isFinite(rect.bottom)) return;
      const bottom = rect.bottom + window.scrollY;
      if (!Number.isFinite(bottom)) return;
      maxBottom = Math.max(maxBottom, bottom);
      hasTarget = true;
    });
    if (!hasTarget) {
      placeholder.style.height = '0px';
      return;
    }
    const needed = Math.max(0, Math.ceil(maxBottom - baseHeight + SCROLL_EXTENSION_BUFFER));
    placeholder.style.height = needed > 0 ? `${needed}px` : '0px';
  }

  function scheduleScrollExtensionUpdate() {
    if (typeof requestAnimationFrame !== 'function') {
      return updateScrollExtensionNow();
    }
    if (pendingScrollExtensionRaf) {
      cancelAnimationFrame(pendingScrollExtensionRaf);
    }
    pendingScrollExtensionRaf = requestAnimationFrame(() => {
      pendingScrollExtensionRaf = 0;
      updateScrollExtensionNow();
    });
  }

  function initializeReadingMeter(displayEl) {
    if (!displayEl) return;

    const readingRoot = document.querySelector('#quarto-document-content');
    if (!readingRoot) {
      displayEl.textContent = '[0/0]';
      displayEl.setAttribute('aria-label', '読書メーター: 0 / 0');
      return;
    }

    const totalText = extractReadableText(readingRoot);
    const totalChars = totalText.length;
    const formattedTotal = formatReadingNumber(totalChars);

    displayEl.textContent = `[0/${formattedTotal}]`;
    displayEl.setAttribute('data-total-chars', `${totalChars}`);
    displayEl.setAttribute('data-current-chars', '0');
    displayEl.setAttribute('aria-live', 'polite');
    displayEl.setAttribute('aria-label', `読書メーター: 0 / ${formattedTotal}`);

    const state = {
      displayEl,
      readingRoot,
      measureElement: readingRoot,
      totalChars,
      formattedTotal,
      lastCurrent: -1,
      lastOutput: '',
      updateScheduled: false,
      cleanup: null
    };

    const computeRatio = () => {
      if (!state.measureElement) return 0;
      const rect = state.measureElement.getBoundingClientRect();
      const contentTop = window.scrollY + rect.top;
      const contentBottom = contentTop + rect.height;
      if (!Number.isFinite(contentTop) || !Number.isFinite(contentBottom) || contentBottom <= contentTop) {
        return 0;
      }

      const scrollTop = window.scrollY;
      const scrollBottom = scrollTop + window.innerHeight;
      const scrollRange = contentBottom - contentTop - window.innerHeight;
      let ratio;

      if (scrollRange <= 0) {
        if (scrollBottom >= contentBottom) {
          ratio = 1;
        } else if (scrollTop <= contentTop) {
          ratio = 0;
        } else {
          ratio = (scrollTop - contentTop) / Math.max(1, contentBottom - contentTop);
        }
      } else {
        ratio = (scrollTop - contentTop) / scrollRange;
      }

      if (!Number.isFinite(ratio)) {
        return 0;
      }
      return Math.min(1, Math.max(0, ratio));
    };

    const applyUpdate = () => {
      state.updateScheduled = false;
      if (state.totalChars <= 0) {
        const output = '[0/0]';
        if (output !== state.lastOutput) {
          state.lastOutput = output;
          state.displayEl.textContent = output;
          state.displayEl.setAttribute('data-current-chars', '0');
          state.displayEl.setAttribute('aria-label', '読書メーター: 0 / 0');
        }
        return;
      }

      const ratio = computeRatio();
      const currentChars = Math.max(0, Math.min(state.totalChars, Math.round(state.totalChars * ratio)));
      if (currentChars === state.lastCurrent && state.lastOutput) {
        return;
      }

      state.lastCurrent = currentChars;
      const formattedCurrent = formatReadingNumber(currentChars);
      const output = `[${formattedCurrent}/${state.formattedTotal}]`;
      if (output !== state.lastOutput) {
        state.lastOutput = output;
        state.displayEl.textContent = output;
        state.displayEl.setAttribute('data-current-chars', `${currentChars}`);
        state.displayEl.setAttribute('aria-label', `読書メーター: ${formattedCurrent} / ${state.formattedTotal}`);
      }
    };

    const scheduleUpdate = () => {
      if (state.updateScheduled) return;
      state.updateScheduled = true;
      requestAnimationFrame(applyUpdate);
    };

    const onScroll = () => scheduleUpdate();
    const onResize = () => scheduleUpdate();

    if (readingMeterState && typeof readingMeterState.cleanup === 'function') {
      readingMeterState.cleanup();
    }

    window.addEventListener('scroll', onScroll, { passive: true });
    window.addEventListener('resize', onResize);

    state.cleanup = () => {
      window.removeEventListener('scroll', onScroll);
      window.removeEventListener('resize', onResize);
    };

    readingMeterState = state;
    scheduleUpdate();
  }

  function getSavedRightTab() {
    try {
      const saved = localStorage.getItem(STORAGE_KEYS.rightTab);
      if (saved && ['footnotes', 'comments', 'both'].includes(saved)) {
        return saved;
      }
    } catch (e) {
      console.warn('Failed to read right tab state', e);
    }
    return 'both';
  }
  function saveRightTab(tab) {
    if (!['footnotes', 'comments', 'both'].includes(tab)) return;
    try { localStorage.setItem(STORAGE_KEYS.rightTab, tab); }
    catch (e) { console.warn('Failed to save right tab state', e); }
  }

  function setupTopChapterNavigation() {
    if (document.querySelector('nav.page-navigation-top')) return;
    const header = document.querySelector('header.quarto-title-block');
    const bottomNav = document.querySelector('nav.page-navigation');
    if (!header || !bottomNav) return;
    const topNav = bottomNav.cloneNode(true);
    topNav.classList.add('page-navigation-top');
    header.parentNode.insertBefore(topNav, header);
  }

  function getActiveChapterSection() {
    return document.querySelector('section.chapter-page.active') || null;
  }
  function getCurrentChapterSlug() {
    const active = getActiveChapterSection();
    if (!active) return null;
    const id = active.getAttribute('id') || '';
    return id.startsWith('page-') ? id.slice(5) : (id || null);
  }

  function getSectionSlugFromElement(el) {
    if (!el || !(el instanceof HTMLElement)) return null;
    const sec = el.closest('section.chapter-page');
    if (!sec || !sec.id) return null;
    const id = sec.id;
    return id.startsWith('page-') ? id.slice(5) : id;
  }

  function findCommentAnchorElement(rec) {
    if (!rec || !Array.isArray(rec.ranges)) return null;
    for (const range of rec.ranges) {
      const node = getNodeByPathSafe(range?.s);
      if (!node) continue;
      let el = node.nodeType === Node.ELEMENT_NODE ? node : node.parentElement;
      while (el && !(el instanceof HTMLElement)) el = el.parentElement;
      if (el) return el;
    }
    return null;
  }

  function detectCommentSlug(rec) {
    const el = findCommentAnchorElement(rec);
    return el ? getSectionSlugFromElement(el) : null;
  }

  function isCommentInSection(rec, section) {
    if (!section) return true;
    const el = findCommentAnchorElement(rec);
    return !!(el && section.contains(el));
  }

  function getActiveComments() {
    const list = (COMMENTS_DB[pageKey()] || []);
    // 章タブやセクションに関わらず、このページ上のコメントをすべて返す
    return list.filter(rec => !!rec);
  }

  function gatherActiveCommentsWithElements() {
    return getActiveComments()
      .map(rec => {
        const el = findCommentAnchorElement(rec);
        return el ? { rec, el } : null;
      })
      .filter(Boolean);
  }

  function gatherActiveFootnotes() {
    const active = getActiveChapterSection();
    const refSelector = 'a[role="doc-noteref"], a.footnote-ref';
    const refMap = new Map();
    const scope = active || document;
    Array.from(scope.querySelectorAll(refSelector)).forEach(ref => {
      if (active && !active.contains(ref)) return;
      const href = ref.getAttribute('href') || ref.getAttribute('data-footnote-href');
      if (!href || !href.startsWith('#')) return;
      const id = href.slice(1);
      const top = ref.getBoundingClientRect().top + window.scrollY;
      const label = (() => {
        const sup = ref.querySelector('sup');
        const raw = (sup ? sup.textContent : ref.textContent) || '';
        return raw.replace(/\s+/g, ' ').trim();
      })();
      const existing = refMap.get(id);
      if (!existing || top < existing.pos) {
        refMap.set(id, { id, ref, pos: top, number: label });
      }
    });
    const items = [];
    refMap.forEach(entry => {
      let def = document.getElementById(entry.id);
      if (!def) return;
      if (!(def instanceof HTMLElement)) def = def.parentElement;
      if (!def) return;
      let li = def;
      if (li.tagName && li.tagName.toLowerCase() !== 'li') {
        const nearestLi = li.closest('li');
        if (nearestLi) li = nearestLi;
      }
      if (!(li instanceof HTMLElement)) return;
      if (active) {
        const parentSection = li.closest('section.chapter-page');
        if (parentSection && parentSection !== active) return;
      }
      const fallbackLabel = entry.number || entry.id.replace(/[^0-9]+/g, '').trim();
      items.push({ id: entry.id, li, ref: entry.ref, pos: entry.pos, number: fallbackLabel });
    });
    return items;
  }

  async function initUI() {
    let navData = null;
    try {
      navData = await loadNavData();
    } catch (e) {
      console.warn('Nav data load failed:', e);
    }

    const safeInvoke = async (label, action) => {
      try {
        const result = action();
        if (result && typeof result.then === 'function') {
          await result;
        }
      } catch (err) {
        console.error(`UI init step failed (${label}):`, err);
      }
    };

    const steps = [
      ['header-controls', () => setupHeaderControls()],
      ['left-sidebar-tabs', () => setupLeftPanelTabs(navData)],
      ['site-title-enhancements', () => applySiteTitleEnhancements(navData)],
      ['mobile-nav-drawer', () => setupMobileNavDrawer(navData)],
      ['left-sidebar-stability', () => setupLeftSidebarStability()],
      ['right-sidebar', () => setupRightSidebar()],
      ['top-nav', () => setupTopChapterNavigation()],
      ['markers', () => setupMarkerFunctionality()],
      ['mobile-footnotes', () => setupMobileFootnoteToggle()],
      ['disable-default-search', () => disableDefaultQuartoSearch()],
      ['sidebar-search', () => setupSidebarSearch()],
      ['global-search', () => setupGlobalSearch()],
      ['shortcuts', () => setupKeyboardShortcuts()],
      ['scroll-position', () => setupScrollPosition()],
      ['body-links', () => reinforceAnchors(document.getElementById('quarto-document-content'))],
      ['index-links', () => updateIndexLinksForContext()],
      ['custom-toc', () => setTimeout(() => CustomTOC.initializeCustomTOC(navData), 100)],
    ];

    for (const [label, action] of steps) {
      await safeInvoke(label, action);
    }

    console.log('UI initialized');
    window.addEventListener('resize', () => scheduleScrollExtensionUpdate(), { passive: true });
    window.addEventListener('orientationchange', () => scheduleScrollExtensionUpdate());
    window.addEventListener('load', () => scheduleScrollExtensionUpdate(), { once: true });
    scheduleScrollExtensionUpdate();
    setTimeout(() => {
      refreshRightPanels();
      restoreReadingState();
    }, 120);
  }
  const queueInit = () => window.setTimeout(initUI, 0);
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', queueInit, { once: true });
  } else {
    queueInit();
  }

  function setupHeaderControls() {
    const settingsToggleBtn = document.getElementById('settings-toggle-btn');
    const settingsMenu = document.getElementById('settings-menu');
    const settingsMenuClose = document.getElementById('settings-menu-close');
    const settingsMenuOverlay = document.getElementById('settings-menu-overlay');
    const themeSelect = document.getElementById('theme-select');
    const fontSizeSelect = document.getElementById('font-size-select');
    const commentsExportPage = document.getElementById('comments-export-page');
    const commentsExportAll = document.getElementById('comments-export-all');
    const commentsImport = document.getElementById('comments-import');
    const commentsImportButton = document.getElementById('comments-import-button');
    const toastMaxRange = document.getElementById('gdoc-toast-max');
    const toastMaxValue = document.getElementById('gdoc-toast-max-value');
    const resetUiBtn = document.getElementById('reset-ui-settings');
    const resetMemoBtn = document.getElementById('reset-memo-settings');
    const resetPreviewBtn = document.getElementById('reset-preview-settings');
    const resetAllBtn = document.getElementById('reset-all-settings');

    // ハンバーガーメニューは廃止

    // 設定メニュー開閉機能
    if (settingsToggleBtn) {
      const iconImg = settingsToggleBtn.querySelector('.settings-toggle-icon[data-asset]');
      if (iconImg) {
        const assetPath = iconImg.getAttribute('data-asset');
        if (assetPath) {
          iconImg.src = resolveAssetPath(assetPath);
        }
      }
    }

    // 一般の画像についても data-asset 属性があれば resolveAssetPath で解決する
    try {
      const assetImgs = document.querySelectorAll('img[data-asset]');
      assetImgs.forEach(img => {
        const rel = img.getAttribute('data-asset');
        if (!rel) return;
        const resolved = resolveAssetPath(rel);
        if (resolved && img.src !== resolved) {
          img.src = resolved;
        }
      });
    } catch (e) {
      console.warn('resolveAssetPath for img[data-asset] failed', e);
    }

    if (settingsToggleBtn && settingsMenu && settingsMenuOverlay) {
      const openSettingsMenu = () => {
        settingsMenu.classList.add('open');
        settingsMenuOverlay.classList.add('open');
      };

      const closeSettingsMenu = () => {
        settingsMenu.classList.remove('open');
        settingsMenuOverlay.classList.remove('open');
      };

      settingsToggleBtn.addEventListener('click', openSettingsMenu);
      settingsMenuClose.addEventListener('click', closeSettingsMenu);
      settingsMenuOverlay.addEventListener('click', closeSettingsMenu);

      // ESCキーでメニューを閉じる
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && settingsMenu.classList.contains('open')) {
          closeSettingsMenu();
        }
      });
    }

    // テーマ切替機能
    if (themeSelect) {
      const mq = window.matchMedia('(prefers-color-scheme: dark)');
      function applyTheme(mode) {
        if (mode === 'auto') {
          document.body.setAttribute('data-theme', mq.matches ? 'dark' : 'light');
        } else {
          document.body.setAttribute('data-theme', mode);
        }
      }
      const saved = localStorage.getItem(STORAGE_KEYS.theme) || 'auto';
      themeSelect.value = saved;
      applyTheme(saved);
      mq.addEventListener('change', () => { if ((localStorage.getItem(STORAGE_KEYS.theme) || 'auto') === 'auto') applyTheme('auto'); });
      themeSelect.addEventListener('change', (e) => {
        const theme = e.target.value;
        localStorage.setItem(STORAGE_KEYS.theme, theme);
        applyTheme(theme);
      });
    }

    // 文字サイズ変更機能
    if (fontSizeSelect) {
      const currentSize = localStorage.getItem(STORAGE_KEYS.fontSize) || 'M';
      fontSizeSelect.value = currentSize;
      document.body.setAttribute('data-font-size', currentSize);
      fontSizeSelect.addEventListener('change', (e) => {
        const size = e.target.value;
        document.body.setAttribute('data-font-size', size);
        localStorage.setItem(STORAGE_KEYS.fontSize, size);
      });
    }

    // コメント出力機能
    if (commentsExportPage) {
      commentsExportPage.addEventListener('click', () => exportComments(true));
    }
    if (commentsExportAll) {
      commentsExportAll.addEventListener('click', () => exportComments(false));
    }

    // コメントインポート機能
    if (commentsImport && commentsImportButton) {
      commentsImport.addEventListener('change', (e) => importCommentsFromFile(e.target.files[0]));
      commentsImportButton.addEventListener('click', () => commentsImport.click());
    }

    // リセットボタン群
    if (resetUiBtn) {
      resetUiBtn.addEventListener('click', () => {
        const ok = window.confirm('UI系の設定（テーマ・文字サイズ・右パネルタブ・ソート設定など）をリセットしますか？');
        if (!ok) return;
        resetUiSettings();
        // 即時反映のため、ページを再読み込み
        window.location.reload();
      });
    }

    if (resetMemoBtn) {
      resetMemoBtn.addEventListener('click', () => {
        const ok = window.confirm('メモ系（マーカー・コメント）の保存データをすべてリセットしますか？\\n※元に戻すことはできません。');
        if (!ok) return;
        resetMemoSettings();
        window.location.reload();
      });
    }

    if (resetPreviewBtn) {
      resetPreviewBtn.addEventListener('click', () => {
        const ok = window.confirm('プレビュー関連の設定（Docs/BGプレビューの状態・トースト表示数）をリセットしますか？');
        if (!ok) return;
        resetPreviewSettings();
        window.location.reload();
      });
    }

    if (resetAllBtn) {
      resetAllBtn.addEventListener('click', () => {
        const ok = window.confirm('すべての設定と保存データを完全にリセットします。\\nlocalStorage / sessionStorage を初期化しますが、本当に実行しますか？');
        if (!ok) return;
        resetAllSettingsHard();
        window.location.reload();
      });
    }

    // プレビューのトースト表示数スライダー
    if (toastMaxRange && toastMaxValue) {
      let stored = 3;
      try {
        const raw = localStorage.getItem('gdocPreviewMaxToasts');
        if (raw != null) {
          const n = parseInt(raw, 10);
          if (!isNaN(n)) stored = Math.min(9, Math.max(0, n));
        }
      } catch (e) {
        // ignore
      }
      toastMaxRange.value = String(stored);
      toastMaxValue.textContent = String(stored);

      toastMaxRange.addEventListener('input', () => {
        toastMaxValue.textContent = String(toastMaxRange.value);
      });
      toastMaxRange.addEventListener('change', () => {
        const n = parseInt(toastMaxRange.value, 10) || 0;
        try {
          localStorage.setItem('gdocPreviewMaxToasts', String(Math.min(9, Math.max(0, n))));
        } catch (e) {}
        if (window.__gdocPreviewAPI__ && typeof window.__gdocPreviewAPI__.refreshToasts === 'function') {
          window.__gdocPreviewAPI__.refreshToasts();
        }
      });
    }

    ensureHeaderListButtons();
    document.addEventListener('quarto-hrChanged', ensureHeaderListButtons);
    window.addEventListener('resize', ensureHeaderListButtons);
  }

  function ensureHeaderListButtons() {
    try {
      const searchButtons = document.querySelectorAll('.quarto-search-button');
      if (!searchButtons.length) return;
      searchButtons.forEach(searchButton => {
        const parent = searchButton.parentElement;
        if (!parent) return;
        if (parent.querySelector('.quarto-list-button')) return;
        const listBtn = document.createElement('button');
        listBtn.type = 'button';
        listBtn.className = 'btn quarto-list-button';
        listBtn.setAttribute('aria-label', 'プレビュー・コメント・マーカー一覧を開く');
        const icon = document.createElement('img');
        icon.alt = '';
        icon.decoding = 'async';
        icon.loading = 'lazy';
        icon.setAttribute('aria-hidden', 'true');
        icon.src = resolveAssetPath('assets/list.png');
        listBtn.appendChild(icon);
        listBtn.addEventListener('click', (event) => {
          event.preventDefault();
          openGlobalListOverlay();
        });
        parent.insertBefore(listBtn, searchButton);
      });
    } catch (e) {
      console.warn('inject list button failed', e);
    }
  }

  function renderNavDrawerContent(container, navData) {
    if (!container) return;
    container.innerHTML = '';
    const switcher = document.createElement('div');
    switcher.className = 'toc-switcher nav-drawer-switcher';
    switcher.innerHTML = `
      <div class="toc-tabs">
        <button type="button" class="toc-tab active" data-tab="site">各章</button>
        <button type="button" class="toc-tab" data-tab="page">章内</button>
        <button type="button" class="toc-tab" data-tab="all">全体</button>
      </div>
      <div class="toc-panel toc-site-content"></div>
      <div class="toc-panel toc-page-content hidden"></div>
      <div class="toc-panel toc-all-content hidden"></div>
    `;
    container.appendChild(switcher);
    const sitePanel = switcher.querySelector('.toc-site-content');
    const pagePanel = switcher.querySelector('.toc-page-content');
    const allPanel = switcher.querySelector('.toc-all-content');
    if (sitePanel) CustomTOC.renderChapterTab(sitePanel, navData);
    if (pagePanel) CustomTOC.renderPageTab(pagePanel, navData, 4);
    if (allPanel) CustomTOC.renderAllTab(allPanel, navData);
    const tabButtons = switcher.querySelectorAll('.toc-tab');
    tabButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        const target = btn.dataset.tab;
        tabButtons.forEach(other => other.classList.remove('active'));
        btn.classList.add('active');
        switcher.querySelectorAll('.toc-panel').forEach(panel => {
          panel.classList.add('hidden');
        });
        const panel = switcher.querySelector(`.toc-${target}-content`);
        if (panel) panel.classList.remove('hidden');
      });
    });
  }

  function setupMobileNavDrawer(navData) {
    const overlay = document.querySelector('.toc-overlay');
    if (!overlay) return;
    const closeBtn = overlay.querySelector('.toc-sheet__close');
    const backdrop = overlay.querySelector('.toc-overlay__backdrop');
    const content = overlay.querySelector('.toc-sheet__content');
    const toggleButtons = document.querySelectorAll('.quarto-btn-toggle, [data-bs-target=".quarto-sidebar-collapse-item"]');
    const buttons = Array.from(new Set(Array.from(toggleButtons)));
    if (!buttons.length) return;

    const closeDrawer = () => {
      document.body.classList.remove('toc-open');
    };

    const openDrawer = () => {
      renderNavDrawerContent(content, navData);
      document.body.classList.add('toc-open');
    };

    const toggleDrawer = () => {
      if (document.body.classList.contains('toc-open')) {
        closeDrawer();
      } else {
        openDrawer();
      }
    };

    const interceptToggle = (event) => {
      if (window.innerWidth > 1024) {
        closeDrawer();
        return;
      }
      event.preventDefault();
      event.stopPropagation();
      if (typeof event.stopImmediatePropagation === 'function') {
        event.stopImmediatePropagation();
      }
      toggleDrawer();
    };

    buttons.forEach(btn => {
      btn.addEventListener('click', interceptToggle, true);
    });

    if (closeBtn) closeBtn.addEventListener('click', closeDrawer);
    if (backdrop) backdrop.addEventListener('click', closeDrawer);
    overlay.addEventListener('click', (event) => {
      if (event.target.classList.contains('toc-overlay')) {
        closeDrawer();
      }
    });
    if (content) {
      content.addEventListener('click', (event) => {
        const anchor = event.target.closest('a');
        if (anchor) closeDrawer();
      });
    }
    document.addEventListener('keydown', (event) => {
      if (event.key === 'Escape' && document.body.classList.contains('toc-open')) {
        closeDrawer();
      }
    });
    window.addEventListener('resize', () => {
      if (window.innerWidth > 1024) closeDrawer();
    });
  }

  function setupLeftPanelTabs(navData) {
    const sidebar = document.getElementById('quarto-sidebar');
    if (!sidebar) return;
    const menuContainer = sidebar.querySelector('.sidebar-menu-container');
    if (!menuContainer) return;

    const tabWrapper = document.createElement('div');
    tabWrapper.className = 'toc-switcher';
    tabWrapper.innerHTML = `
      <div class="toc-tabs">
        <button type="button" class="toc-tab active" data-tab="site">各章</button>
        <button type="button" class="toc-tab" data-tab="page">章内</button>
        <button type="button" class="toc-tab" data-tab="all">全体</button>
      </div>
      <div class="toc-panel toc-site-content"></div>
      <div class="toc-panel toc-page-content hidden"></div>
      <div class="toc-panel toc-all-content hidden"></div>
    `;

    const parent = menuContainer.parentNode;
    parent.replaceChild(tabWrapper, menuContainer);

    const sitePanel = tabWrapper.querySelector('.toc-site-content');
    const pagePanel = tabWrapper.querySelector('.toc-page-content');
    const allPanel = tabWrapper.querySelector('.toc-all-content');

    sitePanel.innerHTML = '';
    pagePanel.innerHTML = '';
    allPanel.innerHTML = '';

    menuContainer.innerHTML = '';
    sitePanel.appendChild(menuContainer);

    const allContainer = document.createElement('div');
    allContainer.className = 'toc-all-container';
    allPanel.appendChild(allContainer);

    if (!navData || !Array.isArray(navData.pages) || !navData.pages.length) {
      menuContainer.innerHTML = '<p class="toc-empty">目次データを読み込めませんでした。</p>';
      allContainer.innerHTML = '<p class="toc-empty">目次データを読み込めませんでした。</p>';
      pagePanel.innerHTML = '<p class="toc-empty">目次データを読み込めませんでした。</p>';
    } else {
      CustomTOC.renderChapterTab(menuContainer, navData);
      CustomTOC.renderAllTab(allContainer, navData);
      CustomTOC.renderPageTab(pagePanel, navData, 4);
    }

    const tabButtons = tabWrapper.querySelectorAll('.toc-tab');
    const panels = { site: sitePanel, page: pagePanel, all: allPanel };
    tabButtons.forEach(button => {
      button.addEventListener('click', () => {
        const target = button.dataset.tab;
        tabButtons.forEach(btn => btn.classList.remove('active'));
        button.classList.add('active');
        Object.values(panels).forEach(p => p.classList.add('hidden'));
        if (panels[target]) {
          panels[target].classList.remove('hidden');
          if (target === 'page' && navData) {
            CustomTOC.renderPageTab(pagePanel, navData, 4);
          }
        }
      });
    });
    scheduleScrollExtensionUpdate();
  }

  function setupLeftSidebarStability() {
    const sidebar = document.getElementById('quarto-sidebar');
    const toggles = document.querySelectorAll('[data-bs-target=".quarto-sidebar-collapse-item"]');
    if (!sidebar || !toggles.length) return;
    let pendingState = null;
    let pendingExpiry = 0;
    let restoreHandle = null;

    const applyPendingState = () => {
      if (!pendingState) return;
      scrollToReadingState(pendingState);
      if (Date.now() > pendingExpiry) {
        pendingState = null;
      }
    };

    const scheduleRestore = () => {
      if (!pendingState) return;
      if (restoreHandle) {
        cancelAnimationFrame(restoreHandle);
        restoreHandle = null;
      }
      restoreHandle = requestAnimationFrame(() => {
        restoreHandle = requestAnimationFrame(() => {
          applyPendingState();
        });
      });
    };

    const captureStateBeforeToggle = () => {
      const snapshot = captureReadingState({ captureNodeRef: true });
      if (!snapshot) return;
      pendingState = snapshot;
      pendingExpiry = Date.now() + 1200;
      scheduleRestore();
    };

    toggles.forEach(btn => {
      btn.addEventListener('click', captureStateBeforeToggle, true);
      btn.addEventListener('keydown', (event) => {
        if (event.key === 'Enter' || event.key === ' ') {
          captureStateBeforeToggle();
        }
      }, true);
    });

    sidebar.addEventListener('transitionstart', () => {
      if (!pendingState) {
        captureStateBeforeToggle();
      }
    });

    sidebar.addEventListener('animationstart', () => {
      if (!pendingState) {
        captureStateBeforeToggle();
      }
    });

    sidebar.addEventListener('transitionend', (event) => {
      if (!pendingState) return;
      if (event && event.propertyName && !/width|flex|margin|padding/i.test(event.propertyName)) return;
      scheduleRestore();
    });

    const sidebarMutationObserver = new MutationObserver(() => {
      if (pendingState) scheduleRestore();
    });
    sidebarMutationObserver.observe(sidebar, { attributes: true, attributeFilter: ['class', 'style'] });

    window.addEventListener('resize', () => {
      if (pendingState) {
        scheduleRestore();
      }
    });
  }

  function applySiteTitleEnhancements(navData) {
    enhanceSidebarSiteTitle();
    updateMainHeaderTitle(navData);
  }

  function enhanceSidebarSiteTitle() {
    try {
      const link = document.querySelector('#quarto-sidebar .sidebar-title a');
      if (!link || link.dataset.siteTitleEnhanced === 'true') return;
      const mainText = (link.textContent || '').trim() || '平和への課題：補遺';
      const safeMain = escapeHtml(mainText);
      const subtitle = 'Background Guide';
      link.innerHTML = `<span class="site-title-main">${safeMain}</span><span class="site-title-sub">${subtitle}</span>`;
      link.dataset.siteTitleEnhanced = 'true';
    } catch (e) {
      console.warn('enhanceSidebarSiteTitle failed', e);
    }
  }

  function updateMainHeaderTitle(navData) {
    const header = document.querySelector('header.quarto-title-block');
    if (!header) return;
    const titleEl = header.querySelector('.quarto-title .title');
    if (!titleEl) return;
    const existingSpan = titleEl.querySelector('.chapter-title') || titleEl.firstElementChild;
    const current = computeCurrentOutputPath();
    let pageTitle = '';
    try {
      if (navData && Array.isArray(navData.pages)) {
        const entry = navData.pages.find(page => {
          if (!page) return false;
          const paths = [page.output, page.url, page.source];
          return paths.some(p => isSamePage(p, current));
        });
        if (entry && entry.title) {
          pageTitle = entry.title;
        }
      }
    } catch (e) {
      console.warn('updateMainHeaderTitle nav data lookup failed', e);
    }
    if (!pageTitle && existingSpan) {
      pageTitle = (existingSpan.textContent || '').trim();
    }
    if (!pageTitle) {
      const contentHeading = document.querySelector('main h1, main h2');
      if (contentHeading) {
        pageTitle = (contentHeading.textContent || '').trim();
      }
    }
    if (!pageTitle) {
      header.style.display = 'none';
      return;
    }
    header.style.display = 'none';
  }

  function setupRightSidebar() {
    ensureRightTabs();
    refreshRightPanels();
    const onResize = debounce(() => {
      ensureRightTabs();
      refreshRightPanels();
    }, 200);
    window.addEventListener('resize', onResize);
    window.addEventListener('orientationchange', onResize);
    window.addEventListener('hashchange', () => { setTimeout(refreshRightPanels, 60); });
  }

  function refreshRightPanels() {
    applyFootnoteLayout();
    renderCommentsPanel();
    if (SIDENOTES_ON) {
      renderSidenotes(currentRightTab());
    }
    enumerateReadingNodes();
    scheduleReadingStateSave();
    scheduleScrollExtensionUpdate();
  }

  function ensureRightTabs() {
    const marginSidebar = document.getElementById('quarto-margin-sidebar');
    if (!marginSidebar) return;
    let wrapper = marginSidebar.querySelector('.right-switcher');
    if (!wrapper) {
      wrapper = document.createElement('div');
      wrapper.className = 'right-switcher';
      wrapper.innerHTML = `
        <div class="toc-tabs">
          <button type="button" class="toc-tab" data-tab="footnotes">脚注</button>
          <button type="button" class="toc-tab" data-tab="comments">ｺﾒﾝﾄ</button>
          <button type="button" class="toc-tab" data-tab="both">両方</button>
        </div>
        <div class="toc-panel right-footnotes"></div>
        <div class="toc-panel right-comments" style="display:none"></div>
        <div class="toc-panel right-both" style="display:none"></div>
      `;
      marginSidebar.innerHTML = '';
      marginSidebar.appendChild(wrapper);

      const tabs = wrapper.querySelectorAll('.toc-tab');
      tabs.forEach(btn => {
        btn.addEventListener('click', () => {
          activateRightTab(btn.dataset.tab || 'footnotes');
        });
      });
      const savedTab = getSavedRightTab();
      activateRightTab(savedTab, { skipSave: true });
      // 傍注表示は常に ON とする
      setSidenotesMode(true);
    } else {
      activateRightTab(getSavedRightTab(), { skipSave: true });
      // 既存 DOM 再利用時も傍注モードを維持
      if (!SIDENOTES_ON) setSidenotesMode(true);
    }
  }

  let SIDENOTES_ON = false;
  let SIDENOTES_ITEMS = [];

  function activateRightTab(tab, opts = {}) {
    const marginSidebar = document.getElementById('quarto-margin-sidebar');
    if (!marginSidebar) return;
    const wrapper = marginSidebar.querySelector('.right-switcher');
    if (!wrapper) return;
    const tabs = Array.from(wrapper.querySelectorAll('.toc-tab'));
    const normalized = ['footnotes', 'comments', 'both'].includes(tab) ? tab : 'both';
    tabs.forEach(btn => btn.classList.toggle('active', btn.dataset.tab === normalized));
    const footPanel = wrapper.querySelector('.right-footnotes');
    const commPanel = wrapper.querySelector('.right-comments');
    const bothPanel = wrapper.querySelector('.right-both');
    if (SIDENOTES_ON) {
      if (footPanel) footPanel.style.display = 'none';
      if (commPanel) commPanel.style.display = 'none';
      if (bothPanel) bothPanel.style.display = 'none';
      renderSidenotes(normalized);
    } else {
      if (footPanel) footPanel.style.display = normalized === 'footnotes' ? '' : 'none';
      if (commPanel) commPanel.style.display = normalized === 'comments' ? '' : 'none';
      if (bothPanel) bothPanel.style.display = normalized === 'both' ? '' : 'none';
    }
    if (!opts.skipSave) saveRightTab(normalized);
  }

  function currentRightTab() {
    const active = document.querySelector('#quarto-margin-sidebar .toc-tab.active');
    if (active) return active.getAttribute('data-tab') || 'footnotes';
    return getSavedRightTab();
  }

  function setSidenotesMode(on) {
    const ms = document.getElementById('quarto-margin-sidebar');
    if (!ms) return;
    const foot = ms.querySelector('.right-footnotes');
    const comm = ms.querySelector('.right-comments');
    const both = ms.querySelector('.right-both');
    SIDENOTES_ON = !!on;
    if (SIDENOTES_ON) {
      ms.classList.add('sidenotes-on');
      if (foot) foot.style.display = 'none';
      if (comm) comm.style.display = 'none';
      if (both) both.style.display = 'none';
      renderSidenotes(currentRightTab());
      window.addEventListener('scroll', updateSidenotesPositions, { passive: true });
      window.addEventListener('resize', updateSidenotesPositions);
    } else {
      ms.classList.remove('sidenotes-on');
      clearSidenotes();
      window.removeEventListener('scroll', updateSidenotesPositions);
      window.removeEventListener('resize', updateSidenotesPositions);
      activateRightTab(currentRightTab(), { skipSave: true });
    }
  }

  function clearSidenotes() {
    const ms = document.getElementById('quarto-margin-sidebar');
    ms.querySelectorAll('.margin-note').forEach(n => n.remove());
    SIDENOTES_ITEMS = [];
  }

  function renderSidenotes(mode) {
    clearSidenotes();
    const ms = document.getElementById('quarto-margin-sidebar');
    if (!ms) return;
    const makeNote = (opts) => {
      const note = document.createElement('div');
      note.className = 'margin-note' + (opts.kind==='comment' ? ' comment' : '');
      note.innerHTML = `
        <div class=\"meta\"><span>${opts.time||''}</span>${opts.moveHtml||''}${opts.showMenu ? '<button class="menu" title="メニュー" style="margin-left:auto;background:none;border:none;cursor:pointer;font-size:16px;line-height:1;">⋯</button>' : ''}</div>
        ${opts.targetHtml||''}
        <div class=\"body\">${opts.bodyHtml||''}</div>
      `;
      ms.appendChild(note);
      return note;
    };

    const footnotes = gatherActiveFootnotes();
    const comments = gatherActiveCommentsWithElements();

    const entries = [];
    if (mode !== 'comments') {
      footnotes.forEach(fn => {
        if (!fn.ref) return;
        entries.push({ kind: 'foot', el: fn.ref, def: fn.li, label: fn.number });
      });
    }
    if (mode !== 'footnotes') {
      comments.forEach(item => {
        if (!item.el) return;
        entries.push({ kind: 'comment', el: item.el, rec: item.rec });
      });
    }

    SIDENOTES_ITEMS = entries.map(entry => {
      if (entry.kind === 'comment') {
        const rec = entry.rec;
        const note = makeNote({
          kind: 'comment',
          time: fmtMMDDHHmm(rec.t),
          moveHtml: `<a href="#" class="mv">移動</a>`,
          targetHtml: `<div class="target">${escapeHtml((rec.text||'').slice(0,80))}</div>`,
          bodyHtml: escapeHtml(rec.body||''),
          showMenu: true
        });
        note.querySelector('.mv')?.addEventListener('click', (e)=>{ e.preventDefault(); scrollToComment(rec); });
        note.querySelector('.menu')?.addEventListener('click', (e)=>{ e.stopPropagation(); openCommentMenu(note, rec, { x: e.clientX, y: e.clientY }); });
        return { kind: 'comment', el: entry.el, node: note };
      } else {
        // 脚注の傍注では、元の脚注HTMLを元にクローンを作り、
        // 先頭に [番号] スパンを 1 個だけ挿入して同一行に表示する
        let bodyHtml = '';
        if (entry.def) {
          const clone = entry.def.cloneNode(true);
          clone.querySelectorAll('.footnote-back, .footnote-backref, [role="doc-backlink"]').forEach(a => a.remove());
          const hasNum = clone.querySelector('.footnote-num');
          if (!hasNum) {
            const numSpan = document.createElement('span');
            numSpan.className = 'footnote-num';
            const labelText = (entry.label && String(entry.label).trim().length)
              ? String(entry.label).trim()
              : '';
            numSpan.textContent = labelText ? (labelText + '. ') : '';
            clone.insertBefore(numSpan, clone.firstChild);
          }
          bodyHtml = clone.innerHTML;
        }
        const note = makeNote({
          kind: 'foot',
          bodyHtml: bodyHtml,
          moveHtml: '',
          showMenu: false
        });
        note.querySelector('.menu')?.remove();
        return { kind: 'foot', el: entry.el, node: note };
      }
    });

    updateSidenotesPositions();
    reinforceAnchors(ms);
  }

  function rightSidebarBaseOffset() {
    const ms = document.getElementById('quarto-margin-sidebar');
    if (!ms) return 0;
    const switcher = ms.querySelector('.right-switcher');
    return switcher ? switcher.offsetHeight + 12 : 0;
  }

  function updateSidenotesPositions() {
    if (!SIDENOTES_ON) return;
    const ms = document.getElementById('quarto-margin-sidebar');
    if (!ms) return;
    const msRect = ms.getBoundingClientRect();
    const viewH = window.innerHeight || document.documentElement.clientHeight || 0;
    const msHeight = ms.clientHeight || (viewH || 0);
    if (!msHeight) return;
    const buffer = viewH || msHeight; // 1画面分のバッファ
    const baseOffset = rightSidebarBaseOffset();

    // アンカー位置に応じて傍注の理想位置を決める
    const entries = SIDENOTES_ITEMS
      .filter(item => item.el && item.node && item.el.getClientRects().length)
      .map(item => {
        const rect = item.el.getBoundingClientRect();
        const node = item.node;
        const nodeHeight = node.offsetHeight || 0;
        // アンカーの上端を右パネル座標系に合わせる
        const anchorTopInSidebar = rect.top - msRect.top;
        // 傍注はタブ行の直下から並ぶので baseOffset を足す
        const desiredTop = anchorTopInSidebar + baseOffset;
        return { item, desiredTop, nodeHeight };
      })
      .sort((a, b) => a.desiredTop - b.desiredTop);

    // ノート同士が重ならないように、手前のノートの下に最小限だけずらして配置する。
    // アンカーが画面外に出ていっても entries からは除外しないことで、
    // 上のノートが非表示になった瞬間に下のノートが大きくジャンプすることを防ぐ。
    const gap = 4;
    let cursor = -Infinity;
    entries.forEach(({ item, desiredTop, nodeHeight }) => {
      const node = item.node;
      if (!node) return;
      const height = nodeHeight || node.offsetHeight || 0;
      // 直前のノートの直下までは押し下げるが、それ以上はアンカーに追随
      const top = Math.max(desiredTop, cursor);
      const bottom = top + height;
      // 1画面分のバッファを考慮し、完全に表示範囲から外れたときだけ非表示にする
      const visible = bottom > (baseOffset - buffer) && top < (msHeight + buffer);
      if (!visible) {
        node.style.display = 'none';
        return;
      }
      node.style.display = 'block';
      node.style.top = top + 'px';
      cursor = top + height + gap;
    });
  }

  function applyFootnoteLayout() {
    const inlineQuery = window.matchMedia(`(max-width: ${FOOTNOTE_INLINE_BREAKPOINT}px)`);
    const shouldInline = inlineQuery.matches || window.innerWidth <= FOOTNOTE_INLINE_BREAKPOINT;
    const nextMode = shouldInline ? 'inline' : 'sidebar';
    if (currentFootnoteLayout !== nextMode) {
      currentFootnoteLayout = nextMode;
      document.body && document.body.classList.toggle('footnotes-inline-mode', shouldInline);
      document.body && document.body.classList.toggle('footnotes-sidebar-mode', !shouldInline);
      if (shouldInline) {
        renderInlineFootnotes();
      } else {
        renderSidebarFootnotes();
      }
    } else if (shouldInline) {
      renderInlineFootnotes();
    } else {
      renderSidebarFootnotes();
    }
    try {
      if (document.body) {
        document.body.classList.add('js-footnotes-enhanced');
      }
    } catch (e) {
      console.warn('applyFootnoteLayout: failed to mark enhanced footnotes state', e);
    }
  }

  function renderSidebarFootnotes() {
    setInlineFootnoteMode(false);
    document.querySelectorAll('.footnote-inline').forEach(n => n.remove());
    let marginSidebar = document.getElementById('quarto-margin-sidebar');
    if (!marginSidebar) return;

    if (marginSidebar.style.display === 'none') {
      const prev = marginSidebar.dataset.prevDisplay || '';
      marginSidebar.style.display = prev;
      delete marginSidebar.dataset.prevDisplay;
    }

    if (!marginSidebar.querySelector('.right-switcher')) {
      ensureRightTabs();
      marginSidebar = document.getElementById('quarto-margin-sidebar');
    }

    let footHost = marginSidebar.querySelector('.right-footnotes');
    if (!footHost) {
      footHost = document.createElement('div');
      footHost.className = 'toc-panel right-footnotes';
      marginSidebar.appendChild(footHost);
    }

    let bothHost = marginSidebar.querySelector('.right-both');
    if (!bothHost) {
      bothHost = document.createElement('div');
      bothHost.className = 'toc-panel right-both';
      bothHost.style.display = 'none';
      marginSidebar.appendChild(bothHost);
    }

    footHost.innerHTML = '';
    if (bothHost) bothHost.innerHTML = '';

    const headerRow = document.createElement('div');
    headerRow.style.cssText = 'display:flex;align-items:center;justify-content:space-between;margin-bottom:6px;';
    const header = document.createElement('h2');
    header.className = 'footnotes-title';
    header.textContent = '脚注';
    const sort = document.createElement('select');
    sort.innerHTML = '<option value="pos">本文位置順</option><option value="num">番号順</option>';
    sort.value = localStorage.getItem('footnotes-sort') || 'pos';
    sort.addEventListener('change', () => { localStorage.setItem('footnotes-sort', sort.value); renderSidebarFootnotes(); });
    headerRow.appendChild(header); headerRow.appendChild(sort);
    footHost.appendChild(headerRow);

    const footnotes = gatherActiveFootnotes();
    if (!footnotes.length) {
      footHost.insertAdjacentHTML('beforeend','<p class="footnotes-empty">このページには脚注がありません。</p>');
      if (bothHost) bothHost.insertAdjacentHTML('beforeend','<p class="footnotes-empty">このページには脚注/コメントがありません。</p>');
      return;
    }

    const items = footnotes.slice();
    const mode = sort.value;
    const getSortableNumber = (item) => {
      const primary = Number(item.number);
      if (!Number.isNaN(primary)) return primary;
      const fallbackFromId = Number(String(item.id || '').replace(/[^0-9]+/g, ''));
      if (!Number.isNaN(fallbackFromId)) return fallbackFromId;
      return Number.POSITIVE_INFINITY;
    };
    if (mode === 'pos') {
      items.sort((a,b)=>a.pos-b.pos);
    } else {
      items.sort((a,b)=> {
        const numA = getSortableNumber(a);
        const numB = getSortableNumber(b);
        if (numA !== numB) return numA - numB;
        const labelA = (a.number || '').toString();
        const labelB = (b.number || '').toString();
        const cmpLabel = labelA.localeCompare(labelB, undefined, { numeric: true, sensitivity: 'base' });
        if (cmpLabel !== 0) return cmpLabel;
        return (a.id || '').localeCompare(b.id || '');
      });
    }

    const wrapper = document.createElement('div');
    wrapper.className = 'margin-footnotes';
    const ol = document.createElement('ol');
    items.forEach((it, idx) => {
      const clone = it.li.cloneNode(true);
      const displayLabel = (it.number && String(it.number).trim().length) ? String(it.number).trim() : String(idx + 1);
      if (!clone.querySelector('.footnote-num')) {
        const num = document.createElement('span');
        num.className = 'footnote-num';
        num.textContent = displayLabel + '. ';
        clone.insertBefore(num, clone.firstChild);
      }
      it.number = displayLabel;
      it.displayIndex = displayLabel;
      it.clone = clone;
      ol.appendChild(clone);
    });
    wrapper.appendChild(ol);
    footHost.appendChild(wrapper);
    reinforceAnchors(footHost);

    // 両方タブ: コメントと脚注を本文位置で混在
    if (bothHost) {
      renderBothPanel(bothHost, items);
      reinforceAnchors(bothHost);
    }

    setupScrollSyncForFootnotes(footHost, items);
    refreshCommentMarkersFromDB({ preserveExisting: true });
    scheduleScrollExtensionUpdate();
  }

  function renderBothPanel(host, footItems) {
    const commentAnchors = gatherActiveCommentsWithElements();
    const commItems = commentAnchors.map(({ rec, el }) => {
      const rect = el ? el.getBoundingClientRect() : null;
      const top = rect ? (rect.top + window.scrollY) : Infinity;
      return { type: 'comment', top, rec };
    });
    const footMixed = (footItems || []).map((f) => ({
      type: 'foot',
      top: f.pos,
      id: f.id,
      displayIndex: f.displayIndex,
      number: f.number,
      clone: f.li.cloneNode(true)
    }));
    const merged = commItems.concat(footMixed).sort((a, b) => a.top - b.top);

    host.innerHTML = '';
    const header = document.createElement('h2');
    header.className = 'footnotes-title';
    header.textContent = '両方';
    host.appendChild(header);

    const list = document.createElement('div');
    list.className = 'both-mixed-list';
    list.style.cssText = 'display:flex; flex-direction:column; gap:8px;';

    merged.forEach(item => {
      if (item.type === 'comment') {
        const rec = item.rec;
        const card = document.createElement('div');
        card.className = 'comment-card';
        card.style.cssText = 'padding:10px;background:#fff;border-radius:6px;border-left:3px solid #ff9800;box-shadow:0 1px 3px rgba(0,0,0,0.08);';
        const meta = document.createElement('div');
        meta.className = 'comment-meta';
        meta.style.cssText = 'font-size:12px;color:#6c757d;margin-bottom:6px;display:flex;gap:8px;align-items:center;';
        const t = document.createElement('span');
        t.textContent = fmtMMDDHHmm(rec.t);
        const move = document.createElement('a');
        move.href = '#';
        move.textContent = '移動';
        move.addEventListener('click', (e) => { e.preventDefault(); scrollToComment(rec); });
        meta.appendChild(t);
        meta.appendChild(move);
        const target = document.createElement('div');
        target.className = 'comment-snippet';
        target.style.cssText = 'font-size:13px;color:#495057;background:#fff3e0;padding:6px 8px;border-radius:4px;margin-bottom:6px;';
        target.textContent = rec.text || '';
        const body = document.createElement('div');
        body.className = 'comment-body';
        body.style.cssText = 'white-space:pre-wrap; line-height:1.5;';
        body.textContent = rec.body || '';
        card.appendChild(meta);
        card.appendChild(target);
        card.appendChild(body);
        list.appendChild(card);
      } else {
        const wrapper = document.createElement('div');
        wrapper.className = 'both-footnote-card';
        wrapper.style.cssText = 'padding:10px;background:#fff;border-radius:6px;border-left:3px solid #6c757d;box-shadow:0 1px 3px rgba(0,0,0,0.06);';
        const clone = item.clone;
        if (!clone.querySelector('.footnote-num')) {
          const num = document.createElement('span');
          num.className = 'footnote-num';
          const label = (item.displayIndex && String(item.displayIndex).trim().length)
            ? String(item.displayIndex).trim()
            : (item.number && String(item.number).trim().length)
              ? String(item.number).trim()
              : String(footMixed.indexOf(item) + 1);
          num.textContent = label + '. ';
          clone.insertBefore(num, clone.firstChild);
        }
        wrapper.appendChild(clone);
        list.appendChild(wrapper);
      }
    });
    host.appendChild(list);
    reinforceAnchors(list);
    setupScrollSyncForBoth(host, merged);
  }

  // 本文側のスクロール位置と右パネル内部スクロールの同期ユーティリティ
  function computeScrollRatioFromPositions(positions) {
    if (!Array.isArray(positions) || !positions.length) return null;
    let minPos = Infinity;
    let maxPos = -Infinity;
    positions.forEach(p => {
      if (typeof p !== 'number' || !isFinite(p)) return;
      if (p < minPos) minPos = p;
      if (p > maxPos) maxPos = p;
    });
    if (!isFinite(minPos) || !isFinite(maxPos)) return null;

    const scrollY = window.scrollY || window.pageYOffset || document.documentElement.scrollTop || 0;
    const viewH = window.innerHeight || document.documentElement.clientHeight || 0;
    const center = scrollY + viewH / 2;

    if (maxPos === minPos) {
      return center <= minPos ? 0 : 1;
    }
    let ratio = (center - minPos) / (maxPos - minPos);
    if (ratio < 0) ratio = 0;
    else if (ratio > 1) ratio = 1;
    return ratio;
  }

  function scrollRightSidebarToRatio(ratio, host) {
    if (ratio == null) return;
    const container = document.getElementById('quarto-margin-sidebar') || host;
    if (!container) return;
    const maxScroll = container.scrollHeight - container.clientHeight;
    if (!(maxScroll > 0)) return;
    const clamped = Math.max(0, Math.min(1, ratio));
    container.scrollTop = maxScroll * clamped;
  }

  function setupScrollSyncForFootnotes(host, items) {
    const mode = localStorage.getItem('footnotes-sort') || 'pos';
    if (mode !== 'pos') return;
    if (!Array.isArray(items) || !items.length) return;
    const positions = items
      .map(it => (typeof it.pos === 'number' ? it.pos : null))
      .filter(p => typeof p === 'number' && isFinite(p));
    if (!positions.length) return;

    const onScroll = () => {
      const ratio = computeScrollRatioFromPositions(positions);
      scrollRightSidebarToRatio(ratio, host);
    };
    window.addEventListener('scroll', onScroll, { passive: true });
  }

  function setupScrollSyncForBoth(host, items) {
    const onScroll = () => {
      if (!Array.isArray(items) || !items.length) return;
      const positions = items
        .map(it => (typeof it.top === 'number' ? it.top : null))
        .filter(p => typeof p === 'number' && isFinite(p));
      const ratio = computeScrollRatioFromPositions(positions);
      scrollRightSidebarToRatio(ratio, host);
    };
    window.addEventListener('scroll', onScroll, { passive: true });
  }

  function renderCommentsPanel() {
    const marginSidebar = document.getElementById('quarto-margin-sidebar');
    if (!marginSidebar) return;
    const commHost = marginSidebar.querySelector('.right-comments');
    if (!commHost) return;
    const list = getActiveComments();
    commHost.innerHTML = '';

    const header = document.createElement('div');
    header.style.cssText = 'display:flex;align-items:center;justify-content:space-between;margin-bottom:6px;';
    const title = document.createElement('h2');
    title.className = 'footnotes-title';
    title.textContent = 'コメント';
    const sort = document.createElement('select');
    sort.innerHTML = '<option value="new">新しい順</option><option value="pos">本文位置順</option><option value="old">古い順</option>';
    sort.value = localStorage.getItem('comments-sort') || 'new';
    sort.addEventListener('change', () => { localStorage.setItem('comments-sort', sort.value); renderCommentsPanel(); });
    header.appendChild(title); header.appendChild(sort);
    commHost.appendChild(header);

    if (!list.length) { commHost.insertAdjacentHTML('beforeend','<p class="footnotes-empty">コメントはありません。</p>'); return; }

    const computePos = (rec) => {
      const el = findCommentAnchorElement(rec);
      const top = el ? (el.getBoundingClientRect().top + window.scrollY) : Infinity;
      return top;
    };

    let arr = list.slice();
    const mode = sort.value;
    if (mode === 'new') arr.sort((a,b)=>b.t-a.t);
    else if (mode === 'old') arr.sort((a,b)=>a.t-b.t);
    else if (mode === 'pos') arr.sort((a,b)=>computePos(a)-computePos(b));

    const ul = document.createElement('ul');
    ul.className = 'comment-list';
    ul.style.listStyle = 'none'; ul.style.padding = '0'; ul.style.margin = '0';

    arr.forEach(rec => {
      const li = document.createElement('li');
      li.dataset.id = rec.id;
      li.className = 'comment-item';
      li.style.cssText = 'margin:12px 0; padding:10px; background:#fff; border-radius:6px; border-left:3px solid #6c757d; box-shadow:0 1px 3px rgba(0,0,0,0.08); position:relative;';
      const meta = document.createElement('div');
      meta.className = 'comment-meta';
      meta.style.cssText = 'font-size:12px; color:#6c757d; margin-bottom:6px; display:flex; gap:8px; align-items:center;';
      const time = fmtMMDDHHmm(rec.t);
      const move = document.createElement('a');
      move.href = '#'; move.textContent = '移動';
      move.addEventListener('click', (e) => { e.preventDefault(); scrollToComment(rec); });
      const menuBtn = document.createElement('button');
      menuBtn.textContent = '⋯';
      menuBtn.setAttribute('aria-label','メニュー');
      menuBtn.style.cssText = 'margin-left:auto;background:none;border:none;cursor:pointer;font-size:18px;line-height:1;';
      menuBtn.addEventListener('click', (e) => { e.stopPropagation(); openCommentMenu(li, rec, {x:e.clientX,y:e.clientY}); });
      meta.innerHTML = `<span>${time}</span>`;
      meta.appendChild(move);
      meta.appendChild(menuBtn);

      const target = document.createElement('div');
      target.className = 'comment-snippet';
      target.style.cssText = 'font-size:13px; color:#495057; background:#f8f9fa; padding:6px 8px; border-radius:4px; margin-bottom:6px;';
      target.textContent = rec.text || '';
      const body = document.createElement('div');
      body.className = 'comment-body';
      body.style.cssText = 'white-space:pre-wrap; line-height:1.5;';
      body.textContent = rec.body || '';
      li.appendChild(meta); li.appendChild(target); li.appendChild(body);
      ul.appendChild(li);
    });

    commHost.appendChild(ul);
    setupScrollSyncForComments(commHost, arr);
  }

  let commentMenuCleanup = null;

  function openCommentMenu(li, rec, pt) {
    closeAnyInlineMenu();
    const menu = document.createElement('div');
    menu.className = 'comment-menu-popup';
    menu.style.cssText = 'position:fixed; background:#fff; border:1px solid #e1e5eb; box-shadow:0 4px 12px rgba(0,0,0,0.12); border-radius:6px; z-index:10001; padding:6px;';
    menu.innerHTML = '<button type="button" data-act="edit" style="display:block;width:100%;text-align:left;padding:6px 10px;background:none;border:none;cursor:pointer;">編集</button>\n<button type="button" data-act="del" style="display:block;width:100%;text-align:left;padding:6px 10px;background:none;border:none;cursor:pointer;">削除</button>';
    document.body.appendChild(menu);
    const x = pt?.x || (li.getBoundingClientRect().right - 10);
    const y = pt?.y || (li.getBoundingClientRect().top + 20);
    menu.style.left = x + 'px';
    menu.style.top = y + 'px';
    const onDoc = (e)=>{ if (!menu.contains(e.target)) { closeAnyInlineMenu(); } };
    const onViewportChange = () => closeAnyInlineMenu();
    document.addEventListener('mousedown', onDoc, true);
    window.addEventListener('scroll', onViewportChange, true);
    window.addEventListener('resize', onViewportChange);
    commentMenuCleanup = () => {
      document.removeEventListener('mousedown', onDoc, true);
      window.removeEventListener('scroll', onViewportChange, true);
      window.removeEventListener('resize', onViewportChange);
      commentMenuCleanup = null;
    };
    menu.addEventListener('click', (e) => {
      const act = e.target?.getAttribute('data-act');
      if (act === 'edit') editComment(rec);
      if (act === 'del') deleteComment(rec);
      closeAnyInlineMenu();
    });
  }

  function closeAnyInlineMenu(){
    document.querySelectorAll('.comment-menu-popup').forEach(n=>n.remove());
    if (typeof commentMenuCleanup === 'function') {
      commentMenuCleanup();
    }
  }

  function editComment(rec) {
    const overlay = document.createElement('div');
    overlay.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.4);z-index:10000;display:flex;align-items:center;justify-content:center;';
    const dialog = document.createElement('div');
    dialog.style.cssText = 'background:#fff;color:#222;max-width:600px;width:92%;padding:16px;border-radius:8px;box-shadow:0 10px 30px rgba(0,0,0,0.25);';
    dialog.innerHTML = `
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
        <h3 style="margin:0;font-size:16px;">コメント編集</h3>
        <button type=\"button\" aria-label=\"閉じる\" style=\"background:none;border:none;font-size:18px;cursor:pointer;\">×</button>
      </div>
      <div style="font-size:13px;color:#555;background:#f8f9fa;border:1px solid #e9ecef;padding:8px;border-radius:4px;margin-bottom:8px;">対象: ${(rec.text||'').slice(0,140)}</div>
      <textarea id="comment-edit-area" rows="6" style="width:100%;font-size:14px;padding:8px;border-radius:6px;border:1px solid #ced4da;resize:vertical;">${(rec.body||'')}</textarea>
      <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:10px;">
        <button type="button" id="comment-edit-cancel" style="padding:6px 12px;border:1px solid #dee2e6;border-radius:4px;background:#f8f9fa;cursor:pointer;">キャンセル</button>
        <button type="button" id="comment-edit-save" style="padding:6px 12px;border:1px solid #0d6efd;border-radius:4px;background:#0d6efd;color:#fff;cursor:pointer;">保存</button>
      </div>
    `;
    overlay.appendChild(dialog);
    document.body.appendChild(overlay);
    const close = ()=>{
      overlay.remove();
      document.removeEventListener('keydown', onKey);
    };
    const onKey = (evt) => {
      if (evt.key === 'Escape') {
        evt.preventDefault();
        close();
      }
    };
    dialog.querySelector('[aria-label="閉じる"]').addEventListener('click', close);
    dialog.querySelector('#comment-edit-cancel').addEventListener('click', close);
    overlay.addEventListener('click', (evt) => {
      if (evt.target === overlay) {
        close();
      }
    });
    document.addEventListener('keydown', onKey);
    const editTextarea = dialog.querySelector('#comment-edit-area');
    const editSaveBtn = dialog.querySelector('#comment-edit-save');
    editSaveBtn.addEventListener('click', () => {
      if (editSaveBtn.disabled) return;
      const v = (editTextarea.value||'').trim();
      if (!v) { editTextarea.focus(); return; }
      editSaveBtn.disabled = true;
      const originalLabel = editSaveBtn.textContent;
      editSaveBtn.textContent = '保存中…';
      let success = false;
      try {
        const key = pageKey();
        const arr = COMMENTS_DB[key]||[];
        const idx = arr.findIndex(x=>x.id===rec.id);
        if (idx>=0) {
          arr[idx].body = v;
          arr[idx].t = Date.now();
          COMMENTS_DB[key]=arr;
          saveComments();
          refreshRightPanels();
          refreshCommentMarkersFromDB();
        }
        success = true;
      } catch (error) {
        console.warn('Failed to update comment', error);
      }
      if (success) {
        Promise.resolve().then(() => {
          closeAnyInlineMenu();
          close();
        });
      } else {
        editSaveBtn.disabled = false;
        editSaveBtn.textContent = originalLabel;
      }
    });
  }

  function deleteComment(rec) {
    closeAnyInlineMenu();
    if (!confirm('このコメントを削除しますか？')) return;
    const key = pageKey();
    const arr = COMMENTS_DB[key]||[];
    COMMENTS_DB[key] = arr.filter(x=>x.id!==rec.id);
    saveComments();
    // マーカーも削除
    document.querySelectorAll(`.text-marker[data-comment-id="${rec.id}"]`).forEach(el => {
      const p = el.parentNode; while (el.firstChild) p.insertBefore(el.firstChild, el); p.removeChild(el);
    });
    refreshCommentMarkersFromDB();
    refreshRightPanels();
  }

  function setupScrollSyncForComments(host, items) {
    const mode = localStorage.getItem('comments-sort') || 'new';
    if (mode !== 'pos') return;
    if (!Array.isArray(items) || !items.length) return;
    const positions = items
      .map(rec => {
        const el = findCommentAnchorElement(rec);
        if (!el) return null;
        const rect = el.getBoundingClientRect();
        return rect ? (rect.top + window.scrollY) : null;
      })
      .filter(p => typeof p === 'number' && isFinite(p));
    if (!positions.length) return;

    const onScroll = () => {
      const ratio = computeScrollRatioFromPositions(positions);
      scrollRightSidebarToRatio(ratio, host);
    };
    window.addEventListener('scroll', onScroll, { passive: true });
  }

  function scrollToComment(rec) {
    try {
      const first = (rec.ranges && rec.ranges[0]);
      if (!first) return;
      const node = getNodeByPathSafe(first.s);
      if (!node) return;
      let el = node.nodeType === Node.ELEMENT_NODE ? node : node.parentElement;
      while (el && el !== document.body && !(el instanceof HTMLElement)) el = el.parentElement;
      if (!el) return;
      el.scrollIntoView({ behavior: 'smooth', block: 'center' });
      const prev = el.style.boxShadow;
      el.style.transition = 'box-shadow 0.3s ease';
      el.style.boxShadow = '0 0 0 3px rgba(26,115,232,0.5)';
      setTimeout(() => { el.style.boxShadow = prev || ''; }, 1600);
    } catch (e) { console.warn('scrollToComment failed', e); }
  }

  function getNodeByPathSafe(path) {
    try { let n=document.body; for (const idx of path||[]) { if (!n || !n.childNodes[idx]) return null; n = n.childNodes[idx]; } return n; } catch { return null; }
  }

  function renderInlineFootnotes() {
    setInlineFootnoteMode(true);
    const marginSidebar = document.getElementById('quarto-margin-sidebar');
    if (marginSidebar && marginSidebar.style.display !== 'none') {
      marginSidebar.dataset.prevDisplay = marginSidebar.style.display || '';
      marginSidebar.style.display = 'none';
    }
    document.querySelectorAll('.footnote-inline').forEach(n => n.remove());
    const active = getActiveChapterSection();
    const scope = active || document;
    const refSelector = 'a[role="doc-noteref"], a.footnote-ref';
    const refs = Array.from(scope.querySelectorAll(refSelector)).filter(ref => !active || active.contains(ref));
    if (!refs.length) return;
    const hostTailMap = new Map();
    refs.forEach(ref => {
      const href = ref.getAttribute('href') || ref.getAttribute('data-footnote-href');
      if (!href || !href.startsWith('#')) return;
      const id = href.slice(1);
      const target = document.getElementById(id);
      if (!target) return;
      if (active) {
        const section = target.closest('section.chapter-page');
        if (section && section !== active) return;
      }
      const numberText = (ref.textContent || '').replace(/[^0-9]/g, '') || '';
      const host = findHostParagraph(ref);
      if (!host) return;
      const clone = target.cloneNode(true);
      clone.querySelectorAll('.footnote-back, .footnote-backref, [role="doc-backlink"]').forEach(a => a.remove());
      const container = document.createElement('div');
      container.className = 'footnote-inline';
      const numSpan = document.createElement('span');
      numSpan.className = 'footnote-num';
      numSpan.textContent = (numberText ? numberText : '') + '. ';
      container.appendChild(numSpan);
      while (clone.firstChild) container.appendChild(clone.firstChild);
      const tail = hostTailMap.get(host);
      if (tail && tail.parentNode) {
        tail.insertAdjacentElement('afterend', container);
      } else {
        host.insertAdjacentElement('afterend', container);
      }
      hostTailMap.set(host, container);
      reinforceAnchors(container);
    });
    ensureCommentMarkerInteractions();
    scheduleScrollExtensionUpdate();
  }

  function findHostParagraph(el) {
    let p = el;
    while (p && p !== document.body) {
      if (p.tagName === 'P' || p.tagName === 'LI') return p;
      p = p.parentElement;
    }
    return null;
  }

  function debounce(fn, ms) {
    let t;
    return (...args) => { clearTimeout(t); t = setTimeout(() => fn.apply(this, args), ms); };
  }

function setupMarkerFunctionality() {
    let markersDB = JSON.parse(localStorage.getItem(STORAGE_KEYS.markers) || '{}');
    let pendingSerializedRange = null;

    const handleSelectionEvent = (e) => {
      if (closestInteractive(e.target)) return;
      const sel = window.getSelection();
      if (!sel || sel.rangeCount === 0) {
        hideMarkerToolbar();
        pendingSerializedRange = null;
        return;
}

  function getHeadingElements() {
    const scope = document.getElementById('quarto-document-content');
    if (!scope) return [];
    return scope.querySelectorAll('h1, h2, h3, h4, h5, h6');
  }

  function enumerateReadingNodes() {}

  function findReadableElement(node) {
    const scope = document.getElementById('quarto-document-content');
    if (!scope) return null;
    let current = node;
    while (current && current !== document.body) {
      if (current.tagName) {
        const tag = current.tagName.toLowerCase();
        if (['p','li','blockquote','pre','table','figure','dd','dt'].includes(tag)) {
          return current;
        }
      }
      current = current.parentElement;
    }
    return null;
  }

  function captureReadingState(options) {
    const opts = options || {};
    const headings = getHeadingElements();
    const docEl = document.documentElement;
    const body = document.body;
    const scrollTop = (docEl && docEl.scrollTop) || (body && body.scrollTop) || 0;
    const viewportHeight = window.innerHeight || docEl.clientHeight || 0;
    const viewportWidth = window.innerWidth || docEl.clientWidth || body.clientWidth || 0;
    const focusLine = scrollTop + viewportHeight * 0.35;
    let current = null;
    for (let i = 0; i < headings.length; i += 1) {
      const el = headings[i];
      const top = el.offsetTop;
      if (top <= focusLine) {
        current = el;
      } else {
        break;
      }
    }
    if (!current && headings.length) {
      current = headings[0];
    }
    const pageHeight = Math.max(1, (docEl && docEl.scrollHeight) || (body && body.scrollHeight) || 1) - viewportHeight;
    const pageRatio = pageHeight > 0 ? scrollTop / pageHeight : 0;
    const state = { pageRatio };
    const centerX = viewportWidth / 2;
    let focusNode = null;
    try {
      focusNode = document.elementFromPoint(centerX, viewportHeight * 0.4);
    } catch (e) {
      focusNode = null;
    }
    if (current) {
      const currentId = current.getAttribute('id') || current.getAttribute('data-anchor-id') || '';
      const next = current.nextElementSibling ? current.nextElementSibling.closest('h1, h2, h3, h4, h5, h6') : null;
      let nextTop = null;
      if (next) {
        nextTop = next.offsetTop;
      } else {
        nextTop = (docEl && docEl.scrollHeight) || (body && body.scrollHeight) || (current.offsetTop + viewportHeight);
      }
      const currentTop = current.offsetTop;
      const sectionHeight = Math.max(1, nextTop - currentTop);
      const rel = (focusLine - currentTop) / sectionHeight;
      if (currentId) {
        state.sectionId = currentId;
        state.sectionOffset = Math.min(0.995, Math.max(0, rel));
      }
    }
    const focusElement = findReadableElement(focusNode);
    if (focusElement) {
      const rect = focusElement.getBoundingClientRect();
      const elementHeight = Math.max(1, rect.height || focusElement.offsetHeight || 1);
      const elementTop = focusElement.offsetTop;
      const relInElement = Math.min(0.995, Math.max(0, (focusLine - elementTop) / elementHeight));
      state.focusElementOffset = relInElement;
      const id = focusElement.getAttribute('id') || focusElement.getAttribute('data-anchor-id') || '';
      if (id) state.focusElementId = id;
      if (opts.captureNodeRef) {
        state.__focusNode = focusElement;
      }
    }
    return state;
  }

  function scrollToReadingState(state) {
    if (!state) return false;
    const docEl = document.documentElement;
    const body = document.body;
    const viewportHeight = window.innerHeight || docEl.clientHeight || 0;
    const focusRatio = typeof state.focusElementOffset === 'number' ? state.focusElementOffset : null;
    const resolveFocusTarget = () => {
      if (state.__focusNode && state.__focusNode instanceof HTMLElement && document.body.contains(state.__focusNode)) {
        return state.__focusNode;
      }
      if (state.focusElementId) {
        return document.getElementById(state.focusElementId) || document.querySelector(`[data-anchor-id="${state.focusElementId}"]`);
      }
      return null;
    };
    const focusTarget = resolveFocusTarget();
    if (focusTarget) {
      const ratio = focusRatio != null ? focusRatio : 0.35;
      const targetTop = focusTarget.offsetTop + ratio * Math.max(1, focusTarget.offsetHeight || 1);
      const desired = targetTop - viewportHeight * 0.35;
      window.scrollTo({ top: Math.max(0, desired), behavior: 'auto' });
      return true;
    }
    if (state.sectionId) {
      const selector = `#${escapeCssId(state.sectionId)}`;
      let target = document.querySelector(selector);
      if (!target) {
        target = document.querySelector(`[data-anchor-id="${state.sectionId}"]`);
      }
      if (target) {
        const headings = Array.from(getHeadingElements());
        const idx = headings.indexOf(target);
        let nextTop = null;
        if (idx >= 0 && idx + 1 < headings.length) {
          nextTop = headings[idx + 1].offsetTop;
        } else {
          nextTop = (docEl && docEl.scrollHeight) || (body && body.scrollHeight) || (target.offsetTop + viewportHeight);
        }
        const currentTop = target.offsetTop;
        const sectionHeight = Math.max(1, nextTop - currentTop);
        const rel = typeof state.sectionOffset === 'number' ? state.sectionOffset : 0;
        const dest = currentTop + rel * sectionHeight;
        window.scrollTo({ top: Math.max(0, dest), behavior: 'auto' });
        return true;
      }
    }
    if (typeof state.pageRatio === 'number') {
      const docHeight = Math.max(1, ((docEl && docEl.scrollHeight) || (body && body.scrollHeight) || 1) - viewportHeight);
      const targetY = state.pageRatio * docHeight;
      window.scrollTo({ top: Math.max(0, targetY), behavior: 'auto' });
      return true;
    }
    return false;
  }

  function escapeCssId(id) {
    if (window.CSS && typeof window.CSS.escape === 'function') {
      return window.CSS.escape(id);
    }
    return id.replace(/[^a-zA-Z0-9_\-]/g, '\\$&');
  }

  function restoreReadingState() {
    let raw = null;
    try {
      raw = sessionStorage.getItem(STORAGE_KEYS.readingState);
    } catch (e) {
      raw = null;
    }
    if (!raw) return;
    let state = null;
    try {
      state = JSON.parse(raw);
    } catch (e) {
      state = null;
    }
    scrollToReadingState(state);
  }

  function persistReadingState() {
    let state = null;
    try {
      state = captureReadingState();
    } catch (e) {
      state = null;
    }
    if (!state) return;
    try {
      sessionStorage.setItem(STORAGE_KEYS.readingState, JSON.stringify(state));
    } catch (e) {
      // ignore
    }
  }

  function scheduleReadingStateSave() {
    if (readingStateSaveTimer) return;
    readingStateSaveTimer = window.setTimeout(() => {
      readingStateSaveTimer = null;
      persistReadingState();
    }, 500);
  }
      const text = sel.toString().trim();
      if (text) {
        const rect = getSelectionRect(sel);
        const fallbackPoint = { x: e.clientX, y: e.clientY };
        try {
          pendingSerializedRange = serializeRange(sel.getRangeAt(0));
        } catch {
          pendingSerializedRange = null;
        }
        showMarkerToolbar(rect, fallbackPoint);
      } else {
        hideMarkerToolbar();
        pendingSerializedRange = null;
      }
    };

    // テキスト選択でツールバーを表示（UI要素上は無効）
    document.addEventListener('mouseup', handleSelectionEvent);
    document.addEventListener('touchend', handleSelectionEvent);

    function closestInteractive(el){
      return el.closest('.marker-toolbar, .js-header, .global-search-dialog, #quarto-sidebar');
    }

    function getSelectionRect(selection) {
      if (!selection || selection.rangeCount === 0) return null;
      try {
        const range = selection.getRangeAt(0).cloneRange();
        const rect = range.getBoundingClientRect();
        if (rect && (rect.width || rect.height)) return rect;
        const rects = range.getClientRects();
        for (const r of rects) {
          if (r.width || r.height) return r;
        }
      } catch (err) {
        console.warn('getSelectionRect failed', err);
      }
      const focusContainer = selection.focusNode instanceof Element ? selection.focusNode : selection.focusNode?.parentElement;
      return focusContainer ? focusContainer.getBoundingClientRect() : null;
    }

    function showMarkerToolbar(rect, fallbackPoint) {
      let toolbar = document.querySelector('.marker-toolbar');
      if (!toolbar) {
        toolbar = createMarkerToolbar();
        document.body.appendChild(toolbar);
      }
      toolbar.classList.add('show');
      toolbar.style.display = 'flex';
      toolbar.style.flexDirection = 'column';
      toolbar.style.gap = '6px';
      toolbar.style.position = 'absolute';
      toolbar.style.removeProperty('right');
      toolbar.style.removeProperty('bottom');
      positionMarkerToolbar(toolbar, rect, fallbackPoint);
    }

    function positionMarkerToolbar(toolbar, rect, fallbackPoint) {
      requestAnimationFrame(() => {
        if (!toolbar.classList.contains('show')) return;
        let targetRect = rect;
        if (!targetRect || (!(targetRect.width || targetRect.height))) {
          if (fallbackPoint && typeof fallbackPoint.x === 'number' && typeof fallbackPoint.y === 'number') {
            targetRect = {
              top: fallbackPoint.y,
              bottom: fallbackPoint.y,
              left: fallbackPoint.x,
              right: fallbackPoint.x,
              width: 0,
              height: 0
            };
          } else {
            const vw = window.innerWidth || document.documentElement.clientWidth || 0;
            const vh = window.innerHeight || document.documentElement.clientHeight || 0;
            targetRect = {
              top: vh / 2,
              bottom: vh / 2,
              left: vw / 2,
              right: vw / 2,
              width: 0,
              height: 0
            };
          }
        }
        const scrollX = window.scrollX ?? window.pageXOffset ?? document.documentElement.scrollLeft ?? 0;
        const scrollY = window.scrollY ?? window.pageYOffset ?? document.documentElement.scrollTop ?? 0;
        const toolbarWidth = toolbar.offsetWidth;
        const toolbarHeight = toolbar.offsetHeight;
        const margin = 12;
        const viewportWidth = document.documentElement.clientWidth || window.innerWidth || toolbarWidth;
        const rectWidth = targetRect.width ?? (targetRect.right - targetRect.left) ?? 0;
        const rectCenterX = targetRect.left + rectWidth / 2;
        let left = scrollX + rectCenterX - toolbarWidth / 2;
        left = Math.max(scrollX + 8, Math.min(left, scrollX + viewportWidth - toolbarWidth - 8));
        const rectBottom = targetRect.bottom ?? (targetRect.top + targetRect.height) ?? targetRect.top;
        let top = scrollY + targetRect.top - toolbarHeight - margin;
        if (top < scrollY + 8) {
          top = scrollY + rectBottom + margin;
        }
        const viewportHeight = document.documentElement.clientHeight || window.innerHeight || toolbarHeight;
        const maxTop = scrollY + viewportHeight - toolbarHeight - 8;
        top = Math.min(top, maxTop);
        toolbar.style.left = `${Math.round(left)}px`;
        toolbar.style.top = `${Math.round(top)}px`;
      });
    }

    function createMarkerToolbar() {
      const toolbar = document.createElement('div');
      toolbar.className = 'marker-toolbar';
      toolbar.innerHTML = `
        <div class="marker-controls" role="toolbar" aria-label="ハイライト色選択">
          <div class="marker-colors">
            <button type="button" class="marker-color-btn" data-color="yellow" title="黄"></button>
            <button type="button" class="marker-color-btn" data-color="green" title="緑"></button>
            <button type="button" class="marker-color-btn" data-color="blue" title="青"></button>
            <button type="button" class="marker-color-btn" data-color="pink" title="ピンク"></button>
          </div>
          <button type="button" class="marker-comment-btn" title="選択範囲にコメント" aria-label="選択範囲にコメント"></button>
        </div>
      `;
      toolbar.querySelectorAll('.marker-color-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          applyMarker(btn.dataset.color);
          hideMarkerToolbar();
        });
      });
      const commentBtn = toolbar.querySelector('.marker-comment-btn');
      if (commentBtn) {
        commentBtn.addEventListener('click', () => {
          openCommentDialog();
        });
      }
      return toolbar;
    }

    function openCommentDialog() {
      const selection = window.getSelection();
      let baseRange = null;
      if (selection && selection.rangeCount > 0 && selection.toString().trim()) {
        baseRange = selection.getRangeAt(0);
      } else if (pendingSerializedRange) {
        baseRange = deserializeRange(pendingSerializedRange);
      }
      if (!baseRange || baseRange.collapsed) return;

      const overlay = document.createElement('div');
      overlay.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.4);z-index:10000;display:flex;align-items:center;justify-content:center;';
      const dialog = document.createElement('div');
      dialog.style.cssText = 'background:#fff;color:#222;max-width:600px;width:92%;padding:16px;border-radius:8px;box-shadow:0 10px 30px rgba(0,0,0,0.25);';
      dialog.innerHTML = `
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
          <h3 style="margin:0;font-size:16px;">コメントを追加</h3>
          <button type="button" aria-label="閉じる" style="background:none;border:none;font-size:18px;cursor:pointer;">×</button>
        </div>
        <div style="font-size:13px;color:#555;background:#f8f9fa;border:1px solid #e9ecef;padding:8px;border-radius:4px;margin-bottom:8px;" id="comment-snippet"></div>
        <textarea id="comment-textarea" rows="6" style="width:100%;font-size:14px;padding:8px;border-radius:6px;border:1px solid #ced4da;resize:vertical;" placeholder="ここにコメントを入力（長文可）"></textarea>
        <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:10px;">
          <button type="button" id="comment-cancel" style="padding:6px 12px;border:1px solid #dee2e6;border-radius:4px;background:#f8f9fa;cursor:pointer;">キャンセル</button>
          <button type="button" id="comment-save" style="padding:6px 12px;border:1px solid #0d6efd;border-radius:4px;background:#0d6efd;color:#fff;cursor:pointer;">保存</button>
        </div>
      `;
      overlay.appendChild(dialog);
      document.body.appendChild(overlay);

      const close = () => overlay.remove();
      dialog.querySelector('button[aria-label="閉じる"]').addEventListener('click', close);
      dialog.querySelector('#comment-cancel').addEventListener('click', close);

      // 選択スニペット表示
      const snippet = baseRange.cloneContents().textContent || window.getSelection().toString();
      dialog.querySelector('#comment-snippet').textContent = `対象: ${snippet?.slice(0,140) || ''}`;

      const saveBtn = dialog.querySelector('#comment-save');
      const commentTextarea = dialog.querySelector('#comment-textarea');
      const originalLabel = saveBtn.textContent;
      saveBtn.addEventListener('click', () => {
        if (saveBtn.disabled) return;
        const body = (commentTextarea.value || '').trim();
        if (!body) { commentTextarea.focus(); return; }
        const segs = getTextSegments(baseRange);
        if (!segs.length) { close(); return; }
        saveBtn.disabled = true;
        saveBtn.textContent = '保存中…';
        let saved = false;
        try {
          const serializedRanges = segs.map(seg => ({ s: getPath(seg.node), so: seg.start, e: getPath(seg.node), eo: seg.end }));
          const rec = { id: `comment-${Date.now()}-${Math.floor(Math.random()*1000)}`, ranges: serializedRanges, text: snippet, body, t: Date.now(), slug: getCurrentChapterSlug() || null };
          const key = pageKey();
          if (!COMMENTS_DB[key]) COMMENTS_DB[key] = [];
          COMMENTS_DB[key].push(rec);
          saveComments();
          saved = true;
          segs.forEach(seg => {
            const span = document.createElement('span');
            span.className = 'text-marker marker-orange';
            span.setAttribute('data-comment-id', rec.id);
            applyColorStyles(span, 'orange');
            wrapBySplitText(seg.node, seg.start, seg.end, span);
          });
          ensureCommentMarkerInteractions();
          try {
            refreshRightPanels();
          } catch (panelError) {
            console.warn('Refresh right panels failed after comment', panelError);
          }
          hideMarkerToolbar();
          const selection = window.getSelection();
          if (selection && typeof selection.removeAllRanges === 'function') {
            selection.removeAllRanges();
          }
          pendingSerializedRange = null;
        } catch (error) {
          console.warn('Failed to save comment', error);
          saveBtn.disabled = false;
          saveBtn.textContent = originalLabel;
          return;
        }
        close();
      });
    }

    function applyMarker(color) {
      const selection = window.getSelection();
      let baseRange = null;
      if (selection && selection.rangeCount > 0 && selection.toString().trim()) {
        baseRange = selection.getRangeAt(0);
      } else if (pendingSerializedRange) {
        baseRange = deserializeRange(pendingSerializedRange);
      }
      if (!baseRange || baseRange.collapsed) return;

      const markerId = `marker-${Date.now()}-${Math.floor(Math.random()*1000)}`;
      const segments = getTextSegments(baseRange);
      if (!segments.length) return;

      const serializedRanges = [];
      segments.forEach(seg => {
        // 分割済みサブレンジをスタイル付与
        const span = document.createElement('span');
        span.className = `text-marker marker-${color}`;
        span.setAttribute('data-marker-id', markerId);
        applyColorStyles(span, color);
        span.addEventListener('dblclick', () => removeMarkerGroup(markerId));
        span.addEventListener('contextmenu', (e) => { e.preventDefault(); cycleMarkerColorGroup(markerId); });

        // 信頼性の高いsplitTextベースのラップ（file://でも安定）
        const serialized = { s: getPath(seg.node), so: seg.start, e: getPath(seg.node), eo: seg.end };
        wrapBySplitText(seg.node, seg.start, seg.end, span);
        serializedRanges.push(serialized);
      });

      selection.removeAllRanges();

      const page = window.location.pathname;
      if (!markersDB[page]) markersDB[page] = [];
      markersDB[page].push({ id: markerId, color, ranges: serializedRanges, t: Date.now() });
      saveMarkers();
      pendingSerializedRange = null;
    }

    // 選択範囲に交差するテキストノードをサブレンジに分割
    function getTextSegments(range) {
      const segments = [];

      // ルートがテキストノードの場合を考慮
      if (range.commonAncestorContainer && range.commonAncestorContainer.nodeType === Node.TEXT_NODE) {
        const node = range.commonAncestorContainer;
        const start = (node === range.startContainer) ? range.startOffset : 0;
        const end = (node === range.endContainer) ? range.endOffset : (node.nodeValue || '').length;
        if (start !== end) segments.push({ node, start, end });
        return segments;
      }

      const walker = document.createTreeWalker(
        range.commonAncestorContainer,
        NodeFilter.SHOW_TEXT,
        {
          acceptNode: (node) => {
            try {
              return range.intersectsNode(node) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;
            } catch (e) {
              // フォールバック: compareBoundaryPoints
              if (!node.nodeValue) return NodeFilter.FILTER_REJECT;
              const r = document.createRange();
              r.selectNodeContents(node);
              const endVsStart = range.compareBoundaryPoints(Range.END_TO_START, r);
              if (endVsStart <= 0) return NodeFilter.FILTER_REJECT;
              const startVsEnd = range.compareBoundaryPoints(Range.START_TO_END, r);
              if (startVsEnd >= 0) return NodeFilter.FILTER_REJECT;
              return NodeFilter.FILTER_ACCEPT;
            }
          }
        }
      );

      let node;
      while ((node = walker.nextNode())) {
        let start = 0;
        let end = node.nodeValue.length;
        if (node === range.startContainer && range.startContainer.nodeType === Node.TEXT_NODE) start = range.startOffset;
        if (node === range.endContainer && range.endContainer.nodeType === Node.TEXT_NODE) end = range.endOffset;
        if (start !== end) segments.push({ node, start, end });
      }
      return segments;
    }

    function hideMarkerToolbar() {
      const toolbar = document.querySelector('.marker-toolbar');
      if (toolbar) {
        toolbar.classList.remove('show');
        toolbar.style.display = 'none';
      }
    }

    function removeMarkerGroup(markerId) {
      document.querySelectorAll(`.text-marker[data-marker-id="${markerId}"]`).forEach(el => {
        const parent = el.parentNode;
        while (el.firstChild) parent.insertBefore(el.firstChild, el);
        parent.removeChild(el);
      });
      const page = window.location.pathname;
      if (markersDB[page]) {
        markersDB[page] = markersDB[page].filter(m => m.id !== markerId);
        if (!markersDB[page].length) delete markersDB[page];
        saveMarkers();
      }
    }

    function clearAllMarkers() {
      document.querySelectorAll('.text-marker').forEach(n => {
        const parent = n.parentNode;
        while (n.firstChild) parent.insertBefore(n.firstChild, n);
        parent.removeChild(n);
      });
      delete markersDB[window.location.pathname];
      saveMarkers();
    }

    function cycleMarkerColorGroup(markerId) {
      const order = ['yellow','green','blue','pink'];
      const els = Array.from(document.querySelectorAll(`.text-marker[data-marker-id="${markerId}"]`));
      if (!els.length) return;
      const el = els[0];
      const current = order.find(c => el.classList.contains(`marker-${c}`)) || 'yellow';
      const next = order[(order.indexOf(current)+1)%order.length];
      els.forEach(e => { order.forEach(c => e.classList.remove(`marker-${c}`)); e.classList.add(`marker-${next}`); applyColorStyles(e, next); });
      const page = window.location.pathname;
      const rec = (markersDB[page]||[]).find(m => m.id === markerId);
      if (rec) { rec.color = next; saveMarkers(); }
    }

    function saveMarkers(){ localStorage.setItem(STORAGE_KEYS.markers, JSON.stringify(markersDB)); }

    function restoreMarkers() {
      const page = window.location.pathname;
      const list = (markersDB[page] || []);
      list.forEach(m => {
        // 互換性: 古い形式 {range} を {ranges:[range]} に変換
        const ranges = m.ranges || (m.range ? [m.range] : []);
        ranges.forEach(rSerialized => {
        const tn = getNodeByPath(rSerialized.s);
        if (!tn || tn.nodeType !== Node.TEXT_NODE) return;
        const span = document.createElement('span');
        span.className = `text-marker marker-${m.color}`;
        span.setAttribute('data-marker-id', m.id);
        applyColorStyles(span, m.color);
        span.addEventListener('dblclick', () => removeMarkerGroup(m.id));
        span.addEventListener('contextmenu', (e) => { e.preventDefault(); cycleMarkerColorGroup(m.id); });
        wrapBySplitText(tn, rSerialized.so, rSerialized.eo, span);
        });
      });
    }

    function restoreCommentMarkers() {
      try {
        const list = (COMMENTS_DB[pageKey()] || []);
        list.forEach(rec => {
          (rec.ranges || []).forEach(r => {
            if (!r || typeof r.so !== 'number' || typeof r.eo !== 'number' || r.so === r.eo) return;
            const tn = getNodeByPath(r.s);
            if (!tn || tn.nodeType !== Node.TEXT_NODE) return;
            const span = document.createElement('span');
            span.className = 'text-marker marker-orange';
            span.setAttribute('data-comment-id', rec.id);
            applyColorStyles(span, 'orange');
            wrapBySplitText(tn, r.so, r.eo, span);
          });
        });
      } catch (e) {
        console.warn('restoreCommentMarkers failed', e);
      }
    }

    cleanupCommentMarkersDom = function() {
      document.querySelectorAll('.text-marker[data-comment-id]').forEach(span => {
        const parent = span.parentNode;
        if (!parent) return;
        while (span.firstChild) parent.insertBefore(span.firstChild, span);
        parent.removeChild(span);
      });
    };

    refreshCommentMarkersFromDB = function(options) {
      const preserveExisting = !!(options && options.preserveExisting);
      const existingCount = document.querySelectorAll('.text-marker[data-comment-id]').length;
      if (preserveExisting && existingCount > 0) {
        ensureCommentMarkerInteractions();
        return;
      }
      cleanupCommentMarkersDom();
      restoreCommentMarkers();
      ensureCommentMarkerInteractions();
    };

    // 既存マーカー / コメントマーカー再描画
    restoreMarkers();
    refreshCommentMarkersFromDB();

    // 範囲のシリアライズ/デシリアライズ
    function serializeRange(range) {
      return {
        s: getPath(range.startContainer), so: range.startOffset,
        e: getPath(range.endContainer), eo: range.endOffset
      };
    }
    function deserializeRange(obj) {
      try {
        const sc = getNodeByPath(obj.s);
        const ec = getNodeByPath(obj.e);
        if (!sc || !ec) return null;
        const r = document.createRange();
        r.setStart(sc, Math.min(obj.so, nodeMaxOffset(sc)));
        r.setEnd(ec, Math.min(obj.eo, nodeMaxOffset(ec)));
        return r;
      } catch { return null; }
    }
    function nodeIndex(node){ let i=0; while(node && node.previousSibling){ node = node.previousSibling; i++; } return i; }
    function getPath(node){ const p=[]; let n=node; while(n && n !== document.body){ p.push(nodeIndex(n)); n = n.parentNode; } return p.reverse(); }
    function getNodeByPath(path){ let n=document.body; for(const idx of path){ if(!n || !n.childNodes[idx]) return null; n = n.childNodes[idx]; } return n; }
    function nodeMaxOffset(n){ return n.nodeType===Node.TEXT_NODE ? (n.nodeValue||'').length : (n.childNodes?n.childNodes.length:0); }

    function wrapBySplitText(textNode, start, end, wrapper) {
      try {
        let mid = textNode;
        if (start > 0) mid = textNode.splitText(start);
        let tail = mid;
        const len = end - start;
        if (len < mid.nodeValue.length) tail = mid.splitText(len);
        const parent = mid.parentNode;
        parent.insertBefore(wrapper, mid);
        wrapper.appendChild(mid);
      } catch (e) {
        console.warn('wrapBySplitText failed', e);
      }
    }

    function applyColorStyles(el, color) {
      // インラインスタイルで確実に可視化（CSSが読み込めないfile://時の保険）
      const map = {
        yellow: 'rgba(255, 235, 59, 0.6)',
        green:  'rgba(129, 199, 132, 0.5)',
        blue:   'rgba(100, 181, 246, 0.5)',
        pink:   'rgba(244, 143, 177, 0.5)',
        orange: 'rgba(255, 152, 0, 0.45)'
      };
      el.style.backgroundColor = map[color] || 'rgba(255, 235, 59, 0.6)';
      el.style.boxShadow = 'inset 0 -0.15em 0 rgba(0,0,0,0.08)';
    }
  }

  function setupMobileFootnoteToggle() {
    document.querySelectorAll('.footnote-ref').forEach(footnote => {
      footnote.addEventListener('click', (e) => {
        e.preventDefault();
        const footnoteId = footnote.getAttribute('href');
        const footnoteDef = document.querySelector(footnoteId);
        if (footnoteDef) footnoteDef.classList.toggle('expanded');
      });
    });
  }

  function disableDefaultQuartoSearch() {
    try {
      const defaultBtn = document.getElementById('quarto-search');
      if (defaultBtn) defaultBtn.remove();
      const defaultPanel = document.getElementById('quarto-search-results');
      if (defaultPanel) defaultPanel.remove();
      const defaultOptions = document.getElementById('quarto-search-options');
      if (defaultOptions) defaultOptions.remove();
      if (window.Quarto && typeof window.Quarto.doc === 'object') {
        window.Quarto.doc.disableSearch = true;
      }
    } catch (e) {
      console.warn('Failed to disable default Quarto search', e);
    }
  }

  function setupSidebarSearch() {
    const sidebarSearch = document.querySelector('#quarto-sidebar .sidebar-search');
    if (!sidebarSearch) return;

    sidebarSearch.innerHTML = '';
    sidebarSearch.style.display = '';

    const utilityBar = document.createElement('div');
    utilityBar.className = 'sidebar-search-utility';

    const searchButton = document.createElement('button');
    searchButton.type = 'button';
    searchButton.className = 'sidebar-search-button';
    searchButton.setAttribute('aria-label', '検索を開く (Cmd+K)');
    searchButton.title = '検索 (Cmd+K)';

    const searchIcon = document.createElement('img');
    searchIcon.className = 'sidebar-search-button-icon';
    searchIcon.alt = '';
    searchIcon.decoding = 'async';
    searchIcon.loading = 'lazy';
    searchIcon.setAttribute('aria-hidden', 'true');
    searchIcon.src = resolveAssetPath('assets/search.png');

    searchButton.appendChild(searchIcon);
    searchButton.addEventListener('click', () => {
      const handle = openSearchOverlay('');
      if (handle && handle.input) {
        const inputEl = handle.input;
        const end = inputEl.value.length;
        inputEl.focus();
        inputEl.setSelectionRange(end, end);
      }
    });

    utilityBar.appendChild(searchButton);

    // プレビュー・コメント・マーカー一覧を開くボタン（検索アイコンのすぐ右）
    const listButton = document.createElement('button');
    listButton.type = 'button';
    listButton.className = 'sidebar-search-button sidebar-list-button';
    listButton.setAttribute('aria-label', 'プレビュー・コメント一覧を開く');
    listButton.title = 'プレビュー・コメント・マーカー一覧';
    listButton.style.marginLeft = '6px';

    const listIcon = document.createElement('img');
    listIcon.className = 'sidebar-search-button-icon';
    listIcon.alt = '';
    listIcon.decoding = 'async';
    listIcon.loading = 'lazy';
    listIcon.setAttribute('aria-hidden', 'true');
    listIcon.src = resolveAssetPath('assets/list.png');
    listButton.appendChild(listIcon);

    listButton.addEventListener('click', () => {
      openGlobalListOverlay();
    });

    utilityBar.appendChild(listButton);

    const meterWrapper = document.createElement('div');
    meterWrapper.className = 'sidebar-reading-meter';
    meterWrapper.setAttribute('role', 'status');
    meterWrapper.setAttribute('aria-label', '読書メーター');
    meterWrapper.title = '読書メーター';

    const meterValue = document.createElement('span');
    meterValue.className = 'sidebar-reading-meter-value';
    meterValue.textContent = '[0/0]';

    meterWrapper.appendChild(meterValue);
    utilityBar.appendChild(meterWrapper);

    sidebarSearch.appendChild(utilityBar);

    SEARCH_RESULTS_VIEW.sidebarContainer = null;
    SEARCH_RESULTS_VIEW.sidebarSummary = null;
    SEARCH_RESULTS_VIEW.sidebarList = null;
    SEARCH_RESULTS_VIEW.sidebarQuery = null;
    SEARCH_RESULTS_VIEW.sidebarClearBtn = null;

    initializeReadingMeter(meterValue);
    restoreSearchSession();
  }

  const SEARCH_SESSION_KEY = 'quarto-search-session';

  function saveSearchSession(session) {
    try {
      sessionStorage.setItem(SEARCH_SESSION_KEY, JSON.stringify(session));
    } catch (error) {
      console.warn('Search session save failed', error);
    }
  }

  function loadSearchSession() {
    try {
      const raw = sessionStorage.getItem(SEARCH_SESSION_KEY);
      if (!raw) return null;
      return JSON.parse(raw);
    } catch (error) {
      console.warn('Search session load failed', error);
      return null;
    }
  }

  function restoreSearchSession() {
    const session = loadSearchSession();
    if (!session || !Array.isArray(session.results) || !session.results.length) {
      clearSidebarSearchResults();
      return;
    }

    SEARCH_RESULTS_VIEW.sidebarData = session;
    renderSidebarSearchResults(session);

    const currentUrl = new URL(window.location.href, window.location.origin);
    if (session.active) {
      const target = new URL(session.active.url, window.location.href);
      if (target.origin === currentUrl.origin && target.pathname === currentUrl.pathname) {
        requestAnimationFrame(() => {
          clearSearchHighlights();
          scrollToMatchOnPage(session.query, session.active.matchIndex || 0);
        });
      }
    }
  }

  function clearSidebarSearchResults() {
    if (SEARCH_RESULTS_VIEW.sidebarContainer) {
      SEARCH_RESULTS_VIEW.sidebarContainer.classList.add('hidden');
      const empty = SEARCH_RESULTS_VIEW.sidebarContainer.querySelector('.sidebar-search-empty');
      if (empty) empty.classList.remove('hidden');
    }
    if (SEARCH_RESULTS_VIEW.sidebarSummary) {
      SEARCH_RESULTS_VIEW.sidebarSummary.innerHTML = '';
    }
    if (SEARCH_RESULTS_VIEW.sidebarList) {
      SEARCH_RESULTS_VIEW.sidebarList.innerHTML = '';
    }
    if (SEARCH_RESULTS_VIEW.sidebarQuery) {
      SEARCH_RESULTS_VIEW.sidebarQuery.textContent = '';
    }
    SEARCH_RESULTS_VIEW.sidebarData = null;
    clearSearchHighlights();
    try {
      sessionStorage.removeItem(SEARCH_SESSION_KEY);
    } catch (error) {
      console.warn('Failed to clear search session', error);
    }
  }

  function renderSidebarSearchResults(session) {
    const container = SEARCH_RESULTS_VIEW.sidebarContainer;
    if (!container) return;

    SEARCH_RESULTS_VIEW.sidebarData = session;

    const empty = container.querySelector('.sidebar-search-empty');
    const summary = SEARCH_RESULTS_VIEW.sidebarSummary;
    const list = SEARCH_RESULTS_VIEW.sidebarList;
    const queryLabel = SEARCH_RESULTS_VIEW.sidebarQuery;

    if (!session || !Array.isArray(session.results) || !session.results.length) {
      clearSidebarSearchResults();
      return;
    }

    container.classList.remove('hidden');
    if (empty) empty.classList.add('hidden');
    if (queryLabel) {
      queryLabel.textContent = `「${session.query}」`;
    }
    if (summary) {
      const hiddenCount = session.results.reduce((sum, item) => sum + (item.remainingMatches || 0), 0);
      const totalMatches = session.results.length + hiddenCount;
      summary.innerHTML = `<p><strong>${totalMatches}</strong>件の結果（「${escapeHtml(session.query)}」）</p>`;
    }
    if (list) {
      list.innerHTML = '';
      session.results.forEach((result, index) => {
        const itemBtn = document.createElement('button');
        itemBtn.type = 'button';
        itemBtn.className = 'sidebar-search-item';
        if (session.active &&
            session.active.url === result.url &&
            session.active.matchIndex === result.matchIndex) {
          itemBtn.classList.add('active');
        }

        itemBtn.innerHTML = `
          <span class="sidebar-search-item-title">${escapeHtml(result.title || result.url)}</span>
          <span class="sidebar-search-item-order">${result.matchIndex + 1}/${result.totalMatches || result.matchCount || 1}</span>
          <span class="sidebar-search-item-count">${result.totalMatches || result.matchCount || 1}件</span>
          <div class="sidebar-search-item-context">${result.context}</div>
        `;

        itemBtn.addEventListener('click', () => {
          handleSidebarResultSelection(result, index);
        });
        list.appendChild(itemBtn);
      });
    }
  }

  function handleSidebarResultSelection(result, index) {
    if (!SEARCH_RESULTS_VIEW.sidebarData) return;
    const session = SEARCH_RESULTS_VIEW.sidebarData;
    session.active = {
      url: result.url,
      matchIndex: result.matchIndex,
      index
    };
    session.timestamp = Date.now();
    saveSearchSession(session);
    renderSidebarSearchResults(session);
    navigateToSearchResult(result, session.query);
  }

  function handleOverlayResultSelection(result) {
    if (!result) return;
    const activePayload = convertResultToSession(result);
    const session = {
      query: SEARCH_RESULTS_VIEW.query,
      results: convertOverlayResultsForSession(SEARCH_RESULTS_VIEW.results),
      active: {
        url: activePayload.url,
        matchIndex: activePayload.matchIndex || 0
      },
      timestamp: Date.now()
    };
    SEARCH_RESULTS_VIEW.sidebarData = session;
    saveSearchSession(session);
    renderSidebarSearchResults(session);
    if (typeof SEARCH_RESULTS_VIEW.closeOverlay === 'function') {
      SEARCH_RESULTS_VIEW.closeOverlay();
    }
    navigateToSearchResult(activePayload, session.query);
  }

  function resolveResultUrl(url) {
    try {
      const resolved = new URL(url, window.location.href);
      return resolved.href;
    } catch {
      return url;
    }
  }

  function convertOverlayResultsForSession(results) {
    return results.map(convertResultToSession);
  }

  function convertResultToSession(result) {
    const page = result.page || {};
    return {
      url: resolveResultUrl(page.url || result.url || window.location.href),
      title: page.title || result.title || (page.url || 'ページ'),
      chapter: page.chapter || result.chapter || '',
      context: result.context || '',
      matchCount: result.matchCount || 1,
      totalMatches: result.totalMatches || result.matchCount || 1,
      remainingMatches: result.remainingMatches || 0,
      matchIndex: result.matchIndex || 0
    };
  }

  function navigateToSearchResult(result, query) {
    if (!result) return;
    const targetUrl = new URL(result.url, window.location.href);
    const currentUrl = new URL(window.location.href);
    const sameDocument = targetUrl.origin === currentUrl.origin && targetUrl.pathname === currentUrl.pathname;

    if (sameDocument) {
      if (targetUrl.hash && targetUrl.hash !== window.location.hash) {
        window.location.hash = targetUrl.hash;
      }
      requestAnimationFrame(() => {
        if (!scrollToMatchOnPage(query, result.matchIndex || 0) && targetUrl.hash) {
          const targetEl = document.querySelector(targetUrl.hash);
          if (targetEl && typeof targetEl.scrollIntoView === 'function') {
            targetEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
          }
        }
      });
    } else {
      window.location.href = targetUrl.href;
    }
  }

  let activeSearchHighlights = [];

  function clearSearchHighlights() {
    if (!activeSearchHighlights.length) return;
    activeSearchHighlights.forEach(span => {
      try {
        if (!span || !span.parentNode) return;
        const parent = span.parentNode;
        while (span.firstChild) {
          parent.insertBefore(span.firstChild, span);
        }
        parent.removeChild(span);
      } catch (error) {
        console.warn('Failed clearing highlight', error);
      }
    });
    activeSearchHighlights = [];
  }

  function highlightRange(range) {
    if (!range) return;
    const mark = document.createElement('mark');
    mark.className = 'search-hit-highlight';
    try {
      range.surroundContents(mark);
      activeSearchHighlights.push(mark);
      mark.scrollIntoView({ behavior: 'smooth', block: 'center' });
      setTimeout(() => {
        mark.classList.add('search-hit-fade');
      }, 100);
    } catch (error) {
      console.warn('Failed to highlight range', error);
    }
  }

  function scrollToMatchOnPage(query, matchIndex) {
    if (!query) return false;
    clearSearchHighlights();
    const walker = document.createTreeWalker(document.body, NodeFilter.SHOW_TEXT, null);
    const target = query.toLowerCase();
    let occurrence = -1;
    let node = walker.nextNode();
    while (node) {
      if (!(node.parentElement && node.parentElement.closest('.global-search-overlay'))) {
        const text = node.textContent || '';
        const lower = text.toLowerCase();
        let pos = 0;
        while (true) {
          const found = lower.indexOf(target, pos);
          if (found === -1) break;
          occurrence += 1;
          if (occurrence === matchIndex) {
            const range = document.createRange();
            range.setStart(node, found);
            range.setEnd(node, found + query.length);
            highlightRange(range);
            return true;
          }
          pos = found + query.length;
        }
      }
      node = walker.nextNode();
    }
    return false;
  }
  function setupGlobalSearch() {
    const openBtn = document.getElementById('search-open-btn');
    if (openBtn) openBtn.addEventListener('click', (e) => { e.preventDefault(); openSearchOverlay(); });

    window.quartoOpenSearch = (initialQuery = '') => {
      if (typeof initialQuery !== 'string') initialQuery = '';
      openSearchOverlay(initialQuery);
    };

    document.addEventListener('keydown', (e) => {
      if ((e.ctrlKey || e.metaKey) && (e.key === 'k' || e.key === 'K')) {
        e.preventDefault();
        openSearchOverlay();
      }
    }, true);
  }

  const SEARCH_STATE = {
    pages: [],
    index: {},
    loading: false,
    loaded: false,
    localSections: []
  };

  const SEARCH_RESULTS_VIEW = {
    results: [],
    query: '',
    rendered: 0,
    chunkSize: 20,
    totalCount: 0,
    summaryEl: null,
    listEl: null,
    loadMoreWrapper: null,
    loadMoreBtn: null,
    lastChapter: '',
    lastPage: '',
    closeOverlay: null,
    overlayKeyHandler: null,
    overlayClickHandler: null,
    sidebarContainer: null,
    sidebarSummary: null,
    sidebarList: null,
    sidebarQuery: null,
    sidebarClearBtn: null,
    sidebarData: null
  };

  const MAX_SNIPPETS_PER_PAGE = 20;
  const MAX_MATCHES_SCAN = 400;

  function collectBookPages() {
    if (SEARCH_STATE.pages.length) return SEARCH_STATE.pages;
    // file:// では他ページfetchがブロックされるため現在ページのみ
    if (location.protocol === 'file:') {
      const sections = Array.from(document.querySelectorAll('section.chapter-page'));
      const baseUrl = window.location.href.split('#')[0];
      if (!sections.length) {
        SEARCH_STATE.localSections = [];
        SEARCH_STATE.pages = [baseUrl];
        return SEARCH_STATE.pages;
      }
      SEARCH_STATE.localSections = sections.map(section => {
        const id = section.id || '';
        const url = id ? `${baseUrl}#${id}` : baseUrl;
        return { id, url, element: section };
      });
      SEARCH_STATE.pages = SEARCH_STATE.localSections.map(entry => entry.url);
      return SEARCH_STATE.pages;
    }
    const sidebar = document.querySelector('#quarto-sidebar .sidebar-menu-container');
    const hrefs = new Set();
    if (sidebar) {
      sidebar.querySelectorAll('a[href]')?.forEach(a => {
        const href = a.getAttribute('href');
        if (!href) return;
        if (href.startsWith('http')) return;
        if (href.startsWith('#')) return;
        hrefs.add(new URL(href, window.location.href).href);
      });
    }
    // Also add current page
    hrefs.add(window.location.href);
    SEARCH_STATE.pages = Array.from(hrefs);
    SEARCH_STATE.localSections = [];
    return SEARCH_STATE.pages;
  }

  function normalizeWhitespace(text) {
    return (text || '').replace(/\s+/g, ' ').trim();
  }

  function deriveSectionTitle(section, fallback) {
    if (!section) return fallback || 'このページ';
    const selectors = ['h1 .chapter-title', 'h1', '.chapter-title', 'header .title', 'h2', 'h3'];
    for (const sel of selectors) {
      const el = section.querySelector(sel);
      if (el) {
        const txt = normalizeWhitespace(el.textContent);
        if (txt) return txt;
      }
    }
    const heading = Array.from(section.querySelectorAll('h1, h2, h3, h4, h5')).find(h => normalizeWhitespace(h.textContent));
    if (heading) return normalizeWhitespace(heading.textContent);
    const id = section.id || '';
    if (id) return normalizeWhitespace(id.replace(/^page-/, '').replace(/[-_]+/g, ' ')) || (fallback || 'このページ');
    return fallback || 'このページ';
  }

  function extractSectionText(section) {
    if (!section) return '';
    const clone = section.cloneNode(true);
    const removable = [
      'script',
      'style',
      'nav',
      '.single-pager',
      '.margin-note',
      '.right-footnotes',
      '.right-comments',
      '.right-both',
      '.comment-menu-popup',
      '.global-search-overlay',
      '.global-search-dialog',
      '.marker-toolbar'
    ];
    removable.forEach(sel => clone.querySelectorAll(sel).forEach(el => el.remove()));
    return normalizeWhitespace(clone.textContent || '');
  }

  async function buildSearchIndex() {
    if (SEARCH_STATE.loaded || SEARCH_STATE.loading) return;
    SEARCH_STATE.loading = true;
    SEARCH_STATE.index = {};
    const pages = collectBookPages();

    if (location.protocol === 'file:') {
      const baseUrl = window.location.href.split('#')[0];
      if (!SEARCH_STATE.localSections || !SEARCH_STATE.localSections.length) {
        collectBookPages();
      }
      const docTitle = normalizeWhitespace(document.querySelector('header .title')?.textContent || document.title || '');
      const sections = (SEARCH_STATE.localSections && SEARCH_STATE.localSections.length)
        ? SEARCH_STATE.localSections
        : [];
      const seen = new Set();
      if (sections.length) {
        sections.forEach(entry => {
          const section = entry.element;
          const url = entry.url || (entry.id ? `${baseUrl}#${entry.id}` : baseUrl);
          const title = deriveSectionTitle(section, docTitle || baseUrl);
          const text = extractSectionText(section);
          SEARCH_STATE.index[url] = { url, title, text, slug: entry.id };
          seen.add(url);
        });
        const hasIndex = sections.some(entry => (entry.id || '').toLowerCase() === 'page-index');
        if (!hasIndex) {
          const main = document.querySelector('main#quarto-document-content') || document.querySelector('main') || document.body;
          if (main) {
            const text = extractSectionText(main);
            const url = baseUrl;
            if (!seen.has(url)) {
              const title = deriveSectionTitle(main, docTitle || baseUrl);
              SEARCH_STATE.index[url] = { url, title, text };
            }
          }
        }
      } else {
        const main = document.querySelector('main#quarto-document-content') || document.querySelector('main') || document.body;
        const text = extractSectionText(main);
        SEARCH_STATE.index[baseUrl] = { url: baseUrl, title: docTitle || baseUrl, text };
      }
      SEARCH_STATE.loaded = true;
      SEARCH_STATE.loading = false;
      return;
    }

    const fetchPage = async (url) => {
      try {
        const res = await fetch(url);
        const html = await res.text();
        const doc = new DOMParser().parseFromString(html, 'text/html');
        const title = (doc.querySelector('header .title')?.textContent || doc.querySelector('title')?.textContent || '').trim();
        const main = doc.querySelector('main') || doc.querySelector('#quarto-document-content') || doc.body;
        const text = (main.textContent || '').replace(/\s+/g, ' ').trim();
        return { url, title, text };
      } catch (e) {
        console.warn('Search: failed to fetch', url, e);
        return { url, title: url, text: '' };
      }
    };

    const results = await Promise.all(pages.map(fetchPage));
    results.forEach(r => { SEARCH_STATE.index[r.url] = r; });
    SEARCH_STATE.loaded = true;
    SEARCH_STATE.loading = false;
  }

  function openSearchOverlay(initialQuery = '') {
    const startQuery = (typeof initialQuery === 'string') ? initialQuery.trim() : '';
    let overlay = document.querySelector('.global-search-overlay');
    if (overlay) overlay.remove();

    overlay = document.createElement('div');
    overlay.className = 'global-search-overlay';
    overlay.innerHTML = `
      <div class="global-search-dialog" role="dialog" aria-modal="true" aria-label="全ページ検索">
        <div class="global-search-header">
          <h3>検索</h3>
          <button class="global-search-close" aria-label="閉じる">×</button>
        </div>
        <div class="global-search-input-wrapper">
          <input id="global-search-input" type="text" placeholder="キーワードを入力 (Ctrl/Cmd + K)" autocomplete="off" />
          <button id="global-search-btn">検索</button>
        </div>
        <div class="global-search-results">
          <div class="search-help">検索語を入力してください。</div>
        </div>
      </div>
    `;
    document.body.appendChild(overlay);
    overlay.style.display = 'block';
    document.body.classList.add('search-overlay-active');

    const close = () => {
      if (overlay && overlay.parentNode) {
        overlay.parentNode.removeChild(overlay);
      }
      document.body.classList.remove('search-overlay-active');
      if (SEARCH_RESULTS_VIEW.overlayKeyHandler) {
        document.removeEventListener('keydown', SEARCH_RESULTS_VIEW.overlayKeyHandler, true);
        SEARCH_RESULTS_VIEW.overlayKeyHandler = null;
      }
      if (SEARCH_RESULTS_VIEW.overlayClickHandler) {
        document.removeEventListener('click', SEARCH_RESULTS_VIEW.overlayClickHandler, true);
        SEARCH_RESULTS_VIEW.overlayClickHandler = null;
      }
      resetSearchResultsView();
      SEARCH_RESULTS_VIEW.closeOverlay = null;
    };
    overlay.addEventListener('click', (e) => { if (e.target === overlay) close(); });
    overlay.querySelector('.global-search-close')?.addEventListener('click', close);

    const input = overlay.querySelector('#global-search-input');
    const btn = overlay.querySelector('#global-search-btn');
    const syncSidebarInput = () => {};
    input.value = startQuery;
    input.focus();

    const ensureIndex = async () => {
      if (!SEARCH_STATE.loaded) {
        const results = overlay.querySelector('.global-search-results');
        results.innerHTML = '<div class="search-loading">索引を作成中...</div>';
        await buildSearchIndex();
      }
    };

    const doSearch = async () => {
      const q = (input.value || '').trim();
      syncSidebarInput(q);
      const resultsEl = overlay.querySelector('.global-search-results');
      if (!q) {
        resultsEl.innerHTML = '<div class="search-help">検索語を入力してください。</div>';
        resetSearchResultsView();
        return;
      }
      await ensureIndex();
      const results = [];
      for (const url of Object.keys(SEARCH_STATE.index)) {
        const item = SEARCH_STATE.index[url];
        if (!item || !item.text) continue;
        const page = {
          url,
          title: item.title || url,
          chapter: item.title || ''
        };
        const matches = findMatches(item.text, q, MAX_SNIPPETS_PER_PAGE);
        matches.forEach(match => {
          results.push({
            page,
            context: match.context,
            matchCount: match.totalMatches,
            totalMatches: match.totalMatches,
            matchIndex: match.matchIndex,
            remainingMatches: match.remainingMatches
          });
        });
      }
      renderResults(resultsEl, results, q);
    };

    const debouncedSearch = debounce(doSearch, 200);

    const dialog = overlay.querySelector('.global-search-dialog');
    const keyHandler = (event) => {
      if (event.key === 'Escape') {
        event.preventDefault();
        close();
      }
    };
    const clickHandler = (event) => {
      if (dialog && !dialog.contains(event.target)) {
        close();
      }
    };
    document.addEventListener('keydown', keyHandler, true);
    document.addEventListener('click', clickHandler, true);
    SEARCH_RESULTS_VIEW.overlayKeyHandler = keyHandler;
    SEARCH_RESULTS_VIEW.overlayClickHandler = clickHandler;
    SEARCH_RESULTS_VIEW.closeOverlay = close;

    input.addEventListener('input', () => { debouncedSearch(); });
    input.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') { e.preventDefault(); doSearch(); }
      if (e.key === 'Escape') { e.preventDefault(); close(); }
    });
    btn.addEventListener('click', () => { doSearch(); });

    if (startQuery.length) {
      doSearch();
      const end = input.value.length;
      input.setSelectionRange(end, end);
    }

    return { overlay, input, close };
  }

  function findMatches(text, query, limit) {
    if (!text || !query) return [];
    const sanitized = text.replace(/\s+/g, ' ');
    const hay = sanitized.toLowerCase();
    const needle = query.toLowerCase();
    const indices = [];
    let pos = 0;
    let safety = 0;
    while (pos < hay.length) {
      const idx = hay.indexOf(needle, pos);
      if (idx === -1) break;
      indices.push(idx);
      pos = idx + needle.length;
      safety += 1;
      if (safety >= MAX_MATCHES_SCAN) break;
    }
    const total = indices.length;
    if (!total) return [];
    const clamp = Math.min(total, limit || MAX_SNIPPETS_PER_PAGE);
    const results = [];
    for (let i = 0; i < clamp; i += 1) {
      const start = Math.max(0, indices[i] - 80);
      const end = Math.min(sanitized.length, indices[i] + query.length + 80);
      let snippet = sanitized.slice(start, end);
      snippet = highlight(snippet, query);
      if (start > 0) snippet = '…' + snippet;
      if (end < sanitized.length) snippet = snippet + '…';
      const remainingMatches = (total > clamp && i === clamp - 1) ? total - clamp : 0;
      if (remainingMatches > 0) {
        snippet += `<span class="search-result-more">他${remainingMatches}件の一致</span>`;
      }
      results.push({
        context: snippet,
        matchIndex: i,
        totalMatches: total,
        remainingMatches
      });
    }
    return results;
  }

  function escapeHtml(s) {
    return (s || '').replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[c]));
  }

  function highlight(text, query) {
    const escQ = query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    return text.replace(new RegExp(escQ, 'gi'), m => `<mark>${escapeHtml(m)}</mark>`);
  }

  function fmtMMDDHHmm(t){
    const d = new Date(t); const pad = (n)=>String(n).padStart(2,'0');
    return `${pad(d.getMonth()+1)}/${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}`;
  }

  // --- グローバル一覧モーダル（プレビュー / コメント / マーカー） ---
  function openGlobalListOverlay() {
    try {
      const existing = document.querySelector('.global-list-overlay');
      if (existing) existing.remove();

      const overlay = document.createElement('div');
      overlay.className = 'global-list-overlay';
      overlay.style.position = 'fixed';
      overlay.style.inset = '0';
      overlay.style.background = 'rgba(0,0,0,0.45)';
      overlay.style.zIndex = '1700';
      overlay.style.display = 'flex';
      overlay.style.alignItems = 'center';
      overlay.style.justifyContent = 'center';

      const dialog = document.createElement('div');
      dialog.className = 'global-list-dialog';
      dialog.style.background = '#fff';
      dialog.style.borderRadius = '10px';
      dialog.style.boxShadow = '0 10px 30px rgba(0,0,0,0.3)';
      dialog.style.maxWidth = '720px';
      dialog.style.width = '96vw';
      dialog.style.maxHeight = '80vh';
      dialog.style.display = 'flex';
      dialog.style.flexDirection = 'column';
      dialog.style.overflow = 'hidden';

      const header = document.createElement('div');
      header.style.display = 'flex';
      header.style.alignItems = 'center';
      header.style.justifyContent = 'space-between';
      header.style.padding = '10px 14px';
      header.style.borderBottom = '1px solid #e1e5e9';
      const title = document.createElement('h3');
      title.textContent = 'プレビュー / コメント / マーカー一覧';
      title.style.margin = '0';
      title.style.fontSize = '15px';
      title.style.fontWeight = '600';
      const closeBtn = document.createElement('button');
      closeBtn.type = 'button';
      closeBtn.textContent = '×';
      closeBtn.setAttribute('aria-label', '閉じる');
      closeBtn.style.border = 'none';
      closeBtn.style.background = 'none';
      closeBtn.style.cursor = 'pointer';
      closeBtn.style.fontSize = '18px';
      closeBtn.style.lineHeight = '1';
      closeBtn.style.marginLeft = '12px';
      header.appendChild(title);
      header.appendChild(closeBtn);

      const tabs = document.createElement('div');
      tabs.style.display = 'flex';
      tabs.style.borderBottom = '1px solid #e1e5e9';

      const tabNames = [
        { id: 'previews-docs', label: 'Docsプレビュー' },
        { id: 'previews-bg', label: 'BGプレビュー' },
        { id: 'comments', label: 'コメント' },
        { id: 'markers', label: 'マーカー' }
      ];
      const panels = {};

      tabNames.forEach((t, idx) => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.textContent = t.label;
        btn.dataset.tab = t.id;
        btn.style.flex = '1';
        btn.style.padding = '8px 10px';
        btn.style.border = 'none';
        btn.style.borderBottom = idx === 0 ? '2px solid #1a73e8' : '2px solid transparent';
        btn.style.background = idx === 0 ? '#ffffff' : '#f8f9fa';
        btn.style.cursor = 'pointer';
        btn.style.fontSize = '13px';
        btn.style.fontWeight = idx === 0 ? '600' : '500';
        btn.addEventListener('click', () => {
          const current = dialog.querySelectorAll('.global-list-tab');
          for (let i = 0; i < current.length; i++) {
            const b = current[i];
            const active = b === btn;
            b.style.borderBottom = active ? '2px solid #1a73e8' : '2px solid transparent';
            b.style.background = active ? '#ffffff' : '#f8f9fa';
            b.style.fontWeight = active ? '600' : '500';
          }
          Object.keys(panels).forEach(id => {
            panels[id].style.display = id === t.id ? 'block' : 'none';
          });
          if (t.id === 'previews-docs') renderGlobalPreviewList(panels['previews-docs'], 'gdoc');
          if (t.id === 'previews-bg') renderGlobalPreviewList(panels['previews-bg'], 'bg');
          if (t.id === 'comments') renderGlobalCommentList(panels.comments);
          if (t.id === 'markers') renderGlobalMarkerList(panels.markers);
        });
        btn.className = 'global-list-tab';
        tabs.appendChild(btn);
      });

      const body = document.createElement('div');
      body.style.flex = '1';
      body.style.overflowY = 'auto';
      body.style.padding = '10px 14px 12px';
      body.style.fontSize = '13px';

      tabNames.forEach((t, idx) => {
        const panel = document.createElement('div');
        panel.className = 'global-list-panel global-list-' + t.id;
        panel.style.display = idx === 0 ? 'block' : 'none';
        body.appendChild(panel);
        panels[t.id] = panel;
      });

      dialog.appendChild(header);
      dialog.appendChild(tabs);
      dialog.appendChild(body);
      overlay.appendChild(dialog);
      document.body.appendChild(overlay);

      const close = () => {
        if (overlay && overlay.parentNode) overlay.parentNode.removeChild(overlay);
      };
      closeBtn.addEventListener('click', close);
      overlay.addEventListener('click', (e) => {
        if (e.target === overlay) close();
      });

      // 初期タブ: Docsプレビュー
      renderGlobalPreviewList(panels['previews-docs'], 'gdoc');
    } catch (e) {
      console.warn('openGlobalListOverlay failed', e);
    }
  }

  function loadPreviewItemsForGlobalList() {
    var items = [];
    try {
      if (window.__gdocPreviewAPI__ && typeof window.__gdocPreviewAPI__.getItems === 'function') {
        items = window.__gdocPreviewAPI__.getItems() || [];
      } else {
        var raw = window.localStorage.getItem('gdocPreviewState_v2');
        if (raw) {
          var parsed = JSON.parse(raw);
          if (parsed && Array.isArray(parsed.items)) items = parsed.items;
        }
      }
    } catch (e) {
      console.warn('loadPreviewItemsForGlobalList failed', e);
      items = [];
    }
    return items;
  }

  function renderGlobalPreviewList(panel, kind) {
    if (!panel) return;
    panel.innerHTML = '';
    var allItems = loadPreviewItemsForGlobalList();
    var items = kind ? allItems.filter(function (item) {
      return item.kind === kind;
    }) : allItems;
    
    if (!items || !items.length) {
      var empty = document.createElement('p');
      var msg = kind === 'gdoc' ? '現在Docsプレビュー中の文書はありません。' :
                kind === 'bg' ? '現在BGプレビュー中の文書はありません。' :
                '現在プレビュー中の文書はありません。';
      empty.textContent = msg;
      empty.style.cssText = 'margin:4px 0;color:#6c757d;';
      panel.appendChild(empty);
      return;
    }

    var list = document.createElement('ul');
    list.style.listStyle = 'none';
    list.style.padding = '0';
    list.style.margin = '0';

    items.forEach(function (item) {
      var li = document.createElement('li');
      li.style.cssText = 'margin:6px 0;padding:6px 8px;border-radius:6px;border:1px solid #e1e5e9;display:flex;flex-direction:column;gap:4px;';

      var titleRow = document.createElement('div');
      titleRow.style.cssText = 'display:flex;align-items:center;gap:8px;';
      var titleSpan = document.createElement('span');
      titleSpan.style.flex = '1';
      titleSpan.style.fontWeight = '500';
      titleSpan.textContent = item.title || item.href || item.id || '(無題)';
      var stateSpan = document.createElement('span');
      stateSpan.style.fontSize = '11px';
      stateSpan.style.color = '#6c757d';
      stateSpan.textContent = item.state === 'active' ? '表示中' : '格納中';
      titleRow.appendChild(titleSpan);
      titleRow.appendChild(stateSpan);

      var actions = document.createElement('div');
      actions.style.cssText = 'display:flex;gap:4px;flex-wrap:wrap;';

      // 「表示」ボタン（目アイコン）
      var btnShow = document.createElement('button');
      btnShow.type = 'button';
      btnShow.className = 'gdoc-toast-btn';
      btnShow.setAttribute('aria-label', 'プレビュー表示');
      btnShow.title = 'プレビュー表示';
      btnShow.innerHTML = '<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M12 5C7 5 3.1 8 1.5 12 3.1 16 7 19 12 19s8.9-3 10.5-7C20.9 8 17 5 12 5zm0 10a3 3 0 110-6 3 3 0 010 6z"></path></svg>';
      btnShow.addEventListener('click', function () {
        if (window.__gdocPreviewAPI__ && typeof window.__gdocPreviewAPI__.activate === 'function') {
          window.__gdocPreviewAPI__.activate(item.key);
        }
      });

      // 「本文へ」ボタン（ジャンプアイコン）
      var btnJump = document.createElement('button');
      btnJump.type = 'button';
      btnJump.className = 'gdoc-toast-btn';
      btnJump.setAttribute('aria-label', '本文へ移動');
      btnJump.title = '本文へ移動';
      btnJump.innerHTML = '<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M12 2c-.55 0-1 .45-1 1v12.59l-4.3-4.3a1 1 0 10-1.4 1.42l6 6a1 1 0 001.4 0l6-6a1 1 0 10-1.4-1.42L13 15.59V3c0-.55-.45-1-1-1z"></path></svg>';
      btnJump.addEventListener('click', function () {
        if (window.__gdocPreviewAPI__ && typeof window.__gdocPreviewAPI__.jumpToSource === 'function') {
          window.__gdocPreviewAPI__.jumpToSource(item.key);
        }
      });

      // 「他タブで開く」ボタン（外部リンクアイコン）
      var btnTab = document.createElement('button');
      btnTab.type = 'button';
      btnTab.className = 'gdoc-toast-btn';
      btnTab.setAttribute('aria-label', '別タブで開く');
      btnTab.title = '別タブで開く';
      btnTab.innerHTML = '<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M14 3h7v7h-2V6.41l-9.29 9.3-1.42-1.42 9.3-9.29H14V3z"></path><path d="M5 5h5V3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2v-5h-2v5H5V5z"></path></svg>';
      btnTab.addEventListener('click', function () {
        var url = item.href || item.previewUrl;
        if (url) window.open(url, '_blank', 'noopener');
      });

      // 「閉じる」ボタン（×アイコン）
      var btnClose = document.createElement('button');
      btnClose.type = 'button';
      btnClose.className = 'gdoc-toast-btn';
      btnClose.setAttribute('aria-label', '閉じる');
      btnClose.title = '閉じる';
      btnClose.innerHTML = '<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M5.293 6.707l5.293 5.293-5.293 5.293c-.39.39-.39 1.024 0 1.414s1.024.39 1.414 0l5.293-5.293 5.293 5.293c.39.39 1.024.39 1.414 0s.39-1.024 0-1.414L13.414 12l5.293-5.293c.39-.39.39-1.024 0-1.414s-1.024-.39-1.414 0L12 10.586 6.707 5.293c-.39-.39-1.024-.39-1.414 0s-.39 1.024 0 1.414z"></path></svg>';
      btnClose.addEventListener('click', function () {
        if (window.__gdocPreviewAPI__ && typeof window.__gdocPreviewAPI__.close === 'function') {
          window.__gdocPreviewAPI__.close(item.key);
          renderGlobalPreviewList(panel);
        }
      });

      actions.appendChild(btnShow);
      actions.appendChild(btnJump);
      actions.appendChild(btnTab);
      actions.appendChild(btnClose);

      li.appendChild(titleRow);
      li.appendChild(actions);
      list.appendChild(li);
    });

    panel.appendChild(list);
  }

  var GLOBAL_LIST_SCOPE = {
    comments: 'page',
    markers: 'page'
  };

  function renderGlobalCommentList(panel) {
    if (!panel) return;
    panel.innerHTML = '';
    var scope = GLOBAL_LIST_SCOPE.comments || 'page';

    // スコープ切り替えトグル（このページ / 全ページ）
    var ctrl = document.createElement('div');
    ctrl.style.cssText = 'display:flex;align-items:center;justify-content:flex-end;margin-bottom:6px;gap:6px;font-size:11px;color:#6c757d;';
    var label = document.createElement('label');
    label.style.display = 'inline-flex';
    label.style.alignItems = 'center';
    label.style.gap = '4px';
    var checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.checked = scope === 'all';
    checkbox.addEventListener('change', function () {
      GLOBAL_LIST_SCOPE.comments = checkbox.checked ? 'all' : 'page';
      renderGlobalCommentList(panel);
    });
    label.appendChild(checkbox);
    label.appendChild(document.createTextNode('全ページ'));
    ctrl.appendChild(label);
    panel.appendChild(ctrl);

    var key = typeof pageKey === 'function' ? pageKey() : window.location.pathname;
    var list = [];
    if (scope === 'page') {
      // コメントパネルと同じロジックで、このページ上のコメントを取得
      if (typeof getActiveComments === 'function') {
        list = getActiveComments().slice();
      } else if (typeof COMMENTS_DB === 'object' && COMMENTS_DB && COMMENTS_DB[key]) {
        list = COMMENTS_DB[key].slice();
      } else {
        list = [];
      }
    } else {
      if (typeof COMMENTS_DB === 'object' && COMMENTS_DB) {
        Object.keys(COMMENTS_DB).forEach(function (k) {
          (COMMENTS_DB[k] || []).forEach(function (rec) {
            list.push({ __pageKey: k, rec: rec });
          });
        });
      }
    }
    if (!list.length) {
      var empty = document.createElement('p');
      empty.textContent = scope === 'page' ? 'このページにはコメントがありません。' : '全ページにコメントがありません。';
      empty.style.cssText = 'margin:4px 0;color:#6c757d;';
      panel.appendChild(empty);
      return;
    }

    // 並び替え（新しい順）
    list.sort(function (a, b) {
      var ra = scope === 'page' ? a : a.rec;
      var rb = scope === 'page' ? b : b.rec;
      return (rb.t || 0) - (ra.t || 0);
    });

    var ul = document.createElement('ul');
    ul.style.listStyle = 'none';
    ul.style.padding = '0';
    ul.style.margin = '0';

    list.forEach(function (entry) {
      var rec = scope === 'page' ? entry : entry.rec;
      var pageKeyForRec = scope === 'page' ? key : entry.__pageKey;

      var li = document.createElement('li');
      li.style.cssText = 'margin:6px 0;padding:6px 8px;border-radius:6px;border:1px solid #e1e5e9;';

      var meta = document.createElement('div');
      meta.style.cssText = 'font-size:11px;color:#6c757d;display:flex;gap:8px;align-items:center;margin-bottom:4px;';
      var time = document.createElement('span');
      time.textContent = fmtMMDDHHmm(rec.t || Date.now());
      meta.appendChild(time);
      if (scope === 'all' && pageKeyForRec !== key) {
        var pageLabel = document.createElement('span');
        pageLabel.textContent = pageKeyForRec;
        pageLabel.style.maxWidth = '220px';
        pageLabel.style.overflow = 'hidden';
        pageLabel.style.textOverflow = 'ellipsis';
        meta.appendChild(pageLabel);
      }
      var move = document.createElement('button');
      move.type = 'button';
      move.textContent = '移動';
      move.style.cssText = 'padding:2px 6px;font-size:11px;border-radius:4px;border:1px solid #6c757d;background:#fff;cursor:pointer;';
      move.addEventListener('click', function () {
        if (scope === 'page' || pageKeyForRec === key) {
          scrollToComment(rec);
        } else {
          // 別ページのコメントの場合はそのページを開く
          try {
            window.location.href = pageKeyForRec;
          } catch (e) {
            window.location.assign(pageKeyForRec);
          }
        }
      });
      meta.appendChild(move);

      var target = document.createElement('div');
      target.style.cssText = 'font-size:13px;color:#495057;background:#f8f9fa;padding:4px 6px;border-radius:4px;margin-bottom:4px;';
      target.textContent = rec.text || '';
      var body = document.createElement('div');
      body.style.cssText = 'white-space:pre-wrap;line-height:1.5;';
      body.textContent = rec.body || '';

      li.appendChild(meta);
      li.appendChild(target);
      li.appendChild(body);
      ul.appendChild(li);
    });

    panel.appendChild(ul);
  }

  function renderGlobalMarkerList(panel) {
    if (!panel) return;
    panel.innerHTML = '';
    var scope = GLOBAL_LIST_SCOPE.markers || 'page';

    var ctrl = document.createElement('div');
    ctrl.style.cssText = 'display:flex;align-items:center;justify-content:flex-end;margin-bottom:6px;gap:6px;font-size:11px;color:#6c757d;';
    var label = document.createElement('label');
    label.style.display = 'inline-flex';
    label.style.alignItems = 'center';
    label.style.gap = '4px';
    var checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.checked = scope === 'all';
    checkbox.addEventListener('change', function () {
      GLOBAL_LIST_SCOPE.markers = checkbox.checked ? 'all' : 'page';
      renderGlobalMarkerList(panel);
    });
    label.appendChild(checkbox);
    label.appendChild(document.createTextNode('全ページ'));
    ctrl.appendChild(label);
    panel.appendChild(ctrl);

    var markersDB;
    try {
      markersDB = JSON.parse(window.localStorage.getItem(STORAGE_KEYS.markers) || '{}') || {};
    } catch (e) {
      markersDB = {};
    }
    var page = window.location.pathname;
    var list = [];
    if (scope === 'page') {
      list = markersDB[page] || [];
    } else {
      Object.keys(markersDB).forEach(function (k) {
        (markersDB[k] || []).forEach(function (m) {
          list.push({ __pageKey: k, marker: m });
        });
      });
    }
    if (!list.length) {
      var empty = document.createElement('p');
      empty.textContent = scope === 'page' ? 'このページにはマーカーがありません。' : '全ページにマーカーがありません。';
      empty.style.cssText = 'margin:4px 0;color:#6c757d;';
      panel.appendChild(empty);
      return;
    }

    var ul = document.createElement('ul');
    ul.style.listStyle = 'none';
    ul.style.padding = '0';
    ul.style.margin = '0';

    list.forEach(function (entry) {
      var m = scope === 'page' ? entry : entry.marker;
      var pageKeyForMarker = scope === 'page' ? page : entry.__pageKey;

      var li = document.createElement('li');
      li.style.cssText = 'margin:6px 0;padding:6px 8px;border-radius:6px;border:1px solid #e1e5e9;display:flex;flex-direction:column;gap:4px;';

      var row = document.createElement('div');
      row.style.cssText = 'display:flex;align-items:center;gap:8px;';
      var label = document.createElement('span');
      label.style.flex = '1';
      label.textContent = (function () {
        var span = document.querySelector('.text-marker[data-marker-id="' + m.id + '"]');
        if (span && span.textContent) return span.textContent.slice(0, 80);
        return '(マーカー)';
      })();
      if (scope === 'all' && pageKeyForMarker !== page) {
        label.textContent = '[' + pageKeyForMarker + '] ' + label.textContent;
      }
      var colorSwatch = document.createElement('span');
      colorSwatch.style.display = 'inline-block';
      colorSwatch.style.width = '10px';
      colorSwatch.style.height = '10px';
      colorSwatch.style.borderRadius = '2px';
      var colorMap = { yellow:'#fff59d', green:'#c8e6c9', blue:'#bbdefb', pink:'#f8bbd0', orange:'#ffcc80' };
      colorSwatch.style.backgroundColor = colorMap[m.color] || '#fff59d';
      row.appendChild(label);
      row.appendChild(colorSwatch);

      var actions = document.createElement('div');
      actions.style.cssText = 'display:flex;gap:6px;flex-wrap:wrap;';
      var btnMove = document.createElement('button');
      btnMove.type = 'button';
      btnMove.textContent = '移動';
      btnMove.style.cssText = 'padding:3px 8px;font-size:11px;border-radius:4px;border:1px solid #6c757d;background:#fff;cursor:pointer;';
      btnMove.addEventListener('click', function () {
        try {
          if (scope === 'page' || pageKeyForMarker === page) {
            var span = document.querySelector('.text-marker[data-marker-id="' + m.id + '"]');
            if (span && typeof span.scrollIntoView === 'function') {
              var el = span;
              while (el && el !== document.body && !(el instanceof HTMLElement)) {
                el = el.parentElement;
              }
              if (!el) el = span;
              el.scrollIntoView({ behavior: 'smooth', block: 'center' });
              try {
                var prevBox = el.style.boxShadow;
                el.style.transition = 'box-shadow 0.3s ease';
                el.style.boxShadow = '0 0 0 3px rgba(26,115,232,0.5)';
                setTimeout(function () {
                  el.style.boxShadow = prevBox || '';
                }, 1600);
              } catch (e2) {}
            }
          } else {
            window.location.href = pageKeyForMarker;
          }
        } catch (e) {}
      });
      var btnDelete = document.createElement('button');
      btnDelete.type = 'button';
      btnDelete.textContent = '削除';
      btnDelete.style.cssText = 'padding:3px 8px;font-size:11px;border-radius:4px;border:1px solid #dc3545;background:#fff;color:#dc3545;cursor:pointer;';
      btnDelete.addEventListener('click', function () {
        try {
          // remove spans
          document.querySelectorAll('.text-marker[data-marker-id="' + m.id + '"]').forEach(function (el) {
            var parent = el.parentNode;
            while (el.firstChild) parent.insertBefore(el.firstChild, el);
            parent.removeChild(el);
          });
          // update storage
          var db = markersDB[page] || [];
          markersDB[page] = db.filter(function (x) { return x.id !== m.id; });
          if (!markersDB[page].length) delete markersDB[page];
          window.localStorage.setItem(STORAGE_KEYS.markers, JSON.stringify(markersDB));
          renderGlobalMarkerList(panel);
        } catch (e) {
          console.warn('failed to delete marker group', e);
        }
      });

      actions.appendChild(btnMove);
      actions.appendChild(btnDelete);

      li.appendChild(row);
      li.appendChild(actions);
      ul.appendChild(li);
    });

    panel.appendChild(ul);
  }

  function renderResults(container, results, query) {
    if (!container) return;

    if (!results.length) {
      container.innerHTML = `<div class="search-no-results"><p>一致が見つかりませんでした。</p><ul><li>語句を短くする</li><li>別のキーワードを試す</li></ul></div>`;
      resetSearchResultsView();
      return;
    }

    resetSearchResultsView();
    clearSearchHighlights();
    SEARCH_RESULTS_VIEW.results = results;
    SEARCH_RESULTS_VIEW.query = query;
    SEARCH_RESULTS_VIEW.totalCount = results.length + results.reduce((sum, r) => sum + (r.remainingMatches || 0), 0);

    container.innerHTML = '';

    const summary = document.createElement('div');
    summary.className = 'search-results-summary';
    container.appendChild(summary);
    SEARCH_RESULTS_VIEW.summaryEl = summary;

    const listWrap = document.createElement('div');
    listWrap.className = 'search-results-items';
    container.appendChild(listWrap);
    SEARCH_RESULTS_VIEW.listEl = listWrap;

    const loadMoreWrapper = document.createElement('div');
    loadMoreWrapper.className = 'search-load-more-wrapper';
    const loadMoreBtn = document.createElement('button');
    loadMoreBtn.type = 'button';
    loadMoreBtn.className = 'search-load-more-btn';
    loadMoreBtn.textContent = 'さらに表示';
    loadMoreWrapper.appendChild(loadMoreBtn);
    container.appendChild(loadMoreWrapper);
    SEARCH_RESULTS_VIEW.loadMoreWrapper = loadMoreWrapper;
    SEARCH_RESULTS_VIEW.loadMoreBtn = loadMoreBtn;
    loadMoreBtn.addEventListener('click', () => renderOverlayResultsChunk());

    renderOverlayResultsChunk(true);
  }

  function renderOverlayResultsChunk(reset = false) {
    const state = SEARCH_RESULTS_VIEW;
    if (!state.listEl) return;

    if (reset) {
      state.listEl.innerHTML = '';
      state.rendered = 0;
      state.lastChapter = '';
      state.lastPage = '';
    }

    const total = state.results.length;
    if (state.rendered >= total) {
      updateOverlayResultsSummary();
      if (state.loadMoreWrapper) state.loadMoreWrapper.style.display = 'none';
      return;
    }

    const limit = Math.min(total, state.rendered + state.chunkSize);
    for (let i = state.rendered; i < limit; i += 1) {
      const result = state.results[i];
      const chapter = result.page?.chapter || '';
      const pageUrl = result.page?.url || '';

      if (chapter && (chapter !== state.lastChapter || pageUrl !== state.lastPage)) {
        const section = document.createElement('section');
        section.className = 'search-chapter-section';
        const heading = document.createElement('h4');
        heading.className = 'search-chapter-title';
        heading.textContent = chapter;
        section.appendChild(heading);
        state.listEl.appendChild(section);
        state.lastChapter = chapter;
        state.lastPage = pageUrl;
      }

      const item = document.createElement('div');
      item.className = 'search-result-item';

      const titleRow = document.createElement('div');
      titleRow.className = 'search-result-title';

      const link = document.createElement('a');
      link.className = 'search-result-link';
      link.href = result.page?.url || '#';
      link.textContent = result.page?.title || result.page?.url || 'ページ';
      link.addEventListener('click', (event) => {
        event.preventDefault();
        handleOverlayResultSelection(result);
      });

      const order = document.createElement('span');
      order.className = 'search-snippet-order';
      order.textContent = `${(result.matchIndex || 0) + 1}/${result.totalMatches || result.matchCount || 1}`;

      const badge = document.createElement('span');
      badge.className = 'search-match-count';
      badge.textContent = `${result.totalMatches || result.matchCount || 1}件`;

      titleRow.appendChild(link);
      titleRow.appendChild(order);
      titleRow.appendChild(badge);
      item.appendChild(titleRow);

      const ctx = document.createElement('div');
      ctx.className = 'search-result-context';
      ctx.innerHTML = result.context;
      item.appendChild(ctx);

      state.listEl.appendChild(item);
    }

    state.rendered = limit;
    updateOverlayResultsSummary();

    if (state.loadMoreWrapper) {
      state.loadMoreWrapper.style.display = state.rendered >= total ? 'none' : '';
    }
  }

  function updateOverlayResultsSummary() {
    const state = SEARCH_RESULTS_VIEW;
    if (!state.summaryEl) return;
    const hiddenCount = state.results.reduce((sum, item) => sum + (item.remainingMatches || 0), 0);
    const totalMatches = state.results.length + hiddenCount;
    const shownMatches = Math.min(state.rendered, state.results.length);
    const escapedQuery = escapeHtml(state.query);
    state.summaryEl.innerHTML = `
      <p><strong>${totalMatches}</strong>件の結果（「${escapedQuery}」）</p>
      <p class="search-results-muted">${shownMatches}件を表示中${hiddenCount > 0 ? `（他${hiddenCount}件）` : ''}</p>
    `;
  }

  function resetSearchResultsView() {
    SEARCH_RESULTS_VIEW.results = [];
    SEARCH_RESULTS_VIEW.query = '';
    SEARCH_RESULTS_VIEW.rendered = 0;
    SEARCH_RESULTS_VIEW.totalCount = 0;
    SEARCH_RESULTS_VIEW.summaryEl = null;
    SEARCH_RESULTS_VIEW.listEl = null;
    SEARCH_RESULTS_VIEW.loadMoreWrapper = null;
    SEARCH_RESULTS_VIEW.loadMoreBtn = null;
    SEARCH_RESULTS_VIEW.lastChapter = '';
    SEARCH_RESULTS_VIEW.lastPage = '';
  }

  function setupKeyboardShortcuts() {
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        const dialogs = document.querySelectorAll('.global-search-dialog');
        dialogs.forEach(dialog => dialog.remove());
      }
    });
  }

  function setupScrollPosition() {
    const scrollY = sessionStorage.getItem(STORAGE_KEYS.scrollPosition);
    if (scrollY) window.scrollTo(0, parseInt(scrollY));
  window.addEventListener('beforeunload', () => {
    sessionStorage.setItem(STORAGE_KEYS.scrollPosition, window.scrollY);
    persistReadingState();
  });
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'hidden') {
        persistReadingState();
      }
    });
    window.addEventListener('scroll', scheduleReadingStateSave, { passive: true });
    window.addEventListener('resize', scheduleReadingStateSave);
  }

  function expandAllInMenu(root) {
    try {
      root.querySelectorAll('.collapse').forEach(el => {
        el.classList.add('show');
        el.style.height = 'auto';
      });
      root.querySelectorAll('[data-bs-toggle="collapse"]').forEach(tg => {
        tg.setAttribute('aria-expanded', 'true');
      });
      root.querySelectorAll('[data-bs-toggle="collapse"]').forEach(tg => {
        tg.removeAttribute('data-bs-toggle');
        tg.removeAttribute('data-bs-target');
      });
    } catch (e) {
      console.warn('Failed to expand all menu levels:', e);
    }
  }

  // Quarto左サイドバー（各章/全体）: 指定階層まで展開、それ以降を折りたたみ
  function setSidebarDepth(root, maxDepth) {
    try {
      const togglers = root.querySelectorAll('[data-bs-toggle="collapse"][data-bs-target]');
      const getDepthForTarget = (target) => {
        let d = 1; let n = target;
        while (n && n !== root) { if (n.tagName === 'UL') d++; n = n.parentElement; }
        return d;
      };
      togglers.forEach(tg => {
        const sel = tg.getAttribute('data-bs-target');
        if (!sel || sel[0] !== '#') return;
        const target = root.querySelector(sel);
        if (!target) return;
        const depth = getDepthForTarget(target);
        const open = (maxDepth === Infinity) || (depth <= maxDepth);
        target.classList.toggle('show', !!open);
        target.style.height = open ? 'auto' : '';
        tg.setAttribute('aria-expanded', open ? 'true' : 'false');
      });
    } catch (e) {
      console.warn('setSidebarDepth error:', e);
    }
  }

  // ページ内目次: ツリー化 + 展開/格納トグルを付与（デフォルト階層まで展開）
  // 階層判定は必ずMarkdownの#数（= 見出しタグH1..H6のレベル）に従う
  function enhancePageToc(panel, defaultDepth) {
    const nav = panel.querySelector('nav#TOC');
    if (!nav) return;
    const getHeadingLevelFromLink = (a) => {
      try {
        if (!a) return null;
        const href = a.getAttribute('href') || '';
        if (!href.startsWith('#')) return null;
        const id = href.slice(1);
        const h = document.getElementById(id);
        if (!h) return null;
        const tag = (h.tagName || '').toUpperCase();
        if (/^H[1-6]$/.test(tag)) return parseInt(tag.slice(1), 10);
        return null;
      } catch { return null; }
    };

    nav.querySelectorAll('li').forEach(li => {
      const childUl = li.querySelector(':scope > ul');
      const link = li.querySelector(':scope > a');
      const level = getHeadingLevelFromLink(link);

      if (childUl) {
        li.classList.add('has-children');
        const toggle = document.createElement('span');
        toggle.className = 'toc-toggle';
        toggle.textContent = '▾';
        if (link && link.parentNode === li) {
          const row = document.createElement('div');
          row.className = 'li-row';
          li.insertBefore(row, link);
          row.appendChild(toggle);
          row.appendChild(link);
        } else {
          li.insertBefore(toggle, li.firstChild);
        }
        toggle.addEventListener('click', () => {
          li.classList.toggle('collapsed');
          toggle.textContent = li.classList.contains('collapsed') ? '▸' : '▾';
        });
      }

      // 初期展開状態は # のレベルで判定
      if (level != null) {
        const open = (defaultDepth === Infinity) || (level <= defaultDepth);
        if (open) {
          li.classList.remove('collapsed');
          const t = li.querySelector(':scope > .toc-toggle');
          if (t) t.textContent = '▾';
        } else {
          li.classList.add('collapsed');
          const t = li.querySelector(':scope > .toc-toggle');
          if (t) t.textContent = '▸';
        }
      }
    });
  }

  // 独自TOCシステム
  const CustomTOC = {
    // 現在のページの見出しを取得
    getPageHeadings: function() {
      const headmap = new Map();
      let maxDepth = 0;
      
      // メインコンテンツから見出しを取得
      const allHeadings = document.querySelectorAll('main h1, main h2, main h3, main h4, main h5, main h6');
      
      allHeadings.forEach(heading => {
        const text = heading.textContent || heading.innerText || '';
        if (!text.trim()) return;
        
        const level = parseInt(heading.tagName.slice(1), 10);
        const id = heading.id || this.generateIdFromText(text);
        
        headmap.set(id, {
          id: id,
          text: text,
          level: level,
          element: heading,
          children: []
        });
        maxDepth = Math.max(maxDepth, level);
      });
      
      return { headings: headmap, maxDepth: maxDepth };
    },
    
    // テキストからIDを生成（Quarto互換）
    generateIdFromText: function(text) {
      return text
        .replace(/\s+/g, ' ')
        .trim()
        .toLowerCase()
        .replace(/[^\w\s-]/g, '')
        .replace(/\s+/g, '-');
    },
    
    // ページ外TOC：すべてのページ情報（静的データ）
    getAllPagesTOC: function() {
      // ページ構成を静的に定義する
      return [
        {
          title: "AJMUN 37th 平和への課題：補遺",
          url: "../index.html",
          type: "cover"
        },
        {
          title: "フロント挨拶",
          url: "../content/00_front.html",
          type: "front"
        },
        {
          title: "第1章 プロジェクトの概要",
          url: "../content/01_ch01.html",
          type: "chapter",
          sections: [
            "1.1 はじめに",
            "1.2 プロジェクトの目的",
            "1.2.1 課題認識",
            "1.2.2 解決方針",
            "1.3 技術選定",
            "1.3.1 Quarto + Pandoc",
            "1.3.2 UDP明朝フォント",
            "1.4 プロジェクト構成",
            "1.4.1 ディレクトリ構造",
            "1.4.2 ファイル配置戦略",
            "1.5 開発アプローチ",
            "1.5.1 プログレッシブエンハンスメント",
            "1.5.2 アクセシビリティ優先"
          ]
        },
        {
          title: "第2章 技術的課題と解決策",
          url: "../content/02_ch02.html",
          type: "chapter",
          sections: [
            "2.1 日本語組版の課題",
            "2.1.1 文字エンコーディング",
            "2.1.2 フォントの扱い",
            "2.2 レスポンシブデザイン",
            "2.2.1 標長画面の制約",
            "2.2.2 モバイルへの対応",
            "2.3 パフォーマンスの最適化",
            "2.3.1 読み込み時間の短縮",
            "2.3.2 スムーズな操作感"
          ]
        },
        {
          title: "第3章 実装方針",
          url: "../content/03_ch03.html",
          type: "chapter",
          sections: [
            "3.1 開発アプローチ",
            "3.1.1 プロジェクト構造",
            "3.1.2 ビルドシステム",
            "3.2 技術選択",
            "3.3 品質保証"
          ]
        },
        {
          title: "コラム1：Webフォントの歴史",
          url: "../content/20_col01.html",
          type: "column",
          sections: [
            "デジタルタイポグラフィの発展",
            "画像フォントの時代",
            "Webフォントの登場",
            "日本語対応の課題",
            "サブセット化の重要性"
          ]
        },
        {
          title: "コラム2：アクセシビリティの重要性",
          url: "../content/21_col02.html",
          type: "column",
          sections: [
            "リテラシーの多様性",
            "視覚的配慮",
            "聴覚的配慮",
            "身体的配慮",
            "技術的な実装"
          ]
        },
        {
          title: "第4章 UI/UX設計",
          url: "../content/04_ch04.html",
          type: "chapter",
          sections: [
            "4.1 基本原則",
            "4.2 コンポーネント設計",
            "4.3 アクセシビリティ"
          ]
        },
        {
          title: "第5章 パフォーマンス最適化",
          url: "../content/05_ch05.html",
          type: "chapter",
          sections: [
            "5.1 読み込み速度",
            "5.2 レンダリングの効率化",
            "5.3 キャッシュ戦略"
          ]
        },
        {
          title: "第6章 国連の制度",
          url: "./06_ch06.html",
          type: "chapter",
          sections: [
            "はじめに",
            "第1節 国連という組織",
            "第1項 概要・組織構造",
            "第2項 安全保障理事会",
            "第3項 国連の紛争対処",
            "第4項 安保理決議に基づく義務",
            "コラム 安保理決議の拘束力",
            "第2節 国連財政",
            "第2項 PKO予算",
            "第3節 国連による経済制裁",
            "第1項 国際連合憲章における経済制裁措置",
            "第2項 冷戦下の経済制裁",
            "第3項 冷戦後の経済制裁",
            "第3項 経済制裁に伴う問題とその後",
            "第4項 国連憲章第50条の注解",
            "第4節 国連平和維持活動(PKO)",
            "参考文献"
          ]
        },
        {
          title: "第7章 まとめと展望",
          url: "../content/07_ch07.html",
          type: "chapter",
          sections: [
            "7.1 プロジェクトの成果",
            "7.2 技術的貢献",
            "7.3 今後の発展",
            "まとめ"
          ]
        },
        {
          title: "コラム3：今後の技術動向",
          url: "../content/22_col03.html",
          type: "column",
          sections: [
            "新しい技術の登場",
            "Variable Fonts",
            "Container Queries",
            "Web Components",
            "発展の可能性",
            "PWA化",
            "オフライン対応",
            "マルチデバイス同期"
          ]
        },
        {
          title: "編集後記",
          url: "../content/90_afterword.html",
          type: "appendix",
          sections: [
            "執筆の経緯",
            "技術的な挑戦",
            "フォント埋込",
            "レスポンシブ設計",
            "脚注処理",
            "読者の皆様へ",
            "今後の展望",
            "結びに"
          ]
        },
        {
          title: "参考文献",
          url: "../content/95_references.html",
          type: "appendix"
        },
        {
          title: "索引",
          url: "../content/96_index.html",
          type: "appendix",
          sections: [
            "あ", "う", "か", "こ", "し", "た", "は", "ろ"
          ]
        }
      ];
    },
    
    // ページ内TOCを生成（章内タブ用）
    generatePageTOC: function(maxDepth) {
      const { headings } = this.getPageHeadings();
      
      if (headings.size === 0) {
        return '<p class="toc-empty">このページには見出しがありません。</p>';
      }
      
      const items = [];
      headings.forEach((heading, id) => {
        const level = Math.min(Math.max(heading.level, 1), 6);
        if (level > maxDepth) return;
        const levelClass = `page-toc-level-${level}`;
        const liClasses = ['page-toc-item', levelClass].join(' ');
        items.push(`<li class="${liClasses}"><a class="page-toc-link" href="#${id}">${heading.text}</a></li>`);
      });

      if (!items.length) {
        return '<p class="toc-empty">このページには見出しがありません。</p>';
      }

      return `<ul class="page-toc-list">${items.join('')}</ul>`;
    },
    
    // 全体TOCを生成（全体タブ用）
    generateAllPagesTOC: function() {
      const pages = this.getAllPagesTOC();
      const currentPath = (window.location.pathname || '').split('/').pop() || 'index.html';
      
      let html = '<ul class="all-toc-list">';
      
      pages.forEach(page => {
        const normalizedPage = (page.url || '').replace(/^\.\//, '').split('/').pop() || '';
        const isActive = normalizedPage === currentPath;
        const itemClasses = ['all-toc-item', `all-toc-item--${page.type || 'other'}`];
        if (isActive) itemClasses.push('active');
        
        html += `<li class="${itemClasses.join(' ')}">`;
        html += `<a href="${page.url}" class="all-toc-link">${page.title}</a>`;
        
        if (Array.isArray(page.sections) && page.sections.length) {
          html += '<ul class="all-toc-sublist">';
          page.sections.forEach(sectionName => {
            const sectionId = this.generateIdFromText(sectionName);
            const link = `${page.url}#${sectionId}`;
            html += `<li class="all-toc-subitem"><a href="${link}" class="all-toc-sublink">${sectionName}</a></li>`;
          });
          html += '</ul>';
        }
        
        html += '</li>';
      });
      
      html += '</ul>';
      return html;
    },
    
    // TOC構造をHTMLに変換
    renderTOCStructure: function(structure, maxDepth = Infinity, options = {}) {
      const {
        listClass = 'custom-toc-list',
        childListClass = 'custom-toc-child-list',
        itemClass = (item, active) => `custom-toc-item level-${item.level} ${active}`,
        linkClass = (item, active) => `custom-toc-link ${active}`
      } = options;

      const normalizeClass = (value) => (value || '').trim().replace(/\s+/g, ' ');

      const renderItems = (items, currentDepth = 1) => {
        let resultHtml = '';

        items.forEach(item => {
          if (Array.isArray(item)) {
            if (currentDepth <= maxDepth) {
              resultHtml += `<ul class="${normalizeClass(childListClass)}">`;
              item.forEach(childItem => {
                resultHtml += renderItems([childItem], currentDepth + 1);
              });
              resultHtml += '</ul>';
            }
          } else if (item && item.id) {
            const isActive = document.getElementById(item.id)?.classList.contains('active');
            const activeClass = isActive ? 'active' : '';
            const liClass = typeof itemClass === 'function' ? itemClass(item, activeClass) : itemClass;
            const linkClassName = typeof linkClass === 'function' ? linkClass(item, activeClass) : linkClass;

            resultHtml += `<li class="${normalizeClass(liClass)}">`;
            resultHtml += `<a href="#${item.id}" class="${normalizeClass(linkClassName)}">${item.text}</a>`;

            if (item.children && item.children.length > 0 && currentDepth < maxDepth) {
              resultHtml += `<ul class="${normalizeClass(childListClass)}">`;
              item.children.forEach(child => {
                resultHtml += renderItems([child], currentDepth + 1);
              });
              resultHtml += '</ul>';
            }

            resultHtml += '</li>';
          }
        });

        return resultHtml;
      };

      let html = `<ul class="${normalizeClass(listClass)}">`;
      structure.forEach(item => {
        html += renderItems([item], 1);
      });
      html += '</ul>';
      return html;
    },
    
    // TOCを初期化
    initializeCustomTOC: function() {
      // 章内タブ用TOC
      const pageTOCPanel = document.querySelector('.toc-page-content');
      if (pageTOCPanel) {
        const pageTOC = this.generatePageTOC(Infinity);
        pageTOCPanel.innerHTML = pageTOC;
      }
      
      // 全体タブ用TOC
      const allTOCPanel = document.querySelector('.toc-all-content');
      if (allTOCPanel) {
        const allTOC = this.generateAllPagesTOC();
        allTOCPanel.innerHTML = allTOC;
        
        // 階層折りたたみ機能
        this.setupTOCToggling(allTOCPanel);
      }
    },
    
    // TOCの階層展開/折りたたみ機能
    setupTOCToggling: function(container) {
      const toggleButtons = container.querySelectorAll('.custom-toc-item > .custom-toc-link');
      
      toggleButtons.forEach(link => {
        const listItem = link.closest('.custom-toc-item');
        const childList = listItem.querySelector('.custom-toc-child-list');
        
        if (childList) {
          // 開閉ボタンを追加
          const toggleBtn = document.createElement('span');
          toggleBtn.className = 'custom-toc-toggle';
          toggleBtn.textContent = '▾';
          
          link.parentNode.insertBefore(toggleBtn, link);
          link.style.paddingLeft = '20px';
          
          // 第4階層以下はデフォルトで折りたたむ
          const level = parseInt(listItem.className.match(/level-(\d+)/)?.[1] || 1, 10);
          const collapsed = level >= 4;
          
          if (collapsed) {
            childList.style.display = 'none';
            toggleBtn.textContent = '▸';
          }
          
          toggleBtn.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            
            const isCollapsed = childList.style.display === 'none';
            childList.style.display = isCollapsed ? '' : 'none';
            toggleBtn.textContent = isCollapsed ? '▾' : '▸';
          });
          
          // 親リンクのクリック動作
          link.addEventListener('click', (e) => {
            e.stopPropagation();
          });
        }
      });
    }
  };

  CustomTOC.getNavData = function(navData) {
    return navData || NAV_DATA_STATE.data;
  };

  CustomTOC.normalizeText = function(text) {
    return (text || '').replace(/\s+/g, ' ').trim();
  };

  CustomTOC.getCurrentPage = function(navData) {
    const data = this.getNavData(navData);
    if (!data || !Array.isArray(data.pages)) return null;
    const current = computeCurrentOutputPath();
    return data.pages.find(page => isSamePage(page.output, current)) || null;
  };

  CustomTOC.createTree = function(nodes, pageOutput, options = {}) {
    const { variant } = options;
    const ul = document.createElement('ul');
    ul.className = 'toc-tree';
    if (variant) ul.classList.add(variant);

    nodes.forEach((node, index) => {
      if (!node) return;
      const depth = Math.min(node.level || 1, 6);
      const li = document.createElement('li');
      li.className = `toc-item toc-level-${depth}`;
      if (index === nodes.length - 1) li.classList.add('is-last');

      const row = document.createElement('div');
      row.className = 'toc-row';

      const link = document.createElement('a');
      link.className = `toc-link toc-level-${depth}`;
      link.href = buildHref(pageOutput, node.anchor || null);
      link.textContent = node.title || '';
      row.appendChild(link);
      li.appendChild(row);

      const hasChildren = Array.isArray(node.children) && node.children.length > 0;
      if (hasChildren) {
        const childList = this.createTree(node.children, pageOutput, options);
        li.appendChild(childList);
        li.classList.add('has-children');
      }

      ul.appendChild(li);
    });

    return ul;
  };

  CustomTOC.cloneNodeWithLevelOffset = function(node, offset) {
    if (!node) return null;
    const level = Math.max(1, (node.level || 1) + offset);
    const clone = {
      title: node.title,
      level,
      anchor: node.anchor,
      children: []
    };
    if (Array.isArray(node.children) && node.children.length) {
      clone.children = node.children
        .map(child => this.cloneNodeWithLevelOffset(child, offset))
        .filter(Boolean);
    }
    return clone;
  };

  CustomTOC.rebasePageHeadings = function(nodes) {
    if (!Array.isArray(nodes) || !nodes.length) return [];

    const rebased = [];
    let consumedLevel1 = false;

    nodes.forEach(node => {
      if (!node) return;
      const level = node.level || 1;
      if (level <= 1) {
        consumedLevel1 = true;
        if (Array.isArray(node.children) && node.children.length) {
          node.children.forEach(child => {
            const adjusted = this.cloneNodeWithLevelOffset(child, -1);
            if (adjusted) rebased.push(adjusted);
          });
        }
      } else {
        const adjusted = this.cloneNodeWithLevelOffset(node, -1);
        if (adjusted) rebased.push(adjusted);
      }
    });

    if (!rebased.length && !consumedLevel1) {
      return nodes
        .map(node => this.cloneNodeWithLevelOffset(node, -1))
        .filter(Boolean);
    }

    return rebased;
  };

  CustomTOC.renderChapterTab = function(container, navData) {
    if (!container) return;
    const data = this.getNavData(navData);
    container.innerHTML = '';

    if (!data || !Array.isArray(data.pages) || !data.pages.length) {
      container.innerHTML = '<p class="toc-empty">目次データを読み込めませんでした。</p>';
      return;
    }

    const list = document.createElement('ul');
    list.className = 'toc-chapter-list toc-tree';
    const current = computeCurrentOutputPath();

    data.pages.forEach(page => {
      if (!page) return;
      const li = document.createElement('li');
      li.className = 'toc-chapter-item';
      if (isSamePage(page.output, current)) li.classList.add('active');

      const headingTree = cloneTreeWithDepth(page.headings || [], 1);
      const nodes = headingTree.length ? headingTree : [{
        title: page.title,
        level: 1,
        anchor: page.headings && page.headings.length ? page.headings[0].anchor : null,
        children: []
      }];

      const primary = nodes[0];
      const link = document.createElement('a');
      link.className = 'toc-link toc-chapter-link';
      link.href = buildHref(page.output, primary.anchor || null);
      link.textContent = primary.title || page.title;
      li.appendChild(link);

      if (nodes.length > 1) {
        const childList = document.createElement('ul');
        childList.className = 'toc-tree toc-chapter-sublist';
        nodes.slice(1).forEach(node => {
          const subLi = document.createElement('li');
          subLi.className = 'toc-item toc-level-1';
          const subLink = document.createElement('a');
          subLink.className = 'toc-link';
          subLink.href = buildHref(page.output, node.anchor || null);
          subLink.textContent = node.title || '';
          subLi.appendChild(subLink);
          childList.appendChild(subLi);
        });
        li.appendChild(childList);
      }

      list.appendChild(li);
    });

    container.appendChild(list);
  };

  CustomTOC.renderAllTab = function(container, navData) {
    if (!container) return;
    const data = this.getNavData(navData);
    container.innerHTML = '';
    container.classList.add('toc-all-container-ready');

    if (!data || !Array.isArray(data.pages) || !data.pages.length) {
      container.innerHTML = '<p class="toc-empty">目次データを読み込めませんでした。</p>';
      return;
    }

    const list = document.createElement('ul');
    list.className = 'toc-all-list toc-tree toc-tree-root toc-tree-all-root';
    const current = computeCurrentOutputPath();

    data.pages.forEach(page => {
      if (!page) return;
      const li = document.createElement('li');
      li.className = 'toc-all-item';
      if (isSamePage(page.output, current)) li.classList.add('active');

      const headingTree = cloneTreeWithDepth(page.headings || [], 3);
      let sectionNodes = headingTree;
      let chapterAnchor = page.headings && page.headings.length ? page.headings[0].anchor : null;
      if (
        headingTree.length === 1 &&
        this.normalizeText(headingTree[0].title) === this.normalizeText(page.title)
      ) {
        chapterAnchor = headingTree[0].anchor || chapterAnchor;
        sectionNodes = headingTree[0].children || [];
      }

      const link = document.createElement('a');
      link.className = 'toc-link toc-all-link';
      link.href = buildHref(page.output, chapterAnchor || null);
      link.textContent = page.title;
      li.appendChild(link);

      if (sectionNodes.length) {
        const childTree = this.createTree(sectionNodes, page.output, { variant: 'toc-tree-all' });
        li.appendChild(childTree);
      }

      list.appendChild(li);
    });

    container.appendChild(list);
  };

  CustomTOC.renderPageTab = function(container, navData, maxDepth = 4) {
    if (!container) return;
    const page = this.getCurrentPage(navData);
    container.innerHTML = '';
    container.classList.add('toc-page-container');

    if (!page) {
      container.innerHTML = '<p class="toc-empty">このページには見出しがありません。</p>';
      return;
    }

    const headingTree = cloneTreeWithDepth(page.headings || [], maxDepth);
    const rebasedTree = this.rebasePageHeadings(headingTree)
      .filter(node => (node.level || 1) >= 1);

    if (!rebasedTree.length) {
      container.innerHTML = '<p class="toc-empty">このページには見出しがありません。</p>';
      return;
    }

    const tree = this.createTree(rebasedTree, page.output, { variant: 'toc-tree-page' });
    tree.classList.add('toc-tree-root', 'toc-tree-page-root');
    container.appendChild(tree);
  };

  CustomTOC.initializeCustomTOC = function(navData) {
    const data = this.getNavData(navData);
    if (!data) return;

    const pagePanel = document.querySelector('.toc-page-content');
    if (pagePanel) {
      this.renderPageTab(pagePanel, data, 4);
    }

    const allPanel = document.querySelector('.toc-all-content .toc-all-container') || document.querySelector('.toc-all-content');
    if (allPanel) {
      this.renderAllTab(allPanel, data);
    }

    const sitePanel = document.querySelector('.toc-site-content .sidebar-menu-container');
    if (sitePanel) {
      this.renderChapterTab(sitePanel, data);
    }
  };

  CustomTOC.generatePageTOC = function(maxDepth = 4) {
    const temp = document.createElement('div');
    this.renderPageTab(temp, this.getNavData(), maxDepth);
    return temp.innerHTML || '<p class="toc-empty">このページには見出しがありません。</p>';
  };

  CustomTOC.generateAllPagesTOC = function() {
    const temp = document.createElement('div');
    this.renderAllTab(temp, this.getNavData());
    return temp.innerHTML || '<p class="toc-empty">目次データを読み込めませんでした。</p>';
  };

  // コメントエクスポート/インポート
  function exportComments(pageOnly) {
    try {
      const data = pageOnly ? { [pageKey()]: COMMENTS_DB[pageKey()]||[] } : COMMENTS_DB;
      const blob = new Blob([JSON.stringify({ version:'1.0', exportedAt: new Date().toISOString(), data }, null, 2)], { type:'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      const base = pageOnly ? (pageKey().split('/').pop()||'page') : 'all';
      a.download = `comments_${base}_${new Date().toISOString().slice(0,10)}.json`;
      document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
    } catch (e) { alert('コメント出力に失敗しました'); }
  }
  function importCommentsFromFile(file) {
    if (!file) return;
    const reader = new FileReader();
    reader.onload = () => {
      try {
        const json = JSON.parse(reader.result);
        const incoming = json.data || {};
        // マージ
        Object.keys(incoming).forEach(k => {
          if (!Array.isArray(incoming[k])) return;
          if (!COMMENTS_DB[k]) COMMENTS_DB[k] = [];
          const existingIds = new Set(COMMENTS_DB[k].map(r=>r.id));
          incoming[k].forEach(rec => { if (!existingIds.has(rec.id)) COMMENTS_DB[k].push(rec); });
        });
        saveComments();
        refreshRightPanels();
        alert('コメントをインポートしました');
      } catch (e) {
        alert('コメント読込に失敗しました');
      }
    };
    reader.readAsText(file, 'utf-8');
  }

})();
</script>
<style>
  .gdoc-popover {
    position: absolute;
    z-index: 1100;
    max-width: 320px;
    background: var(--gdoc-popover-bg, #fff);
    color: inherit;
    border-radius: 6px;
    box-shadow: 0 4px 16px rgba(0,0,0,0.18);
    border: 1px solid rgba(0,0,0,0.07);
    font-size: 14px;
  }
  .gdoc-popover[hidden] {
    display: none !important;
  }
  .gdoc-popover-inner {
    padding: 8px 10px;
  }
  .gdoc-popover-header {
    margin-bottom: 6px;
    font-weight: 600;
    line-height: 1.3;
    max-height: 3.2em;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .gdoc-popover-title {
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
  }
  .gdoc-popover-actions {
    display: flex;
    gap: 6px;
    justify-content: flex-end;
  }
  .gdoc-popover-actions .gdoc-btn {
    border: none;
    background: transparent;
    padding: 4px 6px;
    border-radius: 4px;
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: 13px;
    color: inherit;
  }
  .gdoc-popover-actions .gdoc-btn:hover {
    background: rgba(0,0,0,0.06);
  }
  .gdoc-popover-actions .gdoc-btn svg {
    width: 16px;
    height: 16px;
  }

.gdoc-modal {
    position: static;
    z-index: auto;
  }
  .gdoc-modal[hidden] {
    display: none !important;
  }
  .gdoc-modal-dialog {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: min(900px, 90vw);
    height: min(600px, 80vh);
    min-width: 320px;
    min-height: 220px;
    max-width: 95vw;
    max-height: 95vh;
    background: #fff;
    border-radius: 8px;
    overflow: hidden;
    box-shadow: 0 10px 30px rgba(0,0,0,0.35);
    display: flex;
    flex-direction: column;
    z-index: 1500;
  }
  .gdoc-modal-header {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 6px 10px;
    border-bottom: 1px solid rgba(0,0,0,0.08);
    background: #f5f5f5;
    cursor: move;
    user-select: none;
  }
  .gdoc-modal-title {
    font-size: 14px;
    font-weight: 600;
    margin-right: 8px;
    max-width: 60vw;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .gdoc-modal-header-actions {
    display: inline-flex;
    align-items: center;
    gap: 4px;
  }
  .gdoc-modal-header-actions .gdoc-modal-btn {
    border: none;
    background: transparent;
    padding: 4px 6px;
    border-radius: 4px;
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: 13px;
    color: inherit;
  }
  .gdoc-modal-header-actions .gdoc-modal-btn:hover {
    background: rgba(0,0,0,0.06);
  }
  .gdoc-modal-header-actions .gdoc-modal-btn svg {
    width: 15px;
    height: 15px;
  }
  .gdoc-modal-body {
    flex: 1 1 auto;
    position: relative;
    overflow: auto;
  }
  .gdoc-modal-iframe {
    border: none;
    width: 100%;
    height: 100%;
    transform-origin: 0 0;
  }
  .bg-preview-body {
    display: none;
    padding: 20px 40px;
    max-width: 900px;
    margin: 0 auto;
    font-size: inherit; /* 設定された文字サイズを継承 */
    line-height: 1.8;
    overflow-y: auto;
    height: 100%;
  }
  
  /* 文字サイズクラスに対応 */
  .font-size-small .bg-preview-body { font-size: 14px; }
  .font-size-medium .bg-preview-body { font-size: 16px; }
  .font-size-large .bg-preview-body { font-size: 18px; }
  .font-size-xlarge .bg-preview-body { font-size: 20px; }
  .bg-preview-body.active {
    display: block;
  }
  .bg-preview-body .inline-footnote {
    color: #1a73e8;
    font-size: 0.9em;
    margin-left: 2px;
  }
  .bg-preview-body .text-marker {
    background: rgba(255, 235, 59, 0.3);
    padding: 0 2px;
  }
  
  /* プレビュー内のポップオーバーを最前面に */
  .bg-preview-body .gdoc-popover,
  .bg-preview-body #bg-preview-popover {
    z-index: 10001 !important;
  }
  .bg-preview-body h1,
  .bg-preview-body h2,
  .bg-preview-body h3,
  .bg-preview-body h4 {
    margin-top: 1.5em;
    margin-bottom: 0.5em;
  }
  .bg-preview-body p {
    margin-bottom: 1em;
  }
  .bg-preview-body a {
    color: #1a73e8;
    text-decoration: none;
  }
  .bg-preview-body a:hover {
    text-decoration: underline;
  }
  /* モバイルモードでは画面全体を覆うモーダルとして動作 */
  .gdoc-modal.gdoc-modal-mobile {
    position: fixed;
    inset: 0;
    z-index: 1500;
    background: rgba(0,0,0,0.35);
  }
  .gdoc-modal.gdoc-modal-mobile .gdoc-modal-dialog {
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 96vw;
    height: 90vh;
    min-width: 0;
    min-height: 0;
    max-width: none;
    max-height: none;
    border-radius: 8px;
  }
  
  /* モバイル版でのウィンドウサイズ変更対応 */
  @media (max-width: 768px) {
    .gdoc-modal-dialog {
      position: fixed !important;
      top: 50% !important;
      left: 50% !important;
      transform: translate(-50%, -50%) !important;
      width: 95vw !important;
      height: 95vh !important;
    }
  }
  .gdoc-resize-handle {
    position: absolute;
    width: 12px;
    height: 12px;
    z-index: 1600;
    background: transparent;
    /* 視認性が必要なら、以下のコメントアウトを外す
    background: rgba(0,0,0,0.15);
    border-radius: 50%;
    */
  }
  .gdoc-resize-handle-nw {
    top: -4px;
    left: -4px;
    cursor: nwse-resize;
  }
  .gdoc-resize-handle-ne {
    top: -4px;
    right: -4px;
    cursor: nesw-resize;
  }
  .gdoc-resize-handle-sw {
    bottom: -4px;
    left: -4px;
    cursor: nesw-resize;
  }
  .gdoc-resize-handle-se {
    bottom: -4px;
    right: -4px;
    cursor: nwse-resize;
  }

  /* 右下に積まれる格納トースト */
  .gdoc-toast-container {
    position: fixed;
    right: 16px;
    bottom: 16px;
    z-index: 1400;
    display: flex;
    flex-direction: column;
    gap: 8px;
    max-width: 480px;
    pointer-events: none;
  }
  .gdoc-toast-container-inner {
    pointer-events: auto;
    display: flex;
    flex-direction: column;
    gap: 8px;
  }
.gdoc-toast {
    width: 480px;
    max-width: 100vw;
    background: #f5f5f5;
    color: #222;
    border-radius: 8px;
    box-shadow: 0 4px 16px rgba(0,0,0,0.18);
    display: flex;
    align-items: center;
    padding: 6px 10px;
    box-sizing: border-box;
  }
  .gdoc-toast-main {
    flex: 1 1 auto;
    min-width: 0;
    display: flex;
    align-items: center;
    gap: 8px;
    cursor: pointer;
  }
  .gdoc-toast-title {
    flex: 1 1 auto;
    min-width: 0;
    font-size: 13px;
    font-weight: 500;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .gdoc-toast-actions {
    flex: 0 0 auto;
    display: inline-flex;
    align-items: center;
    gap: 4px;
  }
  .gdoc-toast-btn {
    border: none;
    background: transparent;
    padding: 2px 4px;
    border-radius: 4px;
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    color: inherit;
  }
  .gdoc-toast-btn:hover {
    background: rgba(255,255,255,0.12);
  }
  .gdoc-toast-btn svg {
    width: 14px;
    height: 14px;
  }

  /* トーストのダークテーマ */
  body[data-theme="dark"] .gdoc-toast {
    background: #303134;
    color: #e0e0e0;
    box-shadow: 0 4px 16px rgba(0,0,0,0.6);
  }

  body[data-theme="dark"] .gdoc-toast-btn:hover {
    background: rgba(255,255,255,0.08);
  }

  /* 他文書一覧モーダル */
  .gdoc-list-modal {
    position: fixed;
    inset: 0;
    z-index: 1550;
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(0,0,0,0.4);
  }
  .gdoc-list-modal[hidden] {
    display: none !important;
  }
  .gdoc-list-modal-dialog {
    width: min(640px, 96vw);
    max-height: 80vh;
    background: #fff;
    border-radius: 8px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.35);
    display: flex;
    flex-direction: column;
    overflow: hidden;
  }
  .gdoc-list-modal-header {
    padding: 8px 12px;
    border-bottom: 1px solid rgba(0,0,0,0.08);
    display: flex;
    align-items: center;
    justify-content: space-between;
  }
  .gdoc-list-modal-title {
    font-size: 14px;
    font-weight: 600;
  }
  .gdoc-list-modal-close {
    border: none;
    background: transparent;
    cursor: pointer;
    font-size: 18px;
    line-height: 1;
  }
  .gdoc-list-modal-body {
    padding: 8px 12px;
    overflow: auto;
  }
  .gdoc-list {
    list-style: none;
    margin: 0;
    padding: 0;
    display: flex;
    flex-direction: column;
    gap: 6px;
  }
  .gdoc-list-item {
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 4px 6px;
    border-radius: 4px;
  }
  .gdoc-list-item:hover {
    background: rgba(0,0,0,0.03);
  }
  .gdoc-list-item-title {
    flex: 1 1 auto;
    min-width: 0;
    font-size: 13px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .gdoc-list-item-actions {
    flex: 0 0 auto;
    display: inline-flex;
    align-items: center;
    gap: 4px;
  }
  .gdoc-list-item-btn {
    border: none;
    background: transparent;
    cursor: pointer;
    padding: 2px 4px;
    border-radius: 4px;
    font-size: 12px;
  }
  .gdoc-list-item-btn:hover {
    background: rgba(0,0,0,0.06);
  }
</style>

<div id="gdoc-preview-popover" class="gdoc-popover" hidden="">
  <div class="gdoc-popover-inner">
    <div class="gdoc-popover-header">
      <span class="gdoc-popover-title"></span>
    </div>
    <div class="gdoc-popover-actions" role="group" aria-label="Googleドキュメント操作">
      <button type="button" class="gdoc-btn gdoc-btn-preview" data-action="preview" title="プレビュー表示" aria-label="プレビュー表示">
        <!-- 目アイコン -->
        <svg viewbox="0 0 24 24" aria-hidden="true"><path d="M12 5C7 5 3.1 8 1.5 12 3.1 16 7 19 12 19s8.9-3 10.5-7C20.9 8 17 5 12 5zm0 10a3 3 0 110-6 3 3 0 010 6z"></path></svg>
      </button>
      <button type="button" class="gdoc-btn gdoc-btn-open" data-action="open" title="別タブで開く" aria-label="別タブで開く">
        <!-- 外部リンクアイコン -->
        <svg viewbox="0 0 24 24" aria-hidden="true"><path d="M14 3h7v7h-2V6.41l-9.29 9.3-1.42-1.42 9.3-9.29H14V3z"></path><path d="M5 5h5V3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2v-5h-2v5H5V5z"></path></svg>
      </button>
      <button type="button" class="gdoc-btn gdoc-btn-copy" data-action="copy" title="リンクをコピー" aria-label="リンクをコピー">
        <!-- コピーアイコン -->
        <svg viewbox="0 0 24 24" aria-hidden="true"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></svg>
      </button>
    </div>
  </div>
</div>

<div id="bg-preview-popover" class="gdoc-popover" hidden="">
  <div class="gdoc-popover-inner">
    <div class="gdoc-popover-header">
      <span class="gdoc-popover-title"></span>
    </div>
    <div class="gdoc-popover-actions" role="group" aria-label="ドキュメント内遷移操作">
      <button type="button" class="gdoc-btn gdoc-btn-preview" data-action="preview" title="プレビュー表示" aria-label="プレビュー表示">
        <svg viewbox="0 0 24 24" aria-hidden="true"><path d="M12 5C7 5 3.1 8 1.5 12 3.1 16 7 19 12 19s8.9-3 10.5-7C20.9 8 17 5 12 5zm0 10a3 3 0 110-6 3 3 0 010 6z"></path></svg>
      </button>
      <button type="button" class="gdoc-btn gdoc-btn-go" data-action="go" title="リンク先に遷移" aria-label="リンク先に遷移">
        <svg viewbox="0 0 24 24" aria-hidden="true"><path d="M12 4l-1.41 1.41L16.17 11H4v2h12.17l-5.58 5.59L12 20l8-8z"></path></svg>
      </button>
      <button type="button" class="gdoc-btn gdoc-btn-toast" data-action="toast" title="トーストへ格納" aria-label="トーストへ格納">
        <svg viewbox="0 0 24 24" aria-hidden="true"><path d="M17 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V7l-4-4zm-5 16c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3zm3-10H5V5h10v4z"></path></svg>
      </button>
      <button type="button" class="gdoc-btn gdoc-btn-close" data-action="close" title="閉じる" aria-label="閉じる">
        <svg viewbox="0 0 24 24" aria-hidden="true"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"></path></svg>
      </button>
    </div>
  </div>
</div>

<div id="gdoc-preview-modal" class="gdoc-modal" hidden="">
  <div class="gdoc-modal-dialog" role="dialog" aria-label="Googleドキュメント プレビュー">
    <div class="gdoc-resize-handle gdoc-resize-handle-nw" data-resize-dir="nw"></div>
    <div class="gdoc-resize-handle gdoc-resize-handle-ne" data-resize-dir="ne"></div>
    <div class="gdoc-resize-handle gdoc-resize-handle-sw" data-resize-dir="sw"></div>
    <div class="gdoc-resize-handle gdoc-resize-handle-se" data-resize-dir="se"></div>
    <div class="gdoc-modal-header">
      <div class="gdoc-modal-title"></div>
      <div class="gdoc-modal-header-actions">
        <button type="button" class="gdoc-modal-btn gdoc-modal-btn-reload" title="再読み込み" aria-label="再読み込み">
          <svg viewbox="0 0 24 24" aria-hidden="true"><path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"></path></svg>
        </button>
        <button type="button" class="gdoc-modal-btn gdoc-modal-btn-copy" title="リンクをコピー" aria-label="リンクをコピー">
          <svg viewbox="0 0 24 24" aria-hidden="true"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></svg>
        </button>
        <button type="button" class="gdoc-modal-btn gdoc-modal-btn-open" title="別タブで開く" aria-label="別タブで開く">
          <svg viewbox="0 0 24 24" aria-hidden="true"><path d="M14 3h7v7h-2V6.41l-9.29 9.3-1.42-1.42 9.3-9.29H14V3z"></path><path d="M5 5h5V3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2v-5h-2v5H5V5z"></path></svg>
        </button>
        <button type="button" class="gdoc-modal-btn gdoc-modal-btn-jump" title="本文へ移動" aria-label="本文へ移動">
          <svg viewbox="0 0 24 24" aria-hidden="true"><path d="M12 2c-.55 0-1 .45-1 1v12.59l-4.3-4.3a1 1 0 10-1.4 1.42l6 6a1 1 0 001.4 0l6-6a1 1 0 10-1.4-1.42L13 15.59V3c0-.55-.45-1-1-1z"></path></svg>
        </button>
        <button type="button" class="gdoc-modal-btn gdoc-modal-btn-close" title="閉じる" aria-label="ポップアップを閉じる">
          <svg viewbox="0 0 24 24" aria-hidden="true"><path d="M5.293 6.707l5.293 5.293-5.293 5.293c-.39.39-.39 1.024 0 1.414s1.024.39 1.414 0l5.293-5.293 5.293 5.293c.39.39 1.024.39 1.414 0s.39-1.024 0-1.414L13.414 12l5.293-5.293c.39-.39.39-1.024 0-1.414s-1.024-.39-1.414 0L12 10.586 6.707 5.293c-.39-.39-1.024-.39-1.414 0s-.39 1.024 0 1.414z"></path></svg>
        </button>
      </div>
    </div>
    <div class="gdoc-modal-body">
      <iframe class="gdoc-modal-iframe" src="about:blank" loading="lazy"></iframe>
      <div class="bg-preview-body"></div>
    </div>
</div>
</div>

<div id="gdoc-preview-toast-container" class="gdoc-toast-container" aria-live="polite" aria-atomic="false">
  <div class="gdoc-toast-container-inner"></div>
</div>

<div id="gdoc-preview-list-modal" class="gdoc-list-modal" hidden="">
  <div class="gdoc-list-modal-dialog" role="dialog" aria-modal="true" aria-label="他のプレビュー文書一覧">
    <div class="gdoc-list-modal-header">
      <div class="gdoc-list-modal-title">プレビュー中の文書</div>
      <button type="button" class="gdoc-list-modal-close" aria-label="閉じる">×</button>
    </div>
    <div class="gdoc-list-modal-body">
      <ul class="gdoc-list"></ul>
    </div>
  </div>
</div>

<script>
(function () {
  'use strict';

  var MOBILE_MAX_WIDTH = 768; // ビューポート幅による PC/モバイル判定
  var STORAGE_KEY = 'gdocPreviewState_v2';
  var ZOOM_MIN = 0.5;
  var ZOOM_MAX = 2.0;
  var ZOOM_STEP = 0.05;

  // ブラウザの自動スクロール復元を無効化（自前で制御する）
  if (history && typeof history.scrollRestoration === 'string') {
    try { history.scrollRestoration = 'manual'; } catch (e) {}
  }

  var popover = document.getElementById('gdoc-preview-popover');
  var titleEl = popover ? popover.querySelector('.gdoc-popover-title') : null;
  var previewBtn = popover ? popover.querySelector('.gdoc-btn-preview') : null;
  var openBtn = popover ? popover.querySelector('.gdoc-btn-open') : null;
  var copyBtn = popover ? popover.querySelector('.gdoc-btn-copy') : null;

  var bgPopover = document.getElementById('bg-preview-popover');
  var bgTitleEl = bgPopover ? bgPopover.querySelector('.gdoc-popover-title') : null;
  var bgPreviewBtn = bgPopover ? bgPopover.querySelector('.gdoc-btn-preview') : null;
  var bgGoBtn = bgPopover ? bgPopover.querySelector('.gdoc-btn-go') : null;
  var bgToastBtn = bgPopover ? bgPopover.querySelector('.gdoc-btn-toast') : null;
  var bgCloseBtn = bgPopover ? bgPopover.querySelector('.gdoc-btn-close') : null;

  var modal = document.getElementById('gdoc-preview-modal');
  var modalDialog = modal ? modal.querySelector('.gdoc-modal-dialog') : null;
  var modalHeader = modal ? modal.querySelector('.gdoc-modal-header') : null;
  var modalTitle = modal ? modal.querySelector('.gdoc-modal-title') : null;
  var modalIframe = modal ? modal.querySelector('.gdoc-modal-iframe') : null;
  var bgPreviewBody = modal ? modal.querySelector('.bg-preview-body') : null;
  var modalBtnClose = modal ? modal.querySelector('.gdoc-modal-btn-close') : null;
  var modalBtnOpen = modal ? modal.querySelector('.gdoc-modal-btn-open') : null;
  var modalBtnReload = modal ? modal.querySelector('.gdoc-modal-btn-reload') : null;
  var modalBtnCopy = modal ? modal.querySelector('.gdoc-modal-btn-copy') : null;
  var modalBtnJump = modal ? modal.querySelector('.gdoc-modal-btn-jump') : null;
  var resizeHandles = modalDialog ? modalDialog.querySelectorAll('.gdoc-resize-handle') : [];

  var toastContainer = document.getElementById('gdoc-preview-toast-container');
  var toastInner = toastContainer ? toastContainer.querySelector('.gdoc-toast-container-inner') : null;

  var listModal = document.getElementById('gdoc-preview-list-modal');
  var listModalDialog = listModal ? listModal.querySelector('.gdoc-list-modal-dialog') : null;
  var listModalClose = listModal ? listModal.querySelector('.gdoc-list-modal-close') : null;
  var listEl = listModal ? listModal.querySelector('.gdoc-list') : null;

  if (!popover || !titleEl || !previewBtn || !openBtn || !copyBtn || !bgPopover || !bgTitleEl || !bgPreviewBtn || !bgGoBtn || !bgToastBtn || !bgCloseBtn || !modal || !modalDialog || !modalHeader || !modalTitle || !modalIframe || !bgPreviewBody || !modalBtnClose || !modalBtnOpen || !modalBtnReload || !modalBtnCopy || !modalBtnJump || !toastContainer || !toastInner || !listModal || !listModalDialog || !listModalClose || !listEl) {
    return;
  }

  var currentLink = null; // ポップオーバー対象リンク（Docs用）
  var currentBgLink = null; // ポップオーバー対象リンク（BG用）
  var hideTimer = null;
  var bgHideTimer = null;
  var showTimer = null; // Docs用ポップオーバー表示遅延タイマー
  var bgShowTimer = null; // BG用ポップオーバー表示遅延タイマー
  var POPOVER_SHOW_DELAY = 400; // ポップオーバー表示までの遅延（ms）
  var isDragging = false;
  var dragStartX = 0;
  var dragStartY = 0;
  var dialogStartLeft = 0;
  var dialogStartTop = 0;

  var isResizing = false;
  var resizeDir = '';
  var resizeStartX = 0;
  var resizeStartY = 0;
  var startWidth = 0;
  var startHeight = 0;
  var startLeft = 0;
  var startTop = 0;

  var isMouseDownOnHeader = false;
  var headerMouseDownX = 0;
  var headerMouseDownY = 0;

  var isMobile = false;
  var state = loadState();
  var currentKey = getActiveKeyFromState(state) || null;
  var currentZoom = 1.0;

  // ---- state persistence ----
  function loadState() {
    try {
      var raw = window.localStorage.getItem(STORAGE_KEY);
      if (!raw) return { items: [], lastGeometry: null };
      var parsed = JSON.parse(raw);
      if (!parsed || !Array.isArray(parsed.items)) {
        return { items: [], lastGeometry: null };
      }
      // 既存アイテムにkindがない場合はgdocとして扱う
      for (var i = 0; i < parsed.items.length; i++) {
        if (!parsed.items[i].kind) {
          parsed.items[i].kind = 'gdoc';
        }
      }
      return parsed;
    } catch (e) {
      return { items: [], lastGeometry: null };
    }
  }

  function saveState() {
    try {
      window.localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
    } catch (e) {
      // ignore
    }
  }

  function getActiveKeyFromState(s) {
    if (!s || !Array.isArray(s.items)) return null;
    for (var i = 0; i < s.items.length; i++) {
      if (s.items[i].state === 'active') return s.items[i].key;
    }
    return null;
  }

  function getPreviewKeyFromLink(link) {
    if (!link) return null;
    // プレビューURLがあればそれをキーにする（同じドキュメント内の別タブも区別）
    var previewUrl = link.dataset.gdocPreviewUrl;
    if (previewUrl) return 'preview:' + previewUrl;
    var id = link.dataset.gdocId;
    if (id) return 'id:' + id;
    return 'href:' + link.href;
  }

  // 各リンク要素にプレビューキーを紐付けておく（本文ジャンプ用）
  function initializeLinkKeys() {
    try {
      var links = document.querySelectorAll('a.gdoc-link[data-gdoc-title]');
      for (var i = 0; i < links.length; i++) {
        var link = links[i];
        var key = getPreviewKeyFromLink(link);
        if (key) {
          link.setAttribute('data-gdoc-key', key);
        }
      }
    } catch (e) {
      // ignore
    }
  }

  // 初期化直後にキーを付与
  initializeLinkKeys();

  function ensureItemForLink(link, previewUrl) {
    var key = getPreviewKeyFromLink(link);
    if (!key) return null;
    var title = link.dataset.gdocTitle || link.textContent || link.href || '';
    var href = link.href;
    var items = state.items;
    var item = null;
    for (var i = 0; i < items.length; i++) {
      if (items[i].key === key) {
        item = items[i];
        break;
      }
    }
    if (!item) {
      var sourceElement = link.closest('[id]') || link;
      item = {
        key: key,
        kind: 'gdoc',
        id: link.dataset.gdocId || null,
        href: href,
        previewUrl: previewUrl,
        title: title,
        state: 'active',
        position: null,
        size: null,
        zoom: 1.0,
        lastUpdated: Date.now(),
        sourceId: sourceElement && sourceElement.id ? sourceElement.id : null,
        sourceUrl: window.location.href.split('#')[0]
      };
      if (state.lastGeometry) {
        item.position = {
          left: state.lastGeometry.left,
          top: state.lastGeometry.top
        };
        item.size = {
          width: state.lastGeometry.width,
          height: state.lastGeometry.height
        };
        item.zoom = state.lastGeometry.zoom || 1.0;
      }
      state.items.push(item);
    } else {
      item.href = href;
      item.previewUrl = previewUrl;
      item.title = title;
      item.lastUpdated = Date.now();
      if (!item.sourceUrl) {
        var srcEl = link.closest('[id]') || link;
        item.sourceId = srcEl && srcEl.id ? srcEl.id : (item.sourceId || null);
        item.sourceUrl = window.location.href.split('#')[0];
      }
    }
    return item;
  }

  function getBgPreviewKeyFromLink(link) {
    if (!link) return null;
    var href = link.href || link.getAttribute('href');
    if (!href) return null;
    return 'bg:' + href;
  }

  function ensureBgItemForLink(link) {
    var key = getBgPreviewKeyFromLink(link);
    if (!key) return null;
    var href = link.href || link.getAttribute('href');
    var title = link.textContent || link.getAttribute('title') || href || '';
    var items = state.items;
    var item = null;
    for (var i = 0; i < items.length; i++) {
      if (items[i].key === key) {
        item = items[i];
        break;
      }
    }
    if (!item) {
      var hrefWithoutHash = href.split('#')[0];
      var anchorId = href.indexOf('#') !== -1 ? href.split('#')[1] : null;
      var sourceElement = link.closest('[id]') || link;
      item = {
        key: key,
        kind: 'bg',
        href: href,
        pageUrl: hrefWithoutHash,
        anchorId: anchorId,
        title: title,
        state: 'active',
        position: null,
        size: null,
        zoom: 1.0,
        lastUpdated: Date.now(),
        snippetHtml: null,
        sourceId: sourceElement && sourceElement.id ? sourceElement.id : null,
        sourceUrl: window.location.href.split('#')[0]
      };
      if (state.lastGeometry) {
        item.position = {
          left: state.lastGeometry.left,
          top: state.lastGeometry.top
        };
        item.size = {
          width: state.lastGeometry.width,
          height: state.lastGeometry.height
        };
        item.zoom = state.lastGeometry.zoom || 1.0;
      }
      state.items.push(item);
    } else {
      // 既存のアイテムが見つかった場合
      item.title = title;
      item.lastUpdated = Date.now();
      if (!item.sourceUrl) {
        var srcEl = link.closest('[id]') || link;
        item.sourceId = srcEl && srcEl.id ? srcEl.id : (item.sourceId || null);
        item.sourceUrl = window.location.href.split('#')[0];
      }
      // minimized状態の場合は何もしない（activatePreviewItemで処理される）
    }
    return item;
  }

  function findItemByKey(key) {
    if (!key) return null;
    var items = state.items;
    for (var i = 0; i < items.length; i++) {
      if (items[i].key === key) return items[i];
    }
    return null;
  }

  function setActiveItem(item) {
    if (!item) return;
    var items = state.items;
    for (var i = 0; i < items.length; i++) {
      if (items[i].key === item.key) {
        items[i].state = 'active';
      } else if (items[i].state === 'active') {
        items[i].state = 'minimized';
      }
    }
    item.state = 'active';
    currentKey = item.key;
    item.lastUpdated = Date.now();
    saveState();
  }

  function closeItemByKey(key) {
    if (!key) return;
    var items = state.items;
    var newItems = [];
    for (var i = 0; i < items.length; i++) {
      if (items[i].key !== key) newItems.push(items[i]);
    }
    state.items = newItems;
    if (currentKey === key) {
      currentKey = null;
    }
    saveState();
    if (!isMobile) {
      rebuildToasts();
    }
  }

  function getActiveItem() {
    if (currentKey) {
      var byKey = findItemByKey(currentKey);
      if (byKey && byKey.state === 'active') return byKey;
    }
    if (!state || !Array.isArray(state.items)) return null;
    for (var i = 0; i < state.items.length; i++) {
      if (state.items[i].state === 'active') {
        currentKey = state.items[i].key;
        return state.items[i];
      }
    }
    return null;
  }

  function updateLastGeometryFromActive() {
    var item = getActiveItem();
    if (!item) return;
    if (!item.position || !item.size) return;
    state.lastGeometry = {
      left: item.position.left,
      top: item.position.top,
      width: item.size.width,
      height: item.size.height,
      zoom: item.zoom || 1.0
    };
    saveState();
  }

  // ---- layout mode ----
  function updateMode() {
    isMobile = window.innerWidth <= MOBILE_MAX_WIDTH;
    if (isMobile) {
      modal.classList.add('gdoc-modal-mobile');
      if (toastContainer) {
        toastContainer.style.display = 'none';
      }
      if (!listModal.hidden) {
        listModal.hidden = true;
      }
    } else {
      modal.classList.remove('gdoc-modal-mobile');
      if (toastContainer) {
        toastContainer.style.display = '';
      }
      rebuildToasts();
      var activeItem = getActiveItem();
      if (activeItem) {
        applyGeometry(activeItem);
        applyZoom(activeItem.zoom || 1.0);
      }
    }
  }

  window.addEventListener('resize', function () {
    updateMode();
  });

  // ---- popover (リンク横UI) ----
  function showPopoverForLink(link) {
    if (!link || !link.dataset || !link.dataset.gdocTitle) return;
    currentLink = link;

    var rect = link.getBoundingClientRect();
    titleEl.textContent = link.dataset.gdocTitle || link.textContent || '';

    var top = rect.bottom + window.scrollY + 8;
    var left = rect.left + window.scrollX;

    popover.style.top = top + 'px';
    popover.style.left = left + 'px';
    popover.hidden = false;
  }

  function scheduleHidePopover() {
    hideTimer = window.setTimeout(function () {
      popover.hidden = true;
      currentLink = null;
    }, 180);
  }

  function cancelHidePopover() {
    if (hideTimer) {
      window.clearTimeout(hideTimer);
      hideTimer = null;
    }
  }

  function cancelShowPopover() {
    if (showTimer) {
      window.clearTimeout(showTimer);
      showTimer = null;
    }
  }

  document.addEventListener('mouseover', function (e) {
    var link = e.target.closest && e.target.closest('a.gdoc-link[data-gdoc-title]');
    if (!link) return;
    cancelHidePopover();
    cancelShowPopover();
    showTimer = window.setTimeout(function () {
      showPopoverForLink(link);
    }, POPOVER_SHOW_DELAY);
  });

  document.addEventListener('focusin', function (e) {
    var link = e.target.closest && e.target.closest('a.gdoc-link[data-gdoc-title]');
    if (!link) return;
    cancelHidePopover();
    showPopoverForLink(link);
  });

  document.addEventListener('click', function (e) {
    var link = e.target.closest && e.target.closest('a.gdoc-link[data-gdoc-title]');
    if (!link) return;
    e.preventDefault();
    cancelHidePopover();
    showPopoverForLink(link);
  });

  document.addEventListener('mouseout', function (e) {
    var fromLink = e.target.closest && e.target.closest('a.gdoc-link[data-gdoc-title]');
    if (!fromLink) return;
    var to = e.relatedTarget;
    if (to && (to.closest && (to.closest('a.gdoc-link[data-gdoc-title]') || to.closest('#gdoc-preview-popover')))) {
      return;
    }
    cancelShowPopover();
    scheduleHidePopover();
  });

  popover.addEventListener('mouseenter', cancelHidePopover);
  popover.addEventListener('mouseleave', scheduleHidePopover);

  function openLinkInNewTabFromLink(link) {
    if (!link) return;
    window.open(link.href, '_blank', 'noopener');
  }

  function copyLinkFromLink(link) {
    if (!link) return;
    var url = link.href;
    if (navigator.clipboard && navigator.clipboard.writeText) {
      navigator.clipboard.writeText(url).catch(function () {});
      return;
    }
    var tmp = document.createElement('textarea');
    tmp.style.position = 'fixed';
    tmp.style.opacity = '0';
    tmp.value = url;
    document.body.appendChild(tmp);
    tmp.select();
    try { document.execCommand('copy'); } catch (e) {}
    document.body.removeChild(tmp);
  }

  // ポップオーバーのボタン
  previewBtn.addEventListener('click', function () {
    if (!currentLink) return;
    openPreviewFromLink(currentLink);
  });

  openBtn.addEventListener('click', function () {
    if (!currentLink) return;
    openLinkInNewTabFromLink(currentLink);
  });

  copyBtn.addEventListener('click', function () {
    if (!currentLink) return;
    copyLinkFromLink(currentLink);
  });

  // BGプレビュー用ポップオーバーのボタン
  bgPreviewBtn.addEventListener('click', function () {
    if (!currentBgLink) return;
    openBgPreviewFromLink(currentBgLink);
    bgPopover.hidden = true;
  });

  bgGoBtn.addEventListener('click', function () {
    if (!currentBgLink) return;
    window.location.href = currentBgLink.href;
  });

  bgToastBtn.addEventListener('click', function () {
    if (!currentBgLink) return;
    var item = ensureBgItemForLink(currentBgLink);
    if (item) {
      item.state = 'minimized';
      saveState();
      rebuildToasts();
    }
    bgPopover.hidden = true;
  });

  bgCloseBtn.addEventListener('click', function () {
    bgPopover.hidden = true;
    currentBgLink = null;
  });

  function openBgPreviewFromLink(link) {
    var item = ensureBgItemForLink(link);
    if (!item) return;
    activatePreviewItem(item, true);
  }

  function showBgPopoverForLink(link) {
    if (!link) return;
    currentBgLink = link;

    var rect = link.getBoundingClientRect();
    bgTitleEl.textContent = link.textContent || link.getAttribute('title') || 'プレビュー';

    var top = rect.bottom + window.scrollY + 8;
    var left = rect.left + window.scrollX;

    bgPopover.style.top = top + 'px';
    bgPopover.style.left = left + 'px';
    bgPopover.hidden = false;
  }

  function scheduleHideBgPopover() {
    bgHideTimer = window.setTimeout(function () {
      bgPopover.hidden = true;
      currentBgLink = null;
    }, 180);
  }

  function cancelHideBgPopover() {
    if (bgHideTimer) {
      window.clearTimeout(bgHideTimer);
      bgHideTimer = null;
    }
  }

  function cancelShowBgPopover() {
    if (bgShowTimer) {
      window.clearTimeout(bgShowTimer);
      bgShowTimer = null;
    }
  }

  bgPopover.addEventListener('mouseenter', cancelHideBgPopover);
  bgPopover.addEventListener('mouseleave', scheduleHideBgPopover);

  // ---- ポップアップ（プレビューウィンドウ） ----
  function computePreviewUrlFromLink(link) {
    if (!link) return null;
    var previewUrl = link.dataset.gdocPreviewUrl;
    if (previewUrl) return previewUrl;
    var baseUrl = link.dataset.gdocBaseUrl;
    if (!baseUrl) {
      return link.href;
    }
    return baseUrl.replace(/\/$/, '') + '/preview';
  }

  function applyGeometry(item) {
    if (!item || !item.position || !item.size) {
      // デフォルト: 中央
      modalDialog.style.top = '50%';
      modalDialog.style.left = '50%';
      modalDialog.style.transform = 'translate(-50%, -50%)';
      modalDialog.style.width = '';
      modalDialog.style.height = '';
      return;
    }
    var left = item.position.left;
    var top = item.position.top;
    var width = item.size.width;
    var height = item.size.height;

    var minWidth = 320;
    var minHeight = 220;
    var maxWidth = Math.min(window.innerWidth - 40, 1400);
    var maxHeight = window.innerHeight - 40;

    if (width < minWidth) width = minWidth;
    if (height < minHeight) height = minHeight;
    if (width > maxWidth) width = maxWidth;
    if (height > maxHeight) height = maxHeight;

    if (left + width > window.innerWidth - 10) {
      left = window.innerWidth - 10 - width;
    }
    if (top + height > window.innerHeight - 10) {
      top = window.innerHeight - 10 - height;
    }
    if (left < 0) left = 0;
    if (top < 0) top = 0;

    modalDialog.style.transform = 'none';
    modalDialog.style.left = left + 'px';
    modalDialog.style.top = top + 'px';
    modalDialog.style.width = width + 'px';
    modalDialog.style.height = height + 'px';
  }

  function applyZoom(z) {
    // ズーム機能を廃止し、常に等倍表示に固定する
    currentZoom = 1.0;
    modalIframe.style.transform = 'scale(1)';
  }

  function openPreviewFromLink(link) {
    var previewUrl = computePreviewUrlFromLink(link);
    if (!previewUrl) return;

    var item = ensureItemForLink(link, previewUrl);
    if (!item) return;
    activatePreviewItem(item, true);
  }

  function loadBgSnippetForItem(item, callback) {
    if (!item || item.kind !== 'bg') {
      if (callback) callback(null);
      return;
    }

    if (item.snippetHtml) {
      if (callback) callback(item.snippetHtml);
      return;
    }

    // 単一HTMLファイル（index_single.html）を検出
    var isSinglePage = window.location.pathname.indexOf('index_single.html') !== -1 || 
                       document.querySelector('section.chapter-page') !== null;
    
    console.log('loadBgSnippetForItem:', {
      pageUrl: item.pageUrl,
      anchorId: item.anchorId,
      isSinglePage: isSinglePage,
      pathname: window.location.pathname
    });
    
    // 単一HTMLファイルの場合は常にページセクションから抽出
    if (isSinglePage) {
      console.log('Single-page mode: extracting from page section');
      var snippet = extractSnippetFromSinglePage(item.pageUrl, item.anchorId);
      if (snippet) {
        item.snippetHtml = snippet;
        saveState();
        if (callback) callback(snippet);
        return;
      } else {
        console.warn('Failed to extract from single page, trying current page');
        // フォールバック: 現在のページから抽出
        snippet = extractSnippetFromCurrentPage(item.anchorId);
        item.snippetHtml = snippet;
        saveState();
        if (callback) callback(snippet);
        return;
      }
    }
    
    // 個別HTMLファイルの場合
    var currentPageUrl = window.location.href.split('#')[0];
    var isSamePage = !item.pageUrl || item.pageUrl === '' || item.pageUrl === currentPageUrl;

    if (isSamePage) {
      var snippet = extractSnippetFromCurrentPage(item.anchorId);
      item.snippetHtml = snippet;
      saveState();
      if (callback) callback(snippet);
    } else {
      // 相対パスを絶対URLに変換
      var absoluteUrl = item.pageUrl;
      try {
        absoluteUrl = new URL(item.pageUrl, window.location.href).href;
      } catch (e) {
        console.warn('Failed to resolve URL', item.pageUrl, e);
      }
      
      console.log('Loading BG preview from:', absoluteUrl);
      
      // file:// プロトコルの場合はXHRを使用（fetchはCORS制限がある）
      var isFileProtocol = window.location.protocol === 'file:' || absoluteUrl.indexOf('file:') === 0;
      
      if (isFileProtocol) {
        // XMLHttpRequestを使用（同期的に読み込む）
        try {
          var xhr = new XMLHttpRequest();
          xhr.open('GET', absoluteUrl, true);
          xhr.onload = function () {
            if (xhr.status === 200 || xhr.status === 0) {
              var html = xhr.responseText;
              var snippet = extractSnippetFromHtml(html, item.anchorId, item.pageUrl);
              item.snippetHtml = snippet;
              saveState();
              if (callback) callback(snippet);
            } else {
              console.warn('XHR failed with status:', xhr.status);
              if (callback) callback('<p>プレビューの読み込みに失敗しました。<br>Status: ' + xhr.status + '</p>');
            }
          };
          xhr.onerror = function () {
            console.warn('XHR error loading:', absoluteUrl);
            var errorMsg = '<p>プレビューの読み込みに失敗しました。</p>';
            errorMsg += '<p style="font-size:0.9em;color:#666;">file://プロトコルではブラウザのセキュリティ制限により、別ページの読み込みができません。</p>';
            errorMsg += '<p style="font-size:0.9em;color:#666;">以下のいずれかの方法をお試しください：</p>';
            errorMsg += '<ol style="font-size:0.9em;color:#666;margin-left:20px;">';
            errorMsg += '<li>HTTPサーバーを起動：<pre style="background:#f5f5f5;padding:10px;border-radius:4px;font-size:0.85em;margin:5px 0;">cd out<br>python3 -m http.server 8000<br>open http://localhost:8000/content/' + window.location.pathname.split('/').pop() + '</pre></li>';
            errorMsg += '<li>単一HTMLファイルを使用：<pre style="background:#f5f5f5;padding:10px;border-radius:4px;font-size:0.85em;margin:5px 0;">open out/index_single.html</pre></li>';
            errorMsg += '</ol>';
            if (callback) callback(errorMsg);
          };
          xhr.send();
        } catch (e) {
          console.warn('XHR exception:', e);
          if (callback) callback('<p>プレビューの読み込みに失敗しました。<br>Error: ' + e.message + '</p>');
        }
      } else {
        // HTTPプロトコルの場合はfetchを使用
        fetch(absoluteUrl)
          .then(function (response) {
            if (!response.ok) {
              throw new Error('HTTP ' + response.status + ': ' + response.statusText);
            }
            return response.text();
          })
          .then(function (html) {
            var snippet = extractSnippetFromHtml(html, item.anchorId, item.pageUrl);
            item.snippetHtml = snippet;
            saveState();
            if (callback) callback(snippet);
          })
          .catch(function (err) {
            console.warn('Failed to load BG preview content', err, 'URL:', absoluteUrl);
            if (callback) callback('<p>プレビューの読み込みに失敗しました。<br>URL: ' + item.pageUrl + '</p>');
          });
      }
    }
  }

  function extractSnippetFromSinglePage(pageUrl, anchorId) {
    // 単一HTMLファイルから該当ページのセクションを抽出
    console.log('extractSnippetFromSinglePage:', { pageUrl: pageUrl, anchorId: anchorId });
    
    // pageUrlが空の場合は現在のページから抽出
    if (!pageUrl || pageUrl === '') {
      console.log('No pageUrl, using current page');
      return extractSnippetFromCurrentPage(anchorId);
    }
    
    // pageUrl: "05_ch05.html" -> "05_ch05"
    var pageName = pageUrl.replace(/\.html.*$/, '').replace(/^.*\//, '');
    var pageId = 'page-' + pageName;
    
    console.log('Searching for single-page section:', pageId, 'pageName:', pageName);
    
    // ページセクションを探す
    var pageSection = document.getElementById(pageId);
    if (!pageSection) {
      // 別の形式も試す
      console.log('Trying alternative selectors...');
      var alternatives = [
        'section[id="' + pageId + '"]',
        'section[id*="' + pageName + '"]',
        'section.chapter-page[id*="' + pageName + '"]'
      ];
      
      for (var i = 0; i < alternatives.length; i++) {
        try {
          pageSection = document.querySelector(alternatives[i]);
          if (pageSection) {
            console.log('Found by alternative selector:', alternatives[i]);
            break;
          }
        } catch (e) {
          // 無効なセレクタの場合
        }
      }
    }
    
    if (!pageSection) {
      console.warn('Page section not found:', pageId);
      // 利用可能なページセクションを表示
      var sections = document.querySelectorAll('section.chapter-page');
      var sectionIds = [];
      for (var j = 0; j < Math.min(10, sections.length); j++) {
        sectionIds.push(sections[j].id);
      }
      console.log('Available page sections:', sectionIds);
      
      // フォールバック: 現在のページから抽出
      return extractSnippetFromCurrentPage(anchorId);
    }
    
    console.log('Found page section:', pageSection.id);
    
    // セクション全体を取得
    var clone = pageSection.cloneNode(true);
    removeUiElements(clone);
    
    // 脚注参照の数を確認
    var refsInClone = clone.querySelectorAll('a[role="doc-noteref"], a.footnote-ref');
    console.log('extractSnippetFromSinglePage: Found', refsInClone.length, 'footnote refs in clone');
    
    inlineFootnotes(clone, document);
    simplifyComments(clone);
    fixRelativeLinks(clone, '');
    
    return clone.innerHTML || '';
  }

  function extractSnippetFromCurrentPage(anchorId) {
    var target = anchorId ? document.getElementById(anchorId) : null;
    
    // セクション全体を取得（章レベル）
    var section = target ? target.closest('section') : document.getElementById('quarto-document-content');
    if (!section) section = document.getElementById('quarto-document-content');
    if (!section) return '<p>コンテンツが見つかりません。</p>';

    console.log('extractSnippetFromCurrentPage: Cloning section', section.id || section.className);
    
    var clone = section.cloneNode(true);
    removeUiElements(clone);
    
    // 脚注参照の数を確認
    var refsInClone = clone.querySelectorAll('a[role="doc-noteref"], a.footnote-ref');
    console.log('extractSnippetFromCurrentPage: Found', refsInClone.length, 'footnote refs in clone');
    
    inlineFootnotes(clone, document);
    simplifyComments(clone);
    fixRelativeLinks(clone, '');
    return clone.innerHTML || '';
  }

  function fixRelativeLinks(container, baseUrl) {
    // プレビュー内のリンクを絶対パスに変換
    var links = container.querySelectorAll('a[href]');
    for (var i = 0; i < links.length; i++) {
      var link = links[i];
      var href = link.getAttribute('href');
      if (href && !href.match(/^https?:/) && !href.match(/^#/)) {
        try {
          var absolute = new URL(href, window.location.href).href;
          link.setAttribute('href', absolute);
        } catch (e) {
          // ignore
        }
      }
    }
  }

  function extractSnippetFromHtml(html, anchorId, pageUrl) {
    try {
      var parser = new DOMParser();
      var doc = parser.parseFromString(html, 'text/html');
      var target = anchorId ? doc.getElementById(anchorId) : null;
      
      // セクション全体を取得（章レベル）
      var section = target ? target.closest('section') : doc.getElementById('quarto-document-content');
      if (!section) section = doc.getElementById('quarto-document-content');
      if (!section) return '<p>コンテンツが見つかりません。</p>';

      var clone = section.cloneNode(true);
      removeUiElements(clone);
      inlineFootnotes(clone, doc);
      simplifyComments(clone);
      fixRelativeLinks(clone, pageUrl);
      
      return clone.innerHTML || '';
    } catch (e) {
      console.warn('Failed to parse HTML', e);
      return '<p>コンテンツの解析に失敗しました。</p>';
    }
  }

  function removeUiElements(container) {
    var selectors = [
      'header', '.header-ui', '#quarto-sidebar', '#quarto-margin-sidebar',
      '.right-comments', '.left-panel', '.right-panel', 'nav', '.navbar'
    ];
    selectors.forEach(function (sel) {
      var elements = container.querySelectorAll(sel);
      for (var i = 0; i < elements.length; i++) {
        elements[i].parentNode.removeChild(elements[i]);
      }
    });
  }

  function inlineFootnotes(container, sourceDoc) {
    var refSelector = 'a[role="doc-noteref"], a.footnote-ref';
    var refs = container.querySelectorAll(refSelector);
    
    console.log('inlineFootnotes: Found', refs.length, 'footnote references');
    
    // 既に処理済みかチェック（インラインマーカーが存在する場合）
    var existingMarkers = container.querySelectorAll('.inline-footnote');
    if (existingMarkers.length > 0 && refs.length === 0) {
      console.log('inlineFootnotes: Already processed (found', existingMarkers.length, 'markers)');
      return;
    }
    
    if (!refs.length) {
      console.log('inlineFootnotes: No footnote references found');
      return;
    }

    var doc = sourceDoc || document;
    
    // 脚注参照を配列に変換して、段落ごとにグループ化
    var refsByHost = new Map();
    
    for (var i = 0; i < refs.length; i++) {
      var ref = refs[i];
      var href = ref.getAttribute('href') || ref.getAttribute('data-footnote-href');
      if (!href || !href.startsWith('#')) continue;
      
      var host = findHostParagraph(ref);
      if (!host) continue;
      
      if (!refsByHost.has(host)) {
        refsByHost.set(host, []);
      }
      refsByHost.get(host).push(ref);
    }
    
    console.log('Found', refsByHost.size, 'host paragraphs with footnotes');
    
    // 各段落の脚注を処理
    refsByHost.forEach(function (hostRefs, host) {
      console.log('Processing', hostRefs.length, 'footnotes for paragraph:', host.textContent.substring(0, 50));
      
      // 脚注コンテナを作成
      var footnotesWrapper = document.createElement('div');
      footnotesWrapper.className = 'footnotes-wrapper';
      footnotesWrapper.style.cssText = 'margin: 0.5em 0;';
      
      // 各脚注を処理
      for (var j = 0; j < hostRefs.length; j++) {
        var ref = hostRefs[j];
        var href = ref.getAttribute('href') || ref.getAttribute('data-footnote-href');
        if (!href || !href.startsWith('#')) continue;
        
        var id = href.slice(1);
        // まずcontainer内を探し、なければsourceDocから探す
        var target = container.querySelector('#' + id);
        if (!target && doc) {
          target = doc.getElementById ? doc.getElementById(id) : doc.querySelector('#' + id);
        }
        if (!target) {
          console.warn('Footnote target not found:', id);
          continue;
        }
        
        var numberText = (ref.textContent || '').replace(/[^0-9]/g, '') || '';
        
        var clone = target.cloneNode(true);
        var backlinks = clone.querySelectorAll('.footnote-back, .footnote-backref, [role="doc-backlink"]');
        for (var k = 0; k < backlinks.length; k++) {
          backlinks[k].parentNode.removeChild(backlinks[k]);
        }
        
        var fnContainer = document.createElement('div');
        fnContainer.className = 'footnote-inline';
        fnContainer.style.cssText = 'margin: 0.3em 0; padding: 0.5em 1em; background: #f8f9fa; border-left: 3px solid #1a73e8; font-size: 0.9em;';
        
        var numSpan = document.createElement('span');
        numSpan.className = 'footnote-num';
        numSpan.style.fontWeight = 'bold';
        numSpan.textContent = (numberText ? numberText : '') + '. ';
        fnContainer.appendChild(numSpan);
        
        while (clone.firstChild) {
          fnContainer.appendChild(clone.firstChild);
        }
        
        footnotesWrapper.appendChild(fnContainer);
        
        // 元の脚注参照をインラインマーカーに置き換え
        if (ref.parentNode) {
          var marker = document.createElement('span');
          marker.className = 'inline-footnote';
          marker.style.cssText = 'color: #1a73e8; font-size: 0.9em; margin-left: 2px; font-weight: 600;';
          marker.textContent = '[' + numberText + ']';
          ref.parentNode.replaceChild(marker, ref);
        }
      }
      
      // 段落の直後に脚注ラッパーを挿入
      if (host.nextSibling) {
        host.parentNode.insertBefore(footnotesWrapper, host.nextSibling);
      } else {
        host.parentNode.appendChild(footnotesWrapper);
      }
      
      console.log('Inserted footnotes wrapper after paragraph');
    });
    
    console.log('Finished processing footnotes');
  }

  function findHostParagraph(el) {
    var p = el;
    while (p && p !== document.body) {
      if (p.tagName === 'P' || p.tagName === 'LI') {
        return p;
      }
      p = p.parentElement;
    }
    return null;
  }

  function getElementKey(el) {
    if (!el) return '';
    if (el.id) return 'id:' + el.id;
    var parent = el.parentNode;
    if (!parent) return '';
    var siblings = parent.children;
    for (var i = 0; i < siblings.length; i++) {
      if (siblings[i] === el) {
        return 'idx:' + i;
      }
    }
    return '';
  }

  function scrollToAnchorInPreview(container, anchorId) {
    if (!container || !anchorId) {
      console.warn('scrollToAnchorInPreview: missing container or anchorId');
      return false;
    }
    
    console.log('Searching for anchor:', anchorId, 'in container');
    
    // 単一HTMLファイルの場合、プレフィックス付きIDも試す
    var isSinglePage = window.location.pathname.indexOf('index_single.html') !== -1 || 
                       document.querySelector('section.chapter-page') !== null;
    var anchorVariants = [anchorId];
    
    if (isSinglePage) {
      // ページ名のプレフィックスを試す（例: 05_ch05--toc-5-4-1）
      var pageNames = ['05_ch05', '04_ch04', '03_ch03', '02_ch02', '01_ch01', '06_ch06'];
      for (var p = 0; p < pageNames.length; p++) {
        anchorVariants.push(pageNames[p] + '--' + anchorId);
      }
    }
    
    // アンカー要素を探す（複数の方法を試す）
    var target = null;
    
    // 全てのバリアントを試す
    for (var v = 0; v < anchorVariants.length && !target; v++) {
      var currentAnchorId = anchorVariants[v];
      
      // 方法1: 直接ID検索（特殊文字をエスケープせずに試す）
      try {
        var selector = '#' + currentAnchorId.replace(/[!"#$%&'()*+,.\/:;<=>?@[\\\]^`{|}~]/g, '\\$&');
        target = container.querySelector(selector);
        if (target) {
          console.log('Found by escaped selector (variant ' + v + '):', currentAnchorId);
          anchorId = currentAnchorId; // 見つかったIDを使用
          break;
        }
      } catch (e) {
        // 次の方法を試す
      }
    }
    
    if (!target) {
      console.log('Method 1 failed for all variants');
    }
    
    // 方法2: CSS.escapeを使用（全バリアント）
    if (!target) {
      for (var v2 = 0; v2 < anchorVariants.length && !target; v2++) {
        try {
          if (typeof CSS !== 'undefined' && CSS.escape) {
            target = container.querySelector('#' + CSS.escape(anchorVariants[v2]));
            if (target) {
              console.log('Found by CSS.escape (variant ' + v2 + '):', anchorVariants[v2]);
              anchorId = anchorVariants[v2];
              break;
            }
          }
        } catch (e) {
          // 次を試す
        }
      }
    }
    
    // 方法3: data-anchor-id属性で検索（全バリアント）
    if (!target) {
      for (var v3 = 0; v3 < anchorVariants.length && !target; v3++) {
        try {
          target = container.querySelector('[data-anchor-id="' + anchorVariants[v3] + '"]');
          if (target) {
            console.log('Found by data-anchor-id (variant ' + v3 + '):', anchorVariants[v3]);
            anchorId = anchorVariants[v3];
            break;
          }
        } catch (e) {
          // 次を試す
        }
      }
    }
    
    // 方法4: id属性を直接検索（全要素をスキャン、全バリアント）
    if (!target) {
      var allElements = container.querySelectorAll('[id]');
      console.log('Scanning', allElements.length, 'elements with id');
      for (var i = 0; i < allElements.length; i++) {
        for (var v4 = 0; v4 < anchorVariants.length; v4++) {
          if (allElements[i].id === anchorVariants[v4]) {
            target = allElements[i];
            console.log('Found by direct scan at index', i, 'variant:', anchorVariants[v4]);
            anchorId = anchorVariants[v4];
            break;
          }
        }
        if (target) break;
      }
    }
    
    // 方法5: spanタグの中を探す（idx-アンカーの場合、全バリアント）
    if (!target) {
      var spans = container.querySelectorAll('span[id]');
      for (var j = 0; j < spans.length; j++) {
        for (var v5 = 0; v5 < anchorVariants.length; v5++) {
          if (anchorVariants[v5].indexOf('idx-') !== -1 && spans[j].id === anchorVariants[v5]) {
            target = spans[j];
            console.log('Found idx anchor in span, variant:', anchorVariants[v5]);
            anchorId = anchorVariants[v5];
            break;
          }
        }
        if (target) break;
      }
    }
    
    // 方法6: toc-X-Y-Z形式の場合、セクション番号から推測
    if (!target && anchorId.match(/^toc-\d+-\d+(-\d+)?$/)) {
      console.log('Trying to find section by number pattern:', anchorId);
      // toc-5-4-1 -> 第5章第4節第1項 のようなパターンを探す
      var parts = anchorId.replace('toc-', '').split('-');
      var sectionNum = parts[1]; // 4
      var itemNum = parts[2]; // 1
      
      // 第X節を探す
      var sectionPattern = '第' + sectionNum + '節';
      var sections = container.querySelectorAll('section[id*="' + sectionPattern + '"], h2[id*="' + sectionPattern + '"], h2[data-anchor-id*="' + sectionPattern + '"]');
      console.log('Found sections matching', sectionPattern, ':', sections.length);
      
      if (sections.length > 0) {
        // 第X節が見つかった場合、その中の第Y項を探す
        if (itemNum) {
          var itemPattern = '第' + itemNum + '項';
          var parentSection = sections[0].closest('section') || sections[0].parentElement;
          if (parentSection) {
            var items = parentSection.querySelectorAll('section[id*="' + itemPattern + '"], h3[id*="' + itemPattern + '"], h3[data-anchor-id*="' + itemPattern + '"]');
            console.log('Found items matching', itemPattern, ':', items.length);
            if (items.length > 0) {
              target = items[0];
              console.log('Found by section/item pattern');
            }
          }
        }
        
        // 項が見つからない場合は節を使用
        if (!target) {
          target = sections[0];
          console.log('Using section as fallback');
        }
      }
    }
    
    if (!target) {
      console.warn('Anchor not found in preview after all attempts:', anchorId);
      // デバッグ: 最初の20個のIDを表示
      var ids = [];
      var els = container.querySelectorAll('[id]');
      for (var k = 0; k < Math.min(20, els.length); k++) {
        ids.push(els[k].id);
      }
      console.log('Available IDs (first 20):', ids);
      return false;
    }
    
    console.log('Found anchor:', anchorId, 'Element:', target.tagName, 'ID:', target.id, 'Class:', target.className);
    
    // 索引アンカー（idx-）の場合は、その段落を探す
    if (anchorId.indexOf('idx-') === 0) {
      var paragraph = findHostParagraph(target);
      if (paragraph) {
        console.log('Using host paragraph for idx anchor:', paragraph.tagName);
        target = paragraph;
      }
    }
    
    // 目次アンカー（toc-）の場合は、対応する見出しを探す
    if (anchorId.indexOf('toc-') === 0) {
      // 見出し要素を探す
      if (target.tagName && target.tagName.match(/^H[1-6]$/)) {
        console.log('Target is already a heading');
      } else {
        var heading = target.closest('h1, h2, h3, h4, h5, h6');
        if (heading) {
          console.log('Using heading for toc anchor:', heading.tagName);
          target = heading;
        } else {
          // data-anchor-idを持つ見出しを探す
          var h = container.querySelector('h1[data-anchor-id="' + anchorId + '"], h2[data-anchor-id="' + anchorId + '"], h3[data-anchor-id="' + anchorId + '"], h4[data-anchor-id="' + anchorId + '"]');
          if (h) {
            console.log('Found heading by data-anchor-id:', h.tagName);
            target = h;
          }
        }
      }
    }
    
    // 要素の位置を計算してスクロール
    var targetTop = 0;
    var el = target;
    var iterations = 0;
    while (el && el !== container && iterations < 50) {
      targetTop += el.offsetTop || 0;
      el = el.offsetParent;
      iterations++;
    }
    
    console.log('Scrolling to position:', targetTop, 'Container scrollHeight:', container.scrollHeight);
    
    // スクロール実行
    if (container.scrollTo) {
      container.scrollTo({
        top: targetTop,
        behavior: 'smooth'
      });
    } else {
      container.scrollTop = targetTop;
    }
    
    // ハイライト効果を追加
    try {
      var originalBg = target.style.backgroundColor;
      var originalTransition = target.style.transition;
      target.style.transition = 'background-color 0.3s ease';
      target.style.backgroundColor = 'rgba(26, 115, 232, 0.15)';
      
      setTimeout(function () {
        target.style.backgroundColor = originalBg;
        setTimeout(function () {
          target.style.transition = originalTransition;
        }, 300);
      }, 1500);
    } catch (e) {
      console.warn('Failed to apply highlight:', e);
    }
    
    return true;
  }

  function simplifyComments(container) {
    var markers = container.querySelectorAll('.text-marker[data-comment-id]');
    for (var i = 0; i < markers.length; i++) {
      markers[i].removeAttribute('data-comment-id');
    }
  }

  function activatePreviewItem(item, fromUser) {
    if (!item) return;

    setActiveItem(item);

    modalTitle.textContent = item.title || '';

    if (item.kind === 'bg') {
      modalIframe.style.display = 'none';
      bgPreviewBody.classList.add('active');
      bgPreviewBody.innerHTML = '<p>読み込み中...</p>';
      
      loadBgSnippetForItem(item, function (html) {
        if (!html) html = '<p>コンテンツが見つかりません。</p>';
        bgPreviewBody.innerHTML = html;
        
        console.log('BG preview loaded, anchorId:', item.anchorId);
        
        // DOMが完全に描画されるまで待つ（複数回試行）
        var scrollAttempts = 0;
        var maxAttempts = 5;
        
        function tryScroll() {
          scrollAttempts++;
          
          if (item.anchorId) {
            var success = scrollToAnchorInPreview(bgPreviewBody, item.anchorId);
            if (!success && scrollAttempts < maxAttempts) {
              // スクロールに失敗した場合は再試行
              setTimeout(tryScroll, 100);
            }
          } else {
            // アンカーがない場合は先頭にスクロール
            bgPreviewBody.scrollTop = 0;
          }
        }
        
        // 初回は少し待ってから実行
        setTimeout(tryScroll, 100);
      });
    } else {
      bgPreviewBody.classList.remove('active');
      bgPreviewBody.innerHTML = '';
      modalIframe.style.display = '';
      modalIframe.src = item.previewUrl || item.href;
    }

    if (isMobile) {
      modalDialog.style.transform = 'translate(-50%, -50%)';
      modalDialog.style.top = '50%';
      modalDialog.style.left = '50%';
      modalDialog.style.width = '96vw';
      modalDialog.style.height = '90vh';
      applyZoom(1.0);
    } else {
      if (!item.position || !item.size) {
        // 初回: デフォルト位置・サイズ
        modalDialog.style.top = '50%';
        modalDialog.style.left = '50%';
        modalDialog.style.transform = 'translate(-50%, -50%)';
        modalDialog.style.width = '';
        modalDialog.style.height = '';
      } else {
        applyGeometry(item);
      }
      applyZoom(item.zoom || 1.0);
      rebuildToasts();
    }

    modal.hidden = false;
    saveState();
    
    // トーストを再構築（minimizedから復帰した場合に必要）
    if (!isMobile) {
      rebuildToasts();
    }
  }

  function closeCurrentPreview() {
    var active = getActiveItem();
    if (!active) {
      modal.hidden = true;
      modalIframe.src = 'about:blank';
      return;
    }
    var key = active.key;
    modal.hidden = true;
    modalIframe.src = 'about:blank';
    closeItemByKey(key);
  }

  // モーダルのヘッダーボタン
  modalBtnClose.addEventListener('click', function () {
    closeCurrentPreview();
  });

  modalBtnOpen.addEventListener('click', function () {
    var active = getActiveItem();
    if (!active) return;
    window.open(active.href, '_blank', 'noopener');
  });

  modalBtnReload.addEventListener('click', function () {
    var active = getActiveItem();
    if (!active) return;
    reloadPreviewItem(active);
  });

  modalBtnCopy.addEventListener('click', function () {
    var active = getActiveItem();
    if (!active) return;
    var url = active.href;
    if (navigator.clipboard && navigator.clipboard.writeText) {
      navigator.clipboard.writeText(url).catch(function () {});
      return;
    }
    var tmp = document.createElement('textarea');
    tmp.style.position = 'fixed';
    tmp.style.opacity = '0';
    tmp.value = url;
    document.body.appendChild(tmp);
    tmp.select();
    try { document.execCommand('copy'); } catch (e) {}
    document.body.removeChild(tmp);
  });

  function reloadPreviewItem(item) {
    if (!item) return;
    
    console.log('Reloading preview item:', item.key);
    
    // キャッシュをクリア
    if (item.kind === 'bg') {
      item.snippetHtml = null;
    }
    
    // 現在のスクロール位置を保存
    var currentScrollTop = 0;
    if (item.kind === 'bg' && bgPreviewBody) {
      currentScrollTop = bgPreviewBody.scrollTop;
    }
    
    // 再読み込み
    if (item.kind === 'bg') {
      bgPreviewBody.innerHTML = '<p>読み込み中...</p>';
      loadBgSnippetForItem(item, function (html) {
        if (!html) html = '<p>コンテンツが見つかりません。</p>';
        bgPreviewBody.innerHTML = html;
        
        // 元のアンカー位置にスクロール（優先）
        if (item.anchorId) {
          setTimeout(function () {
            scrollToAnchorInPreview(bgPreviewBody, item.anchorId);
          }, 100);
        } else {
          // アンカーがない場合は元のスクロール位置に戻す
          setTimeout(function () {
            bgPreviewBody.scrollTop = currentScrollTop;
          }, 100);
        }
      });
    } else if (item.kind === 'gdoc') {
      // Google Docsプレビューの場合はiframeを再読み込み
      if (modalIframe) {
        var currentSrc = modalIframe.src;
        modalIframe.src = 'about:blank';
        setTimeout(function () {
          modalIframe.src = currentSrc;
        }, 100);
      }
    }
    
    // 状態を保存
    saveState();
  }

  function getScrollElement() {
    return document.scrollingElement || document.documentElement || document.body;
  }

  function applyJumpHighlight(target) {
    if (!target) return;
    var el = target;
    if (!(el instanceof HTMLElement)) {
      el = target.parentElement || null;
    }
    while (el && el !== document.body && !(el instanceof HTMLElement)) {
      el = el.parentElement;
    }
    if (!el) return;
    try {
      el.scrollIntoView({ block: 'center', behavior: 'smooth' });
      var prevBox = el.style.boxShadow;
      el.style.transition = 'box-shadow 0.3s ease';
      el.style.boxShadow = '0 0 0 3px rgba(26,115,232,0.5)';
      setTimeout(function () {
        el.style.boxShadow = prevBox || '';
      }, 1600);
    } catch (e) {
      try {
        target.scrollIntoView({ block: 'center', behavior: 'smooth' });
      } catch (e2) {}
    }
  }

  function findSourceElementForItem(item) {
    if (!item) return null;

    // まず data-gdoc-key で厳密に一致するリンクを探す（タブ/重複対応）
    if (item.key) {
      try {
        var keySelector = 'a.gdoc-link[data-gdoc-key="' + String(item.key).replace(/"/g, '\"') + '"]';
        var byKey = document.querySelector(keySelector);
        if (byKey) return byKey;
      } catch (e) {
        // fall through to id/href
      }
    }

    var selector = '';
    if (item.id) {
      // Google Docs ID は英数字等なので単純なエスケープで十分
      selector = 'a.gdoc-link[data-gdoc-id="' + String(item.id).replace(/"/g, '\"') + '"]';
    } else if (item.href) {
      selector = 'a.gdoc-link[href="' + String(item.href).replace(/"/g, '\"') + '"]';
    }
    if (!selector) return null;
    try {
      var candidates = document.querySelectorAll(selector);
      if (!candidates || !candidates.length) return null;
      return candidates[0];
    } catch (e) {
      return null;
    }
  }

  function jumpToSourceForItem(item) {
    if (!item) return;

    var currentBase = window.location.href.split('#')[0];
    var sourceUrl = item.sourceUrl || null;
    var sourceId = item.sourceId || null;

    // 別ページに元リンクがある場合は、そのページへ遷移
    if (sourceUrl && sourceUrl !== currentBase) {
      var targetUrl = sourceUrl;
      if (sourceId) {
        // 既にハッシュが含まれていない前提
        targetUrl = sourceUrl + '#' + encodeURIComponent(sourceId);
      }
      try {
        window.location.href = targetUrl;
      } catch (e) {
        window.location.assign(targetUrl);
      }
      return;
    }

    // 同一ページ内: ソースID優先でスクロール
    var target = null;
    if (sourceId) {
      target = document.getElementById(sourceId) || null;
    }
    if (!target) {
      var linkEl = findSourceElementForItem(item);
      if (!linkEl) return;
      target = linkEl.closest('[id]') || linkEl;
    }

    var scrollEl = getScrollElement();
    var currentY = scrollEl.scrollTop;
    try {
      history.pushState({ __gdocScrollRestore: currentY }, '', window.location.href);
    } catch (e2) {}
    applyJumpHighlight(target);
  }

  modalBtnJump.addEventListener('click', function () {
    var active = getActiveItem();
    if (!active) return;
    jumpToSourceForItem(active);
  });

  // ヘッダー: ドラッグ & クリックで格納
  modalHeader.addEventListener('mousedown', function (e) {
    if (e.button !== 0) return;
    if (isMobile) return; // モバイルではドラッグ/格納なし

    isMouseDownOnHeader = true;
    headerMouseDownX = e.clientX;
    headerMouseDownY = e.clientY;

    isDragging = true;
    dragStartX = e.clientX;
    dragStartY = e.clientY;
    var rect = modalDialog.getBoundingClientRect();
    dialogStartLeft = rect.left;
    dialogStartTop = rect.top;
    modalDialog.style.transform = 'none';
    document.addEventListener('mousemove', onDragMove);
    document.addEventListener('mouseup', onHeaderMouseUp);
  });

  function onDragMove(e) {
    if (!isDragging || isMobile) return;
    var dx = e.clientX - dragStartX;
    var dy = e.clientY - dragStartY;
    var newLeft = dialogStartLeft + dx;
    var newTop = dialogStartTop + dy;

    var maxLeft = window.innerWidth - 100;
    var maxTop = window.innerHeight - 60;
    if (newLeft < 0) newLeft = 0;
    if (newTop < 0) newTop = 0;
    if (newLeft > maxLeft) newLeft = maxLeft;
    if (newTop > maxTop) newTop = maxTop;

    modalDialog.style.left = newLeft + 'px';
    modalDialog.style.top = newTop + 'px';
  }

  function onHeaderMouseUp(e) {
    document.removeEventListener('mousemove', onDragMove);
    document.removeEventListener('mouseup', onHeaderMouseUp);

    if (!isDragging) {
      isMouseDownOnHeader = false;
      return;
    }

    isDragging = false;

    var active = getActiveItem();
    if (active && !isMobile) {
      var rect = modalDialog.getBoundingClientRect();
      active.position = { left: rect.left, top: rect.top };
      if (active.size) {
        active.size.width = rect.width;
        active.size.height = rect.height;
      }
      saveState();
      updateLastGeometryFromActive();
    }

    // クリック判定（ドラッグ距離が小さい場合）
    if (isMouseDownOnHeader) {
      var dx = Math.abs(e.clientX - headerMouseDownX);
      var dy = Math.abs(e.clientY - headerMouseDownY);
      if (dx < 3 && dy < 3) {
        // ヘッダーの「ボタンやリサイズハンドル以外」をクリックした場合に格納
        var target = e.target;
        if (!target.closest('.gdoc-modal-btn') && !target.closest('.gdoc-resize-handle')) {
          minimizeActiveToToast();
        }
      }
    }
    isMouseDownOnHeader = false;
  }

  function minimizeActiveToToast() {
    if (isMobile) return;
    var active = getActiveItem();
    if (!active) return;
    active.state = 'minimized';
    active.lastUpdated = Date.now();
    currentKey = null;
    saveState();
    modal.hidden = true;
    modalIframe.src = 'about:blank';
    rebuildToasts();
  }

  // 4隅のリサイズ
  if (resizeHandles && resizeHandles.length) {
    resizeHandles.forEach(function (handle) {
      handle.addEventListener('mousedown', function (e) {
        if (e.button !== 0) return;
        if (isMobile) return;
        e.preventDefault();
        isResizing = true;
        resizeDir = handle.getAttribute('data-resize-dir') || '';
        var rect = modalDialog.getBoundingClientRect();
        resizeStartX = e.clientX;
        resizeStartY = e.clientY;
        startWidth = rect.width;
        startHeight = rect.height;
        startLeft = rect.left;
        startTop = rect.top;
        modalDialog.style.transform = 'none';
        document.addEventListener('mousemove', onResizeMove);
        document.addEventListener('mouseup', onResizeEnd);
      });
    });
  }

  function onResizeMove(e) {
    if (!isResizing || isMobile) return;

    var dx = e.clientX - resizeStartX;
    var dy = e.clientY - resizeStartY;

    var newWidth = startWidth;
    var newHeight = startHeight;
    var newLeft = startLeft;
    var newTop = startTop;

    if (resizeDir.indexOf('e') !== -1) {
      newWidth = startWidth + dx;
    }
    if (resizeDir.indexOf('s') !== -1) {
      newHeight = startHeight + dy;
    }
    if (resizeDir.indexOf('w') !== -1) {
      newWidth = startWidth - dx;
      newLeft = startLeft + dx;
    }
    if (resizeDir.indexOf('n') !== -1) {
      newHeight = startHeight - dy;
      newTop = startTop + dy;
    }

    var minWidth = 320;
    var minHeight = 220;
    var maxWidth = Math.min(window.innerWidth - 40, 1400);
    var maxHeight = window.innerHeight - 40;

    if (newWidth < minWidth) {
      newWidth = minWidth;
      if (resizeDir.indexOf('w') !== -1) {
        newLeft = startLeft + (startWidth - minWidth);
      }
    }
    if (newHeight < minHeight) {
      newHeight = minHeight;
      if (resizeDir.indexOf('n') !== -1) {
        newTop = startTop + (startHeight - minHeight);
      }
    }

    if (newWidth > maxWidth) {
      newWidth = maxWidth;
    }
    if (newHeight > maxHeight) {
      newHeight = maxHeight;
    }

    var maxRight = window.innerWidth - 10;
    var maxBottom = window.innerHeight - 10;
    if (newLeft + newWidth > maxRight) {
      if (resizeDir.indexOf('e') !== -1) {
        newWidth = maxRight - newLeft;
      } else {
        newLeft = maxRight - newWidth;
      }
    }
    if (newTop + newHeight > maxBottom) {
      if (resizeDir.indexOf('s') !== -1) {
        newHeight = maxBottom - newTop;
      } else {
        newTop = maxBottom - newHeight;
      }
    }

    modalDialog.style.width = newWidth + 'px';
    modalDialog.style.height = newHeight + 'px';
    modalDialog.style.left = newLeft + 'px';
    modalDialog.style.top = newTop + 'px';
  }

  function onResizeEnd() {
    if (!isResizing) return;
    document.removeEventListener('mousemove', onResizeMove);
    document.removeEventListener('mouseup', onResizeEnd);
    isResizing = false;

    var active = getActiveItem();
    if (active && !isMobile) {
      var rect = modalDialog.getBoundingClientRect();
      active.position = { left: rect.left, top: rect.top };
      active.size = { width: rect.width, height: rect.height };
      active.zoom = currentZoom;
      saveState();
      updateLastGeometryFromActive();
    }
  }

  // ズーム（ポップアップ内だけ）
  // Ctrl/Command + スクロールによる拡大・縮小は無効化し、
  // 通常スクロールのみを許可する
  modalDialog.addEventListener('wheel', function (e) {
    if (isMobile) return;
    var isZoomGesture = e.ctrlKey || e.metaKey || e.deltaZ !== 0;
    if (!isZoomGesture) return;

    // ブラウザのページズームが発動しないように止める
    e.preventDefault();
  }, { passive: false });

  // ---- トースト（格納状態） ----
  function getMaxIndividualToasts() {
    try {
      var raw = window.localStorage.getItem('gdocPreviewMaxToasts');
      if (raw == null) return 3;
      var n = parseInt(raw, 10);
      if (isNaN(n)) n = 3;
      if (n < 0) n = 0;
      if (n > 9) n = 9;
      return n;
    } catch (e) {
      return 3;
    }
  }

  function rebuildToasts() {
    if (!toastInner || isMobile) return;
    toastInner.innerHTML = '';

    var minimized = [];
    for (var i = 0; i < state.items.length; i++) {
      if (state.items[i].state === 'minimized') minimized.push(state.items[i]);
    }

    if (!minimized.length) return;

    // 更新日時の新しいものが上に来るように並べ替え
    minimized.sort(function (a, b) {
      return (b.lastUpdated || 0) - (a.lastUpdated || 0);
    });

    var maxIndividual = getMaxIndividualToasts();
    var individualCount = Math.min(minimized.length, maxIndividual);

    for (var j = 0; j < individualCount; j++) {
      var item = minimized[j];
      var toast = document.createElement('div');
      toast.className = 'gdoc-toast';
      toast.setAttribute('data-preview-key', item.key);

      var main = document.createElement('div');
      main.className = 'gdoc-toast-main';

      var titleNode = document.createElement('div');
      titleNode.className = 'gdoc-toast-title';
      var prefix = item.kind === 'bg' ? '[BG] ' : '[Docs] ';
      titleNode.textContent = prefix + (item.title || item.href || '');
      main.appendChild(titleNode);

      toast.appendChild(main);

      var actions = document.createElement('div');
      actions.className = 'gdoc-toast-actions';

      var btnCopy = document.createElement('button');
      btnCopy.type = 'button';
      btnCopy.className = 'gdoc-toast-btn';
      btnCopy.setAttribute('data-action', 'copy');
      btnCopy.title = 'リンクをコピー';
      btnCopy.innerHTML = '<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></svg>';
      actions.appendChild(btnCopy);

      var btnOpen = document.createElement('button');
      btnOpen.type = 'button';
      btnOpen.className = 'gdoc-toast-btn';
      btnOpen.setAttribute('data-action', 'open');
      btnOpen.title = '別タブで開く';
      btnOpen.innerHTML = '<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M14 3h7v7h-2V6.41l-9.29 9.3-1.42-1.42 9.3-9.29H14V3z"></path><path d="M5 5h5V3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2v-5h-2v5H5V5z"></path></svg>';
      actions.appendChild(btnOpen);

      var btnJump = document.createElement('button');
      btnJump.type = 'button';
      btnJump.className = 'gdoc-toast-btn';
      btnJump.setAttribute('data-action', 'jump');
      btnJump.title = '本文へ移動';
      btnJump.innerHTML = '<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M12 2c-.55 0-1 .45-1 1v12.59l-4.3-4.3a1 1 0 10-1.4 1.42l6 6a1 1 0 001.4 0l6-6a1 1 0 10-1.4-1.42L13 15.59V3c0-.55-.45-1-1-1z"></path></svg>';
      actions.appendChild(btnJump);

      var btnClose = document.createElement('button');
      btnClose.type = 'button';
      btnClose.className = 'gdoc-toast-btn';
      btnClose.setAttribute('data-action', 'close');
      btnClose.title = '閉じる';
      btnClose.innerHTML = '<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M5.293 6.707l5.293 5.293-5.293 5.293c-.39.39-.39 1.024 0 1.414s1.024.39 1.414 0l5.293-5.293 5.293 5.293c.39.39 1.024.39 1.414 0s.39-1.024 0-1.414L13.414 12l5.293-5.293c.39-.39.39-1.024 0-1.414s-1.024-.39-1.414 0L12 10.586 6.707 5.293c-.39-.39-1.024-.39-1.414 0s-.39 1.024 0 1.414z"></path></svg>';
      actions.appendChild(btnClose);

      toast.appendChild(actions);
      toastInner.appendChild(toast);
    }

    if (minimized.length > maxIndividual) {
      var othersCount = minimized.length - maxIndividual;
      var othersToast = document.createElement('div');
      othersToast.className = 'gdoc-toast';
      othersToast.setAttribute('data-preview-key', 'others');
      othersToast.setAttribute('data-other-toast', '1');

      var main2 = document.createElement('div');
      main2.className = 'gdoc-toast-main';
      var title2 = document.createElement('div');
      title2.className = 'gdoc-toast-title';
      title2.textContent = 'プレビューの他文書 (' + othersCount + ' 件)';
      main2.appendChild(title2);
      othersToast.appendChild(main2);

      toastInner.appendChild(othersToast);
    }
  }

  toastInner.addEventListener('click', function (e) {
    var toast = e.target.closest('.gdoc-toast');
    if (!toast) return;
    var key = toast.getAttribute('data-preview-key');
    var isOthers = toast.hasAttribute('data-other-toast');

    if (isOthers) {
      if (!isMobile) {
        openListModal();
      }
      return;
    }

    var actionEl = e.target.closest('[data-action]');
    var action = actionEl ? actionEl.getAttribute('data-action') : null;
    var item = findItemByKey(key);
    if (!item) return;

    if (!action) {
      // トースト本体クリック → 復帰
      activatePreviewItem(item, true);
      return;
    }

    if (action === 'copy') {
      var url = item.href;
      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(url).catch(function () {});
      } else {
        var tmp = document.createElement('textarea');
        tmp.style.position = 'fixed';
        tmp.style.opacity = '0';
        tmp.value = url;
        document.body.appendChild(tmp);
        tmp.select();
        try { document.execCommand('copy'); } catch (err) {}
        document.body.removeChild(tmp);
      }
    } else if (action === 'open') {
      window.open(item.href, '_blank', 'noopener');
    } else if (action === 'close') {
      closeItemByKey(item.key);
    } else if (action === 'jump') {
      jumpToSourceForItem(item);
    }
  });

  // ---- 他文書一覧モーダル ----
  function renderListModal() {
    listEl.innerHTML = '';
    if (!state.items.length) return;

    for (var i = 0; i < state.items.length; i++) {
      var item = state.items[i];
      var li = document.createElement('li');
      li.className = 'gdoc-list-item';
      li.setAttribute('data-preview-key', item.key);

      var titleDiv = document.createElement('div');
      titleDiv.className = 'gdoc-list-item-title';
      titleDiv.textContent = item.title || item.href || '';
      li.appendChild(titleDiv);

      var actionsDiv = document.createElement('div');
      actionsDiv.className = 'gdoc-list-item-actions';

      var btnActivate = document.createElement('button');
      btnActivate.type = 'button';
      btnActivate.className = 'gdoc-list-item-btn';
      btnActivate.setAttribute('data-action', 'activate');
      btnActivate.textContent = '表示';
      actionsDiv.appendChild(btnActivate);

      var btnJumpBody = document.createElement('button');
      btnJumpBody.type = 'button';
      btnJumpBody.className = 'gdoc-list-item-btn';
      btnJumpBody.setAttribute('data-action', 'jump');
      btnJumpBody.textContent = '本文';
      actionsDiv.appendChild(btnJumpBody);

      var btnOpenTab = document.createElement('button');
      btnOpenTab.type = 'button';
      btnOpenTab.className = 'gdoc-list-item-btn';
      btnOpenTab.setAttribute('data-action', 'openTab');
      btnOpenTab.textContent = '他タブ';
      actionsDiv.appendChild(btnOpenTab);

      var btnClose = document.createElement('button');
      btnClose.type = 'button';
      btnClose.className = 'gdoc-list-item-btn';
      btnClose.setAttribute('data-action', 'close');
      btnClose.textContent = '閉じる';
      actionsDiv.appendChild(btnClose);

      var btnUp = document.createElement('button');
      btnUp.type = 'button';
      btnUp.className = 'gdoc-list-item-btn';
      btnUp.setAttribute('data-action', 'up');
      btnUp.textContent = '↑';
      actionsDiv.appendChild(btnUp);

      var btnDown = document.createElement('button');
      btnDown.type = 'button';
      btnDown.className = 'gdoc-list-item-btn';
      btnDown.setAttribute('data-action', 'down');
      btnDown.textContent = '↓';
      actionsDiv.appendChild(btnDown);

      li.appendChild(actionsDiv);
      listEl.appendChild(li);
    }
  }

  function openListModal() {
    if (isMobile) return;
    renderListModal();
    listModal.hidden = false;
  }

  function closeListModal() {
    listModal.hidden = true;
  }

  listModalClose.addEventListener('click', function () {
    closeListModal();
  });

  listModal.addEventListener('click', function (e) {
    if (e.target === listModal) {
      closeListModal();
    }
  });

  listEl.addEventListener('click', function (e) {
    var li = e.target.closest('.gdoc-list-item');
    if (!li) return;
    var key = li.getAttribute('data-preview-key');
    var item = findItemByKey(key);
    if (!item) return;

    var btn = e.target.closest('[data-action]');
    if (!btn) return;
    var action = btn.getAttribute('data-action');

    if (action === 'openTab') {
      window.open(item.href, '_blank', 'noopener');
    } else if (action === 'close') {
      closeItemByKey(item.key);
      renderListModal();
    } else if (action === 'activate') {
      activatePreviewItem(item, true);
      closeListModal();
    } else if (action === 'jump') {
      jumpToSourceForItem(item);
      closeListModal();
    } else if (action === 'up' || action === 'down') {
      var items = state.items;
      var idx = -1;
      for (var i = 0; i < items.length; i++) {
        if (items[i].key === item.key) { idx = i; break; }
      }
      if (idx === -1) return;
      var newIdx = action === 'up' ? idx - 1 : idx + 1;
      if (newIdx < 0 || newIdx >= items.length) return;
      var tmp = items[idx];
      items[idx] = items[newIdx];
      items[newIdx] = tmp;
      saveState();
      renderListModal();
      rebuildToasts();
    }
  });

  // ---- キーボード ----
  document.addEventListener('keydown', function (e) {
    if (e.key === 'Escape') {
      if (!popover.hidden) {
        popover.hidden = true;
        currentLink = null;
      } else if (!listModal.hidden) {
        closeListModal();
      } else if (!modal.hidden) {
        // ESC ではプレビューを閉じず、トーストへ格納する
        minimizeActiveToToast();
      }
    }
  });

  // ページ内リンクのクリックに対して、戻るボタンで元の位置に戻れるように履歴を積む
  document.addEventListener('click', function (e) {
    var a = e.target.closest && e.target.closest('a[href^="#"]');
    if (!a) return;
    var href = a.getAttribute('href');
    if (!href || href === '#') return;

    var url;
    try {
      url = new URL(a.href, window.location.href);
    } catch (err) {
      return;
    }
    if (url.pathname !== window.location.pathname || url.origin !== window.location.origin) {
      return;
    }

    var id = decodeURIComponent(url.hash.slice(1));
    if (!id) return;
    var target = document.getElementById(id);
    if (!target) return;

    e.preventDefault();

    var scrollEl = getScrollElement();
    var currentY = scrollEl.scrollTop;
    try {
      history.pushState({ __gdocScrollRestore: currentY }, url.hash, url.href);
    } catch (err2) {}

    applyJumpHighlight(target);
  });

  window.addEventListener('popstate', function (e) {
    if (e.state && typeof e.state.__gdocScrollRestore === 'number') {
      var scrollEl = getScrollElement();
      scrollEl.scrollTop = e.state.__gdocScrollRestore;
    }
  });

  // BGプレビュー対象リンクの検出とマーク
  function markBgPreviewLinks() {
    try {
      // 全てのリンクを対象に検索
      var allLinks = document.querySelectorAll('a[href]');
      var markedCount = 0;
      
    for (var i = 0; i < allLinks.length; i++) {
      var link = allLinks[i];
      var href = link.getAttribute('href');
      if (!href) continue;
      if (link.classList && (link.classList.contains('footnote-ref') || link.getAttribute('role') === 'doc-noteref')) {
        continue;
      }
        
        // 既にマークされている場合はスキップ
        if (link.classList.contains('bg-preview-link')) continue;
        
        // 1. 索引リンク（idx- を含む）
        if (href.indexOf('#idx-') !== -1) {
          link.classList.add('bg-preview-link');
          link.setAttribute('data-bg-type', 'index');
          markedCount++;
          continue;
        }
        
        // 2. 目次リンク（toc- を含む）
        if (href.indexOf('#toc-') !== -1 || href.indexOf('toc-') !== -1) {
          link.classList.add('bg-preview-link');
          link.setAttribute('data-bg-type', 'toc');
          markedCount++;
          continue;
        }
        
        // 3. 章ファイルへのリンク（NN_chNN.html 形式）
        if (href.match(/\d+_ch\d+\.html/)) {
          link.classList.add('bg-preview-link');
          link.setAttribute('data-bg-type', 'chapter');
          markedCount++;
          continue;
        }
        
        // 4. 同一ページ内のアンカーリンク（#で始まる）
        if (href.indexOf('#') === 0 && href.length > 1) {
          // ヘッダーナビゲーションは除外
          if (link.closest('header') || link.closest('.header-ui')) continue;
          
          link.classList.add('bg-preview-link');
          link.setAttribute('data-bg-type', 'anchor');
          markedCount++;
          continue;
        }
      }
      
      console.log('BGプレビューリンクをマーク:', markedCount + '個');
    } catch (e) {
      console.warn('markBgPreviewLinks failed', e);
    }
  }

  // BGプレビューリンクのイベントハンドラ
  document.addEventListener('mouseover', function (e) {
    var link = e.target.closest && e.target.closest('a.bg-preview-link');
    if (!link) return;
    
    // プレビュー内のリンクの場合、既存のプレビューを最小化
    if (link.closest('.bg-preview-body')) {
      var activeItem = getActiveItem();
      if (activeItem && activeItem.state === 'active') {
        activeItem.state = 'minimized';
        saveState();
        if (!isMobile) {
          rebuildToasts();
        }
      }
    }
    
    cancelHideBgPopover();
    cancelShowBgPopover();
    bgShowTimer = window.setTimeout(function () {
      showBgPopoverForLink(link);
    }, POPOVER_SHOW_DELAY);
  });

  document.addEventListener('mouseout', function (e) {
    var fromLink = e.target.closest && e.target.closest('a.bg-preview-link');
    if (!fromLink) return;
    var to = e.relatedTarget;
    if (to && (to.closest && (to.closest('a.bg-preview-link') || to.closest('#bg-preview-popover')))) {
      return;
    }
    cancelShowBgPopover();
    scheduleHideBgPopover();
  });

  document.addEventListener('click', function (e) {
    var link = e.target.closest && e.target.closest('a.bg-preview-link');
    if (!link) return;
    
    // ポップオーバー内のボタンクリックの場合は何もしない
    if (e.target.closest('#bg-preview-popover')) {
      return;
    }
    
    // モバイルまたはタッチデバイスの場合
    if (isMobile || ('ontouchstart' in window)) {
      e.preventDefault();
      cancelHideBgPopover();
      if (bgPopover.hidden) {
        showBgPopoverForLink(link);
      } else if (currentBgLink === link) {
        // 2回目のタップで遷移
        window.location.href = link.href;
      } else {
        showBgPopoverForLink(link);
      }
    }
    // PCの場合は通常のクリックで遷移（ポップオーバーは補助的）
    // デフォルトの動作を許可（リンク遷移）
  });

  // 初期化: モード判定と既存状態の復元
  updateMode();
  markBgPreviewLinks();
  
  (function restoreFromState() {
    if (!state || !state.items.length) return;
    if (isMobile) return; // モバイルでは復元しない

    rebuildToasts();
    var active = getActiveItem();
    if (active) {
      activatePreviewItem(active, false);
    }
  })();

  // 外部統合用の簡易API
  window.__gdocPreviewAPI__ = {
    getState: function () {
      return { items: state.items.slice(), currentKey: currentKey };
    },
    getItems: function () {
      return state.items.slice();
    },
    getItemsByKind: function (kind) {
      return state.items.filter(function (item) {
        return item.kind === kind;
      });
    },
    activate: function (key) {
      var item = findItemByKey(key);
      if (item) activatePreviewItem(item, true);
    },
    close: function (key) {
      closeItemByKey(key);
    },
    jumpToSource: function (key) {
      var item = findItemByKey(key);
      if (item) jumpToSourceForItem(item);
    },
    minimizeActive: function () {
      minimizeActiveToToast();
    },
    refreshToasts: function () {
      rebuildToasts();
    },
    openBgPreview: function (href, title) {
      var link = document.createElement('a');
      link.href = href;
      link.textContent = title || href;
      openBgPreviewFromLink(link);
    }
  };
})();
</script>
<script src="../src/js/index-scroll.js"></script>




</body></html>