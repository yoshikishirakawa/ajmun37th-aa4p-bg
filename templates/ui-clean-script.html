<script>
  // Inlined UI script for offline file:// compatibility
  // Source: src/js/ui-clean.js (inlined)
  (function () {
    'use strict';

    const STORAGE_KEYS = {
      tocLocation: 'quarto-toc-location',
      theme: 'quarto-theme',
      fontSize: 'quarto-font-size',
      markers: 'quarto-markers',
      comments: 'quarto-comments',
      scrollPosition: 'quarto-scroll-position',
      rightTab: 'quarto-right-tab',
      readingState: 'quarto-reading-state'
    };

    const NAV_DATA_STATE = {
      promise: null,
      data: null,
      rootPrefix: null
    };

    function getRootPrefix() {
      if (NAV_DATA_STATE.rootPrefix != null) return NAV_DATA_STATE.rootPrefix;
      const meta = document.querySelector('meta[name="quarto:offset"]');
      let prefix = meta ? (meta.getAttribute('content') || '') : '';
      if (prefix && !prefix.endsWith('/')) prefix += '/';
      NAV_DATA_STATE.rootPrefix = prefix;
      return prefix;
    }

    function normalizePath(path) {
      const cleaned = (path || '').replace(/\\/g, '/');
      const decoded = decodeURIComponent(cleaned);
      return decoded.replace(/^\/+/, '');
    }

    // =============================
    // 設定リセット系ユーティリティ
    // =============================
    function resetUiSettings() {
      try {
        // 現行UIの表示系
        localStorage.removeItem(STORAGE_KEYS.theme);
        localStorage.removeItem(STORAGE_KEYS.fontSize);
        localStorage.removeItem(STORAGE_KEYS.rightTab);
        localStorage.removeItem('footnotes-sort');
        localStorage.removeItem('comments-sort');

        // 旧UI由来（残っている可能性があるもの）
        localStorage.removeItem('txtSize');
        localStorage.removeItem('theme');
        localStorage.removeItem('tocLocation');
        localStorage.removeItem('scrollPos');
      } catch (e) {
        console.warn('resetUiSettings failed', e);
      }
    }

    function resetMemoSettings() {
      try {
        // マーカー／コメント関連
        localStorage.removeItem(STORAGE_KEYS.markers);
        localStorage.removeItem(STORAGE_KEYS.comments);
      } catch (e) {
        console.warn('resetMemoSettings failed', e);
      }
    }

    function resetPreviewSettings() {
      try {
        // Docs/BG プレビュー関連
        localStorage.removeItem('gdocPreviewMaxToasts');
        localStorage.removeItem('gdocPreviewState_v2');
      } catch (e) {
        console.warn('resetPreviewSettings failed', e);
      }
    }

    function resetAllSettingsHard() {
      try {
        // localStorage 全消去（他サイトのデータは同一オリジン内なので注意が必要だが、
        // このBGビューア専用オリジン前提で、完全リセットとして実装）
        localStorage.clear();
      } catch (e) {
        console.warn('resetAllSettingsHard failed', e);
      }
      try {
        // 読書状態・スクロール状態など sessionStorage 由来のものもクリア
        sessionStorage.clear();
      } catch (e) {
        console.warn('sessionStorage clear failed', e);
      }
    }

    function computeCurrentOutputPath() {
      const currentUrl = new URL(window.location.href);
      let rel = decodeURIComponent(currentUrl.pathname);
      try {
        const rootUrl = new URL(getRootPrefix() || './', window.location.href);
        if (rel.startsWith(rootUrl.pathname)) {
          rel = rel.slice(rootUrl.pathname.length);
        }
      } catch (e) {
        console.warn('computeCurrentOutputPath root resolution failed:', e);
      }
      const outIdx = rel.indexOf('/out/');
      if (outIdx >= 0) rel = rel.slice(outIdx + 5);
      rel = rel.replace(/^\//, '');
      if (!rel) rel = 'index.html';
      if (rel.endsWith('/')) rel += 'index.html';
      return rel;
    }

    function isSamePage(pathA, pathB) {
      return normalizePath(pathA) === normalizePath(pathB);
    }

    function buildHref(pagePath, anchor) {
      const current = computeCurrentOutputPath();
      if (isSamePage(pagePath, current)) {
        return anchor ? `#${anchor}` : '#';
      }
      const prefix = getRootPrefix();
      const base = `${prefix || ''}${pagePath}`;
      return anchor ? `${base}#${anchor}` : base;
    }

    function updateIndexLinksForContext() {
      const currentPath = computeCurrentOutputPath();
      const inContentDir = typeof currentPath === 'string' && currentPath.startsWith('content/');
      const links = document.querySelectorAll('a[data-aj-index-root-href]');
      if (!links.length) return;
      links.forEach(link => {
        const rootHref = link.getAttribute('data-aj-index-root-href');
        const localHref = link.getAttribute('data-aj-index-local-href');
        const target = inContentDir && localHref ? localHref : rootHref;
        if (target) {
          link.setAttribute('href', target);
        }
      });
    }

    function reinforceAnchors(scope) {
      if (!scope || typeof scope.querySelectorAll !== 'function') return;
      const anchors = scope.querySelectorAll('a[href]');
      anchors.forEach(anchor => {
        if (anchor.dataset.ajLinkReinforced === 'true') return;
        anchor.dataset.ajLinkReinforced = 'true';
        const href = anchor.getAttribute('href') || '';
        if (/^https?:\/\//i.test(href)) {
          if (!anchor.getAttribute('target')) {
            anchor.setAttribute('target', '_blank');
          }
          const rel = anchor.getAttribute('rel') || '';
          if (!/noopener/i.test(rel)) {
            anchor.setAttribute('rel', (rel + ' noopener noreferrer').trim());
          }
        }
      });
    }

    function setInlineFootnoteMode(active) {
      const next = !!active;
      if (INLINE_FOOTNOTE_MODE === next) return;
      INLINE_FOOTNOTE_MODE = next;
      if (!INLINE_FOOTNOTE_MODE) {
        hideCommentPopover();
      }
    }

    function ensureCommentMarkerInteractions() {
      const markers = document.querySelectorAll('.text-marker[data-comment-id]');
      markers.forEach(marker => {
        if (marker.dataset.commentMarkerBound === 'true') return;
        marker.dataset.commentMarkerBound = 'true';
        marker.addEventListener('click', handleCommentMarkerClick);
        marker.addEventListener('pointerenter', handleCommentMarkerPointerEnter);
        marker.addEventListener('pointerleave', handleCommentMarkerPointerLeave);
      });
    }

    function handleCommentMarkerClick(event) {
      if (!INLINE_FOOTNOTE_MODE) return;
      event.preventDefault();
      event.stopPropagation();
      const marker = event.currentTarget;
      if (commentPopoverEl && commentPopoverMarker === marker && commentPopoverPersistent) {
        hideCommentPopover();
      } else {
        showCommentPopover(marker, { persistent: true });
      }
    }

    function handleCommentMarkerPointerEnter(event) {
      if (!INLINE_FOOTNOTE_MODE) return;
      if (event.pointerType && event.pointerType !== 'mouse') return;
      const marker = event.currentTarget;
      showCommentPopover(marker, { persistent: false });
      clearCommentPopoverHideTimer();
    }

    function handleCommentMarkerPointerLeave() {
      if (!INLINE_FOOTNOTE_MODE) return;
      scheduleCommentPopoverHide(200);
    }

    function showCommentPopover(marker, opts) {
      if (!marker) return;
      const rec = getCommentRecordById(marker.getAttribute('data-comment-id'));
      if (!rec) return;
      const persistent = !!(opts && opts.persistent);
      clearCommentPopoverHideTimer();
      commentPopoverPersistent = persistent;
      commentPopoverMarker = marker;
      if (commentPopoverEl) {
        commentPopoverEl.remove();
        commentPopoverEl = null;
      }
      commentPopoverEl = document.createElement('div');
      commentPopoverEl.className = 'comment-inline-popover';
      const snippetRaw = (rec.text || '').trim();
      const snippetHtml = snippetRaw ? `対象: ${escapeHtml(snippetRaw.slice(0, 160))}` : '';
      const bodyHtml = escapeHtml(rec.body || '').replace(/\n/g, '<br>');
      commentPopoverEl.innerHTML = `
      ${snippetHtml ? `<div class="comment-inline-popover__snippet">${snippetHtml}</div>` : ''}
      <div class="comment-inline-popover__body">${bodyHtml || '<em>コメント内容がありません。</em>'}</div>
    `;
      commentPopoverEl.addEventListener('pointerenter', clearCommentPopoverHideTimer);
      commentPopoverEl.addEventListener('pointerleave', () => scheduleCommentPopoverHide(200));
      document.body.appendChild(commentPopoverEl);
      positionCommentPopover(marker);
    }

    function hideCommentPopover() {
      clearCommentPopoverHideTimer();
      if (commentPopoverEl) {
        commentPopoverEl.remove();
        commentPopoverEl = null;
      }
      commentPopoverMarker = null;
      commentPopoverPersistent = false;
    }

    function scheduleCommentPopoverHide(delay) {
      if (commentPopoverPersistent || !commentPopoverEl) return;
      clearCommentPopoverHideTimer();
      commentPopoverHideTimer = window.setTimeout(() => {
        hideCommentPopover();
      }, delay || 0);
    }

    function clearCommentPopoverHideTimer() {
      if (commentPopoverHideTimer) {
        clearTimeout(commentPopoverHideTimer);
        commentPopoverHideTimer = null;
      }
    }

    function positionCommentPopover(marker) {
      if (!commentPopoverEl || !marker) return;
      const rect = marker.getBoundingClientRect();
      const popRect = commentPopoverEl.getBoundingClientRect();
      const scrollX = window.scrollX || document.documentElement.scrollLeft || 0;
      const scrollY = window.scrollY || document.documentElement.scrollTop || 0;
      const viewportWidth = document.documentElement.clientWidth || window.innerWidth || popRect.width;
      const viewportHeight = document.documentElement.clientHeight || window.innerHeight || popRect.height;
      let top = scrollY + rect.bottom + 10;
      let left = scrollX + rect.left + (rect.width / 2) - (popRect.width / 2);
      const minLeft = scrollX + 8;
      const maxLeft = scrollX + viewportWidth - popRect.width - 8;
      if (left < minLeft) left = minLeft;
      if (left > maxLeft) left = maxLeft;
      const maxTop = scrollY + viewportHeight - popRect.height - 8;
      if (top > maxTop) {
        top = scrollY + rect.top - popRect.height - 10;
      }
      if (top < scrollY + 8) {
        top = scrollY + 8;
      }
      commentPopoverEl.style.top = `${top}px`;
      commentPopoverEl.style.left = `${left}px`;
    }

    function updateCommentPopoverPosition() {
      if (!INLINE_FOOTNOTE_MODE || !commentPopoverEl || !commentPopoverMarker) return;
      positionCommentPopover(commentPopoverMarker);
    }

    function getCommentRecordById(id) {
      if (!id) return null;
      const list = COMMENTS_DB[pageKey()] || [];
      return list.find(rec => rec && rec.id === id) || null;
    }

    document.addEventListener('click', (event) => {
      if (!INLINE_FOOTNOTE_MODE) return;
      const marker = event.target.closest && event.target.closest('.text-marker[data-comment-id]');
      if (marker) return;
      if (commentPopoverEl && !event.target.closest('.comment-inline-popover')) {
        hideCommentPopover();
      }
    });

    window.addEventListener('scroll', () => updateCommentPopoverPosition(), { passive: true });
    window.addEventListener('resize', () => updateCommentPopoverPosition());

    function cloneTreeWithDepth(nodes, maxLevel) {
      if (!Array.isArray(nodes) || !nodes.length) return [];
      const walk = (list) => {
        const acc = [];
        list.forEach(node => {
          if (!node || typeof node !== 'object') return;
          if (typeof node.level !== 'number' || node.level > maxLevel) return;
          const copy = {
            title: node.title,
            level: node.level,
            anchor: node.anchor,
            children: []
          };
          if (Array.isArray(node.children) && node.children.length) {
            copy.children = walk(node.children);
          }
          acc.push(copy);
        });
        return acc;
      };
      return walk(nodes);
    }

    function resolveNavData(data) {
      if (data && typeof data === 'object' && Array.isArray(data.pages)) {
        NAV_DATA_STATE.data = data;
        return data;
      }
      throw new Error('Invalid navigation data payload');
    }

    function loadNavDataViaScript(prefix) {
      if (typeof document === 'undefined') {
        return Promise.reject(new Error('DOM unavailable for script loading'));
      }
      return new Promise((resolve, reject) => {
        const existing = document.querySelector('script[data-nav-data="true"]');
        if (existing && typeof window.__NAV_DATA__ === 'object' && window.__NAV_DATA__) {
          try {
            resolve(resolveNavData(window.__NAV_DATA__));
          } catch (err) {
            reject(err);
          }
          return;
        }
        const script = document.createElement('script');
        script.type = 'text/javascript';
        script.dataset.navData = 'true';
        script.src = `${prefix}assets/nav-data.js`;
        script.onload = () => {
          try {
            resolve(resolveNavData(window.__NAV_DATA__));
          } catch (err) {
            reject(err);
          }
        };
        script.onerror = () => reject(new Error('Failed to load nav-data.js'));
        document.head.appendChild(script);
      });
    }

    function loadNavData() {
      if (NAV_DATA_STATE.data) return Promise.resolve(NAV_DATA_STATE.data);
      if (typeof window.__NAV_DATA__ === 'object' && window.__NAV_DATA__) {
        try {
          return Promise.resolve(resolveNavData(window.__NAV_DATA__));
        } catch (err) {
          return Promise.reject(err);
        }
      }
      if (NAV_DATA_STATE.promise) return NAV_DATA_STATE.promise;
      const prefix = getRootPrefix() || '';
      if (location.protocol === 'file:') {
        NAV_DATA_STATE.promise = loadNavDataViaScript(prefix)
          .catch(err => {
            console.warn('Failed to load nav data via script:', err);
            NAV_DATA_STATE.data = null;
            return null;
          });
        return NAV_DATA_STATE.promise;
      }

      const url = new URL(`${prefix}assets/nav-data.json`, window.location.href);
      NAV_DATA_STATE.promise = fetch(url.href)
        .then(res => {
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          return res.json();
        })
        .then(json => resolveNavData(json))
        .catch(err => {
          console.warn('Failed to fetch nav data, retrying with script fallback:', err);
          return loadNavDataViaScript(prefix)
            .catch(scriptErr => {
              console.warn('Script fallback failed for nav data:', scriptErr);
              NAV_DATA_STATE.data = null;
              return null;
            });
        });
      return NAV_DATA_STATE.promise;
    }

    function canonicalPageKey(pathname) {
      try {
        let path = (pathname || '').split(/[?#]/)[0];
        path = path.replace(/\\/g, '/').replace(/\/+/g, '/');
        const segments = path.split('/').filter(Boolean);
        if (!segments.length) return 'index.html';
        const last = segments[segments.length - 1];
        if (!last || last.toLowerCase() === 'index.html') {
          const prev = segments.length > 1 ? segments[segments.length - 2] : '';
          return prev ? `${prev}/index.html` : 'index.html';
        }
        return last;
      } catch {
        return pathname || 'index.html';
      }
    }

    function pageKey() {
      return canonicalPageKey(window.location.pathname || '');
    }

    function canonicalizeCommentsDB(db) {
      const merged = {};
      const seenMap = {};
      if (!db || typeof db !== 'object') {
        return {};
      }
      Object.keys(db).forEach(oldKey => {
        const canonical = canonicalPageKey(oldKey);
        if (!merged[canonical]) {
          merged[canonical] = [];
          seenMap[canonical] = new Set();
        }
        const list = db[oldKey] || [];
        list.forEach(rec => {
          if (!rec || !rec.id || seenMap[canonical].has(rec.id)) return;
          merged[canonical].push(rec);
          seenMap[canonical].add(rec.id);
        });
      });
      return merged;
    }

    // コメントDB（ページキー毎に配列）
    let COMMENTS_DB = {};
    try {
      COMMENTS_DB = JSON.parse(localStorage.getItem(STORAGE_KEYS.comments) || '{}') || {};
    } catch {
      COMMENTS_DB = {};
    }
    COMMENTS_DB = canonicalizeCommentsDB(COMMENTS_DB);
    try { localStorage.setItem(STORAGE_KEYS.comments, JSON.stringify(COMMENTS_DB)); } catch { }
    function saveComments() {
      try { localStorage.setItem(STORAGE_KEYS.comments, JSON.stringify(COMMENTS_DB)); }
      catch (e) { console.warn('Save comments failed', e); }
    }

    let INLINE_FOOTNOTE_MODE = false;
    let commentPopoverEl = null;
    let commentPopoverMarker = null;
    let commentPopoverPersistent = false;
    let commentPopoverHideTimer = null;
    let cleanupCommentMarkersDom = () => { };
    let refreshCommentMarkersFromDB = () => { };
    let readingStateSaveTimer = null;

    function resolveAssetPath(relPath) {
      try {
        // Prefer Quarto's offset meta when available so paths work on index.html and content pages
        const offsetMeta = document.querySelector('meta[name="quarto:offset"]');
        if (offsetMeta) {
          let offset = offsetMeta.getAttribute('content') || '';
          if (offset && !offset.endsWith('/')) offset += '/';
          return offset + relPath;
        }

        // Fallback: derive base from simple-theme.css location if present
        const themeLink = document.querySelector('link[rel="stylesheet"][href*="src/css/simple-theme.css"]');
        if (themeLink) {
          const href = themeLink.getAttribute('href') || '';
          const parts = href.split('/');
          const srcIndex = parts.indexOf('src');
          if (srcIndex >= 0) {
            const prefix = parts.slice(0, srcIndex).join('/');
            const base = prefix ? prefix.replace(/\/*$/, '/') : '';
            return base + relPath;
          }
        }
      } catch (e) {
        console.warn('resolveAssetPath failed', e);
      }
      return relPath;
    }

    let readingMeterState = null;
    let scrollExtensionEl = null;
    let pendingScrollExtensionRaf = 0;
    const SCROLL_EXTENSION_BUFFER = 80;
    const FOOTNOTE_INLINE_BREAKPOINT = 1024;
    let currentFootnoteLayout = null;

    function formatReadingNumber(value) {
      if (!Number.isFinite(value)) return '0';
      try {
        return value.toLocaleString('ja-JP');
      } catch (error) {
        console.warn('Failed to format number:', error);
        return String(Math.trunc(value));
      }
    }

    function extractReadableText(root) {
      if (!root) return '';
      const clone = root.cloneNode(true);
      const selectorsToRemove = [
        '.header-ui',
        '.settings-menu',
        '.settings-menu-overlay',
        '.scroll-settings-header',
        '#scroll-settings-header',
        '.toc-overlay',
        '.global-search-overlay',
        '.marker-toolbar'
      ];
      selectorsToRemove.forEach((selector) => {
        clone.querySelectorAll(selector).forEach((node) => node.remove());
      });
      return (clone.textContent || '').replace(/\s+/g, '');
    }

    function ensureScrollExtensionElement() {
      if (scrollExtensionEl && document.body.contains(scrollExtensionEl)) {
        return scrollExtensionEl;
      }
      if (!document.body) return null;
      scrollExtensionEl = document.createElement('div');
      scrollExtensionEl.id = 'scroll-extension-anchor';
      scrollExtensionEl.setAttribute('aria-hidden', 'true');
      scrollExtensionEl.style.cssText = 'width:1px;height:0;margin:0;padding:0;';
      document.body.appendChild(scrollExtensionEl);
      return scrollExtensionEl;
    }

    function updateScrollExtensionNow() {
      const placeholder = ensureScrollExtensionElement();
      if (!placeholder) return;
      placeholder.style.height = '0px';
      const docElement = document.documentElement || document.body;
      const baseHeight = Math.max(
        document.body ? document.body.scrollHeight : 0,
        docElement ? docElement.scrollHeight : 0
      );
      let maxBottom = baseHeight;
      let hasTarget = false;
      const targets = [
        document.getElementById('quarto-document-content'),
        document.getElementById('quarto-sidebar'),
        document.getElementById('quarto-margin-sidebar')
      ];
      targets.forEach(el => {
        if (!el) return;
        const rect = el.getBoundingClientRect();
        if (!rect || !Number.isFinite(rect.bottom)) return;
        const bottom = rect.bottom + window.scrollY;
        if (!Number.isFinite(bottom)) return;
        maxBottom = Math.max(maxBottom, bottom);
        hasTarget = true;
      });
      if (!hasTarget) {
        placeholder.style.height = '0px';
        return;
      }
      const needed = Math.max(0, Math.ceil(maxBottom - baseHeight + SCROLL_EXTENSION_BUFFER));
      placeholder.style.height = needed > 0 ? `${needed}px` : '0px';
    }

    function scheduleScrollExtensionUpdate() {
      if (typeof requestAnimationFrame !== 'function') {
        return updateScrollExtensionNow();
      }
      if (pendingScrollExtensionRaf) {
        cancelAnimationFrame(pendingScrollExtensionRaf);
      }
      pendingScrollExtensionRaf = requestAnimationFrame(() => {
        pendingScrollExtensionRaf = 0;
        updateScrollExtensionNow();
      });
    }

    function initializeReadingMeter(displayEl) {
      if (!displayEl) return;

      const readingRoot = document.querySelector('#quarto-document-content');
      if (!readingRoot) {
        displayEl.textContent = '[0/0]';
        displayEl.setAttribute('aria-label', '読書メーター: 0 / 0');
        return;
      }

      const totalText = extractReadableText(readingRoot);
      const totalChars = totalText.length;
      const formattedTotal = formatReadingNumber(totalChars);

      displayEl.textContent = `[0/${formattedTotal}]`;
      displayEl.setAttribute('data-total-chars', `${totalChars}`);
      displayEl.setAttribute('data-current-chars', '0');
      displayEl.setAttribute('aria-live', 'polite');
      displayEl.setAttribute('aria-label', `読書メーター: 0 / ${formattedTotal}`);

      const state = {
        displayEl,
        readingRoot,
        measureElement: readingRoot,
        totalChars,
        formattedTotal,
        lastCurrent: -1,
        lastOutput: '',
        updateScheduled: false,
        cleanup: null
      };

      const computeRatio = () => {
        if (!state.measureElement) return 0;
        const rect = state.measureElement.getBoundingClientRect();
        const contentTop = window.scrollY + rect.top;
        const contentBottom = contentTop + rect.height;
        if (!Number.isFinite(contentTop) || !Number.isFinite(contentBottom) || contentBottom <= contentTop) {
          return 0;
        }

        const scrollTop = window.scrollY;
        const scrollBottom = scrollTop + window.innerHeight;
        const scrollRange = contentBottom - contentTop - window.innerHeight;
        let ratio;

        if (scrollRange <= 0) {
          if (scrollBottom >= contentBottom) {
            ratio = 1;
          } else if (scrollTop <= contentTop) {
            ratio = 0;
          } else {
            ratio = (scrollTop - contentTop) / Math.max(1, contentBottom - contentTop);
          }
        } else {
          ratio = (scrollTop - contentTop) / scrollRange;
        }

        if (!Number.isFinite(ratio)) {
          return 0;
        }
        return Math.min(1, Math.max(0, ratio));
      };

      const applyUpdate = () => {
        state.updateScheduled = false;
        if (state.totalChars <= 0) {
          const output = '[0/0]';
          if (output !== state.lastOutput) {
            state.lastOutput = output;
            state.displayEl.textContent = output;
            state.displayEl.setAttribute('data-current-chars', '0');
            state.displayEl.setAttribute('aria-label', '読書メーター: 0 / 0');
          }
          return;
        }

        const ratio = computeRatio();
        const currentChars = Math.max(0, Math.min(state.totalChars, Math.round(state.totalChars * ratio)));
        if (currentChars === state.lastCurrent && state.lastOutput) {
          return;
        }

        state.lastCurrent = currentChars;
        const formattedCurrent = formatReadingNumber(currentChars);
        const output = `[${formattedCurrent}/${state.formattedTotal}]`;
        if (output !== state.lastOutput) {
          state.lastOutput = output;
          state.displayEl.textContent = output;
          state.displayEl.setAttribute('data-current-chars', `${currentChars}`);
          state.displayEl.setAttribute('aria-label', `読書メーター: ${formattedCurrent} / ${state.formattedTotal}`);
        }
      };

      const scheduleUpdate = () => {
        if (state.updateScheduled) return;
        state.updateScheduled = true;
        requestAnimationFrame(applyUpdate);
      };

      const onScroll = () => scheduleUpdate();
      const onResize = () => scheduleUpdate();

      if (readingMeterState && typeof readingMeterState.cleanup === 'function') {
        readingMeterState.cleanup();
      }

      window.addEventListener('scroll', onScroll, { passive: true });
      window.addEventListener('resize', onResize);

      state.cleanup = () => {
        window.removeEventListener('scroll', onScroll);
        window.removeEventListener('resize', onResize);
      };

      readingMeterState = state;
      scheduleUpdate();
    }

    function getSavedRightTab() {
      try {
        const saved = localStorage.getItem(STORAGE_KEYS.rightTab);
        if (saved && ['footnotes', 'comments', 'both'].includes(saved)) {
          return saved;
        }
      } catch (e) {
        console.warn('Failed to read right tab state', e);
      }
      return 'both';
    }
    function saveRightTab(tab) {
      if (!['footnotes', 'comments', 'both'].includes(tab)) return;
      try { localStorage.setItem(STORAGE_KEYS.rightTab, tab); }
      catch (e) { console.warn('Failed to save right tab state', e); }
    }

    function setupTopChapterNavigation() {
      if (document.querySelector('nav.page-navigation-top')) return;
      const header = document.querySelector('header.quarto-title-block');
      const bottomNav = document.querySelector('nav.page-navigation');
      if (!header || !bottomNav) return;
      const topNav = bottomNav.cloneNode(true);
      topNav.classList.add('page-navigation-top');
      header.parentNode.insertBefore(topNav, header);
    }

    function getActiveChapterSection() {
      return document.querySelector('section.chapter-page.active') || null;
    }
    function getCurrentChapterSlug() {
      const active = getActiveChapterSection();
      if (!active) return null;
      const id = active.getAttribute('id') || '';
      return id.startsWith('page-') ? id.slice(5) : (id || null);
    }

    function getSectionSlugFromElement(el) {
      if (!el || !(el instanceof HTMLElement)) return null;
      const sec = el.closest('section.chapter-page');
      if (!sec || !sec.id) return null;
      const id = sec.id;
      return id.startsWith('page-') ? id.slice(5) : id;
    }

    function findCommentAnchorElement(rec) {
      if (!rec || !Array.isArray(rec.ranges)) return null;
      for (const range of rec.ranges) {
        const node = getNodeByPathSafe(range?.s);
        if (!node) continue;
        let el = node.nodeType === Node.ELEMENT_NODE ? node : node.parentElement;
        while (el && !(el instanceof HTMLElement)) el = el.parentElement;
        if (el) return el;
      }
      return null;
    }

    function detectCommentSlug(rec) {
      const el = findCommentAnchorElement(rec);
      return el ? getSectionSlugFromElement(el) : null;
    }

    function isCommentInSection(rec, section) {
      if (!section) return true;
      const el = findCommentAnchorElement(rec);
      return !!(el && section.contains(el));
    }

    function getActiveComments() {
      const list = (COMMENTS_DB[pageKey()] || []);
      // 章タブやセクションに関わらず、このページ上のコメントをすべて返す
      return list.filter(rec => !!rec);
    }

    function gatherActiveCommentsWithElements() {
      return getActiveComments()
        .map(rec => {
          const el = findCommentAnchorElement(rec);
          return el ? { rec, el } : null;
        })
        .filter(Boolean);
    }

    function gatherActiveFootnotes() {
      const active = getActiveChapterSection();
      const refSelector = 'a[role="doc-noteref"], a.footnote-ref';
      const refMap = new Map();
      const scope = active || document;
      Array.from(scope.querySelectorAll(refSelector)).forEach(ref => {
        if (active && !active.contains(ref)) return;
        const href = ref.getAttribute('href') || ref.getAttribute('data-footnote-href');
        if (!href || !href.startsWith('#')) return;
        const id = href.slice(1);
        const top = ref.getBoundingClientRect().top + window.scrollY;
        const label = (() => {
          const sup = ref.querySelector('sup');
          const raw = (sup ? sup.textContent : ref.textContent) || '';
          return raw.replace(/\s+/g, ' ').trim();
        })();
        const existing = refMap.get(id);
        if (!existing || top < existing.pos) {
          refMap.set(id, { id, ref, pos: top, number: label });
        }
      });
      const items = [];
      refMap.forEach(entry => {
        let def = document.getElementById(entry.id);
        if (!def) return;
        if (!(def instanceof HTMLElement)) def = def.parentElement;
        if (!def) return;
        let li = def;
        if (li.tagName && li.tagName.toLowerCase() !== 'li') {
          const nearestLi = li.closest('li');
          if (nearestLi) li = nearestLi;
        }
        if (!(li instanceof HTMLElement)) return;
        if (active) {
          const parentSection = li.closest('section.chapter-page');
          if (parentSection && parentSection !== active) return;
        }
        const fallbackLabel = entry.number || entry.id.replace(/[^0-9]+/g, '').trim();
        items.push({ id: entry.id, li, ref: entry.ref, pos: entry.pos, number: fallbackLabel });
      });
      return items;
    }

    async function initUI() {
      let navData = null;
      try {
        navData = await loadNavData();
      } catch (e) {
        console.warn('Nav data load failed:', e);
      }

      const safeInvoke = async (label, action) => {
        try {
          const result = action();
          if (result && typeof result.then === 'function') {
            await result;
          }
        } catch (err) {
          console.error(`UI init step failed (${label}):`, err);
        }
      };

      const steps = [
        ['header-controls', () => setupHeaderControls()],
        ['left-sidebar-tabs', () => setupLeftPanelTabs(navData)],
        ['site-title-enhancements', () => applySiteTitleEnhancements(navData)],
        ['mobile-nav-drawer', () => setupMobileNavDrawer(navData)],
        ['left-sidebar-stability', () => setupLeftSidebarStability()],
        ['right-sidebar', () => setupRightSidebar()],
        ['top-nav', () => setupTopChapterNavigation()],
        ['markers', () => setupMarkerFunctionality()],
        ['mobile-footnotes', () => setupMobileFootnoteToggle()],
        ['disable-default-search', () => disableDefaultQuartoSearch()],
        ['sidebar-search', () => setupSidebarSearch()],
        ['global-search', () => setupGlobalSearch()],
        ['shortcuts', () => setupKeyboardShortcuts()],
        ['scroll-position', () => setupScrollPosition()],
        ['body-links', () => reinforceAnchors(document.getElementById('quarto-document-content'))],
        ['index-links', () => updateIndexLinksForContext()],
        ['custom-toc', () => setTimeout(() => CustomTOC.initializeCustomTOC(navData), 100)],
      ];

      for (const [label, action] of steps) {
        await safeInvoke(label, action);
      }

      console.log('UI initialized');
      window.addEventListener('resize', () => scheduleScrollExtensionUpdate(), { passive: true });
      window.addEventListener('orientationchange', () => scheduleScrollExtensionUpdate());
      window.addEventListener('load', () => scheduleScrollExtensionUpdate(), { once: true });
      scheduleScrollExtensionUpdate();
      setTimeout(() => {
        refreshRightPanels();
        restoreReadingState();
      }, 120);
    }
    const queueInit = () => window.setTimeout(initUI, 0);
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', queueInit, { once: true });
    } else {
      queueInit();
    }

    function setTocLocation(location) {
      const root = document.documentElement;
      root.classList.toggle('toc-right-on', location === 'right');
      root.classList.toggle('toc-body-on', location === 'body');
      try {
        localStorage.setItem(STORAGE_KEYS.tocLocation, location);
      } catch (e) {
        console.warn('Failed to save TOC location', e);
      }
    }

    function setupHeaderControls() {
      const settingsToggleBtn = document.getElementById('settings-toggle-btn');
      const settingsMenu = document.getElementById('settings-menu');
      const settingsMenuClose = document.getElementById('settings-menu-close');
      const settingsMenuOverlay = document.getElementById('settings-menu-overlay');
      const themeSelect = document.getElementById('theme-select');
      const fontSizeSelect = document.getElementById('font-size-select');
      const commentsExportPage = document.getElementById('comments-export-page');
      const commentsExportAll = document.getElementById('comments-export-all');
      const commentsImport = document.getElementById('comments-import');
      const commentsImportButton = document.getElementById('comments-import-button');
      const toastMaxRange = document.getElementById('gdoc-toast-max');
      const toastMaxValue = document.getElementById('gdoc-toast-max-value');
      const resetUiBtn = document.getElementById('reset-ui-settings');
      const resetMemoBtn = document.getElementById('reset-memo-settings');
      const resetPreviewBtn = document.getElementById('reset-preview-settings');
      const resetAllBtn = document.getElementById('reset-all-settings');
      const tocLocationBtn = document.getElementById('toc-location-btn');

      // Restore TOC location
      const savedTocLocation = localStorage.getItem(STORAGE_KEYS.tocLocation) || 'right';
      setTocLocation(savedTocLocation);

      if (tocLocationBtn) {
        tocLocationBtn.addEventListener('click', () => {
          const current = document.documentElement.classList.contains('toc-right-on') ? 'body' : 'right';
          setTocLocation(current);
        });
      }

      // ハンバーガーメニューは廃止

      // 設定メニュー開閉機能
      if (settingsToggleBtn) {
        const iconImg = settingsToggleBtn.querySelector('.settings-toggle-icon[data-asset]');
        if (iconImg) {
          const assetPath = iconImg.getAttribute('data-asset');
          if (assetPath) {
            iconImg.src = resolveAssetPath(assetPath);
          }
        }
      }

      // 一般の画像についても data-asset 属性があれば resolveAssetPath で解決する
      try {
        const assetImgs = document.querySelectorAll('img[data-asset]');
        assetImgs.forEach(img => {
          const rel = img.getAttribute('data-asset');
          if (!rel) return;
          const resolved = resolveAssetPath(rel);
          if (resolved && img.src !== resolved) {
            img.src = resolved;
          }
        });
      } catch (e) {
        console.warn('resolveAssetPath for img[data-asset] failed', e);
      }

      if (settingsToggleBtn && settingsMenu && settingsMenuOverlay) {
        const openSettingsMenu = () => {
          settingsMenu.classList.add('open');
          settingsMenuOverlay.classList.add('open');
        };

        const closeSettingsMenu = () => {
          settingsMenu.classList.remove('open');
          settingsMenuOverlay.classList.remove('open');
        };

        settingsToggleBtn.addEventListener('click', openSettingsMenu);
        settingsMenuClose.addEventListener('click', closeSettingsMenu);
        settingsMenuOverlay.addEventListener('click', closeSettingsMenu);

        // ESCキーでメニューを閉じる
        document.addEventListener('keydown', (e) => {
          if (e.key === 'Escape' && settingsMenu.classList.contains('open')) {
            closeSettingsMenu();
          }
        });
      }

      // テーマ切替機能
      if (themeSelect) {
        const mq = window.matchMedia('(prefers-color-scheme: dark)');
        function applyTheme(mode) {
          if (mode === 'auto') {
            document.body.setAttribute('data-theme', mq.matches ? 'dark' : 'light');
          } else {
            document.body.setAttribute('data-theme', mode);
          }
        }
        const saved = localStorage.getItem(STORAGE_KEYS.theme) || 'auto';
        themeSelect.value = saved;
        applyTheme(saved);
        mq.addEventListener('change', () => { if ((localStorage.getItem(STORAGE_KEYS.theme) || 'auto') === 'auto') applyTheme('auto'); });
        themeSelect.addEventListener('change', (e) => {
          const theme = e.target.value;
          localStorage.setItem(STORAGE_KEYS.theme, theme);
          applyTheme(theme);
        });
      }

      // 文字サイズ変更機能
      if (fontSizeSelect) {
        const currentSize = localStorage.getItem(STORAGE_KEYS.fontSize) || 'M';
        fontSizeSelect.value = currentSize;
        document.body.setAttribute('data-font-size', currentSize);
        fontSizeSelect.addEventListener('change', (e) => {
          const size = e.target.value;
          document.body.setAttribute('data-font-size', size);
          localStorage.setItem(STORAGE_KEYS.fontSize, size);
        });
      }

      // コメント出力機能
      if (commentsExportPage) {
        commentsExportPage.addEventListener('click', () => exportComments(true));
      }
      if (commentsExportAll) {
        commentsExportAll.addEventListener('click', () => exportComments(false));
      }

      // コメントインポート機能
      if (commentsImport && commentsImportButton) {
        commentsImport.addEventListener('change', (e) => importCommentsFromFile(e.target.files[0]));
        commentsImportButton.addEventListener('click', () => commentsImport.click());
      }

      // リセットボタン群
      if (resetUiBtn) {
        resetUiBtn.addEventListener('click', () => {
          const ok = window.confirm('UI系の設定（テーマ・文字サイズ・右パネルタブ・ソート設定など）をリセットしますか？');
          if (!ok) return;
          resetUiSettings();
          // 即時反映のため、ページを再読み込み
          window.location.reload();
        });
      }

      if (resetMemoBtn) {
        resetMemoBtn.addEventListener('click', () => {
          const ok = window.confirm('メモ系（マーカー・コメント）の保存データをすべてリセットしますか？\\n※元に戻すことはできません。');
          if (!ok) return;
          resetMemoSettings();
          window.location.reload();
        });
      }

      if (resetPreviewBtn) {
        resetPreviewBtn.addEventListener('click', () => {
          const ok = window.confirm('プレビュー関連の設定（Docs/BGプレビューの状態・トースト表示数）をリセットしますか？');
          if (!ok) return;
          resetPreviewSettings();
          window.location.reload();
        });
      }

      if (resetAllBtn) {
        resetAllBtn.addEventListener('click', () => {
          const ok = window.confirm('すべての設定と保存データを完全にリセットします。\\nlocalStorage / sessionStorage を初期化しますが、本当に実行しますか？');
          if (!ok) return;
          resetAllSettingsHard();
          window.location.reload();
        });
      }

      // プレビューのトースト表示数スライダー
      if (toastMaxRange && toastMaxValue) {
        let stored = 3;
        try {
          const raw = localStorage.getItem('gdocPreviewMaxToasts');
          if (raw != null) {
            const n = parseInt(raw, 10);
            if (!isNaN(n)) stored = Math.min(9, Math.max(0, n));
          }
        } catch (e) {
          // ignore
        }
        toastMaxRange.value = String(stored);
        toastMaxValue.textContent = String(stored);

        toastMaxRange.addEventListener('input', () => {
          toastMaxValue.textContent = String(toastMaxRange.value);
        });
        toastMaxRange.addEventListener('change', () => {
          const n = parseInt(toastMaxRange.value, 10) || 0;
          try {
            localStorage.setItem('gdocPreviewMaxToasts', String(Math.min(9, Math.max(0, n))));
          } catch (e) { }
          if (window.__gdocPreviewAPI__ && typeof window.__gdocPreviewAPI__.refreshToasts === 'function') {
            window.__gdocPreviewAPI__.refreshToasts();
          }
        });
      }

      ensureHeaderListButtons();
      document.addEventListener('quarto-hrChanged', ensureHeaderListButtons);
      window.addEventListener('resize', ensureHeaderListButtons);
    }

    function ensureHeaderListButtons() {
      try {
        const searchButtons = document.querySelectorAll('.quarto-search-button');
        if (!searchButtons.length) return;
        searchButtons.forEach(searchButton => {
          const parent = searchButton.parentElement;
          if (!parent) return;
          if (parent.querySelector('.quarto-list-button')) return;
          const listBtn = document.createElement('button');
          listBtn.type = 'button';
          listBtn.className = 'btn quarto-list-button';
          listBtn.setAttribute('aria-label', 'プレビュー・コメント・マーカー一覧を開く');
          const icon = document.createElement('img');
          icon.alt = '';
          icon.decoding = 'async';
          icon.loading = 'lazy';
          icon.setAttribute('aria-hidden', 'true');
          icon.src = resolveAssetPath('assets/list.png');
          listBtn.appendChild(icon);
          listBtn.addEventListener('click', (event) => {
            event.preventDefault();
            openGlobalListOverlay();
          });
          parent.insertBefore(listBtn, searchButton);
        });
      } catch (e) {
        console.warn('inject list button failed', e);
      }
    }

    function renderNavDrawerContent(container, navData) {
      if (!container) return;
      container.innerHTML = '';
      const switcher = document.createElement('div');
      switcher.className = 'toc-switcher nav-drawer-switcher';
      switcher.innerHTML = `
      <div class="toc-tabs">
        <button type="button" class="toc-tab active" data-tab="site">各章</button>
        <button type="button" class="toc-tab" data-tab="page">章内</button>
        <button type="button" class="toc-tab" data-tab="all">全体</button>
      </div>
      <div class="toc-panel toc-site-content"></div>
      <div class="toc-panel toc-page-content hidden"></div>
      <div class="toc-panel toc-all-content hidden"></div>
    `;
      container.appendChild(switcher);
      const sitePanel = switcher.querySelector('.toc-site-content');
      const pagePanel = switcher.querySelector('.toc-page-content');
      const allPanel = switcher.querySelector('.toc-all-content');
      if (sitePanel) CustomTOC.renderChapterTab(sitePanel, navData);
      if (pagePanel) CustomTOC.renderPageTab(pagePanel, navData, 4);
      if (allPanel) CustomTOC.renderAllTab(allPanel, navData);
      const tabButtons = switcher.querySelectorAll('.toc-tab');
      tabButtons.forEach(btn => {
        btn.addEventListener('click', () => {
          const target = btn.dataset.tab;
          tabButtons.forEach(other => other.classList.remove('active'));
          btn.classList.add('active');
          switcher.querySelectorAll('.toc-panel').forEach(panel => {
            panel.classList.add('hidden');
          });
          const panel = switcher.querySelector(`.toc-${target}-content`);
          if (panel) panel.classList.remove('hidden');
        });
      });
    }

    function setupMobileNavDrawer(navData) {
      const overlay = document.querySelector('.toc-overlay');
      if (!overlay) return;
      const closeBtn = overlay.querySelector('.toc-sheet__close');
      const backdrop = overlay.querySelector('.toc-overlay__backdrop');
      const content = overlay.querySelector('.toc-sheet__content');
      const toggleButtons = document.querySelectorAll('.quarto-btn-toggle, [data-bs-target=".quarto-sidebar-collapse-item"]');
      const buttons = Array.from(new Set(Array.from(toggleButtons)));
      if (!buttons.length) return;

      const closeDrawer = () => {
        document.body.classList.remove('toc-open');
      };

      const openDrawer = () => {
        renderNavDrawerContent(content, navData);
        document.body.classList.add('toc-open');
      };

      const toggleDrawer = () => {
        if (document.body.classList.contains('toc-open')) {
          closeDrawer();
        } else {
          openDrawer();
        }
      };

      const interceptToggle = (event) => {
        if (window.innerWidth > 1024) {
          closeDrawer();
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        if (typeof event.stopImmediatePropagation === 'function') {
          event.stopImmediatePropagation();
        }
        toggleDrawer();
      };

      buttons.forEach(btn => {
        btn.addEventListener('click', interceptToggle, true);
      });

      if (closeBtn) closeBtn.addEventListener('click', closeDrawer);
      if (backdrop) backdrop.addEventListener('click', closeDrawer);
      overlay.addEventListener('click', (event) => {
        if (event.target.classList.contains('toc-overlay')) {
          closeDrawer();
        }
      });
      if (content) {
        content.addEventListener('click', (event) => {
          const anchor = event.target.closest('a');
          if (anchor) closeDrawer();
        });
      }
      document.addEventListener('keydown', (event) => {
        if (event.key === 'Escape' && document.body.classList.contains('toc-open')) {
          closeDrawer();
        }
      });
      window.addEventListener('resize', () => {
        if (window.innerWidth > 1024) closeDrawer();
      });
    }

    function setupLeftPanelTabs(navData) {
      const sidebar = document.getElementById('quarto-sidebar');
      if (!sidebar) return;
      const menuContainer = sidebar.querySelector('.sidebar-menu-container');
      if (!menuContainer) return;

      const tabWrapper = document.createElement('div');
      tabWrapper.className = 'toc-switcher';
      tabWrapper.innerHTML = `
      <div class="toc-tabs">
        <button type="button" class="toc-tab active" data-tab="site">各章</button>
        <button type="button" class="toc-tab" data-tab="page">章内</button>
        <button type="button" class="toc-tab" data-tab="all">全体</button>
      </div>
      <div class="toc-panel toc-site-content"></div>
      <div class="toc-panel toc-page-content hidden"></div>
      <div class="toc-panel toc-all-content hidden"></div>
    `;

      const parent = menuContainer.parentNode;
      parent.replaceChild(tabWrapper, menuContainer);

      const sitePanel = tabWrapper.querySelector('.toc-site-content');
      const pagePanel = tabWrapper.querySelector('.toc-page-content');
      const allPanel = tabWrapper.querySelector('.toc-all-content');

      sitePanel.innerHTML = '';
      pagePanel.innerHTML = '';
      allPanel.innerHTML = '';

      menuContainer.innerHTML = '';
      sitePanel.appendChild(menuContainer);

      const allContainer = document.createElement('div');
      allContainer.className = 'toc-all-container';
      allPanel.appendChild(allContainer);

      if (!navData || !Array.isArray(navData.pages) || !navData.pages.length) {
        menuContainer.innerHTML = '<p class="toc-empty">目次データを読み込めませんでした。</p>';
        allContainer.innerHTML = '<p class="toc-empty">目次データを読み込めませんでした。</p>';
        pagePanel.innerHTML = '<p class="toc-empty">目次データを読み込めませんでした。</p>';
      } else {
        CustomTOC.renderChapterTab(menuContainer, navData);
        CustomTOC.renderAllTab(allContainer, navData);
        CustomTOC.renderPageTab(pagePanel, navData, 4);
      }

      const tabButtons = tabWrapper.querySelectorAll('.toc-tab');
      const panels = { site: sitePanel, page: pagePanel, all: allPanel };
      tabButtons.forEach(button => {
        button.addEventListener('click', () => {
          const target = button.dataset.tab;
          tabButtons.forEach(btn => btn.classList.remove('active'));
          button.classList.add('active');
          Object.values(panels).forEach(p => p.classList.add('hidden'));
          if (panels[target]) {
            panels[target].classList.remove('hidden');
            if (target === 'page' && navData) {
              CustomTOC.renderPageTab(pagePanel, navData, 4);
            }
          }
        });
      });
      scheduleScrollExtensionUpdate();
    }

    function setupLeftSidebarStability() {
      const sidebar = document.getElementById('quarto-sidebar');
      const toggles = document.querySelectorAll('[data-bs-target=".quarto-sidebar-collapse-item"]');
      if (!sidebar || !toggles.length) return;
      let pendingState = null;
      let pendingExpiry = 0;
      let restoreHandle = null;

      const applyPendingState = () => {
        if (!pendingState) return;
        scrollToReadingState(pendingState);
        if (Date.now() > pendingExpiry) {
          pendingState = null;
        }
      };

      const scheduleRestore = () => {
        if (!pendingState) return;
        if (restoreHandle) {
          cancelAnimationFrame(restoreHandle);
          restoreHandle = null;
        }
        restoreHandle = requestAnimationFrame(() => {
          restoreHandle = requestAnimationFrame(() => {
            applyPendingState();
          });
        });
      };

      const captureStateBeforeToggle = () => {
        const snapshot = captureReadingState({ captureNodeRef: true });
        if (!snapshot) return;
        pendingState = snapshot;
        pendingExpiry = Date.now() + 1200;
        scheduleRestore();
      };

      toggles.forEach(btn => {
        btn.addEventListener('click', captureStateBeforeToggle, true);
        btn.addEventListener('keydown', (event) => {
          if (event.key === 'Enter' || event.key === ' ') {
            captureStateBeforeToggle();
          }
        }, true);
      });

      sidebar.addEventListener('transitionstart', () => {
        if (!pendingState) {
          captureStateBeforeToggle();
        }
      });

      sidebar.addEventListener('animationstart', () => {
        if (!pendingState) {
          captureStateBeforeToggle();
        }
      });

      sidebar.addEventListener('transitionend', (event) => {
        if (!pendingState) return;
        if (event && event.propertyName && !/width|flex|margin|padding/i.test(event.propertyName)) return;
        scheduleRestore();
      });

      const sidebarMutationObserver = new MutationObserver(() => {
        if (pendingState) scheduleRestore();
      });
      sidebarMutationObserver.observe(sidebar, { attributes: true, attributeFilter: ['class', 'style'] });

      window.addEventListener('resize', () => {
        if (pendingState) {
          scheduleRestore();
        }
      });
    }

    function applySiteTitleEnhancements(navData) {
      enhanceSidebarSiteTitle();
      updateMainHeaderTitle(navData);
    }

    function enhanceSidebarSiteTitle() {
      try {
        const link = document.querySelector('#quarto-sidebar .sidebar-title a');
        if (!link || link.dataset.siteTitleEnhanced === 'true') return;
        const mainText = (link.textContent || '').trim() || '平和への課題：補遺';
        const safeMain = escapeHtml(mainText);
        const subtitle = 'Background Guide';
        link.innerHTML = `<span class="site-title-main">${safeMain}</span><span class="site-title-sub">${subtitle}</span>`;
        link.dataset.siteTitleEnhanced = 'true';
      } catch (e) {
        console.warn('enhanceSidebarSiteTitle failed', e);
      }
    }

    function updateMainHeaderTitle(navData) {
      const header = document.querySelector('header.quarto-title-block');
      if (!header) return;
      const titleEl = header.querySelector('.quarto-title .title');
      if (!titleEl) return;
      const existingSpan = titleEl.querySelector('.chapter-title') || titleEl.firstElementChild;
      const current = computeCurrentOutputPath();
      let pageTitle = '';
      try {
        if (navData && Array.isArray(navData.pages)) {
          const entry = navData.pages.find(page => {
            if (!page) return false;
            const paths = [page.output, page.url, page.source];
            return paths.some(p => isSamePage(p, current));
          });
          if (entry && entry.title) {
            pageTitle = entry.title;
          }
        }
      } catch (e) {
        console.warn('updateMainHeaderTitle nav data lookup failed', e);
      }
      if (!pageTitle && existingSpan) {
        pageTitle = (existingSpan.textContent || '').trim();
      }
      if (!pageTitle) {
        const contentHeading = document.querySelector('main h1, main h2');
        if (contentHeading) {
          pageTitle = (contentHeading.textContent || '').trim();
        }
      }
      if (!pageTitle) {
        header.style.display = 'none';
        return;
      }
      header.style.display = 'none';
    }

    function setupRightSidebar() {
      ensureRightTabs();
      refreshRightPanels();
      const onResize = debounce(() => {
        ensureRightTabs();
        refreshRightPanels();
      }, 200);
      window.addEventListener('resize', onResize);
      window.addEventListener('orientationchange', onResize);
      window.addEventListener('hashchange', () => { setTimeout(refreshRightPanels, 60); });
    }

    function refreshRightPanels() {
      applyFootnoteLayout();
      renderCommentsPanel();
      if (SIDENOTES_ON) {
        renderSidenotes(currentRightTab());
      }
      enumerateReadingNodes();
      scheduleReadingStateSave();
      scheduleScrollExtensionUpdate();
    }

    function ensureRightTabs() {
      const marginSidebar = document.getElementById('quarto-margin-sidebar');
      if (!marginSidebar) return;
      let wrapper = marginSidebar.querySelector('.right-switcher');
      if (!wrapper) {
        wrapper = document.createElement('div');
        wrapper.className = 'right-switcher';
        wrapper.innerHTML = `
        <div class="toc-tabs">
          <button type="button" class="toc-tab" data-tab="footnotes">脚注</button>
          <button type="button" class="toc-tab" data-tab="comments">ｺﾒﾝﾄ</button>
          <button type="button" class="toc-tab" data-tab="both">両方</button>
        </div>
        <div class="toc-panel right-footnotes"></div>
        <div class="toc-panel right-comments" style="display:none"></div>
        <div class="toc-panel right-both" style="display:none"></div>
      `;
        marginSidebar.innerHTML = '';
        marginSidebar.appendChild(wrapper);

        const tabs = wrapper.querySelectorAll('.toc-tab');
        tabs.forEach(btn => {
          btn.addEventListener('click', () => {
            activateRightTab(btn.dataset.tab || 'footnotes');
          });
        });
        const savedTab = getSavedRightTab();
        activateRightTab(savedTab, { skipSave: true });
        // 傍注表示は常に ON とする
        setSidenotesMode(true);
      } else {
        activateRightTab(getSavedRightTab(), { skipSave: true });
        // 既存 DOM 再利用時も傍注モードを維持
        if (!SIDENOTES_ON) setSidenotesMode(true);
      }
    }

    let SIDENOTES_ON = false;
    let SIDENOTES_ITEMS = [];

    function activateRightTab(tab, opts = {}) {
      const marginSidebar = document.getElementById('quarto-margin-sidebar');
      if (!marginSidebar) return;
      const wrapper = marginSidebar.querySelector('.right-switcher');
      if (!wrapper) return;
      const tabs = Array.from(wrapper.querySelectorAll('.toc-tab'));
      const normalized = ['footnotes', 'comments', 'both'].includes(tab) ? tab : 'both';
      tabs.forEach(btn => btn.classList.toggle('active', btn.dataset.tab === normalized));
      const footPanel = wrapper.querySelector('.right-footnotes');
      const commPanel = wrapper.querySelector('.right-comments');
      const bothPanel = wrapper.querySelector('.right-both');
      if (SIDENOTES_ON) {
        if (footPanel) footPanel.style.display = 'none';
        if (commPanel) commPanel.style.display = 'none';
        if (bothPanel) bothPanel.style.display = 'none';
        renderSidenotes(normalized);
      } else {
        if (footPanel) footPanel.style.display = normalized === 'footnotes' ? '' : 'none';
        if (commPanel) commPanel.style.display = normalized === 'comments' ? '' : 'none';
        if (bothPanel) bothPanel.style.display = normalized === 'both' ? '' : 'none';
      }
      if (!opts.skipSave) saveRightTab(normalized);
    }

    function currentRightTab() {
      const active = document.querySelector('#quarto-margin-sidebar .toc-tab.active');
      if (active) return active.getAttribute('data-tab') || 'footnotes';
      return getSavedRightTab();
    }

    function setSidenotesMode(on) {
      const ms = document.getElementById('quarto-margin-sidebar');
      if (!ms) return;
      const foot = ms.querySelector('.right-footnotes');
      const comm = ms.querySelector('.right-comments');
      const both = ms.querySelector('.right-both');
      SIDENOTES_ON = !!on;
      if (SIDENOTES_ON) {
        ms.classList.add('sidenotes-on');
        if (foot) foot.style.display = 'none';
        if (comm) comm.style.display = 'none';
        if (both) both.style.display = 'none';
        renderSidenotes(currentRightTab());
        window.addEventListener('scroll', updateSidenotesPositions, { passive: true });
        window.addEventListener('resize', updateSidenotesPositions);
      } else {
        ms.classList.remove('sidenotes-on');
        clearSidenotes();
        window.removeEventListener('scroll', updateSidenotesPositions);
        window.removeEventListener('resize', updateSidenotesPositions);
        activateRightTab(currentRightTab(), { skipSave: true });
      }
    }

    function clearSidenotes() {
      const ms = document.getElementById('quarto-margin-sidebar');
      ms.querySelectorAll('.margin-note').forEach(n => n.remove());
      SIDENOTES_ITEMS = [];
    }

    function renderSidenotes(mode) {
      clearSidenotes();
      const ms = document.getElementById('quarto-margin-sidebar');
      if (!ms) return;
      const makeNote = (opts) => {
        const note = document.createElement('div');
        note.className = 'margin-note' + (opts.kind === 'comment' ? ' comment' : '');
        note.innerHTML = `
        <div class=\"meta\"><span>${opts.time || ''}</span>${opts.moveHtml || ''}${opts.showMenu ? '<button class="menu" title="メニュー" style="margin-left:auto;background:none;border:none;cursor:pointer;font-size:16px;line-height:1;">⋯</button>' : ''}</div>
        ${opts.targetHtml || ''}
        <div class=\"body\">${opts.bodyHtml || ''}</div>
      `;
        ms.appendChild(note);
        return note;
      };

      const footnotes = gatherActiveFootnotes();
      const comments = gatherActiveCommentsWithElements();

      const entries = [];
      if (mode !== 'comments') {
        footnotes.forEach(fn => {
          if (!fn.ref) return;
          entries.push({ kind: 'foot', el: fn.ref, def: fn.li, label: fn.number });
        });
      }
      if (mode !== 'footnotes') {
        comments.forEach(item => {
          if (!item.el) return;
          entries.push({ kind: 'comment', el: item.el, rec: item.rec });
        });
      }

      SIDENOTES_ITEMS = entries.map(entry => {
        if (entry.kind === 'comment') {
          const rec = entry.rec;
          const note = makeNote({
            kind: 'comment',
            time: fmtMMDDHHmm(rec.t),
            moveHtml: `<a href="#" class="mv">移動</a>`,
            targetHtml: `<div class="target">${escapeHtml((rec.text || '').slice(0, 80))}</div>`,
            bodyHtml: escapeHtml(rec.body || ''),
            showMenu: true
          });
          note.querySelector('.mv')?.addEventListener('click', (e) => { e.preventDefault(); scrollToComment(rec); });
          note.querySelector('.menu')?.addEventListener('click', (e) => { e.stopPropagation(); openCommentMenu(note, rec, { x: e.clientX, y: e.clientY }); });
          return { kind: 'comment', el: entry.el, node: note };
        } else {
          // 脚注の傍注では、元の脚注HTMLを元にクローンを作り、
          // 先頭に [番号] スパンを 1 個だけ挿入して同一行に表示する
          let bodyHtml = '';
          if (entry.def) {
            const clone = entry.def.cloneNode(true);
            clone.querySelectorAll('.footnote-back, .footnote-backref, [role="doc-backlink"]').forEach(a => a.remove());
            const hasNum = clone.querySelector('.footnote-num');
            if (!hasNum) {
              const numSpan = document.createElement('span');
              numSpan.className = 'footnote-num';
              const labelText = (entry.label && String(entry.label).trim().length)
                ? String(entry.label).trim()
                : '';
              numSpan.textContent = labelText ? (labelText + '. ') : '';
              clone.insertBefore(numSpan, clone.firstChild);
            }
            bodyHtml = clone.innerHTML;
          }
          const note = makeNote({
            kind: 'foot',
            bodyHtml: bodyHtml,
            moveHtml: '',
            showMenu: false
          });
          note.querySelector('.menu')?.remove();
          return { kind: 'foot', el: entry.el, node: note };
        }
      });

      updateSidenotesPositions();
      reinforceAnchors(ms);
    }

    function rightSidebarBaseOffset() {
      const ms = document.getElementById('quarto-margin-sidebar');
      if (!ms) return 0;
      const switcher = ms.querySelector('.right-switcher');
      return switcher ? switcher.offsetHeight + 12 : 0;
    }

    function updateSidenotesPositions() {
      if (!SIDENOTES_ON) return;
      const ms = document.getElementById('quarto-margin-sidebar');
      if (!ms) return;
      const msRect = ms.getBoundingClientRect();
      const viewH = window.innerHeight || document.documentElement.clientHeight || 0;
      const msHeight = ms.clientHeight || (viewH || 0);
      if (!msHeight) return;
      const buffer = viewH || msHeight; // 1画面分のバッファ
      const baseOffset = rightSidebarBaseOffset();

      // アンカー位置に応じて傍注の理想位置を決める
      const entries = SIDENOTES_ITEMS
        .filter(item => item.el && item.node && item.el.getClientRects().length)
        .map(item => {
          const rect = item.el.getBoundingClientRect();
          const node = item.node;
          const nodeHeight = node.offsetHeight || 0;
          // アンカーの上端を右パネル座標系に合わせる
          const anchorTopInSidebar = rect.top - msRect.top;
          // 傍注はタブ行の直下から並ぶので baseOffset を足す
          const desiredTop = anchorTopInSidebar + baseOffset;
          return { item, desiredTop, nodeHeight };
        })
        .sort((a, b) => a.desiredTop - b.desiredTop);

      // ノート同士が重ならないように、手前のノートの下に最小限だけずらして配置する。
      // アンカーが画面外に出ていっても entries からは除外しないことで、
      // 上のノートが非表示になった瞬間に下のノートが大きくジャンプすることを防ぐ。
      const gap = 4;
      let cursor = -Infinity;
      entries.forEach(({ item, desiredTop, nodeHeight }) => {
        const node = item.node;
        if (!node) return;
        const height = nodeHeight || node.offsetHeight || 0;
        // 直前のノートの直下までは押し下げるが、それ以上はアンカーに追随
        const top = Math.max(desiredTop, cursor);
        const bottom = top + height;
        // 1画面分のバッファを考慮し、完全に表示範囲から外れたときだけ非表示にする
        const visible = bottom > (baseOffset - buffer) && top < (msHeight + buffer);
        if (!visible) {
          node.style.display = 'none';
          return;
        }
        node.style.display = 'block';
        node.style.top = top + 'px';
        cursor = top + height + gap;
      });
    }

    function applyFootnoteLayout() {
      const inlineQuery = window.matchMedia(`(max-width: ${FOOTNOTE_INLINE_BREAKPOINT}px)`);
      const shouldInline = inlineQuery.matches || window.innerWidth <= FOOTNOTE_INLINE_BREAKPOINT;
      const nextMode = shouldInline ? 'inline' : 'sidebar';
      if (currentFootnoteLayout !== nextMode) {
        currentFootnoteLayout = nextMode;
        document.body && document.body.classList.toggle('footnotes-inline-mode', shouldInline);
        document.body && document.body.classList.toggle('footnotes-sidebar-mode', !shouldInline);
        if (shouldInline) {
          renderInlineFootnotes();
        } else {
          renderSidebarFootnotes();
        }
      } else if (shouldInline) {
        renderInlineFootnotes();
      } else {
        renderSidebarFootnotes();
      }
      try {
        if (document.body) {
          document.body.classList.add('js-footnotes-enhanced');
        }
      } catch (e) {
        console.warn('applyFootnoteLayout: failed to mark enhanced footnotes state', e);
      }
    }

    function renderSidebarFootnotes() {
      setInlineFootnoteMode(false);
      document.querySelectorAll('.footnote-inline').forEach(n => n.remove());
      let marginSidebar = document.getElementById('quarto-margin-sidebar');
      if (!marginSidebar) return;

      if (marginSidebar.style.display === 'none') {
        const prev = marginSidebar.dataset.prevDisplay || '';
        marginSidebar.style.display = prev;
        delete marginSidebar.dataset.prevDisplay;
      }

      if (!marginSidebar.querySelector('.right-switcher')) {
        ensureRightTabs();
        marginSidebar = document.getElementById('quarto-margin-sidebar');
      }

      let footHost = marginSidebar.querySelector('.right-footnotes');
      if (!footHost) {
        footHost = document.createElement('div');
        footHost.className = 'toc-panel right-footnotes';
        marginSidebar.appendChild(footHost);
      }

      let bothHost = marginSidebar.querySelector('.right-both');
      if (!bothHost) {
        bothHost = document.createElement('div');
        bothHost.className = 'toc-panel right-both';
        bothHost.style.display = 'none';
        marginSidebar.appendChild(bothHost);
      }

      footHost.innerHTML = '';
      if (bothHost) bothHost.innerHTML = '';

      const headerRow = document.createElement('div');
      headerRow.style.cssText = 'display:flex;align-items:center;justify-content:space-between;margin-bottom:6px;';
      const header = document.createElement('h2');
      header.className = 'footnotes-title';
      header.textContent = '脚注';
      const sort = document.createElement('select');
      sort.innerHTML = '<option value="pos">本文位置順</option><option value="num">番号順</option>';
      sort.value = localStorage.getItem('footnotes-sort') || 'pos';
      sort.addEventListener('change', () => { localStorage.setItem('footnotes-sort', sort.value); renderSidebarFootnotes(); });
      headerRow.appendChild(header); headerRow.appendChild(sort);
      footHost.appendChild(headerRow);

      const footnotes = gatherActiveFootnotes();
      if (!footnotes.length) {
        footHost.insertAdjacentHTML('beforeend', '<p class="footnotes-empty">このページには脚注がありません。</p>');
        if (bothHost) bothHost.insertAdjacentHTML('beforeend', '<p class="footnotes-empty">このページには脚注/コメントがありません。</p>');
        return;
      }

      const items = footnotes.slice();
      const mode = sort.value;
      const getSortableNumber = (item) => {
        const primary = Number(item.number);
        if (!Number.isNaN(primary)) return primary;
        const fallbackFromId = Number(String(item.id || '').replace(/[^0-9]+/g, ''));
        if (!Number.isNaN(fallbackFromId)) return fallbackFromId;
        return Number.POSITIVE_INFINITY;
      };
      if (mode === 'pos') {
        items.sort((a, b) => a.pos - b.pos);
      } else {
        items.sort((a, b) => {
          const numA = getSortableNumber(a);
          const numB = getSortableNumber(b);
          if (numA !== numB) return numA - numB;
          const labelA = (a.number || '').toString();
          const labelB = (b.number || '').toString();
          const cmpLabel = labelA.localeCompare(labelB, undefined, { numeric: true, sensitivity: 'base' });
          if (cmpLabel !== 0) return cmpLabel;
          return (a.id || '').localeCompare(b.id || '');
        });
      }

      const wrapper = document.createElement('div');
      wrapper.className = 'margin-footnotes';
      const ol = document.createElement('ol');
      items.forEach((it, idx) => {
        const clone = it.li.cloneNode(true);
        const displayLabel = (it.number && String(it.number).trim().length) ? String(it.number).trim() : String(idx + 1);
        if (!clone.querySelector('.footnote-num')) {
          const num = document.createElement('span');
          num.className = 'footnote-num';
          num.textContent = displayLabel + '. ';
          clone.insertBefore(num, clone.firstChild);
        }
        it.number = displayLabel;
        it.displayIndex = displayLabel;
        it.clone = clone;
        ol.appendChild(clone);
      });
      wrapper.appendChild(ol);
      footHost.appendChild(wrapper);
      reinforceAnchors(footHost);

      // 両方タブ: コメントと脚注を本文位置で混在
      if (bothHost) {
        renderBothPanel(bothHost, items);
        reinforceAnchors(bothHost);
      }

      setupScrollSyncForFootnotes(footHost, items);
      refreshCommentMarkersFromDB({ preserveExisting: true });
      scheduleScrollExtensionUpdate();
    }

    function renderBothPanel(host, footItems) {
      const commentAnchors = gatherActiveCommentsWithElements();
      const commItems = commentAnchors.map(({ rec, el }) => {
        const rect = el ? el.getBoundingClientRect() : null;
        const top = rect ? (rect.top + window.scrollY) : Infinity;
        return { type: 'comment', top, rec };
      });
      const footMixed = (footItems || []).map((f) => ({
        type: 'foot',
        top: f.pos,
        id: f.id,
        displayIndex: f.displayIndex,
        number: f.number,
        clone: f.li.cloneNode(true)
      }));
      const merged = commItems.concat(footMixed).sort((a, b) => a.top - b.top);

      host.innerHTML = '';
      const header = document.createElement('h2');
      header.className = 'footnotes-title';
      header.textContent = '両方';
      host.appendChild(header);

      const list = document.createElement('div');
      list.className = 'both-mixed-list';
      list.style.cssText = 'display:flex; flex-direction:column; gap:8px;';

      merged.forEach(item => {
        if (item.type === 'comment') {
          const rec = item.rec;
          const card = document.createElement('div');
          card.className = 'comment-card';
          card.style.cssText = 'padding:10px;background:#fff;border-radius:6px;border-left:3px solid #ff9800;box-shadow:0 1px 3px rgba(0,0,0,0.08);';
          const meta = document.createElement('div');
          meta.className = 'comment-meta';
          meta.style.cssText = 'font-size:12px;color:#6c757d;margin-bottom:6px;display:flex;gap:8px;align-items:center;';
          const t = document.createElement('span');
          t.textContent = fmtMMDDHHmm(rec.t);
          const move = document.createElement('a');
          move.href = '#';
          move.textContent = '移動';
          move.addEventListener('click', (e) => { e.preventDefault(); scrollToComment(rec); });
          meta.appendChild(t);
          meta.appendChild(move);
          const target = document.createElement('div');
          target.className = 'comment-snippet';
          target.style.cssText = 'font-size:13px;color:#495057;background:#fff3e0;padding:6px 8px;border-radius:4px;margin-bottom:6px;';
          target.textContent = rec.text || '';
          const body = document.createElement('div');
          body.className = 'comment-body';
          body.style.cssText = 'white-space:pre-wrap; line-height:1.5;';
          body.textContent = rec.body || '';
          card.appendChild(meta);
          card.appendChild(target);
          card.appendChild(body);
          list.appendChild(card);
        } else {
          const wrapper = document.createElement('div');
          wrapper.className = 'both-footnote-card';
          wrapper.style.cssText = 'padding:10px;background:#fff;border-radius:6px;border-left:3px solid #6c757d;box-shadow:0 1px 3px rgba(0,0,0,0.06);';
          const clone = item.clone;
          if (!clone.querySelector('.footnote-num')) {
            const num = document.createElement('span');
            num.className = 'footnote-num';
            const label = (item.displayIndex && String(item.displayIndex).trim().length)
              ? String(item.displayIndex).trim()
              : (item.number && String(item.number).trim().length)
                ? String(item.number).trim()
                : String(footMixed.indexOf(item) + 1);
            num.textContent = label + '. ';
            clone.insertBefore(num, clone.firstChild);
          }
          wrapper.appendChild(clone);
          list.appendChild(wrapper);
        }
      });
      host.appendChild(list);
      reinforceAnchors(list);
      setupScrollSyncForBoth(host, merged);
    }

    // 本文側のスクロール位置と右パネル内部スクロールの同期ユーティリティ
    function computeScrollRatioFromPositions(positions) {
      if (!Array.isArray(positions) || !positions.length) return null;
      let minPos = Infinity;
      let maxPos = -Infinity;
      positions.forEach(p => {
        if (typeof p !== 'number' || !isFinite(p)) return;
        if (p < minPos) minPos = p;
        if (p > maxPos) maxPos = p;
      });
      if (!isFinite(minPos) || !isFinite(maxPos)) return null;

      const scrollY = window.scrollY || window.pageYOffset || document.documentElement.scrollTop || 0;
      const viewH = window.innerHeight || document.documentElement.clientHeight || 0;
      const center = scrollY + viewH / 2;

      if (maxPos === minPos) {
        return center <= minPos ? 0 : 1;
      }
      let ratio = (center - minPos) / (maxPos - minPos);
      if (ratio < 0) ratio = 0;
      else if (ratio > 1) ratio = 1;
      return ratio;
    }

    function scrollRightSidebarToRatio(ratio, host) {
      if (ratio == null) return;
      const container = document.getElementById('quarto-margin-sidebar') || host;
      if (!container) return;
      const maxScroll = container.scrollHeight - container.clientHeight;
      if (!(maxScroll > 0)) return;
      const clamped = Math.max(0, Math.min(1, ratio));
      container.scrollTop = maxScroll * clamped;
    }

    function setupScrollSyncForFootnotes(host, items) {
      const mode = localStorage.getItem('footnotes-sort') || 'pos';
      if (mode !== 'pos') return;
      if (!Array.isArray(items) || !items.length) return;
      const positions = items
        .map(it => (typeof it.pos === 'number' ? it.pos : null))
        .filter(p => typeof p === 'number' && isFinite(p));
      if (!positions.length) return;

      const onScroll = () => {
        const ratio = computeScrollRatioFromPositions(positions);
        scrollRightSidebarToRatio(ratio, host);
      };
      window.addEventListener('scroll', onScroll, { passive: true });
    }

    function setupScrollSyncForBoth(host, items) {
      const onScroll = () => {
        if (!Array.isArray(items) || !items.length) return;
        const positions = items
          .map(it => (typeof it.top === 'number' ? it.top : null))
          .filter(p => typeof p === 'number' && isFinite(p));
        const ratio = computeScrollRatioFromPositions(positions);
        scrollRightSidebarToRatio(ratio, host);
      };
      window.addEventListener('scroll', onScroll, { passive: true });
    }

    function renderCommentsPanel() {
      const marginSidebar = document.getElementById('quarto-margin-sidebar');
      if (!marginSidebar) return;
      const commHost = marginSidebar.querySelector('.right-comments');
      if (!commHost) return;
      const list = getActiveComments();
      commHost.innerHTML = '';

      const header = document.createElement('div');
      header.style.cssText = 'display:flex;align-items:center;justify-content:space-between;margin-bottom:6px;';
      const title = document.createElement('h2');
      title.className = 'footnotes-title';
      title.textContent = 'コメント';
      const sort = document.createElement('select');
      sort.innerHTML = '<option value="new">新しい順</option><option value="pos">本文位置順</option><option value="old">古い順</option>';
      sort.value = localStorage.getItem('comments-sort') || 'new';
      sort.addEventListener('change', () => { localStorage.setItem('comments-sort', sort.value); renderCommentsPanel(); });
      header.appendChild(title); header.appendChild(sort);
      commHost.appendChild(header);

      if (!list.length) { commHost.insertAdjacentHTML('beforeend', '<p class="footnotes-empty">コメントはありません。</p>'); return; }

      const computePos = (rec) => {
        const el = findCommentAnchorElement(rec);
        const top = el ? (el.getBoundingClientRect().top + window.scrollY) : Infinity;
        return top;
      };

      let arr = list.slice();
      const mode = sort.value;
      if (mode === 'new') arr.sort((a, b) => b.t - a.t);
      else if (mode === 'old') arr.sort((a, b) => a.t - b.t);
      else if (mode === 'pos') arr.sort((a, b) => computePos(a) - computePos(b));

      const ul = document.createElement('ul');
      ul.className = 'comment-list';
      ul.style.listStyle = 'none'; ul.style.padding = '0'; ul.style.margin = '0';

      arr.forEach(rec => {
        const li = document.createElement('li');
        li.dataset.id = rec.id;
        li.className = 'comment-item';
        li.style.cssText = 'margin:12px 0; padding:10px; background:#fff; border-radius:6px; border-left:3px solid #6c757d; box-shadow:0 1px 3px rgba(0,0,0,0.08); position:relative;';
        const meta = document.createElement('div');
        meta.className = 'comment-meta';
        meta.style.cssText = 'font-size:12px; color:#6c757d; margin-bottom:6px; display:flex; gap:8px; align-items:center;';
        const time = fmtMMDDHHmm(rec.t);
        const move = document.createElement('a');
        move.href = '#'; move.textContent = '移動';
        move.addEventListener('click', (e) => { e.preventDefault(); scrollToComment(rec); });
        const menuBtn = document.createElement('button');
        menuBtn.textContent = '⋯';
        menuBtn.setAttribute('aria-label', 'メニュー');
        menuBtn.style.cssText = 'margin-left:auto;background:none;border:none;cursor:pointer;font-size:18px;line-height:1;';
        menuBtn.addEventListener('click', (e) => { e.stopPropagation(); openCommentMenu(li, rec, { x: e.clientX, y: e.clientY }); });
        meta.innerHTML = `<span>${time}</span>`;
        meta.appendChild(move);
        meta.appendChild(menuBtn);

        const target = document.createElement('div');
        target.className = 'comment-snippet';
        target.style.cssText = 'font-size:13px; color:#495057; background:#f8f9fa; padding:6px 8px; border-radius:4px; margin-bottom:6px;';
        target.textContent = rec.text || '';
        const body = document.createElement('div');
        body.className = 'comment-body';
        body.style.cssText = 'white-space:pre-wrap; line-height:1.5;';
        body.textContent = rec.body || '';
        li.appendChild(meta); li.appendChild(target); li.appendChild(body);
        ul.appendChild(li);
      });

      commHost.appendChild(ul);
      setupScrollSyncForComments(commHost, arr);
    }

    let commentMenuCleanup = null;

    function openCommentMenu(li, rec, pt) {
      closeAnyInlineMenu();
      const menu = document.createElement('div');
      menu.className = 'comment-menu-popup';
      menu.style.cssText = 'position:fixed; background:#fff; border:1px solid #e1e5eb; box-shadow:0 4px 12px rgba(0,0,0,0.12); border-radius:6px; z-index:10001; padding:6px;';
      menu.innerHTML = '<button type="button" data-act="edit" style="display:block;width:100%;text-align:left;padding:6px 10px;background:none;border:none;cursor:pointer;">編集</button>\n<button type="button" data-act="del" style="display:block;width:100%;text-align:left;padding:6px 10px;background:none;border:none;cursor:pointer;">削除</button>';
      document.body.appendChild(menu);
      const x = pt?.x || (li.getBoundingClientRect().right - 10);
      const y = pt?.y || (li.getBoundingClientRect().top + 20);
      menu.style.left = x + 'px';
      menu.style.top = y + 'px';
      const onDoc = (e) => { if (!menu.contains(e.target)) { closeAnyInlineMenu(); } };
      const onViewportChange = () => closeAnyInlineMenu();
      document.addEventListener('mousedown', onDoc, true);
      window.addEventListener('scroll', onViewportChange, true);
      window.addEventListener('resize', onViewportChange);
      commentMenuCleanup = () => {
        document.removeEventListener('mousedown', onDoc, true);
        window.removeEventListener('scroll', onViewportChange, true);
        window.removeEventListener('resize', onViewportChange);
        commentMenuCleanup = null;
      };
      menu.addEventListener('click', (e) => {
        const act = e.target?.getAttribute('data-act');
        if (act === 'edit') editComment(rec);
        if (act === 'del') deleteComment(rec);
        closeAnyInlineMenu();
      });
    }

    function closeAnyInlineMenu() {
      document.querySelectorAll('.comment-menu-popup').forEach(n => n.remove());
      if (typeof commentMenuCleanup === 'function') {
        commentMenuCleanup();
      }
    }

    function editComment(rec) {
      const overlay = document.createElement('div');
      overlay.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.4);z-index:10000;display:flex;align-items:center;justify-content:center;';
      const dialog = document.createElement('div');
      dialog.style.cssText = 'background:#fff;color:#222;max-width:600px;width:92%;padding:16px;border-radius:8px;box-shadow:0 10px 30px rgba(0,0,0,0.25);';
      dialog.innerHTML = `
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
        <h3 style="margin:0;font-size:16px;">コメント編集</h3>
        <button type=\"button\" aria-label=\"閉じる\" style=\"background:none;border:none;font-size:18px;cursor:pointer;\">×</button>
      </div>
      <div style="font-size:13px;color:#555;background:#f8f9fa;border:1px solid #e9ecef;padding:8px;border-radius:4px;margin-bottom:8px;">対象: ${(rec.text || '').slice(0, 140)}</div>
      <textarea id="comment-edit-area" rows="6" style="width:100%;font-size:14px;padding:8px;border-radius:6px;border:1px solid #ced4da;resize:vertical;">${(rec.body || '')}</textarea>
      <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:10px;">
        <button type="button" id="comment-edit-cancel" style="padding:6px 12px;border:1px solid #dee2e6;border-radius:4px;background:#f8f9fa;cursor:pointer;">キャンセル</button>
        <button type="button" id="comment-edit-save" style="padding:6px 12px;border:1px solid #0d6efd;border-radius:4px;background:#0d6efd;color:#fff;cursor:pointer;">保存</button>
      </div>
    `;
      overlay.appendChild(dialog);
      document.body.appendChild(overlay);
      const close = () => {
        overlay.remove();
        document.removeEventListener('keydown', onKey);
      };
      const onKey = (evt) => {
        if (evt.key === 'Escape') {
          evt.preventDefault();
          close();
        }
      };
      dialog.querySelector('[aria-label="閉じる"]').addEventListener('click', close);
      dialog.querySelector('#comment-edit-cancel').addEventListener('click', close);
      overlay.addEventListener('click', (evt) => {
        if (evt.target === overlay) {
          close();
        }
      });
      document.addEventListener('keydown', onKey);
      const editTextarea = dialog.querySelector('#comment-edit-area');
      const editSaveBtn = dialog.querySelector('#comment-edit-save');
      editSaveBtn.addEventListener('click', () => {
        if (editSaveBtn.disabled) return;
        const v = (editTextarea.value || '').trim();
        if (!v) { editTextarea.focus(); return; }
        editSaveBtn.disabled = true;
        const originalLabel = editSaveBtn.textContent;
        editSaveBtn.textContent = '保存中…';
        let success = false;
        try {
          const key = pageKey();
          const arr = COMMENTS_DB[key] || [];
          const idx = arr.findIndex(x => x.id === rec.id);
          if (idx >= 0) {
            arr[idx].body = v;
            arr[idx].t = Date.now();
            COMMENTS_DB[key] = arr;
            saveComments();
            refreshRightPanels();
            refreshCommentMarkersFromDB();
          }
          success = true;
        } catch (error) {
          console.warn('Failed to update comment', error);
        }
        if (success) {
          Promise.resolve().then(() => {
            closeAnyInlineMenu();
            close();
          });
        } else {
          editSaveBtn.disabled = false;
          editSaveBtn.textContent = originalLabel;
        }
      });
    }

    function deleteComment(rec) {
      closeAnyInlineMenu();
      if (!confirm('このコメントを削除しますか？')) return;
      const key = pageKey();
      const arr = COMMENTS_DB[key] || [];
      COMMENTS_DB[key] = arr.filter(x => x.id !== rec.id);
      saveComments();
      // マーカーも削除
      document.querySelectorAll(`.text-marker[data-comment-id="${rec.id}"]`).forEach(el => {
        const p = el.parentNode; while (el.firstChild) p.insertBefore(el.firstChild, el); p.removeChild(el);
      });
      refreshCommentMarkersFromDB();
      refreshRightPanels();
    }

    function setupScrollSyncForComments(host, items) {
      const mode = localStorage.getItem('comments-sort') || 'new';
      if (mode !== 'pos') return;
      if (!Array.isArray(items) || !items.length) return;
      const positions = items
        .map(rec => {
          const el = findCommentAnchorElement(rec);
          if (!el) return null;
          const rect = el.getBoundingClientRect();
          return rect ? (rect.top + window.scrollY) : null;
        })
        .filter(p => typeof p === 'number' && isFinite(p));
      if (!positions.length) return;

      const onScroll = () => {
        const ratio = computeScrollRatioFromPositions(positions);
        scrollRightSidebarToRatio(ratio, host);
      };
      window.addEventListener('scroll', onScroll, { passive: true });
    }

    function scrollToComment(rec) {
      try {
        const first = (rec.ranges && rec.ranges[0]);
        if (!first) return;
        const node = getNodeByPathSafe(first.s);
        if (!node) return;
        let el = node.nodeType === Node.ELEMENT_NODE ? node : node.parentElement;
        while (el && el !== document.body && !(el instanceof HTMLElement)) el = el.parentElement;
        if (!el) return;
        el.scrollIntoView({ behavior: 'smooth', block: 'center' });
        const prev = el.style.boxShadow;
        el.style.transition = 'box-shadow 0.3s ease';
        el.style.boxShadow = '0 0 0 3px rgba(26,115,232,0.5)';
        setTimeout(() => { el.style.boxShadow = prev || ''; }, 1600);
      } catch (e) { console.warn('scrollToComment failed', e); }
    }

    function getNodeByPathSafe(path) {
      try { let n = document.body; for (const idx of path || []) { if (!n || !n.childNodes[idx]) return null; n = n.childNodes[idx]; } return n; } catch { return null; }
    }

    function renderInlineFootnotes() {
      setInlineFootnoteMode(true);
      const marginSidebar = document.getElementById('quarto-margin-sidebar');
      if (marginSidebar && marginSidebar.style.display !== 'none') {
        marginSidebar.dataset.prevDisplay = marginSidebar.style.display || '';
        marginSidebar.style.display = 'none';
      }
      document.querySelectorAll('.footnote-inline').forEach(n => n.remove());
      const active = getActiveChapterSection();
      const scope = active || document;
      const refSelector = 'a[role="doc-noteref"], a.footnote-ref';
      const refs = Array.from(scope.querySelectorAll(refSelector)).filter(ref => !active || active.contains(ref));
      if (!refs.length) return;
      const hostTailMap = new Map();
      refs.forEach(ref => {
        const href = ref.getAttribute('href') || ref.getAttribute('data-footnote-href');
        if (!href || !href.startsWith('#')) return;
        const id = href.slice(1);
        const target = document.getElementById(id);
        if (!target) return;
        if (active) {
          const section = target.closest('section.chapter-page');
          if (section && section !== active) return;
        }
        const numberText = (ref.textContent || '').replace(/[^0-9]/g, '') || '';
        const host = findHostParagraph(ref);
        if (!host) return;
        const clone = target.cloneNode(true);
        clone.querySelectorAll('.footnote-back, .footnote-backref, [role="doc-backlink"]').forEach(a => a.remove());
        const container = document.createElement('div');
        container.className = 'footnote-inline';
        const numSpan = document.createElement('span');
        numSpan.className = 'footnote-num';
        numSpan.textContent = (numberText ? numberText : '') + '. ';
        container.appendChild(numSpan);
        while (clone.firstChild) container.appendChild(clone.firstChild);
        const tail = hostTailMap.get(host);
        if (tail && tail.parentNode) {
          tail.insertAdjacentElement('afterend', container);
        } else {
          host.insertAdjacentElement('afterend', container);
        }
        hostTailMap.set(host, container);
        reinforceAnchors(container);
      });
      ensureCommentMarkerInteractions();
      scheduleScrollExtensionUpdate();
    }

    function findHostParagraph(el) {
      let p = el;
      while (p && p !== document.body) {
        if (p.tagName === 'P' || p.tagName === 'LI') return p;
        p = p.parentElement;
      }
      return null;
    }

    function debounce(fn, ms) {
      let t;
      return (...args) => { clearTimeout(t); t = setTimeout(() => fn.apply(this, args), ms); };
    }

    function setupMarkerFunctionality() {
      let markersDB = JSON.parse(localStorage.getItem(STORAGE_KEYS.markers) || '{}');
      let pendingSerializedRange = null;

      const handleSelectionEvent = (e) => {
        if (closestInteractive(e.target)) return;
        const sel = window.getSelection();
        if (!sel || sel.rangeCount === 0) {
          hideMarkerToolbar();
          pendingSerializedRange = null;
          return;
        }

        function getHeadingElements() {
          const scope = document.getElementById('quarto-document-content');
          if (!scope) return [];
          return scope.querySelectorAll('h1, h2, h3, h4, h5, h6');
        }

        function enumerateReadingNodes() { }

        function findReadableElement(node) {
          const scope = document.getElementById('quarto-document-content');
          if (!scope) return null;
          let current = node;
          while (current && current !== document.body) {
            if (current.tagName) {
              const tag = current.tagName.toLowerCase();
              if (['p', 'li', 'blockquote', 'pre', 'table', 'figure', 'dd', 'dt'].includes(tag)) {
                return current;
              }
            }
            current = current.parentElement;
          }
          return null;
        }

        function captureReadingState(options) {
          const opts = options || {};
          const headings = getHeadingElements();
          const docEl = document.documentElement;
          const body = document.body;
          const scrollTop = (docEl && docEl.scrollTop) || (body && body.scrollTop) || 0;
          const viewportHeight = window.innerHeight || docEl.clientHeight || 0;
          const viewportWidth = window.innerWidth || docEl.clientWidth || body.clientWidth || 0;
          const focusLine = scrollTop + viewportHeight * 0.35;
          let current = null;
          for (let i = 0; i < headings.length; i += 1) {
            const el = headings[i];
            const top = el.offsetTop;
            if (top <= focusLine) {
              current = el;
            } else {
              break;
            }
          }
          if (!current && headings.length) {
            current = headings[0];
          }
          const pageHeight = Math.max(1, (docEl && docEl.scrollHeight) || (body && body.scrollHeight) || 1) - viewportHeight;
          const pageRatio = pageHeight > 0 ? scrollTop / pageHeight : 0;
          const state = { pageRatio };
          const centerX = viewportWidth / 2;
          let focusNode = null;
          try {
            focusNode = document.elementFromPoint(centerX, viewportHeight * 0.4);
          } catch (e) {
            focusNode = null;
          }
          if (current) {
            const currentId = current.getAttribute('id') || current.getAttribute('data-anchor-id') || '';
            const next = current.nextElementSibling ? current.nextElementSibling.closest('h1, h2, h3, h4, h5, h6') : null;
            let nextTop = null;
            if (next) {
              nextTop = next.offsetTop;
            } else {
              nextTop = (docEl && docEl.scrollHeight) || (body && body.scrollHeight) || (current.offsetTop + viewportHeight);
            }
            const currentTop = current.offsetTop;
            const sectionHeight = Math.max(1, nextTop - currentTop);
            const rel = (focusLine - currentTop) / sectionHeight;
            if (currentId) {
              state.sectionId = currentId;
              state.sectionOffset = Math.min(0.995, Math.max(0, rel));
            }
          }
          const focusElement = findReadableElement(focusNode);
          if (focusElement) {
            const rect = focusElement.getBoundingClientRect();
            const elementHeight = Math.max(1, rect.height || focusElement.offsetHeight || 1);
            const elementTop = focusElement.offsetTop;
            const relInElement = Math.min(0.995, Math.max(0, (focusLine - elementTop) / elementHeight));
            state.focusElementOffset = relInElement;
            const id = focusElement.getAttribute('id') || focusElement.getAttribute('data-anchor-id') || '';
            if (id) state.focusElementId = id;
            if (opts.captureNodeRef) {
              state.__focusNode = focusElement;
            }
          }
          return state;
        }

        function scrollToReadingState(state) {
          if (!state) return false;
          const docEl = document.documentElement;
          const body = document.body;
          const viewportHeight = window.innerHeight || docEl.clientHeight || 0;
          const focusRatio = typeof state.focusElementOffset === 'number' ? state.focusElementOffset : null;
          const resolveFocusTarget = () => {
            if (state.__focusNode && state.__focusNode instanceof HTMLElement && document.body.contains(state.__focusNode)) {
              return state.__focusNode;
            }
            if (state.focusElementId) {
              return document.getElementById(state.focusElementId) || document.querySelector(`[data-anchor-id="${state.focusElementId}"]`);
            }
            return null;
          };
          const focusTarget = resolveFocusTarget();
          if (focusTarget) {
            const ratio = focusRatio != null ? focusRatio : 0.35;
            const targetTop = focusTarget.offsetTop + ratio * Math.max(1, focusTarget.offsetHeight || 1);
            const desired = targetTop - viewportHeight * 0.35;
            window.scrollTo({ top: Math.max(0, desired), behavior: 'auto' });
            return true;
          }
          if (state.sectionId) {
            const selector = `#${escapeCssId(state.sectionId)}`;
            let target = document.querySelector(selector);
            if (!target) {
              target = document.querySelector(`[data-anchor-id="${state.sectionId}"]`);
            }
            if (target) {
              const headings = Array.from(getHeadingElements());
              const idx = headings.indexOf(target);
              let nextTop = null;
              if (idx >= 0 && idx + 1 < headings.length) {
                nextTop = headings[idx + 1].offsetTop;
              } else {
                nextTop = (docEl && docEl.scrollHeight) || (body && body.scrollHeight) || (target.offsetTop + viewportHeight);
              }
              const currentTop = target.offsetTop;
              const sectionHeight = Math.max(1, nextTop - currentTop);
              const rel = typeof state.sectionOffset === 'number' ? state.sectionOffset : 0;
              const dest = currentTop + rel * sectionHeight;
              window.scrollTo({ top: Math.max(0, dest), behavior: 'auto' });
              return true;
            }
          }
          if (typeof state.pageRatio === 'number') {
            const docHeight = Math.max(1, ((docEl && docEl.scrollHeight) || (body && body.scrollHeight) || 1) - viewportHeight);
            const targetY = state.pageRatio * docHeight;
            window.scrollTo({ top: Math.max(0, targetY), behavior: 'auto' });
            return true;
          }
          return false;
        }

        function escapeCssId(id) {
          if (window.CSS && typeof window.CSS.escape === 'function') {
            return window.CSS.escape(id);
          }
          return id.replace(/[^a-zA-Z0-9_\-]/g, '\\$&');
        }

        function restoreReadingState() {
          let raw = null;
          try {
            raw = sessionStorage.getItem(STORAGE_KEYS.readingState);
          } catch (e) {
            raw = null;
          }
          if (!raw) return;
          let state = null;
          try {
            state = JSON.parse(raw);
          } catch (e) {
            state = null;
          }
          scrollToReadingState(state);
        }

        function persistReadingState() {
          let state = null;
          try {
            state = captureReadingState();
          } catch (e) {
            state = null;
          }
          if (!state) return;
          try {
            sessionStorage.setItem(STORAGE_KEYS.readingState, JSON.stringify(state));
          } catch (e) {
            // ignore
          }
        }

        function scheduleReadingStateSave() {
          if (readingStateSaveTimer) return;
          readingStateSaveTimer = window.setTimeout(() => {
            readingStateSaveTimer = null;
            persistReadingState();
          }, 500);
        }
        const text = sel.toString().trim();
        if (text) {
          const rect = getSelectionRect(sel);
          const fallbackPoint = { x: e.clientX, y: e.clientY };
          try {
            pendingSerializedRange = serializeRange(sel.getRangeAt(0));
          } catch {
            pendingSerializedRange = null;
          }
          showMarkerToolbar(rect, fallbackPoint);
        } else {
          hideMarkerToolbar();
          pendingSerializedRange = null;
        }
      };

      // テキスト選択でツールバーを表示（UI要素上は無効）
      document.addEventListener('mouseup', handleSelectionEvent);
      document.addEventListener('touchend', handleSelectionEvent);

      function closestInteractive(el) {
        return el.closest('.marker-toolbar, .js-header, .global-search-dialog, #quarto-sidebar');
      }

      function getSelectionRect(selection) {
        if (!selection || selection.rangeCount === 0) return null;
        try {
          const range = selection.getRangeAt(0).cloneRange();
          const rect = range.getBoundingClientRect();
          if (rect && (rect.width || rect.height)) return rect;
          const rects = range.getClientRects();
          for (const r of rects) {
            if (r.width || r.height) return r;
          }
        } catch (err) {
          console.warn('getSelectionRect failed', err);
        }
        const focusContainer = selection.focusNode instanceof Element ? selection.focusNode : selection.focusNode?.parentElement;
        return focusContainer ? focusContainer.getBoundingClientRect() : null;
      }

      function showMarkerToolbar(rect, fallbackPoint) {
        let toolbar = document.querySelector('.marker-toolbar');
        if (!toolbar) {
          toolbar = createMarkerToolbar();
          document.body.appendChild(toolbar);
        }
        toolbar.classList.add('show');
        toolbar.style.display = 'flex';
        toolbar.style.flexDirection = 'column';
        toolbar.style.gap = '6px';
        toolbar.style.position = 'absolute';
        toolbar.style.removeProperty('right');
        toolbar.style.removeProperty('bottom');
        positionMarkerToolbar(toolbar, rect, fallbackPoint);
      }

      function positionMarkerToolbar(toolbar, rect, fallbackPoint) {
        requestAnimationFrame(() => {
          if (!toolbar.classList.contains('show')) return;
          let targetRect = rect;
          if (!targetRect || (!(targetRect.width || targetRect.height))) {
            if (fallbackPoint && typeof fallbackPoint.x === 'number' && typeof fallbackPoint.y === 'number') {
              targetRect = {
                top: fallbackPoint.y,
                bottom: fallbackPoint.y,
                left: fallbackPoint.x,
                right: fallbackPoint.x,
                width: 0,
                height: 0
              };
            } else {
              const vw = window.innerWidth || document.documentElement.clientWidth || 0;
              const vh = window.innerHeight || document.documentElement.clientHeight || 0;
              targetRect = {
                top: vh / 2,
                bottom: vh / 2,
                left: vw / 2,
                right: vw / 2,
                width: 0,
                height: 0
              };
            }
          }
          const scrollX = window.scrollX ?? window.pageXOffset ?? document.documentElement.scrollLeft ?? 0;
          const scrollY = window.scrollY ?? window.pageYOffset ?? document.documentElement.scrollTop ?? 0;
          const toolbarWidth = toolbar.offsetWidth;
          const toolbarHeight = toolbar.offsetHeight;
          const margin = 12;
          const viewportWidth = document.documentElement.clientWidth || window.innerWidth || toolbarWidth;
          const rectWidth = targetRect.width ?? (targetRect.right - targetRect.left) ?? 0;
          const rectCenterX = targetRect.left + rectWidth / 2;
          let left = scrollX + rectCenterX - toolbarWidth / 2;
          left = Math.max(scrollX + 8, Math.min(left, scrollX + viewportWidth - toolbarWidth - 8));
          const rectBottom = targetRect.bottom ?? (targetRect.top + targetRect.height) ?? targetRect.top;
          let top = scrollY + targetRect.top - toolbarHeight - margin;
          if (top < scrollY + 8) {
            top = scrollY + rectBottom + margin;
          }
          const viewportHeight = document.documentElement.clientHeight || window.innerHeight || toolbarHeight;
          const maxTop = scrollY + viewportHeight - toolbarHeight - 8;
          top = Math.min(top, maxTop);
          toolbar.style.left = `${Math.round(left)}px`;
          toolbar.style.top = `${Math.round(top)}px`;
        });
      }

      function createMarkerToolbar() {
        const toolbar = document.createElement('div');
        toolbar.className = 'marker-toolbar';
        toolbar.innerHTML = `
        <div class="marker-controls" role="toolbar" aria-label="ハイライト色選択">
          <div class="marker-colors">
            <button type="button" class="marker-color-btn" data-color="yellow" title="黄"></button>
            <button type="button" class="marker-color-btn" data-color="green" title="緑"></button>
            <button type="button" class="marker-color-btn" data-color="blue" title="青"></button>
            <button type="button" class="marker-color-btn" data-color="pink" title="ピンク"></button>
          </div>
          <button type="button" class="marker-comment-btn" title="選択範囲にコメント" aria-label="選択範囲にコメント"></button>
        </div>
      `;
        toolbar.querySelectorAll('.marker-color-btn').forEach(btn => {
          btn.addEventListener('click', () => {
            applyMarker(btn.dataset.color);
            hideMarkerToolbar();
          });
        });
        const commentBtn = toolbar.querySelector('.marker-comment-btn');
        if (commentBtn) {
          commentBtn.addEventListener('click', () => {
            openCommentDialog();
          });
        }
        return toolbar;
      }

      function openCommentDialog() {
        const selection = window.getSelection();
        let baseRange = null;
        if (selection && selection.rangeCount > 0 && selection.toString().trim()) {
          baseRange = selection.getRangeAt(0);
        } else if (pendingSerializedRange) {
          baseRange = deserializeRange(pendingSerializedRange);
        }
        if (!baseRange || baseRange.collapsed) return;

        const overlay = document.createElement('div');
        overlay.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.4);z-index:10000;display:flex;align-items:center;justify-content:center;';
        const dialog = document.createElement('div');
        dialog.style.cssText = 'background:#fff;color:#222;max-width:600px;width:92%;padding:16px;border-radius:8px;box-shadow:0 10px 30px rgba(0,0,0,0.25);';
        dialog.innerHTML = `
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
          <h3 style="margin:0;font-size:16px;">コメントを追加</h3>
          <button type="button" aria-label="閉じる" style="background:none;border:none;font-size:18px;cursor:pointer;">×</button>
        </div>
        <div style="font-size:13px;color:#555;background:#f8f9fa;border:1px solid #e9ecef;padding:8px;border-radius:4px;margin-bottom:8px;" id="comment-snippet"></div>
        <textarea id="comment-textarea" rows="6" style="width:100%;font-size:14px;padding:8px;border-radius:6px;border:1px solid #ced4da;resize:vertical;" placeholder="ここにコメントを入力（長文可）"></textarea>
        <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:10px;">
          <button type="button" id="comment-cancel" style="padding:6px 12px;border:1px solid #dee2e6;border-radius:4px;background:#f8f9fa;cursor:pointer;">キャンセル</button>
          <button type="button" id="comment-save" style="padding:6px 12px;border:1px solid #0d6efd;border-radius:4px;background:#0d6efd;color:#fff;cursor:pointer;">保存</button>
        </div>
      `;
        overlay.appendChild(dialog);
        document.body.appendChild(overlay);

        const close = () => overlay.remove();
        dialog.querySelector('button[aria-label="閉じる"]').addEventListener('click', close);
        dialog.querySelector('#comment-cancel').addEventListener('click', close);

        // 選択スニペット表示
        const snippet = baseRange.cloneContents().textContent || window.getSelection().toString();
        dialog.querySelector('#comment-snippet').textContent = `対象: ${snippet?.slice(0, 140) || ''}`;

        const saveBtn = dialog.querySelector('#comment-save');
        const commentTextarea = dialog.querySelector('#comment-textarea');
        const originalLabel = saveBtn.textContent;
        saveBtn.addEventListener('click', () => {
          if (saveBtn.disabled) return;
          const body = (commentTextarea.value || '').trim();
          if (!body) { commentTextarea.focus(); return; }
          const segs = getTextSegments(baseRange);
          if (!segs.length) { close(); return; }
          saveBtn.disabled = true;
          saveBtn.textContent = '保存中…';
          let saved = false;
          try {
            const serializedRanges = segs.map(seg => ({ s: getPath(seg.node), so: seg.start, e: getPath(seg.node), eo: seg.end }));
            const rec = { id: `comment-${Date.now()}-${Math.floor(Math.random() * 1000)}`, ranges: serializedRanges, text: snippet, body, t: Date.now(), slug: getCurrentChapterSlug() || null };
            const key = pageKey();
            if (!COMMENTS_DB[key]) COMMENTS_DB[key] = [];
            COMMENTS_DB[key].push(rec);
            saveComments();
            saved = true;
            segs.forEach(seg => {
              const span = document.createElement('span');
              span.className = 'text-marker marker-orange';
              span.setAttribute('data-comment-id', rec.id);
              applyColorStyles(span, 'orange');
              wrapBySplitText(seg.node, seg.start, seg.end, span);
            });
            ensureCommentMarkerInteractions();
            try {
              refreshRightPanels();
            } catch (panelError) {
              console.warn('Refresh right panels failed after comment', panelError);
            }
            hideMarkerToolbar();
            const selection = window.getSelection();
            if (selection && typeof selection.removeAllRanges === 'function') {
              selection.removeAllRanges();
            }
            pendingSerializedRange = null;
          } catch (error) {
            console.warn('Failed to save comment', error);
            saveBtn.disabled = false;
            saveBtn.textContent = originalLabel;
            return;
          }
          close();
        });
      }

      function applyMarker(color) {
        const selection = window.getSelection();
        let baseRange = null;
        if (selection && selection.rangeCount > 0 && selection.toString().trim()) {
          baseRange = selection.getRangeAt(0);
        } else if (pendingSerializedRange) {
          baseRange = deserializeRange(pendingSerializedRange);
        }
        if (!baseRange || baseRange.collapsed) return;

        const markerId = `marker-${Date.now()}-${Math.floor(Math.random() * 1000)}`;
        const segments = getTextSegments(baseRange);
        if (!segments.length) return;

        const serializedRanges = [];
        segments.forEach(seg => {
          // 分割済みサブレンジをスタイル付与
          const span = document.createElement('span');
          span.className = `text-marker marker-${color}`;
          span.setAttribute('data-marker-id', markerId);
          applyColorStyles(span, color);
          span.addEventListener('dblclick', () => removeMarkerGroup(markerId));
          span.addEventListener('contextmenu', (e) => { e.preventDefault(); cycleMarkerColorGroup(markerId); });

          // 信頼性の高いsplitTextベースのラップ（file://でも安定）
          const serialized = { s: getPath(seg.node), so: seg.start, e: getPath(seg.node), eo: seg.end };
          wrapBySplitText(seg.node, seg.start, seg.end, span);
          serializedRanges.push(serialized);
        });

        selection.removeAllRanges();

        const page = window.location.pathname;
        if (!markersDB[page]) markersDB[page] = [];
        markersDB[page].push({ id: markerId, color, ranges: serializedRanges, t: Date.now() });
        saveMarkers();
        pendingSerializedRange = null;
      }

      // 選択範囲に交差するテキストノードをサブレンジに分割
      function getTextSegments(range) {
        const segments = [];

        // ルートがテキストノードの場合を考慮
        if (range.commonAncestorContainer && range.commonAncestorContainer.nodeType === Node.TEXT_NODE) {
          const node = range.commonAncestorContainer;
          const start = (node === range.startContainer) ? range.startOffset : 0;
          const end = (node === range.endContainer) ? range.endOffset : (node.nodeValue || '').length;
          if (start !== end) segments.push({ node, start, end });
          return segments;
        }

        const walker = document.createTreeWalker(
          range.commonAncestorContainer,
          NodeFilter.SHOW_TEXT,
          {
            acceptNode: (node) => {
              try {
                return range.intersectsNode(node) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;
              } catch (e) {
                // フォールバック: compareBoundaryPoints
                if (!node.nodeValue) return NodeFilter.FILTER_REJECT;
                const r = document.createRange();
                r.selectNodeContents(node);
                const endVsStart = range.compareBoundaryPoints(Range.END_TO_START, r);
                if (endVsStart <= 0) return NodeFilter.FILTER_REJECT;
                const startVsEnd = range.compareBoundaryPoints(Range.START_TO_END, r);
                if (startVsEnd >= 0) return NodeFilter.FILTER_REJECT;
                return NodeFilter.FILTER_ACCEPT;
              }
            }
          }
        );

        let node;
        while ((node = walker.nextNode())) {
          let start = 0;
          let end = node.nodeValue.length;
          if (node === range.startContainer && range.startContainer.nodeType === Node.TEXT_NODE) start = range.startOffset;
          if (node === range.endContainer && range.endContainer.nodeType === Node.TEXT_NODE) end = range.endOffset;
          if (start !== end) segments.push({ node, start, end });
        }
        return segments;
      }

      function hideMarkerToolbar() {
        const toolbar = document.querySelector('.marker-toolbar');
        if (toolbar) {
          toolbar.classList.remove('show');
          toolbar.style.display = 'none';
        }
      }

      function removeMarkerGroup(markerId) {
        document.querySelectorAll(`.text-marker[data-marker-id="${markerId}"]`).forEach(el => {
          const parent = el.parentNode;
          while (el.firstChild) parent.insertBefore(el.firstChild, el);
          parent.removeChild(el);
        });
        const page = window.location.pathname;
        if (markersDB[page]) {
          markersDB[page] = markersDB[page].filter(m => m.id !== markerId);
          if (!markersDB[page].length) delete markersDB[page];
          saveMarkers();
        }
      }

      function clearAllMarkers() {
        document.querySelectorAll('.text-marker').forEach(n => {
          const parent = n.parentNode;
          while (n.firstChild) parent.insertBefore(n.firstChild, n);
          parent.removeChild(n);
        });
        delete markersDB[window.location.pathname];
        saveMarkers();
      }

      function cycleMarkerColorGroup(markerId) {
        const order = ['yellow', 'green', 'blue', 'pink'];
        const els = Array.from(document.querySelectorAll(`.text-marker[data-marker-id="${markerId}"]`));
        if (!els.length) return;
        const el = els[0];
        const current = order.find(c => el.classList.contains(`marker-${c}`)) || 'yellow';
        const next = order[(order.indexOf(current) + 1) % order.length];
        els.forEach(e => { order.forEach(c => e.classList.remove(`marker-${c}`)); e.classList.add(`marker-${next}`); applyColorStyles(e, next); });
        const page = window.location.pathname;
        const rec = (markersDB[page] || []).find(m => m.id === markerId);
        if (rec) { rec.color = next; saveMarkers(); }
      }

      function saveMarkers() { localStorage.setItem(STORAGE_KEYS.markers, JSON.stringify(markersDB)); }

      function restoreMarkers() {
        const page = window.location.pathname;
        const list = (markersDB[page] || []);
        list.forEach(m => {
          // 互換性: 古い形式 {range} を {ranges:[range]} に変換
          const ranges = m.ranges || (m.range ? [m.range] : []);
          ranges.forEach(rSerialized => {
            const tn = getNodeByPath(rSerialized.s);
            if (!tn || tn.nodeType !== Node.TEXT_NODE) return;
            const span = document.createElement('span');
            span.className = `text-marker marker-${m.color}`;
            span.setAttribute('data-marker-id', m.id);
            applyColorStyles(span, m.color);
            span.addEventListener('dblclick', () => removeMarkerGroup(m.id));
            span.addEventListener('contextmenu', (e) => { e.preventDefault(); cycleMarkerColorGroup(m.id); });
            wrapBySplitText(tn, rSerialized.so, rSerialized.eo, span);
          });
        });
      }

      function restoreCommentMarkers() {
        try {
          const list = (COMMENTS_DB[pageKey()] || []);
          list.forEach(rec => {
            (rec.ranges || []).forEach(r => {
              if (!r || typeof r.so !== 'number' || typeof r.eo !== 'number' || r.so === r.eo) return;
              const tn = getNodeByPath(r.s);
              if (!tn || tn.nodeType !== Node.TEXT_NODE) return;
              const span = document.createElement('span');
              span.className = 'text-marker marker-orange';
              span.setAttribute('data-comment-id', rec.id);
              applyColorStyles(span, 'orange');
              wrapBySplitText(tn, r.so, r.eo, span);
            });
          });
        } catch (e) {
          console.warn('restoreCommentMarkers failed', e);
        }
      }

      cleanupCommentMarkersDom = function () {
        document.querySelectorAll('.text-marker[data-comment-id]').forEach(span => {
          const parent = span.parentNode;
          if (!parent) return;
          while (span.firstChild) parent.insertBefore(span.firstChild, span);
          parent.removeChild(span);
        });
      };

      refreshCommentMarkersFromDB = function (options) {
        const preserveExisting = !!(options && options.preserveExisting);
        const existingCount = document.querySelectorAll('.text-marker[data-comment-id]').length;
        if (preserveExisting && existingCount > 0) {
          ensureCommentMarkerInteractions();
          return;
        }
        cleanupCommentMarkersDom();
        restoreCommentMarkers();
        ensureCommentMarkerInteractions();
      };

      // 既存マーカー / コメントマーカー再描画
      restoreMarkers();
      refreshCommentMarkersFromDB();

      // 範囲のシリアライズ/デシリアライズ
      function serializeRange(range) {
        return {
          s: getPath(range.startContainer), so: range.startOffset,
          e: getPath(range.endContainer), eo: range.endOffset
        };
      }
      function deserializeRange(obj) {
        try {
          const sc = getNodeByPath(obj.s);
          const ec = getNodeByPath(obj.e);
          if (!sc || !ec) return null;
          const r = document.createRange();
          r.setStart(sc, Math.min(obj.so, nodeMaxOffset(sc)));
          r.setEnd(ec, Math.min(obj.eo, nodeMaxOffset(ec)));
          return r;
        } catch { return null; }
      }
      function nodeIndex(node) { let i = 0; while (node && node.previousSibling) { node = node.previousSibling; i++; } return i; }
      function getPath(node) { const p = []; let n = node; while (n && n !== document.body) { p.push(nodeIndex(n)); n = n.parentNode; } return p.reverse(); }
      function getNodeByPath(path) { let n = document.body; for (const idx of path) { if (!n || !n.childNodes[idx]) return null; n = n.childNodes[idx]; } return n; }
      function nodeMaxOffset(n) { return n.nodeType === Node.TEXT_NODE ? (n.nodeValue || '').length : (n.childNodes ? n.childNodes.length : 0); }

      function wrapBySplitText(textNode, start, end, wrapper) {
        try {
          let mid = textNode;
          if (start > 0) mid = textNode.splitText(start);
          let tail = mid;
          const len = end - start;
          if (len < mid.nodeValue.length) tail = mid.splitText(len);
          const parent = mid.parentNode;
          parent.insertBefore(wrapper, mid);
          wrapper.appendChild(mid);
        } catch (e) {
          console.warn('wrapBySplitText failed', e);
        }
      }

      function applyColorStyles(el, color) {
        // インラインスタイルで確実に可視化（CSSが読み込めないfile://時の保険）
        const map = {
          yellow: 'rgba(255, 235, 59, 0.6)',
          green: 'rgba(129, 199, 132, 0.5)',
          blue: 'rgba(100, 181, 246, 0.5)',
          pink: 'rgba(244, 143, 177, 0.5)',
          orange: 'rgba(255, 152, 0, 0.45)'
        };
        el.style.backgroundColor = map[color] || 'rgba(255, 235, 59, 0.6)';
        el.style.boxShadow = 'inset 0 -0.15em 0 rgba(0,0,0,0.08)';
      }
    }

    function setupMobileFootnoteToggle() {
      document.querySelectorAll('.footnote-ref').forEach(footnote => {
        footnote.addEventListener('click', (e) => {
          e.preventDefault();
          const footnoteId = footnote.getAttribute('href');
          const footnoteDef = document.querySelector(footnoteId);
          if (footnoteDef) footnoteDef.classList.toggle('expanded');
        });
      });
    }

    function disableDefaultQuartoSearch() {
      try {
        const defaultBtn = document.getElementById('quarto-search');
        if (defaultBtn) defaultBtn.remove();
        const defaultPanel = document.getElementById('quarto-search-results');
        if (defaultPanel) defaultPanel.remove();
        const defaultOptions = document.getElementById('quarto-search-options');
        if (defaultOptions) defaultOptions.remove();
        if (window.Quarto && typeof window.Quarto.doc === 'object') {
          window.Quarto.doc.disableSearch = true;
        }
      } catch (e) {
        console.warn('Failed to disable default Quarto search', e);
      }
    }

    function setupSidebarSearch() {
      const sidebarSearch = document.querySelector('#quarto-sidebar .sidebar-search');
      if (!sidebarSearch) return;

      sidebarSearch.innerHTML = '';
      sidebarSearch.style.display = '';

      const utilityBar = document.createElement('div');
      utilityBar.className = 'sidebar-search-utility';

      const searchButton = document.createElement('button');
      searchButton.type = 'button';
      searchButton.className = 'sidebar-search-button';
      searchButton.setAttribute('aria-label', '検索を開く (Cmd+K)');
      searchButton.title = '検索 (Cmd+K)';

      const searchIcon = document.createElement('img');
      searchIcon.className = 'sidebar-search-button-icon';
      searchIcon.alt = '';
      searchIcon.decoding = 'async';
      searchIcon.loading = 'lazy';
      searchIcon.setAttribute('aria-hidden', 'true');
      searchIcon.src = resolveAssetPath('assets/search.png');

      searchButton.appendChild(searchIcon);
      searchButton.addEventListener('click', () => {
        const handle = openSearchOverlay('');
        if (handle && handle.input) {
          const inputEl = handle.input;
          const end = inputEl.value.length;
          inputEl.focus();
          inputEl.setSelectionRange(end, end);
        }
      });

      utilityBar.appendChild(searchButton);

      // プレビュー・コメント・マーカー一覧を開くボタン（検索アイコンのすぐ右）
      const listButton = document.createElement('button');
      listButton.type = 'button';
      listButton.className = 'sidebar-search-button sidebar-list-button';
      listButton.setAttribute('aria-label', 'プレビュー・コメント一覧を開く');
      listButton.title = 'プレビュー・コメント・マーカー一覧';
      listButton.style.marginLeft = '6px';

      const listIcon = document.createElement('img');
      listIcon.className = 'sidebar-search-button-icon';
      listIcon.alt = '';
      listIcon.decoding = 'async';
      listIcon.loading = 'lazy';
      listIcon.setAttribute('aria-hidden', 'true');
      listIcon.src = resolveAssetPath('assets/list.png');
      listButton.appendChild(listIcon);

      listButton.addEventListener('click', () => {
        openGlobalListOverlay();
      });

      utilityBar.appendChild(listButton);

      const meterWrapper = document.createElement('div');
      meterWrapper.className = 'sidebar-reading-meter';
      meterWrapper.setAttribute('role', 'status');
      meterWrapper.setAttribute('aria-label', '読書メーター');
      meterWrapper.title = '読書メーター';

      const meterValue = document.createElement('span');
      meterValue.className = 'sidebar-reading-meter-value';
      meterValue.textContent = '[0/0]';

      meterWrapper.appendChild(meterValue);
      utilityBar.appendChild(meterWrapper);

      sidebarSearch.appendChild(utilityBar);

      SEARCH_RESULTS_VIEW.sidebarContainer = null;
      SEARCH_RESULTS_VIEW.sidebarSummary = null;
      SEARCH_RESULTS_VIEW.sidebarList = null;
      SEARCH_RESULTS_VIEW.sidebarQuery = null;
      SEARCH_RESULTS_VIEW.sidebarClearBtn = null;

      initializeReadingMeter(meterValue);
      restoreSearchSession();
    }

    const SEARCH_SESSION_KEY = 'quarto-search-session';

    function saveSearchSession(session) {
      try {
        sessionStorage.setItem(SEARCH_SESSION_KEY, JSON.stringify(session));
      } catch (error) {
        console.warn('Search session save failed', error);
      }
    }

    function loadSearchSession() {
      try {
        const raw = sessionStorage.getItem(SEARCH_SESSION_KEY);
        if (!raw) return null;
        return JSON.parse(raw);
      } catch (error) {
        console.warn('Search session load failed', error);
        return null;
      }
    }

    function restoreSearchSession() {
      const session = loadSearchSession();
      if (!session || !Array.isArray(session.results) || !session.results.length) {
        clearSidebarSearchResults();
        return;
      }

      SEARCH_RESULTS_VIEW.sidebarData = session;
      renderSidebarSearchResults(session);

      const currentUrl = new URL(window.location.href, window.location.origin);
      if (session.active) {
        const target = new URL(session.active.url, window.location.href);
        if (target.origin === currentUrl.origin && target.pathname === currentUrl.pathname) {
          requestAnimationFrame(() => {
            clearSearchHighlights();
            scrollToMatchOnPage(session.query, session.active.matchIndex || 0);
          });
        }
      }
    }

    function clearSidebarSearchResults() {
      if (SEARCH_RESULTS_VIEW.sidebarContainer) {
        SEARCH_RESULTS_VIEW.sidebarContainer.classList.add('hidden');
        const empty = SEARCH_RESULTS_VIEW.sidebarContainer.querySelector('.sidebar-search-empty');
        if (empty) empty.classList.remove('hidden');
      }
      if (SEARCH_RESULTS_VIEW.sidebarSummary) {
        SEARCH_RESULTS_VIEW.sidebarSummary.innerHTML = '';
      }
      if (SEARCH_RESULTS_VIEW.sidebarList) {
        SEARCH_RESULTS_VIEW.sidebarList.innerHTML = '';
      }
      if (SEARCH_RESULTS_VIEW.sidebarQuery) {
        SEARCH_RESULTS_VIEW.sidebarQuery.textContent = '';
      }
      SEARCH_RESULTS_VIEW.sidebarData = null;
      clearSearchHighlights();
      try {
        sessionStorage.removeItem(SEARCH_SESSION_KEY);
      } catch (error) {
        console.warn('Failed to clear search session', error);
      }
    }

    function renderSidebarSearchResults(session) {
      const container = SEARCH_RESULTS_VIEW.sidebarContainer;
      if (!container) return;

      SEARCH_RESULTS_VIEW.sidebarData = session;

      const empty = container.querySelector('.sidebar-search-empty');
      const summary = SEARCH_RESULTS_VIEW.sidebarSummary;
      const list = SEARCH_RESULTS_VIEW.sidebarList;
      const queryLabel = SEARCH_RESULTS_VIEW.sidebarQuery;

      if (!session || !Array.isArray(session.results) || !session.results.length) {
        clearSidebarSearchResults();
        return;
      }

      container.classList.remove('hidden');
      if (empty) empty.classList.add('hidden');
      if (queryLabel) {
        queryLabel.textContent = `「${session.query}」`;
      }
      if (summary) {
        const hiddenCount = session.results.reduce((sum, item) => sum + (item.remainingMatches || 0), 0);
        const totalMatches = session.results.length + hiddenCount;
        summary.innerHTML = `<p><strong>${totalMatches}</strong>件の結果（「${escapeHtml(session.query)}」）</p>`;
      }
      if (list) {
        list.innerHTML = '';
        session.results.forEach((result, index) => {
          const itemBtn = document.createElement('button');
          itemBtn.type = 'button';
          itemBtn.className = 'sidebar-search-item';
          if (session.active &&
            session.active.url === result.url &&
            session.active.matchIndex === result.matchIndex) {
            itemBtn.classList.add('active');
          }

          itemBtn.innerHTML = `
          <span class="sidebar-search-item-title">${escapeHtml(result.title || result.url)}</span>
          <span class="sidebar-search-item-order">${result.matchIndex + 1}/${result.totalMatches || result.matchCount || 1}</span>
          <span class="sidebar-search-item-count">${result.totalMatches || result.matchCount || 1}件</span>
          <div class="sidebar-search-item-context">${result.context}</div>
        `;

          itemBtn.addEventListener('click', () => {
            handleSidebarResultSelection(result, index);
          });
          list.appendChild(itemBtn);
        });
      }
    }

    function handleSidebarResultSelection(result, index) {
      if (!SEARCH_RESULTS_VIEW.sidebarData) return;
      const session = SEARCH_RESULTS_VIEW.sidebarData;
      session.active = {
        url: result.url,
        matchIndex: result.matchIndex,
        index
      };
      session.timestamp = Date.now();
      saveSearchSession(session);
      renderSidebarSearchResults(session);
      navigateToSearchResult(result, session.query);
    }

    function handleOverlayResultSelection(result) {
      if (!result) return;
      const activePayload = convertResultToSession(result);
      const session = {
        query: SEARCH_RESULTS_VIEW.query,
        results: convertOverlayResultsForSession(SEARCH_RESULTS_VIEW.results),
        active: {
          url: activePayload.url,
          matchIndex: activePayload.matchIndex || 0
        },
        timestamp: Date.now()
      };
      SEARCH_RESULTS_VIEW.sidebarData = session;
      saveSearchSession(session);
      renderSidebarSearchResults(session);
      if (typeof SEARCH_RESULTS_VIEW.closeOverlay === 'function') {
        SEARCH_RESULTS_VIEW.closeOverlay();
      }
      navigateToSearchResult(activePayload, session.query);
    }

    function resolveResultUrl(url) {
      try {
        const resolved = new URL(url, window.location.href);
        return resolved.href;
      } catch {
        return url;
      }
    }

    function convertOverlayResultsForSession(results) {
      return results.map(convertResultToSession);
    }

    function convertResultToSession(result) {
      const page = result.page || {};
      return {
        url: resolveResultUrl(page.url || result.url || window.location.href),
        title: page.title || result.title || (page.url || 'ページ'),
        chapter: page.chapter || result.chapter || '',
        context: result.context || '',
        matchCount: result.matchCount || 1,
        totalMatches: result.totalMatches || result.matchCount || 1,
        remainingMatches: result.remainingMatches || 0,
        matchIndex: result.matchIndex || 0
      };
    }

    function navigateToSearchResult(result, query) {
      if (!result) return;
      const targetUrl = new URL(result.url, window.location.href);
      const currentUrl = new URL(window.location.href);
      const sameDocument = targetUrl.origin === currentUrl.origin && targetUrl.pathname === currentUrl.pathname;

      if (sameDocument) {
        if (targetUrl.hash && targetUrl.hash !== window.location.hash) {
          window.location.hash = targetUrl.hash;
        }
        requestAnimationFrame(() => {
          if (!scrollToMatchOnPage(query, result.matchIndex || 0) && targetUrl.hash) {
            const targetEl = document.querySelector(targetUrl.hash);
            if (targetEl && typeof targetEl.scrollIntoView === 'function') {
              targetEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
          }
        });
      } else {
        window.location.href = targetUrl.href;
      }
    }

    let activeSearchHighlights = [];

    function clearSearchHighlights() {
      if (!activeSearchHighlights.length) return;
      activeSearchHighlights.forEach(span => {
        try {
          if (!span || !span.parentNode) return;
          const parent = span.parentNode;
          while (span.firstChild) {
            parent.insertBefore(span.firstChild, span);
          }
          parent.removeChild(span);
        } catch (error) {
          console.warn('Failed clearing highlight', error);
        }
      });
      activeSearchHighlights = [];
    }

    function highlightRange(range) {
      if (!range) return;
      const mark = document.createElement('mark');
      mark.className = 'search-hit-highlight';
      try {
        range.surroundContents(mark);
        activeSearchHighlights.push(mark);
        mark.scrollIntoView({ behavior: 'smooth', block: 'center' });
        setTimeout(() => {
          mark.classList.add('search-hit-fade');
        }, 100);
      } catch (error) {
        console.warn('Failed to highlight range', error);
      }
    }

    function scrollToMatchOnPage(query, matchIndex) {
      if (!query) return false;
      clearSearchHighlights();
      const walker = document.createTreeWalker(document.body, NodeFilter.SHOW_TEXT, null);
      const target = query.toLowerCase();
      let occurrence = -1;
      let node = walker.nextNode();
      while (node) {
        if (!(node.parentElement && node.parentElement.closest('.global-search-overlay'))) {
          const text = node.textContent || '';
          const lower = text.toLowerCase();
          let pos = 0;
          while (true) {
            const found = lower.indexOf(target, pos);
            if (found === -1) break;
            occurrence += 1;
            if (occurrence === matchIndex) {
              const range = document.createRange();
              range.setStart(node, found);
              range.setEnd(node, found + query.length);
              highlightRange(range);
              return true;
            }
            pos = found + query.length;
          }
        }
        node = walker.nextNode();
      }
      return false;
    }
    function setupGlobalSearch() {
      const openBtn = document.getElementById('search-open-btn');
      if (openBtn) openBtn.addEventListener('click', (e) => { e.preventDefault(); openSearchOverlay(); });

      window.quartoOpenSearch = (initialQuery = '') => {
        if (typeof initialQuery !== 'string') initialQuery = '';
        openSearchOverlay(initialQuery);
      };

      document.addEventListener('keydown', (e) => {
        if ((e.ctrlKey || e.metaKey) && (e.key === 'k' || e.key === 'K')) {
          e.preventDefault();
          openSearchOverlay();
        }
      }, true);
    }

    const SEARCH_STATE = {
      pages: [],
      index: {},
      loading: false,
      loaded: false,
      localSections: []
    };

    const SEARCH_RESULTS_VIEW = {
      results: [],
      query: '',
      rendered: 0,
      chunkSize: 20,
      totalCount: 0,
      summaryEl: null,
      listEl: null,
      loadMoreWrapper: null,
      loadMoreBtn: null,
      lastChapter: '',
      lastPage: '',
      closeOverlay: null,
      overlayKeyHandler: null,
      overlayClickHandler: null,
      sidebarContainer: null,
      sidebarSummary: null,
      sidebarList: null,
      sidebarQuery: null,
      sidebarClearBtn: null,
      sidebarData: null
    };

    const MAX_SNIPPETS_PER_PAGE = 20;
    const MAX_MATCHES_SCAN = 400;

    function collectBookPages() {
      if (SEARCH_STATE.pages.length) return SEARCH_STATE.pages;
      // file:// では他ページfetchがブロックされるため現在ページのみ
      if (location.protocol === 'file:') {
        const sections = Array.from(document.querySelectorAll('section.chapter-page'));
        const baseUrl = window.location.href.split('#')[0];
        if (!sections.length) {
          SEARCH_STATE.localSections = [];
          SEARCH_STATE.pages = [baseUrl];
          return SEARCH_STATE.pages;
        }
        SEARCH_STATE.localSections = sections.map(section => {
          const id = section.id || '';
          const url = id ? `${baseUrl}#${id}` : baseUrl;
          return { id, url, element: section };
        });
        SEARCH_STATE.pages = SEARCH_STATE.localSections.map(entry => entry.url);
        return SEARCH_STATE.pages;
      }
      const sidebar = document.querySelector('#quarto-sidebar .sidebar-menu-container');
      const hrefs = new Set();
      if (sidebar) {
        sidebar.querySelectorAll('a[href]')?.forEach(a => {
          const href = a.getAttribute('href');
          if (!href) return;
          if (href.startsWith('http')) return;
          if (href.startsWith('#')) return;
          hrefs.add(new URL(href, window.location.href).href);
        });
      }
      // Also add current page
      hrefs.add(window.location.href);
      SEARCH_STATE.pages = Array.from(hrefs);
      SEARCH_STATE.localSections = [];
      return SEARCH_STATE.pages;
    }

    function normalizeWhitespace(text) {
      return (text || '').replace(/\s+/g, ' ').trim();
    }

    function deriveSectionTitle(section, fallback) {
      if (!section) return fallback || 'このページ';
      const selectors = ['h1 .chapter-title', 'h1', '.chapter-title', 'header .title', 'h2', 'h3'];
      for (const sel of selectors) {
        const el = section.querySelector(sel);
        if (el) {
          const txt = normalizeWhitespace(el.textContent);
          if (txt) return txt;
        }
      }
      const heading = Array.from(section.querySelectorAll('h1, h2, h3, h4, h5')).find(h => normalizeWhitespace(h.textContent));
      if (heading) return normalizeWhitespace(heading.textContent);
      const id = section.id || '';
      if (id) return normalizeWhitespace(id.replace(/^page-/, '').replace(/[-_]+/g, ' ')) || (fallback || 'このページ');
      return fallback || 'このページ';
    }

    function extractSectionText(section) {
      if (!section) return '';
      const clone = section.cloneNode(true);
      const removable = [
        'script',
        'style',
        'nav',
        '.single-pager',
        '.margin-note',
        '.right-footnotes',
        '.right-comments',
        '.right-both',
        '.comment-menu-popup',
        '.global-search-overlay',
        '.global-search-dialog',
        '.marker-toolbar'
      ];
      removable.forEach(sel => clone.querySelectorAll(sel).forEach(el => el.remove()));
      return normalizeWhitespace(clone.textContent || '');
    }

    async function buildSearchIndex() {
      if (SEARCH_STATE.loaded || SEARCH_STATE.loading) return;
      SEARCH_STATE.loading = true;
      SEARCH_STATE.index = {};
      const pages = collectBookPages();

      if (location.protocol === 'file:') {
        const baseUrl = window.location.href.split('#')[0];
        if (!SEARCH_STATE.localSections || !SEARCH_STATE.localSections.length) {
          collectBookPages();
        }
        const docTitle = normalizeWhitespace(document.querySelector('header .title')?.textContent || document.title || '');
        const sections = (SEARCH_STATE.localSections && SEARCH_STATE.localSections.length)
          ? SEARCH_STATE.localSections
          : [];
        const seen = new Set();
        if (sections.length) {
          sections.forEach(entry => {
            const section = entry.element;
            const url = entry.url || (entry.id ? `${baseUrl}#${entry.id}` : baseUrl);
            const title = deriveSectionTitle(section, docTitle || baseUrl);
            const text = extractSectionText(section);
            SEARCH_STATE.index[url] = { url, title, text, slug: entry.id };
            seen.add(url);
          });
          const hasIndex = sections.some(entry => (entry.id || '').toLowerCase() === 'page-index');
          if (!hasIndex) {
            const main = document.querySelector('main#quarto-document-content') || document.querySelector('main') || document.body;
            if (main) {
              const text = extractSectionText(main);
              const url = baseUrl;
              if (!seen.has(url)) {
                const title = deriveSectionTitle(main, docTitle || baseUrl);
                SEARCH_STATE.index[url] = { url, title, text };
              }
            }
          }
        } else {
          const main = document.querySelector('main#quarto-document-content') || document.querySelector('main') || document.body;
          const text = extractSectionText(main);
          SEARCH_STATE.index[baseUrl] = { url: baseUrl, title: docTitle || baseUrl, text };
        }
        SEARCH_STATE.loaded = true;
        SEARCH_STATE.loading = false;
        return;
      }

      const fetchPage = async (url) => {
        try {
          const res = await fetch(url);
          const html = await res.text();
          const doc = new DOMParser().parseFromString(html, 'text/html');
          const title = (doc.querySelector('header .title')?.textContent || doc.querySelector('title')?.textContent || '').trim();
          const main = doc.querySelector('main') || doc.querySelector('#quarto-document-content') || doc.body;
          const text = (main.textContent || '').replace(/\s+/g, ' ').trim();
          return { url, title, text };
        } catch (e) {
          console.warn('Search: failed to fetch', url, e);
          return { url, title: url, text: '' };
        }
      };

      const results = await Promise.all(pages.map(fetchPage));
      results.forEach(r => { SEARCH_STATE.index[r.url] = r; });
      SEARCH_STATE.loaded = true;
      SEARCH_STATE.loading = false;
    }

    function openSearchOverlay(initialQuery = '') {
      const startQuery = (typeof initialQuery === 'string') ? initialQuery.trim() : '';
      let overlay = document.querySelector('.global-search-overlay');
      if (overlay) overlay.remove();

      overlay = document.createElement('div');
      overlay.className = 'global-search-overlay';
      overlay.innerHTML = `
      <div class="global-search-dialog" role="dialog" aria-modal="true" aria-label="全ページ検索">
        <div class="global-search-header">
          <h3>検索</h3>
          <button class="global-search-close" aria-label="閉じる">×</button>
        </div>
        <div class="global-search-input-wrapper">
          <input id="global-search-input" type="text" placeholder="キーワードを入力 (Ctrl/Cmd + K)" autocomplete="off" />
          <button id="global-search-btn">検索</button>
        </div>
        <div class="global-search-results">
          <div class="search-help">検索語を入力してください。</div>
        </div>
      </div>
    `;
      document.body.appendChild(overlay);
      overlay.style.display = 'block';
      document.body.classList.add('search-overlay-active');

      const close = () => {
        if (overlay && overlay.parentNode) {
          overlay.parentNode.removeChild(overlay);
        }
        document.body.classList.remove('search-overlay-active');
        if (SEARCH_RESULTS_VIEW.overlayKeyHandler) {
          document.removeEventListener('keydown', SEARCH_RESULTS_VIEW.overlayKeyHandler, true);
          SEARCH_RESULTS_VIEW.overlayKeyHandler = null;
        }
        if (SEARCH_RESULTS_VIEW.overlayClickHandler) {
          document.removeEventListener('click', SEARCH_RESULTS_VIEW.overlayClickHandler, true);
          SEARCH_RESULTS_VIEW.overlayClickHandler = null;
        }
        resetSearchResultsView();
        SEARCH_RESULTS_VIEW.closeOverlay = null;
      };
      overlay.addEventListener('click', (e) => { if (e.target === overlay) close(); });
      overlay.querySelector('.global-search-close')?.addEventListener('click', close);

      const input = overlay.querySelector('#global-search-input');
      const btn = overlay.querySelector('#global-search-btn');
      const syncSidebarInput = () => { };
      input.value = startQuery;
      input.focus();

      const ensureIndex = async () => {
        if (!SEARCH_STATE.loaded) {
          const results = overlay.querySelector('.global-search-results');
          results.innerHTML = '<div class="search-loading">索引を作成中...</div>';
          await buildSearchIndex();
        }
      };

      const doSearch = async () => {
        const q = (input.value || '').trim();
        syncSidebarInput(q);
        const resultsEl = overlay.querySelector('.global-search-results');
        if (!q) {
          resultsEl.innerHTML = '<div class="search-help">検索語を入力してください。</div>';
          resetSearchResultsView();
          return;
        }
        await ensureIndex();
        const results = [];
        for (const url of Object.keys(SEARCH_STATE.index)) {
          const item = SEARCH_STATE.index[url];
          if (!item || !item.text) continue;
          const page = {
            url,
            title: item.title || url,
            chapter: item.title || ''
          };
          const matches = findMatches(item.text, q, MAX_SNIPPETS_PER_PAGE);
          matches.forEach(match => {
            results.push({
              page,
              context: match.context,
              matchCount: match.totalMatches,
              totalMatches: match.totalMatches,
              matchIndex: match.matchIndex,
              remainingMatches: match.remainingMatches
            });
          });
        }
        renderResults(resultsEl, results, q);
      };

      const debouncedSearch = debounce(doSearch, 200);

      const dialog = overlay.querySelector('.global-search-dialog');
      const keyHandler = (event) => {
        if (event.key === 'Escape') {
          event.preventDefault();
          close();
        }
      };
      const clickHandler = (event) => {
        if (dialog && !dialog.contains(event.target)) {
          close();
        }
      };
      document.addEventListener('keydown', keyHandler, true);
      document.addEventListener('click', clickHandler, true);
      SEARCH_RESULTS_VIEW.overlayKeyHandler = keyHandler;
      SEARCH_RESULTS_VIEW.overlayClickHandler = clickHandler;
      SEARCH_RESULTS_VIEW.closeOverlay = close;

      input.addEventListener('input', () => { debouncedSearch(); });
      input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') { e.preventDefault(); doSearch(); }
        if (e.key === 'Escape') { e.preventDefault(); close(); }
      });
      btn.addEventListener('click', () => { doSearch(); });

      if (startQuery.length) {
        doSearch();
        const end = input.value.length;
        input.setSelectionRange(end, end);
      }

      return { overlay, input, close };
    }

    function findMatches(text, query, limit) {
      if (!text || !query) return [];
      const sanitized = text.replace(/\s+/g, ' ');
      const hay = sanitized.toLowerCase();
      const needle = query.toLowerCase();
      const indices = [];
      let pos = 0;
      let safety = 0;
      while (pos < hay.length) {
        const idx = hay.indexOf(needle, pos);
        if (idx === -1) break;
        indices.push(idx);
        pos = idx + needle.length;
        safety += 1;
        if (safety >= MAX_MATCHES_SCAN) break;
      }
      const total = indices.length;
      if (!total) return [];
      const clamp = Math.min(total, limit || MAX_SNIPPETS_PER_PAGE);
      const results = [];
      for (let i = 0; i < clamp; i += 1) {
        const start = Math.max(0, indices[i] - 80);
        const end = Math.min(sanitized.length, indices[i] + query.length + 80);
        let snippet = sanitized.slice(start, end);
        snippet = highlight(snippet, query);
        if (start > 0) snippet = '…' + snippet;
        if (end < sanitized.length) snippet = snippet + '…';
        const remainingMatches = (total > clamp && i === clamp - 1) ? total - clamp : 0;
        if (remainingMatches > 0) {
          snippet += `<span class="search-result-more">他${remainingMatches}件の一致</span>`;
        }
        results.push({
          context: snippet,
          matchIndex: i,
          totalMatches: total,
          remainingMatches
        });
      }
      return results;
    }

    function escapeHtml(s) {
      return (s || '').replace(/[&<>"']/g, c => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', '\'': '&#39;' }[c]));
    }

    function highlight(text, query) {
      const escQ = query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      return text.replace(new RegExp(escQ, 'gi'), m => `<mark>${escapeHtml(m)}</mark>`);
    }

    function fmtMMDDHHmm(t) {
      const d = new Date(t); const pad = (n) => String(n).padStart(2, '0');
      return `${pad(d.getMonth() + 1)}/${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}`;
    }

    // --- グローバル一覧モーダル（プレビュー / コメント / マーカー） ---
    function openGlobalListOverlay() {
      try {
        const existing = document.querySelector('.global-list-overlay');
        if (existing) existing.remove();

        const overlay = document.createElement('div');
        overlay.className = 'global-list-overlay';
        overlay.style.position = 'fixed';
        overlay.style.inset = '0';
        overlay.style.background = 'rgba(0,0,0,0.45)';
        overlay.style.zIndex = '1700';
        overlay.style.display = 'flex';
        overlay.style.alignItems = 'center';
        overlay.style.justifyContent = 'center';

        const dialog = document.createElement('div');
        dialog.className = 'global-list-dialog';
        dialog.style.background = '#fff';
        dialog.style.borderRadius = '10px';
        dialog.style.boxShadow = '0 10px 30px rgba(0,0,0,0.3)';
        dialog.style.maxWidth = '720px';
        dialog.style.width = '96vw';
        dialog.style.maxHeight = '80vh';
        dialog.style.display = 'flex';
        dialog.style.flexDirection = 'column';
        dialog.style.overflow = 'hidden';

        const header = document.createElement('div');
        header.style.display = 'flex';
        header.style.alignItems = 'center';
        header.style.justifyContent = 'space-between';
        header.style.padding = '10px 14px';
        header.style.borderBottom = '1px solid #e1e5e9';
        const title = document.createElement('h3');
        title.textContent = 'プレビュー / コメント / マーカー一覧';
        title.style.margin = '0';
        title.style.fontSize = '15px';
        title.style.fontWeight = '600';
        const closeBtn = document.createElement('button');
        closeBtn.type = 'button';
        closeBtn.textContent = '×';
        closeBtn.setAttribute('aria-label', '閉じる');
        closeBtn.style.border = 'none';
        closeBtn.style.background = 'none';
        closeBtn.style.cursor = 'pointer';
        closeBtn.style.fontSize = '18px';
        closeBtn.style.lineHeight = '1';
        closeBtn.style.marginLeft = '12px';
        header.appendChild(title);
        header.appendChild(closeBtn);

        const tabs = document.createElement('div');
        tabs.style.display = 'flex';
        tabs.style.borderBottom = '1px solid #e1e5e9';

        const tabNames = [
          { id: 'previews-docs', label: 'Docsプレビュー' },
          { id: 'previews-bg', label: 'BGプレビュー' },
          { id: 'comments', label: 'コメント' },
          { id: 'markers', label: 'マーカー' }
        ];
        const panels = {};

        tabNames.forEach((t, idx) => {
          const btn = document.createElement('button');
          btn.type = 'button';
          btn.textContent = t.label;
          btn.dataset.tab = t.id;
          btn.style.flex = '1';
          btn.style.padding = '8px 10px';
          btn.style.border = 'none';
          btn.style.borderBottom = idx === 0 ? '2px solid #1a73e8' : '2px solid transparent';
          btn.style.background = idx === 0 ? '#ffffff' : '#f8f9fa';
          btn.style.cursor = 'pointer';
          btn.style.fontSize = '13px';
          btn.style.fontWeight = idx === 0 ? '600' : '500';
          btn.addEventListener('click', () => {
            const current = dialog.querySelectorAll('.global-list-tab');
            for (let i = 0; i < current.length; i++) {
              const b = current[i];
              const active = b === btn;
              b.style.borderBottom = active ? '2px solid #1a73e8' : '2px solid transparent';
              b.style.background = active ? '#ffffff' : '#f8f9fa';
              b.style.fontWeight = active ? '600' : '500';
            }
            Object.keys(panels).forEach(id => {
              panels[id].style.display = id === t.id ? 'block' : 'none';
            });
            if (t.id === 'previews-docs') renderGlobalPreviewList(panels['previews-docs'], 'gdoc');
            if (t.id === 'previews-bg') renderGlobalPreviewList(panels['previews-bg'], 'bg');
            if (t.id === 'comments') renderGlobalCommentList(panels.comments);
            if (t.id === 'markers') renderGlobalMarkerList(panels.markers);
          });
          btn.className = 'global-list-tab';
          tabs.appendChild(btn);
        });

        const body = document.createElement('div');
        body.style.flex = '1';
        body.style.overflowY = 'auto';
        body.style.padding = '10px 14px 12px';
        body.style.fontSize = '13px';

        tabNames.forEach((t, idx) => {
          const panel = document.createElement('div');
          panel.className = 'global-list-panel global-list-' + t.id;
          panel.style.display = idx === 0 ? 'block' : 'none';
          body.appendChild(panel);
          panels[t.id] = panel;
        });

        dialog.appendChild(header);
        dialog.appendChild(tabs);
        dialog.appendChild(body);
        overlay.appendChild(dialog);
        document.body.appendChild(overlay);

        const close = () => {
          if (overlay && overlay.parentNode) overlay.parentNode.removeChild(overlay);
        };
        closeBtn.addEventListener('click', close);
        overlay.addEventListener('click', (e) => {
          if (e.target === overlay) close();
        });

        // 初期タブ: Docsプレビュー
        renderGlobalPreviewList(panels['previews-docs'], 'gdoc');
      } catch (e) {
        console.warn('openGlobalListOverlay failed', e);
      }
    }

    function loadPreviewItemsForGlobalList() {
      var items = [];
      try {
        if (window.__gdocPreviewAPI__ && typeof window.__gdocPreviewAPI__.getItems === 'function') {
          items = window.__gdocPreviewAPI__.getItems() || [];
        } else {
          var raw = window.localStorage.getItem('gdocPreviewState_v2');
          if (raw) {
            var parsed = JSON.parse(raw);
            if (parsed && Array.isArray(parsed.items)) items = parsed.items;
          }
        }
      } catch (e) {
        console.warn('loadPreviewItemsForGlobalList failed', e);
        items = [];
      }
      return items;
    }

    function renderGlobalPreviewList(panel, kind) {
      if (!panel) return;
      panel.innerHTML = '';
      var allItems = loadPreviewItemsForGlobalList();
      var items = kind ? allItems.filter(function (item) {
        return item.kind === kind;
      }) : allItems;

      if (!items || !items.length) {
        var empty = document.createElement('p');
        var msg = kind === 'gdoc' ? '現在Docsプレビュー中の文書はありません。' :
          kind === 'bg' ? '現在BGプレビュー中の文書はありません。' :
            '現在プレビュー中の文書はありません。';
        empty.textContent = msg;
        empty.style.cssText = 'margin:4px 0;color:#6c757d;';
        panel.appendChild(empty);
        return;
      }

      var list = document.createElement('ul');
      list.style.listStyle = 'none';
      list.style.padding = '0';
      list.style.margin = '0';

      items.forEach(function (item) {
        var li = document.createElement('li');
        li.style.cssText = 'margin:6px 0;padding:6px 8px;border-radius:6px;border:1px solid #e1e5e9;display:flex;flex-direction:column;gap:4px;';

        var titleRow = document.createElement('div');
        titleRow.style.cssText = 'display:flex;align-items:center;gap:8px;';
        var titleSpan = document.createElement('span');
        titleSpan.style.flex = '1';
        titleSpan.style.fontWeight = '500';
        titleSpan.textContent = item.title || item.href || item.id || '(無題)';
        var stateSpan = document.createElement('span');
        stateSpan.style.fontSize = '11px';
        stateSpan.style.color = '#6c757d';
        stateSpan.textContent = item.state === 'active' ? '表示中' : '格納中';
        titleRow.appendChild(titleSpan);
        titleRow.appendChild(stateSpan);

        var actions = document.createElement('div');
        actions.style.cssText = 'display:flex;gap:4px;flex-wrap:wrap;';

        // 「表示」ボタン（目アイコン）
        var btnShow = document.createElement('button');
        btnShow.type = 'button';
        btnShow.className = 'gdoc-toast-btn';
        btnShow.setAttribute('aria-label', 'プレビュー表示');
        btnShow.title = 'プレビュー表示';
        btnShow.innerHTML = '<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M12 5C7 5 3.1 8 1.5 12 3.1 16 7 19 12 19s8.9-3 10.5-7C20.9 8 17 5 12 5zm0 10a3 3 0 110-6 3 3 0 010 6z"></path></svg>';
        btnShow.addEventListener('click', function () {
          if (window.__gdocPreviewAPI__ && typeof window.__gdocPreviewAPI__.activate === 'function') {
            window.__gdocPreviewAPI__.activate(item.key);
          }
        });

        // 「本文へ」ボタン（ジャンプアイコン）
        var btnJump = document.createElement('button');
        btnJump.type = 'button';
        btnJump.className = 'gdoc-toast-btn';
        btnJump.setAttribute('aria-label', '本文へ移動');
        btnJump.title = '本文へ移動';
        btnJump.innerHTML = '<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M12 2c-.55 0-1 .45-1 1v12.59l-4.3-4.3a1 1 0 10-1.4 1.42l6 6a1 1 0 001.4 0l6-6a1 1 0 10-1.4-1.42L13 15.59V3c0-.55-.45-1-1-1z"></path></svg>';
        btnJump.addEventListener('click', function () {
          if (window.__gdocPreviewAPI__ && typeof window.__gdocPreviewAPI__.jumpToSource === 'function') {
            window.__gdocPreviewAPI__.jumpToSource(item.key);
          }
        });

        // 「他タブで開く」ボタン（外部リンクアイコン）
        var btnTab = document.createElement('button');
        btnTab.type = 'button';
        btnTab.className = 'gdoc-toast-btn';
        btnTab.setAttribute('aria-label', '別タブで開く');
        btnTab.title = '別タブで開く';
        btnTab.innerHTML = '<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M14 3h7v7h-2V6.41l-9.29 9.3-1.42-1.42 9.3-9.29H14V3z"></path><path d="M5 5h5V3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2v-5h-2v5H5V5z"></path></svg>';
        btnTab.addEventListener('click', function () {
          var url = item.href || item.previewUrl;
          if (url) window.open(url, '_blank', 'noopener');
        });

        // 「閉じる」ボタン（×アイコン）
        var btnClose = document.createElement('button');
        btnClose.type = 'button';
        btnClose.className = 'gdoc-toast-btn';
        btnClose.setAttribute('aria-label', '閉じる');
        btnClose.title = '閉じる';
        btnClose.innerHTML = '<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M5.293 6.707l5.293 5.293-5.293 5.293c-.39.39-.39 1.024 0 1.414s1.024.39 1.414 0l5.293-5.293 5.293 5.293c.39.39 1.024.39 1.414 0s.39-1.024 0-1.414L13.414 12l5.293-5.293c.39-.39.39-1.024 0-1.414s-1.024-.39-1.414 0L12 10.586 6.707 5.293c-.39-.39-1.024-.39-1.414 0s-.39 1.024 0 1.414z"></path></svg>';
        btnClose.addEventListener('click', function () {
          if (window.__gdocPreviewAPI__ && typeof window.__gdocPreviewAPI__.close === 'function') {
            window.__gdocPreviewAPI__.close(item.key);
            renderGlobalPreviewList(panel);
          }
        });

        actions.appendChild(btnShow);
        actions.appendChild(btnJump);
        actions.appendChild(btnTab);
        actions.appendChild(btnClose);

        li.appendChild(titleRow);
        li.appendChild(actions);
        list.appendChild(li);
      });

      panel.appendChild(list);
    }

    var GLOBAL_LIST_SCOPE = {
      comments: 'page',
      markers: 'page'
    };

    function renderGlobalCommentList(panel) {
      if (!panel) return;
      panel.innerHTML = '';
      var scope = GLOBAL_LIST_SCOPE.comments || 'page';

      // スコープ切り替えトグル（このページ / 全ページ）
      var ctrl = document.createElement('div');
      ctrl.style.cssText = 'display:flex;align-items:center;justify-content:flex-end;margin-bottom:6px;gap:6px;font-size:11px;color:#6c757d;';
      var label = document.createElement('label');
      label.style.display = 'inline-flex';
      label.style.alignItems = 'center';
      label.style.gap = '4px';
      var checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.checked = scope === 'all';
      checkbox.addEventListener('change', function () {
        GLOBAL_LIST_SCOPE.comments = checkbox.checked ? 'all' : 'page';
        renderGlobalCommentList(panel);
      });
      label.appendChild(checkbox);
      label.appendChild(document.createTextNode('全ページ'));
      ctrl.appendChild(label);
      panel.appendChild(ctrl);

      var key = typeof pageKey === 'function' ? pageKey() : window.location.pathname;
      var list = [];
      if (scope === 'page') {
        // コメントパネルと同じロジックで、このページ上のコメントを取得
        if (typeof getActiveComments === 'function') {
          list = getActiveComments().slice();
        } else if (typeof COMMENTS_DB === 'object' && COMMENTS_DB && COMMENTS_DB[key]) {
          list = COMMENTS_DB[key].slice();
        } else {
          list = [];
        }
      } else {
        if (typeof COMMENTS_DB === 'object' && COMMENTS_DB) {
          Object.keys(COMMENTS_DB).forEach(function (k) {
            (COMMENTS_DB[k] || []).forEach(function (rec) {
              list.push({ __pageKey: k, rec: rec });
            });
          });
        }
      }
      if (!list.length) {
        var empty = document.createElement('p');
        empty.textContent = scope === 'page' ? 'このページにはコメントがありません。' : '全ページにコメントがありません。';
        empty.style.cssText = 'margin:4px 0;color:#6c757d;';
        panel.appendChild(empty);
        return;
      }

      // 並び替え（新しい順）
      list.sort(function (a, b) {
        var ra = scope === 'page' ? a : a.rec;
        var rb = scope === 'page' ? b : b.rec;
        return (rb.t || 0) - (ra.t || 0);
      });

      var ul = document.createElement('ul');
      ul.style.listStyle = 'none';
      ul.style.padding = '0';
      ul.style.margin = '0';

      list.forEach(function (entry) {
        var rec = scope === 'page' ? entry : entry.rec;
        var pageKeyForRec = scope === 'page' ? key : entry.__pageKey;

        var li = document.createElement('li');
        li.style.cssText = 'margin:6px 0;padding:6px 8px;border-radius:6px;border:1px solid #e1e5e9;';

        var meta = document.createElement('div');
        meta.style.cssText = 'font-size:11px;color:#6c757d;display:flex;gap:8px;align-items:center;margin-bottom:4px;';
        var time = document.createElement('span');
        time.textContent = fmtMMDDHHmm(rec.t || Date.now());
        meta.appendChild(time);
        if (scope === 'all' && pageKeyForRec !== key) {
          var pageLabel = document.createElement('span');
          pageLabel.textContent = pageKeyForRec;
          pageLabel.style.maxWidth = '220px';
          pageLabel.style.overflow = 'hidden';
          pageLabel.style.textOverflow = 'ellipsis';
          meta.appendChild(pageLabel);
        }
        var move = document.createElement('button');
        move.type = 'button';
        move.textContent = '移動';
        move.style.cssText = 'padding:2px 6px;font-size:11px;border-radius:4px;border:1px solid #6c757d;background:#fff;cursor:pointer;';
        move.addEventListener('click', function () {
          if (scope === 'page' || pageKeyForRec === key) {
            scrollToComment(rec);
          } else {
            // 別ページのコメントの場合はそのページを開く
            try {
              window.location.href = pageKeyForRec;
            } catch (e) {
              window.location.assign(pageKeyForRec);
            }
          }
        });
        meta.appendChild(move);

        var target = document.createElement('div');
        target.style.cssText = 'font-size:13px;color:#495057;background:#f8f9fa;padding:4px 6px;border-radius:4px;margin-bottom:4px;';
        target.textContent = rec.text || '';
        var body = document.createElement('div');
        body.style.cssText = 'white-space:pre-wrap;line-height:1.5;';
        body.textContent = rec.body || '';

        li.appendChild(meta);
        li.appendChild(target);
        li.appendChild(body);
        ul.appendChild(li);
      });

      panel.appendChild(ul);
    }

    function renderGlobalMarkerList(panel) {
      if (!panel) return;
      panel.innerHTML = '';
      var scope = GLOBAL_LIST_SCOPE.markers || 'page';

      var ctrl = document.createElement('div');
      ctrl.style.cssText = 'display:flex;align-items:center;justify-content:flex-end;margin-bottom:6px;gap:6px;font-size:11px;color:#6c757d;';
      var label = document.createElement('label');
      label.style.display = 'inline-flex';
      label.style.alignItems = 'center';
      label.style.gap = '4px';
      var checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.checked = scope === 'all';
      checkbox.addEventListener('change', function () {
        GLOBAL_LIST_SCOPE.markers = checkbox.checked ? 'all' : 'page';
        renderGlobalMarkerList(panel);
      });
      label.appendChild(checkbox);
      label.appendChild(document.createTextNode('全ページ'));
      ctrl.appendChild(label);
      panel.appendChild(ctrl);

      var markersDB;
      try {
        markersDB = JSON.parse(window.localStorage.getItem(STORAGE_KEYS.markers) || '{}') || {};
      } catch (e) {
        markersDB = {};
      }
      var page = window.location.pathname;
      var list = [];
      if (scope === 'page') {
        list = markersDB[page] || [];
      } else {
        Object.keys(markersDB).forEach(function (k) {
          (markersDB[k] || []).forEach(function (m) {
            list.push({ __pageKey: k, marker: m });
          });
        });
      }
      if (!list.length) {
        var empty = document.createElement('p');
        empty.textContent = scope === 'page' ? 'このページにはマーカーがありません。' : '全ページにマーカーがありません。';
        empty.style.cssText = 'margin:4px 0;color:#6c757d;';
        panel.appendChild(empty);
        return;
      }

      var ul = document.createElement('ul');
      ul.style.listStyle = 'none';
      ul.style.padding = '0';
      ul.style.margin = '0';

      list.forEach(function (entry) {
        var m = scope === 'page' ? entry : entry.marker;
        var pageKeyForMarker = scope === 'page' ? page : entry.__pageKey;

        var li = document.createElement('li');
        li.style.cssText = 'margin:6px 0;padding:6px 8px;border-radius:6px;border:1px solid #e1e5e9;display:flex;flex-direction:column;gap:4px;';

        var row = document.createElement('div');
        row.style.cssText = 'display:flex;align-items:center;gap:8px;';
        var label = document.createElement('span');
        label.style.flex = '1';
        label.textContent = (function () {
          var span = document.querySelector('.text-marker[data-marker-id="' + m.id + '"]');
          if (span && span.textContent) return span.textContent.slice(0, 80);
          return '(マーカー)';
        })();
        if (scope === 'all' && pageKeyForMarker !== page) {
          label.textContent = '[' + pageKeyForMarker + '] ' + label.textContent;
        }
        var colorSwatch = document.createElement('span');
        colorSwatch.style.display = 'inline-block';
        colorSwatch.style.width = '10px';
        colorSwatch.style.height = '10px';
        colorSwatch.style.borderRadius = '2px';
        var colorMap = { yellow: '#fff59d', green: '#c8e6c9', blue: '#bbdefb', pink: '#f8bbd0', orange: '#ffcc80' };
        colorSwatch.style.backgroundColor = colorMap[m.color] || '#fff59d';
        row.appendChild(label);
        row.appendChild(colorSwatch);

        var actions = document.createElement('div');
        actions.style.cssText = 'display:flex;gap:6px;flex-wrap:wrap;';
        var btnMove = document.createElement('button');
        btnMove.type = 'button';
        btnMove.textContent = '移動';
        btnMove.style.cssText = 'padding:3px 8px;font-size:11px;border-radius:4px;border:1px solid #6c757d;background:#fff;cursor:pointer;';
        btnMove.addEventListener('click', function () {
          try {
            if (scope === 'page' || pageKeyForMarker === page) {
              var span = document.querySelector('.text-marker[data-marker-id="' + m.id + '"]');
              if (span && typeof span.scrollIntoView === 'function') {
                var el = span;
                while (el && el !== document.body && !(el instanceof HTMLElement)) {
                  el = el.parentElement;
                }
                if (!el) el = span;
                el.scrollIntoView({ behavior: 'smooth', block: 'center' });
                try {
                  var prevBox = el.style.boxShadow;
                  el.style.transition = 'box-shadow 0.3s ease';
                  el.style.boxShadow = '0 0 0 3px rgba(26,115,232,0.5)';
                  setTimeout(function () {
                    el.style.boxShadow = prevBox || '';
                  }, 1600);
                } catch (e2) { }
              }
            } else {
              window.location.href = pageKeyForMarker;
            }
          } catch (e) { }
        });
        var btnDelete = document.createElement('button');
        btnDelete.type = 'button';
        btnDelete.textContent = '削除';
        btnDelete.style.cssText = 'padding:3px 8px;font-size:11px;border-radius:4px;border:1px solid #dc3545;background:#fff;color:#dc3545;cursor:pointer;';
        btnDelete.addEventListener('click', function () {
          try {
            // remove spans
            document.querySelectorAll('.text-marker[data-marker-id="' + m.id + '"]').forEach(function (el) {
              var parent = el.parentNode;
              while (el.firstChild) parent.insertBefore(el.firstChild, el);
              parent.removeChild(el);
            });
            // update storage
            var db = markersDB[page] || [];
            markersDB[page] = db.filter(function (x) { return x.id !== m.id; });
            if (!markersDB[page].length) delete markersDB[page];
            window.localStorage.setItem(STORAGE_KEYS.markers, JSON.stringify(markersDB));
            renderGlobalMarkerList(panel);
          } catch (e) {
            console.warn('failed to delete marker group', e);
          }
        });

        actions.appendChild(btnMove);
        actions.appendChild(btnDelete);

        li.appendChild(row);
        li.appendChild(actions);
        ul.appendChild(li);
      });

      panel.appendChild(ul);
    }

    function renderResults(container, results, query) {
      if (!container) return;

      if (!results.length) {
        container.innerHTML = `<div class="search-no-results"><p>一致が見つかりませんでした。</p><ul><li>語句を短くする</li><li>別のキーワードを試す</li></ul></div>`;
        resetSearchResultsView();
        return;
      }

      resetSearchResultsView();
      clearSearchHighlights();
      SEARCH_RESULTS_VIEW.results = results;
      SEARCH_RESULTS_VIEW.query = query;
      SEARCH_RESULTS_VIEW.totalCount = results.length + results.reduce((sum, r) => sum + (r.remainingMatches || 0), 0);

      container.innerHTML = '';

      const summary = document.createElement('div');
      summary.className = 'search-results-summary';
      container.appendChild(summary);
      SEARCH_RESULTS_VIEW.summaryEl = summary;

      const listWrap = document.createElement('div');
      listWrap.className = 'search-results-items';
      container.appendChild(listWrap);
      SEARCH_RESULTS_VIEW.listEl = listWrap;

      const loadMoreWrapper = document.createElement('div');
      loadMoreWrapper.className = 'search-load-more-wrapper';
      const loadMoreBtn = document.createElement('button');
      loadMoreBtn.type = 'button';
      loadMoreBtn.className = 'search-load-more-btn';
      loadMoreBtn.textContent = 'さらに表示';
      loadMoreWrapper.appendChild(loadMoreBtn);
      container.appendChild(loadMoreWrapper);
      SEARCH_RESULTS_VIEW.loadMoreWrapper = loadMoreWrapper;
      SEARCH_RESULTS_VIEW.loadMoreBtn = loadMoreBtn;
      loadMoreBtn.addEventListener('click', () => renderOverlayResultsChunk());

      renderOverlayResultsChunk(true);
    }

    function renderOverlayResultsChunk(reset = false) {
      const state = SEARCH_RESULTS_VIEW;
      if (!state.listEl) return;

      if (reset) {
        state.listEl.innerHTML = '';
        state.rendered = 0;
        state.lastChapter = '';
        state.lastPage = '';
      }

      const total = state.results.length;
      if (state.rendered >= total) {
        updateOverlayResultsSummary();
        if (state.loadMoreWrapper) state.loadMoreWrapper.style.display = 'none';
        return;
      }

      const limit = Math.min(total, state.rendered + state.chunkSize);
      for (let i = state.rendered; i < limit; i += 1) {
        const result = state.results[i];
        const chapter = result.page?.chapter || '';
        const pageUrl = result.page?.url || '';

        if (chapter && (chapter !== state.lastChapter || pageUrl !== state.lastPage)) {
          const section = document.createElement('section');
          section.className = 'search-chapter-section';
          const heading = document.createElement('h4');
          heading.className = 'search-chapter-title';
          heading.textContent = chapter;
          section.appendChild(heading);
          state.listEl.appendChild(section);
          state.lastChapter = chapter;
          state.lastPage = pageUrl;
        }

        const item = document.createElement('div');
        item.className = 'search-result-item';

        const titleRow = document.createElement('div');
        titleRow.className = 'search-result-title';

        const link = document.createElement('a');
        link.className = 'search-result-link';
        link.href = result.page?.url || '#';
        link.textContent = result.page?.title || result.page?.url || 'ページ';
        link.addEventListener('click', (event) => {
          event.preventDefault();
          handleOverlayResultSelection(result);
        });

        const order = document.createElement('span');
        order.className = 'search-snippet-order';
        order.textContent = `${(result.matchIndex || 0) + 1}/${result.totalMatches || result.matchCount || 1}`;

        const badge = document.createElement('span');
        badge.className = 'search-match-count';
        badge.textContent = `${result.totalMatches || result.matchCount || 1}件`;

        titleRow.appendChild(link);
        titleRow.appendChild(order);
        titleRow.appendChild(badge);
        item.appendChild(titleRow);

        const ctx = document.createElement('div');
        ctx.className = 'search-result-context';
        ctx.innerHTML = result.context;
        item.appendChild(ctx);

        state.listEl.appendChild(item);
      }

      state.rendered = limit;
      updateOverlayResultsSummary();

      if (state.loadMoreWrapper) {
        state.loadMoreWrapper.style.display = state.rendered >= total ? 'none' : '';
      }
    }

    function updateOverlayResultsSummary() {
      const state = SEARCH_RESULTS_VIEW;
      if (!state.summaryEl) return;
      const hiddenCount = state.results.reduce((sum, item) => sum + (item.remainingMatches || 0), 0);
      const totalMatches = state.results.length + hiddenCount;
      const shownMatches = Math.min(state.rendered, state.results.length);
      const escapedQuery = escapeHtml(state.query);
      state.summaryEl.innerHTML = `
      <p><strong>${totalMatches}</strong>件の結果（「${escapedQuery}」）</p>
      <p class="search-results-muted">${shownMatches}件を表示中${hiddenCount > 0 ? `（他${hiddenCount}件）` : ''}</p>
    `;
    }

    function resetSearchResultsView() {
      SEARCH_RESULTS_VIEW.results = [];
      SEARCH_RESULTS_VIEW.query = '';
      SEARCH_RESULTS_VIEW.rendered = 0;
      SEARCH_RESULTS_VIEW.totalCount = 0;
      SEARCH_RESULTS_VIEW.summaryEl = null;
      SEARCH_RESULTS_VIEW.listEl = null;
      SEARCH_RESULTS_VIEW.loadMoreWrapper = null;
      SEARCH_RESULTS_VIEW.loadMoreBtn = null;
      SEARCH_RESULTS_VIEW.lastChapter = '';
      SEARCH_RESULTS_VIEW.lastPage = '';
    }

    function setupKeyboardShortcuts() {
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          const dialogs = document.querySelectorAll('.global-search-dialog');
          dialogs.forEach(dialog => dialog.remove());
        }
      });
    }

    function setupScrollPosition() {
      const scrollY = sessionStorage.getItem(STORAGE_KEYS.scrollPosition);
      if (scrollY) window.scrollTo(0, parseInt(scrollY));
      window.addEventListener('beforeunload', () => {
        sessionStorage.setItem(STORAGE_KEYS.scrollPosition, window.scrollY);
        persistReadingState();
      });
      document.addEventListener('visibilitychange', () => {
        if (document.visibilityState === 'hidden') {
          persistReadingState();
        }
      });
      window.addEventListener('scroll', scheduleReadingStateSave, { passive: true });
      window.addEventListener('resize', scheduleReadingStateSave);
    }

    function expandAllInMenu(root) {
      try {
        root.querySelectorAll('.collapse').forEach(el => {
          el.classList.add('show');
          el.style.height = 'auto';
        });
        root.querySelectorAll('[data-bs-toggle="collapse"]').forEach(tg => {
          tg.setAttribute('aria-expanded', 'true');
        });
        root.querySelectorAll('[data-bs-toggle="collapse"]').forEach(tg => {
          tg.removeAttribute('data-bs-toggle');
          tg.removeAttribute('data-bs-target');
        });
      } catch (e) {
        console.warn('Failed to expand all menu levels:', e);
      }
    }

    // Quarto左サイドバー（各章/全体）: 指定階層まで展開、それ以降を折りたたみ
    function setSidebarDepth(root, maxDepth) {
      try {
        const togglers = root.querySelectorAll('[data-bs-toggle="collapse"][data-bs-target]');
        const getDepthForTarget = (target) => {
          let d = 1; let n = target;
          while (n && n !== root) { if (n.tagName === 'UL') d++; n = n.parentElement; }
          return d;
        };
        togglers.forEach(tg => {
          const sel = tg.getAttribute('data-bs-target');
          if (!sel || sel[0] !== '#') return;
          const target = root.querySelector(sel);
          if (!target) return;
          const depth = getDepthForTarget(target);
          const open = (maxDepth === Infinity) || (depth <= maxDepth);
          target.classList.toggle('show', !!open);
          target.style.height = open ? 'auto' : '';
          tg.setAttribute('aria-expanded', open ? 'true' : 'false');
        });
      } catch (e) {
        console.warn('setSidebarDepth error:', e);
      }
    }

    // ページ内目次: ツリー化 + 展開/格納トグルを付与（デフォルト階層まで展開）
    // 階層判定は必ずMarkdownの#数（= 見出しタグH1..H6のレベル）に従う
    function enhancePageToc(panel, defaultDepth) {
      const nav = panel.querySelector('nav#TOC');
      if (!nav) return;
      const getHeadingLevelFromLink = (a) => {
        try {
          if (!a) return null;
          const href = a.getAttribute('href') || '';
          if (!href.startsWith('#')) return null;
          const id = href.slice(1);
          const h = document.getElementById(id);
          if (!h) return null;
          const tag = (h.tagName || '').toUpperCase();
          if (/^H[1-6]$/.test(tag)) return parseInt(tag.slice(1), 10);
          return null;
        } catch { return null; }
      };

      nav.querySelectorAll('li').forEach(li => {
        const childUl = li.querySelector(':scope > ul');
        const link = li.querySelector(':scope > a');
        const level = getHeadingLevelFromLink(link);

        if (childUl) {
          li.classList.add('has-children');
          const toggle = document.createElement('span');
          toggle.className = 'toc-toggle';
          toggle.textContent = '▾';
          if (link && link.parentNode === li) {
            const row = document.createElement('div');
            row.className = 'li-row';
            li.insertBefore(row, link);
            row.appendChild(toggle);
            row.appendChild(link);
          } else {
            li.insertBefore(toggle, li.firstChild);
          }
          toggle.addEventListener('click', () => {
            li.classList.toggle('collapsed');
            toggle.textContent = li.classList.contains('collapsed') ? '▸' : '▾';
          });
        }

        // 初期展開状態は # のレベルで判定
        if (level != null) {
          const open = (defaultDepth === Infinity) || (level <= defaultDepth);
          if (open) {
            li.classList.remove('collapsed');
            const t = li.querySelector(':scope > .toc-toggle');
            if (t) t.textContent = '▾';
          } else {
            li.classList.add('collapsed');
            const t = li.querySelector(':scope > .toc-toggle');
            if (t) t.textContent = '▸';
          }
        }
      });
    }

    // 独自TOCシステム
    const CustomTOC = {
      // 現在のページの見出しを取得
      getPageHeadings: function () {
        const headmap = new Map();
        let maxDepth = 0;

        // メインコンテンツから見出しを取得
        const allHeadings = document.querySelectorAll('main h1, main h2, main h3, main h4, main h5, main h6');

        allHeadings.forEach(heading => {
          const text = heading.textContent || heading.innerText || '';
          if (!text.trim()) return;

          const level = parseInt(heading.tagName.slice(1), 10);
          const id = heading.id || this.generateIdFromText(text);

          headmap.set(id, {
            id: id,
            text: text,
            level: level,
            element: heading,
            children: []
          });
          maxDepth = Math.max(maxDepth, level);
        });

        return { headings: headmap, maxDepth: maxDepth };
      },

      // テキストからIDを生成（Quarto互換）
      generateIdFromText: function (text) {
        return text
          .replace(/\s+/g, ' ')
          .trim()
          .toLowerCase()
          .replace(/[^\w\s-]/g, '')
          .replace(/\s+/g, '-');
      },

      // ページ外TOC：すべてのページ情報（静的データ）
      getAllPagesTOC: function () {
        // ページ構成を静的に定義する
        return [
          {
            title: "AJMUN 37th 平和への課題：補遺",
            url: "../index.html",
            type: "cover"
          },
          {
            title: "フロント挨拶",
            url: "../content/00_front.html",
            type: "front"
          },
          {
            title: "第1章 プロジェクトの概要",
            url: "../content/01_ch01.html",
            type: "chapter",
            sections: [
              "1.1 はじめに",
              "1.2 プロジェクトの目的",
              "1.2.1 課題認識",
              "1.2.2 解決方針",
              "1.3 技術選定",
              "1.3.1 Quarto + Pandoc",
              "1.3.2 UDP明朝フォント",
              "1.4 プロジェクト構成",
              "1.4.1 ディレクトリ構造",
              "1.4.2 ファイル配置戦略",
              "1.5 開発アプローチ",
              "1.5.1 プログレッシブエンハンスメント",
              "1.5.2 アクセシビリティ優先"
            ]
          },
          {
            title: "第2章 技術的課題と解決策",
            url: "../content/02_ch02.html",
            type: "chapter",
            sections: [
              "2.1 日本語組版の課題",
              "2.1.1 文字エンコーディング",
              "2.1.2 フォントの扱い",
              "2.2 レスポンシブデザイン",
              "2.2.1 標長画面の制約",
              "2.2.2 モバイルへの対応",
              "2.3 パフォーマンスの最適化",
              "2.3.1 読み込み時間の短縮",
              "2.3.2 スムーズな操作感"
            ]
          },
          {
            title: "第3章 実装方針",
            url: "../content/03_ch03.html",
            type: "chapter",
            sections: [
              "3.1 開発アプローチ",
              "3.1.1 プロジェクト構造",
              "3.1.2 ビルドシステム",
              "3.2 技術選択",
              "3.3 品質保証"
            ]
          },
          {
            title: "コラム1：Webフォントの歴史",
            url: "../content/20_col01.html",
            type: "column",
            sections: [
              "デジタルタイポグラフィの発展",
              "画像フォントの時代",
              "Webフォントの登場",
              "日本語対応の課題",
              "サブセット化の重要性"
            ]
          },
          {
            title: "コラム2：アクセシビリティの重要性",
            url: "../content/21_col02.html",
            type: "column",
            sections: [
              "リテラシーの多様性",
              "視覚的配慮",
              "聴覚的配慮",
              "身体的配慮",
              "技術的な実装"
            ]
          },
          {
            title: "第4章 UI/UX設計",
            url: "../content/04_ch04.html",
            type: "chapter",
            sections: [
              "4.1 基本原則",
              "4.2 コンポーネント設計",
              "4.3 アクセシビリティ"
            ]
          },
          {
            title: "第5章 パフォーマンス最適化",
            url: "../content/05_ch05.html",
            type: "chapter",
            sections: [
              "5.1 読み込み速度",
              "5.2 レンダリングの効率化",
              "5.3 キャッシュ戦略"
            ]
          },
          {
            title: "第6章 国連の制度",
            url: "./06_ch06.html",
            type: "chapter",
            sections: [
              "はじめに",
              "第1節 国連という組織",
              "第1項 概要・組織構造",
              "第2項 安全保障理事会",
              "第3項 国連の紛争対処",
              "第4項 安保理決議に基づく義務",
              "コラム 安保理決議の拘束力",
              "第2節 国連財政",
              "第2項 PKO予算",
              "第3節 国連による経済制裁",
              "第1項 国際連合憲章における経済制裁措置",
              "第2項 冷戦下の経済制裁",
              "第3項 冷戦後の経済制裁",
              "第3項 経済制裁に伴う問題とその後",
              "第4項 国連憲章第50条の注解",
              "第4節 国連平和維持活動(PKO)",
              "参考文献"
            ]
          },
          {
            title: "第7章 まとめと展望",
            url: "../content/07_ch07.html",
            type: "chapter",
            sections: [
              "7.1 プロジェクトの成果",
              "7.2 技術的貢献",
              "7.3 今後の発展",
              "まとめ"
            ]
          },
          {
            title: "コラム3：今後の技術動向",
            url: "../content/22_col03.html",
            type: "column",
            sections: [
              "新しい技術の登場",
              "Variable Fonts",
              "Container Queries",
              "Web Components",
              "発展の可能性",
              "PWA化",
              "オフライン対応",
              "マルチデバイス同期"
            ]
          },
          {
            title: "編集後記",
            url: "../content/90_afterword.html",
            type: "appendix",
            sections: [
              "執筆の経緯",
              "技術的な挑戦",
              "フォント埋込",
              "レスポンシブ設計",
              "脚注処理",
              "読者の皆様へ",
              "今後の展望",
              "結びに"
            ]
          },
          {
            title: "参考文献",
            url: "../content/95_references.html",
            type: "appendix"
          },
          {
            title: "索引",
            url: "../content/96_index.html",
            type: "appendix",
            sections: [
              "あ", "う", "か", "こ", "し", "た", "は", "ろ"
            ]
          }
        ];
      },

      // ページ内TOCを生成（章内タブ用）
      generatePageTOC: function (maxDepth) {
        const { headings } = this.getPageHeadings();

        if (headings.size === 0) {
          return '<p class="toc-empty">このページには見出しがありません。</p>';
        }

        const items = [];
        headings.forEach((heading, id) => {
          const level = Math.min(Math.max(heading.level, 1), 6);
          if (level > maxDepth) return;
          const levelClass = `page-toc-level-${level}`;
          const liClasses = ['page-toc-item', levelClass].join(' ');
          items.push(`<li class="${liClasses}"><a class="page-toc-link" href="#${id}">${heading.text}</a></li>`);
        });

        if (!items.length) {
          return '<p class="toc-empty">このページには見出しがありません。</p>';
        }

        return `<ul class="page-toc-list">${items.join('')}</ul>`;
      },

      // 全体TOCを生成（全体タブ用）
      generateAllPagesTOC: function () {
        const pages = this.getAllPagesTOC();
        const currentPath = (window.location.pathname || '').split('/').pop() || 'index.html';

        let html = '<ul class="all-toc-list">';

        pages.forEach(page => {
          const normalizedPage = (page.url || '').replace(/^\.\//, '').split('/').pop() || '';
          const isActive = normalizedPage === currentPath;
          const itemClasses = ['all-toc-item', `all-toc-item--${page.type || 'other'}`];
          if (isActive) itemClasses.push('active');

          html += `<li class="${itemClasses.join(' ')}">`;
          html += `<a href="${page.url}" class="all-toc-link">${page.title}</a>`;

          if (Array.isArray(page.sections) && page.sections.length) {
            html += '<ul class="all-toc-sublist">';
            page.sections.forEach(sectionName => {
              const sectionId = this.generateIdFromText(sectionName);
              const link = `${page.url}#${sectionId}`;
              html += `<li class="all-toc-subitem"><a href="${link}" class="all-toc-sublink">${sectionName}</a></li>`;
            });
            html += '</ul>';
          }

          html += '</li>';
        });

        html += '</ul>';
        return html;
      },

      // TOC構造をHTMLに変換
      renderTOCStructure: function (structure, maxDepth = Infinity, options = {}) {
        const {
          listClass = 'custom-toc-list',
          childListClass = 'custom-toc-child-list',
          itemClass = (item, active) => `custom-toc-item level-${item.level} ${active}`,
          linkClass = (item, active) => `custom-toc-link ${active}`
        } = options;

        const normalizeClass = (value) => (value || '').trim().replace(/\s+/g, ' ');

        const renderItems = (items, currentDepth = 1) => {
          let resultHtml = '';

          items.forEach(item => {
            if (Array.isArray(item)) {
              if (currentDepth <= maxDepth) {
                resultHtml += `<ul class="${normalizeClass(childListClass)}">`;
                item.forEach(childItem => {
                  resultHtml += renderItems([childItem], currentDepth + 1);
                });
                resultHtml += '</ul>';
              }
            } else if (item && item.id) {
              const isActive = document.getElementById(item.id)?.classList.contains('active');
              const activeClass = isActive ? 'active' : '';
              const liClass = typeof itemClass === 'function' ? itemClass(item, activeClass) : itemClass;
              const linkClassName = typeof linkClass === 'function' ? linkClass(item, activeClass) : linkClass;

              resultHtml += `<li class="${normalizeClass(liClass)}">`;
              resultHtml += `<a href="#${item.id}" class="${normalizeClass(linkClassName)}">${item.text}</a>`;

              if (item.children && item.children.length > 0 && currentDepth < maxDepth) {
                resultHtml += `<ul class="${normalizeClass(childListClass)}">`;
                item.children.forEach(child => {
                  resultHtml += renderItems([child], currentDepth + 1);
                });
                resultHtml += '</ul>';
              }

              resultHtml += '</li>';
            }
          });

          return resultHtml;
        };

        let html = `<ul class="${normalizeClass(listClass)}">`;
        structure.forEach(item => {
          html += renderItems([item], 1);
        });
        html += '</ul>';
        return html;
      },

      // TOCを初期化
      initializeCustomTOC: function () {
        // 章内タブ用TOC
        const pageTOCPanel = document.querySelector('.toc-page-content');
        if (pageTOCPanel) {
          const pageTOC = this.generatePageTOC(Infinity);
          pageTOCPanel.innerHTML = pageTOC;
        }

        // 全体タブ用TOC
        const allTOCPanel = document.querySelector('.toc-all-content');
        if (allTOCPanel) {
          const allTOC = this.generateAllPagesTOC();
          allTOCPanel.innerHTML = allTOC;

          // 階層折りたたみ機能
          this.setupTOCToggling(allTOCPanel);
        }
      },

      // TOCの階層展開/折りたたみ機能
      setupTOCToggling: function (container) {
        const toggleButtons = container.querySelectorAll('.custom-toc-item > .custom-toc-link');

        toggleButtons.forEach(link => {
          const listItem = link.closest('.custom-toc-item');
          const childList = listItem.querySelector('.custom-toc-child-list');

          if (childList) {
            // 開閉ボタンを追加
            const toggleBtn = document.createElement('span');
            toggleBtn.className = 'custom-toc-toggle';
            toggleBtn.textContent = '▾';

            link.parentNode.insertBefore(toggleBtn, link);
            link.style.paddingLeft = '20px';

            // 第4階層以下はデフォルトで折りたたむ
            const level = parseInt(listItem.className.match(/level-(\d+)/)?.[1] || 1, 10);
            const collapsed = level >= 4;

            if (collapsed) {
              childList.style.display = 'none';
              toggleBtn.textContent = '▸';
            }

            toggleBtn.addEventListener('click', (e) => {
              e.preventDefault();
              e.stopPropagation();

              const isCollapsed = childList.style.display === 'none';
              childList.style.display = isCollapsed ? '' : 'none';
              toggleBtn.textContent = isCollapsed ? '▾' : '▸';
            });

            // 親リンクのクリック動作
            link.addEventListener('click', (e) => {
              e.stopPropagation();
            });
          }
        });
      }
    };

    CustomTOC.getNavData = function (navData) {
      return navData || NAV_DATA_STATE.data;
    };

    CustomTOC.normalizeText = function (text) {
      return (text || '').replace(/\s+/g, ' ').trim();
    };

    CustomTOC.getCurrentPage = function (navData) {
      const data = this.getNavData(navData);
      if (!data || !Array.isArray(data.pages)) return null;
      const current = computeCurrentOutputPath();
      return data.pages.find(page => isSamePage(page.output, current)) || null;
    };

    CustomTOC.createTree = function (nodes, pageOutput, options = {}) {
      const { variant } = options;
      const ul = document.createElement('ul');
      ul.className = 'toc-tree';
      if (variant) ul.classList.add(variant);

      nodes.forEach((node, index) => {
        if (!node) return;
        const depth = Math.min(node.level || 1, 6);
        const li = document.createElement('li');
        li.className = `toc-item toc-level-${depth}`;
        if (index === nodes.length - 1) li.classList.add('is-last');

        const row = document.createElement('div');
        row.className = 'toc-row';

        const link = document.createElement('a');
        link.className = `toc-link toc-level-${depth}`;
        link.href = buildHref(pageOutput, node.anchor || null);
        link.textContent = node.title || '';
        row.appendChild(link);
        li.appendChild(row);

        const hasChildren = Array.isArray(node.children) && node.children.length > 0;
        if (hasChildren) {
          const childList = this.createTree(node.children, pageOutput, options);
          li.appendChild(childList);
          li.classList.add('has-children');
        }

        ul.appendChild(li);
      });

      return ul;
    };

    CustomTOC.cloneNodeWithLevelOffset = function (node, offset) {
      if (!node) return null;
      const level = Math.max(1, (node.level || 1) + offset);
      const clone = {
        title: node.title,
        level,
        anchor: node.anchor,
        children: []
      };
      if (Array.isArray(node.children) && node.children.length) {
        clone.children = node.children
          .map(child => this.cloneNodeWithLevelOffset(child, offset))
          .filter(Boolean);
      }
      return clone;
    };

    CustomTOC.rebasePageHeadings = function (nodes) {
      if (!Array.isArray(nodes) || !nodes.length) return [];

      const rebased = [];
      let consumedLevel1 = false;

      nodes.forEach(node => {
        if (!node) return;
        const level = node.level || 1;
        if (level <= 1) {
          consumedLevel1 = true;
          if (Array.isArray(node.children) && node.children.length) {
            node.children.forEach(child => {
              const adjusted = this.cloneNodeWithLevelOffset(child, -1);
              if (adjusted) rebased.push(adjusted);
            });
          }
        } else {
          const adjusted = this.cloneNodeWithLevelOffset(node, -1);
          if (adjusted) rebased.push(adjusted);
        }
      });

      if (!rebased.length && !consumedLevel1) {
        return nodes
          .map(node => this.cloneNodeWithLevelOffset(node, -1))
          .filter(Boolean);
      }

      return rebased;
    };

    CustomTOC.renderChapterTab = function (container, navData) {
      if (!container) return;
      const data = this.getNavData(navData);
      container.innerHTML = '';

      if (!data || !Array.isArray(data.pages) || !data.pages.length) {
        container.innerHTML = '<p class="toc-empty">目次データを読み込めませんでした。</p>';
        return;
      }

      const list = document.createElement('ul');
      list.className = 'toc-chapter-list toc-tree';
      const current = computeCurrentOutputPath();

      data.pages.forEach(page => {
        if (!page) return;
        const li = document.createElement('li');
        li.className = 'toc-chapter-item';
        if (isSamePage(page.output, current)) li.classList.add('active');

        const headingTree = cloneTreeWithDepth(page.headings || [], 1);
        const nodes = headingTree.length ? headingTree : [{
          title: page.title,
          level: 1,
          anchor: page.headings && page.headings.length ? page.headings[0].anchor : null,
          children: []
        }];

        const primary = nodes[0];
        const link = document.createElement('a');
        link.className = 'toc-link toc-chapter-link';
        link.href = buildHref(page.output, primary.anchor || null);
        link.textContent = primary.title || page.title;
        li.appendChild(link);

        if (nodes.length > 1) {
          const childList = document.createElement('ul');
          childList.className = 'toc-tree toc-chapter-sublist';
          nodes.slice(1).forEach(node => {
            const subLi = document.createElement('li');
            subLi.className = 'toc-item toc-level-1';
            const subLink = document.createElement('a');
            subLink.className = 'toc-link';
            subLink.href = buildHref(page.output, node.anchor || null);
            subLink.textContent = node.title || '';
            subLi.appendChild(subLink);
            childList.appendChild(subLi);
          });
          li.appendChild(childList);
        }

        list.appendChild(li);
      });

      container.appendChild(list);
    };

    CustomTOC.renderAllTab = function (container, navData) {
      if (!container) return;
      const data = this.getNavData(navData);
      container.innerHTML = '';
      container.classList.add('toc-all-container-ready');

      if (!data || !Array.isArray(data.pages) || !data.pages.length) {
        container.innerHTML = '<p class="toc-empty">目次データを読み込めませんでした。</p>';
        return;
      }

      const list = document.createElement('ul');
      list.className = 'toc-all-list toc-tree toc-tree-root toc-tree-all-root';
      const current = computeCurrentOutputPath();

      data.pages.forEach(page => {
        if (!page) return;
        const li = document.createElement('li');
        li.className = 'toc-all-item';
        if (isSamePage(page.output, current)) li.classList.add('active');

        const headingTree = cloneTreeWithDepth(page.headings || [], 3);
        let sectionNodes = headingTree;
        let chapterAnchor = page.headings && page.headings.length ? page.headings[0].anchor : null;
        if (
          headingTree.length === 1 &&
          this.normalizeText(headingTree[0].title) === this.normalizeText(page.title)
        ) {
          chapterAnchor = headingTree[0].anchor || chapterAnchor;
          sectionNodes = headingTree[0].children || [];
        }

        const link = document.createElement('a');
        link.className = 'toc-link toc-all-link';
        link.href = buildHref(page.output, chapterAnchor || null);
        link.textContent = page.title;
        li.appendChild(link);

        if (sectionNodes.length) {
          const childTree = this.createTree(sectionNodes, page.output, { variant: 'toc-tree-all' });
          li.appendChild(childTree);
        }

        list.appendChild(li);
      });

      container.appendChild(list);
    };

    CustomTOC.renderPageTab = function (container, navData, maxDepth = 4) {
      if (!container) return;
      const page = this.getCurrentPage(navData);
      container.innerHTML = '';
      container.classList.add('toc-page-container');

      if (!page) {
        container.innerHTML = '<p class="toc-empty">このページには見出しがありません。</p>';
        return;
      }

      const headingTree = cloneTreeWithDepth(page.headings || [], maxDepth);
      const rebasedTree = this.rebasePageHeadings(headingTree)
        .filter(node => (node.level || 1) >= 1);

      if (!rebasedTree.length) {
        container.innerHTML = '<p class="toc-empty">このページには見出しがありません。</p>';
        return;
      }

      const tree = this.createTree(rebasedTree, page.output, { variant: 'toc-tree-page' });
      tree.classList.add('toc-tree-root', 'toc-tree-page-root');
      container.appendChild(tree);
    };

    CustomTOC.initializeCustomTOC = function (navData) {
      const data = this.getNavData(navData);
      if (!data) return;

      const pagePanel = document.querySelector('.toc-page-content');
      if (pagePanel) {
        this.renderPageTab(pagePanel, data, 4);
      }

      const allPanel = document.querySelector('.toc-all-content .toc-all-container') || document.querySelector('.toc-all-content');
      if (allPanel) {
        this.renderAllTab(allPanel, data);
      }

      const sitePanel = document.querySelector('.toc-site-content .sidebar-menu-container');
      if (sitePanel) {
        this.renderChapterTab(sitePanel, data);
      }
    };

    CustomTOC.generatePageTOC = function (maxDepth = 4) {
      const temp = document.createElement('div');
      this.renderPageTab(temp, this.getNavData(), maxDepth);
      return temp.innerHTML || '<p class="toc-empty">このページには見出しがありません。</p>';
    };

    CustomTOC.generateAllPagesTOC = function () {
      const temp = document.createElement('div');
      this.renderAllTab(temp, this.getNavData());
      return temp.innerHTML || '<p class="toc-empty">目次データを読み込めませんでした。</p>';
    };

    // コメントエクスポート/インポート
    function exportComments(pageOnly) {
      try {
        const data = pageOnly ? { [pageKey()]: COMMENTS_DB[pageKey()] || [] } : COMMENTS_DB;
        const blob = new Blob([JSON.stringify({ version: '1.0', exportedAt: new Date().toISOString(), data }, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        const base = pageOnly ? (pageKey().split('/').pop() || 'page') : 'all';
        a.download = `comments_${base}_${new Date().toISOString().slice(0, 10)}.json`;
        document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
      } catch (e) { alert('コメント出力に失敗しました'); }
    }
    function importCommentsFromFile(file) {
      if (!file) return;
      const reader = new FileReader();
      reader.onload = () => {
        try {
          const json = JSON.parse(reader.result);
          const incoming = json.data || {};
          // マージ
          Object.keys(incoming).forEach(k => {
            if (!Array.isArray(incoming[k])) return;
            if (!COMMENTS_DB[k]) COMMENTS_DB[k] = [];
            const existingIds = new Set(COMMENTS_DB[k].map(r => r.id));
            incoming[k].forEach(rec => { if (!existingIds.has(rec.id)) COMMENTS_DB[k].push(rec); });
          });
          saveComments();
          refreshRightPanels();
          alert('コメントをインポートしました');
        } catch (e) {
          alert('コメント読込に失敗しました');
        }
      };
      reader.readAsText(file, 'utf-8');
    }

  })();
</script>